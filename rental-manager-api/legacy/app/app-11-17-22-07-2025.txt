===== __init__.py â€“ 2025-07-19 12:13:41 IST =====


===== app-11-17-22-07-2025.txt â€“ 2025-07-22 11:17:14 IST =====


===== main.py â€“ 2025-07-21 19:30:43 IST =====
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn

from app.core.config import settings
from app.core.database import engine
from app.core.middleware import WhitelistMiddleware, EndpointAccessMiddleware
from app.db.base import Base
from app.shared.exceptions import CustomHTTPException

# Import all models to ensure they are registered with Base.metadata
from app.modules.auth.routes import router as auth_router
from app.modules.users.routes import router as users_router
from app.modules.master_data.routes import router as master_data_router
from app.modules.suppliers.routes import router as suppliers_router
from app.modules.customers.routes import router as customers_router
from app.modules.inventory.routes import router as inventory_router
from app.modules.transactions.routes import router as transactions_router  # Re-enabled for Swagger
from app.modules.analytics.routes import router as analytics_router
from app.modules.system.routes import router as system_router

# Import centralized logging configuration
from app.core.logging_config import setup_application_logging, get_application_logger
from app.core.logging_middleware import TransactionLoggingMiddleware, RequestContextMiddleware

# Import task scheduler
from app.core.scheduler import task_scheduler

# Import performance monitoring
from app.modules.monitoring.performance_monitor import monitoring_router, PerformanceTrackingMiddleware

# Initialize centralized logging
setup_application_logging()
logger = get_application_logger(__name__)

# Create FastAPI app
app = FastAPI(
    title=settings.PROJECT_NAME,
    description=settings.PROJECT_DESCRIPTION,
    version=settings.PROJECT_VERSION,
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    openapi_tags=[
        {
            "name": "Authentication",
            "description": "User authentication and authorization operations"
        },
        {
            "name": "Users",
            "description": "User management operations"
        },
        {
            "name": "Master Data",
            "description": "Master data management operations"
        },
        {
            "name": "Items",
            "description": "Item master data operations - create, read, update, delete items with search and filtering"
        },
        {
            "name": "Suppliers",
            "description": "Supplier management operations"
        },
        {
            "name": "Customers",
            "description": "Customer management operations"
        },
        {
            "name": "Inventory",
            "description": "Inventory management operations"
        },
        {
            "name": "Transactions",
            "description": "All transaction management operations"
        },
        {
            "name": "Purchases",
            "description": "Purchase transaction management operations"
        },
        {
            "name": "Sales",
            "description": "Sales transaction management operations"
        },
        {
            "name": "Rentals",
            "description": "Rental transaction management operations"
        },
        {
            "name": "Rental Returns",
            "description": "Rental return and inspection management operations"
        },
        {
            "name": "Transaction Queries",
            "description": "Cross-module transaction queries and reports"
        },
        {
            "name": "Analytics",
            "description": "Analytics and reporting operations"
        },
        {
            "name": "System",
            "description": "System administration operations"
        }
    ]
)

# Add custom whitelist middleware (before CORS)
app.add_middleware(WhitelistMiddleware, enabled=settings.USE_WHITELIST_CONFIG)
app.add_middleware(EndpointAccessMiddleware, enabled=settings.USE_WHITELIST_CONFIG)

# Add transaction logging middleware
app.add_middleware(TransactionLoggingMiddleware)
app.add_middleware(RequestContextMiddleware)

# Add performance tracking middleware
app.add_middleware(PerformanceTrackingMiddleware)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,  # Use origins from settings
    allow_credentials=True,  # Allow credentials when using specific origins
    allow_methods=["*"],  # Allow all methods
    allow_headers=["*"],  # Allow all headers
    expose_headers=[
        "X-Total-Count",
        "X-Page-Count", 
        "X-Has-Next",
        "X-Has-Previous"
    ],
)

# Custom exception handler
@app.exception_handler(CustomHTTPException)
async def custom_http_exception_handler(request: Request, exc: CustomHTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail, "type": exc.error_type}
    )

# Global exception handler for debugging UUID issue
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    import traceback
    print(f"GLOBAL ERROR: {exc}")
    print(f"GLOBAL ERROR TYPE: {type(exc)}")
    print(f"GLOBAL ERROR TRACEBACK: {traceback.format_exc()}")
    return JSONResponse(
        status_code=500,
        content={"detail": f"Internal server error: {str(exc)}"}
    )

# Health check endpoint
@app.get("/api/health")
async def health_check():
    return {"status": "healthy", "service": settings.PROJECT_NAME}

# Detailed health check with pool status
@app.get("/api/health/detailed")
async def health_check_detailed():
    from app.core.database import get_pool_status
    from datetime import datetime
    
    pool_status = await get_pool_status()
    return {
        "status": "healthy",
        "service": settings.PROJECT_NAME,
        "database_pool": pool_status,
        "timestamp": datetime.now().isoformat()
    }

# Include routers
app.include_router(auth_router, prefix="/api/auth", tags=["Authentication"])
app.include_router(users_router, prefix="/api/users", tags=["Users"])
app.include_router(master_data_router, prefix="/api/master-data", tags=["Master Data"])
app.include_router(suppliers_router, prefix="/api/suppliers", tags=["Suppliers"])
app.include_router(customers_router, prefix="/api/customers", tags=["Customers"])
app.include_router(inventory_router, prefix="/api/inventory", tags=["Inventory"])
app.include_router(transactions_router, prefix="/api/transactions", tags=["Transactions"])
app.include_router(analytics_router, prefix="/api/analytics", tags=["Analytics"])
app.include_router(system_router, prefix="/api/system", tags=["System"])
app.include_router(monitoring_router)  # Performance monitoring endpoints

# Startup event
@app.on_event("startup")
async def startup():
    logger.info(f"Starting {settings.PROJECT_NAME}")
    logger.info("Comprehensive logging system initialized")
    logger.info("Transaction audit logging enabled")
    
    # Create tables if they don't exist
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
        
    logger.info("Database tables created/verified")
    
    # Initialize Redis cache
    try:
        from app.core.cache import cache, CacheWarmer
        await cache.initialize()
        logger.info("Redis cache initialized")
        
        # Warm cache with frequently accessed data
        from app.shared.dependencies import get_session
        async for session in get_session():
            try:
                warmer = CacheWarmer()
                await warmer.warm_item_cache(session)
                await warmer.warm_location_cache(session)
                logger.info("Cache warmed with frequently accessed data")
                break
            except Exception as e:
                logger.warning(f"Cache warming failed: {str(e)}")
                break
    except Exception as e:
        logger.warning(f"Redis initialization failed: {str(e)} - Cache disabled")
    
    # Initialize system settings
    try:
        from app.modules.system.service import SystemService
        from app.shared.dependencies import get_session
        
        # Get a database session for initialization
        async for session in get_session():
            try:
                system_service = SystemService(session)
                initialized_settings = await system_service.initialize_default_settings()
                if initialized_settings:
                    logger.info(f"Initialized {len(initialized_settings)} default system settings")
                else:
                    logger.info("System settings already initialized")
                break  # Exit after first successful session
            except Exception as e:
                logger.error(f"Failed to initialize system settings: {str(e)}")
                # Continue startup even if settings initialization fails
                break
    except Exception as e:
        logger.error(f"Error during system settings initialization: {str(e)}")
        # Continue startup even if there's an import or other error
    
    # Initialize and start the task scheduler
    try:
        await task_scheduler.start()
        logger.info("Task scheduler started successfully")
    except Exception as e:
        logger.error(f"Failed to start task scheduler: {str(e)}")
        # Continue startup even if scheduler fails to start
    
    logger.info(f"{settings.PROJECT_NAME} startup complete")

# Shutdown event
@app.on_event("shutdown")
async def shutdown():
    logger.info(f"Shutting down {settings.PROJECT_NAME}")
    
    # Stop the task scheduler
    try:
        await task_scheduler.stop()
        logger.info("Task scheduler stopped successfully")
    except Exception as e:
        logger.error(f"Error stopping task scheduler: {str(e)}")
    
    # Close Redis cache
    try:
        from app.core.cache import cache
        await cache.close()
        logger.info("Redis cache closed")
    except Exception as e:
        logger.warning(f"Error closing Redis cache: {str(e)}")
    
    logger.info("Shutdown complete")

if __name__ == "__main__":
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level="info"
    )

===== core/__init__.py â€“ 2025-07-19 12:13:41 IST =====


===== core/cache.py â€“ 2025-07-19 12:13:41 IST =====
"""
Redis caching layer for performance optimization.
Caches frequently accessed data to reduce database load.
"""

import json
import pickle
from typing import Any, Optional, Union, Callable
from datetime import timedelta
from functools import wraps
import hashlib
import asyncio

from redis import asyncio as aioredis
from app.core.config import settings


class CacheManager:
    """Manages Redis cache operations with async support."""
    
    _instance = None
    _redis_client = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    async def initialize(self):
        """Initialize Redis connection."""
        if not self._redis_client:
            self._redis_client = await aioredis.from_url(
                settings.REDIS_URL or "redis://localhost:6379",
                encoding="utf-8",
                decode_responses=False,  # We'll handle encoding/decoding
                max_connections=50,
                socket_keepalive=True,
                socket_keepalive_options={
                    1: 1,  # TCP_KEEPIDLE
                    2: 60,  # TCP_KEEPINTVL
                    3: 3,  # TCP_KEEPCNT
                }
            )
    
    async def get_client(self) -> aioredis.Redis:
        """Get Redis client, initializing if needed."""
        if not self._redis_client:
            await self.initialize()
        return self._redis_client
    
    async def close(self):
        """Close Redis connection."""
        if self._redis_client:
            await self._redis_client.close()
            self._redis_client = None
    
    @staticmethod
    def generate_key(prefix: str, *args, **kwargs) -> str:
        """Generate a cache key from prefix and arguments."""
        # Create a unique key from arguments
        key_parts = [prefix]
        
        # Add positional arguments
        for arg in args:
            if isinstance(arg, (str, int, float, bool)):
                key_parts.append(str(arg))
            else:
                # For complex objects, use hash
                key_parts.append(hashlib.md5(
                    json.dumps(arg, sort_keys=True, default=str).encode()
                ).hexdigest()[:8])
        
        # Add keyword arguments
        for k, v in sorted(kwargs.items()):
            key_parts.append(f"{k}:{v}")
        
        return ":".join(key_parts)
    
    async def get(self, key: str) -> Optional[Any]:
        """Get value from cache."""
        client = await self.get_client()
        try:
            value = await client.get(key)
            if value:
                return pickle.loads(value)
        except Exception as e:
            # Log error but don't fail
            print(f"Cache get error for {key}: {e}")
        return None
    
    async def set(self, key: str, value: Any, ttl: int = 300):
        """Set value in cache with TTL in seconds."""
        client = await self.get_client()
        try:
            serialized = pickle.dumps(value)
            await client.setex(key, ttl, serialized)
        except Exception as e:
            # Log error but don't fail
            print(f"Cache set error for {key}: {e}")
    
    async def delete(self, key: str):
        """Delete key from cache."""
        client = await self.get_client()
        try:
            await client.delete(key)
        except Exception as e:
            print(f"Cache delete error for {key}: {e}")
    
    async def delete_pattern(self, pattern: str):
        """Delete all keys matching pattern."""
        client = await self.get_client()
        try:
            cursor = 0
            while True:
                cursor, keys = await client.scan(cursor, match=pattern, count=100)
                if keys:
                    await client.delete(*keys)
                if cursor == 0:
                    break
        except Exception as e:
            print(f"Cache delete pattern error for {pattern}: {e}")


# Global cache instance
cache = CacheManager()


# Decorators for caching
def cached(
    prefix: str = None,
    ttl: int = 300,
    key_func: Optional[Callable] = None
):
    """
    Decorator to cache function results.
    
    Args:
        prefix: Cache key prefix (defaults to function name)
        ttl: Time to live in seconds (default 5 minutes)
        key_func: Custom function to generate cache key
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Generate cache key
            cache_prefix = prefix or f"{func.__module__}.{func.__name__}"
            
            if key_func:
                cache_key = key_func(*args, **kwargs)
            else:
                # Skip 'self' argument for methods
                cache_args = args[1:] if args and hasattr(args[0], '__class__') else args
                cache_key = cache.generate_key(cache_prefix, *cache_args, **kwargs)
            
            # Try to get from cache
            cached_value = await cache.get(cache_key)
            if cached_value is not None:
                return cached_value
            
            # Execute function and cache result
            result = await func(*args, **kwargs)
            await cache.set(cache_key, result, ttl)
            
            return result
        
        # Add cache management methods
        wrapper.invalidate = lambda *args, **kwargs: cache.delete(
            cache.generate_key(prefix or f"{func.__module__}.{func.__name__}", *args, **kwargs)
        )
        wrapper.invalidate_pattern = lambda pattern: cache.delete_pattern(pattern)
        
        return wrapper
    return decorator


def cache_aside(
    prefix: str,
    ttl: int = 300,
    serialize_func: Optional[Callable] = None,
    deserialize_func: Optional[Callable] = None
):
    """
    Cache-aside pattern decorator with custom serialization.
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            cache_key = cache.generate_key(prefix, *args[1:], **kwargs)
            
            # Try cache first
            cached_data = await cache.get(cache_key)
            if cached_data is not None:
                if deserialize_func:
                    return deserialize_func(cached_data)
                return cached_data
            
            # Get from source
            result = await func(*args, **kwargs)
            
            # Serialize and cache
            to_cache = serialize_func(result) if serialize_func else result
            await cache.set(cache_key, to_cache, ttl)
            
            return result
        
        return wrapper
    return decorator


# Specialized caching functions for rental operations
class RentalCache:
    """Specialized caching for rental-related data."""
    
    @staticmethod
    @cached(prefix="items:rentable", ttl=600)  # 10 minutes
    async def get_rentable_items(session, item_ids: list):
        """Cache rentable items lookup."""
        from sqlalchemy import select
        from app.modules.master_data.item_master.models import Item
        
        result = await session.execute(
            select(Item).where(
                Item.id.in_([str(id) for id in item_ids]),
                Item.is_rentable == True,
                Item.is_active == True
            )
        )
        return result.scalars().all()
    
    @staticmethod
    @cached(prefix="stock:levels", ttl=60)  # 1 minute for stock levels
    async def get_stock_levels(session, item_ids: list, location_id: str):
        """Cache stock levels lookup with shorter TTL."""
        from sqlalchemy import select, and_
        from app.modules.inventory.models import StockLevel
        
        result = await session.execute(
            select(StockLevel).where(
                and_(
                    StockLevel.item_id.in_([str(id) for id in item_ids]),
                    StockLevel.location_id == str(location_id),
                    StockLevel.is_active == True
                )
            )
        )
        return result.scalars().all()
    
    @staticmethod
    async def invalidate_stock_cache(item_ids: list, location_id: str):
        """Invalidate stock cache after updates."""
        for item_id in item_ids:
            await cache.delete(f"stock:levels:{item_id}:{location_id}")
    
    @staticmethod
    @cached(prefix="customer:details", ttl=900)  # 15 minutes
    async def get_customer_details(session, customer_id: str):
        """Cache customer information."""
        from sqlalchemy import select
        from app.modules.customers.models import Customer
        
        result = await session.execute(
            select(Customer).where(Customer.id == str(customer_id))
        )
        return result.scalar_one_or_none()
    
    @staticmethod
    @cached(prefix="location:details", ttl=1800)  # 30 minutes
    async def get_location_details(session, location_id: str):
        """Cache location information."""
        from sqlalchemy import select
        from app.modules.master_data.locations.models import Location
        
        result = await session.execute(
            select(Location).where(Location.id == str(location_id))
        )
        return result.scalar_one_or_none()


# Cache warming utilities
class CacheWarmer:
    """Utilities to pre-warm cache with frequently accessed data."""
    
    @staticmethod
    async def warm_item_cache(session):
        """Pre-warm cache with active rentable items."""
        from sqlalchemy import select
        from app.modules.master_data.item_master.models import Item
        
        # Get all active rentable items
        result = await session.execute(
            select(Item).where(
                Item.is_rentable == True,
                Item.is_active == True
            )
        )
        items = result.scalars().all()
        
        # Cache items in batches
        batch_size = 100
        for i in range(0, len(items), batch_size):
            batch = items[i:i + batch_size]
            item_ids = [item.id for item in batch]
            
            # Trigger cache population
            await RentalCache.get_rentable_items(session, item_ids)
    
    @staticmethod
    async def warm_location_cache(session):
        """Pre-warm cache with all active locations."""
        from sqlalchemy import select
        from app.modules.master_data.locations.models import Location
        
        result = await session.execute(
            select(Location).where(Location.is_active == True)
        )
        locations = result.scalars().all()
        
        # Cache each location
        for location in locations:
            await RentalCache.get_location_details(session, location.id)


# Usage example:
"""
# In service methods:
from app.core.cache import cached, RentalCache, cache

class TransactionService:
    @cached(prefix="transaction:summary", ttl=300)
    async def get_transaction_summary(self, transaction_id: str):
        # This result will be cached for 5 minutes
        return await self._fetch_transaction_summary(transaction_id)
    
    async def create_new_rental_optimized(self, rental_data):
        # Use cached lookups
        validated_items = await RentalCache.get_rentable_items(
            self.session, rental_data.item_ids
        )
        
        stock_levels = await RentalCache.get_stock_levels(
            self.session, rental_data.item_ids, rental_data.location_id
        )
        
        # ... create rental ...
        
        # Invalidate relevant caches after update
        await RentalCache.invalidate_stock_cache(
            rental_data.item_ids, rental_data.location_id
        )

# In app startup:
@app.on_event("startup")
async def startup_event():
    await cache.initialize()
    
    # Warm cache with frequently accessed data
    async with AsyncSessionLocal() as session:
        warmer = CacheWarmer()
        await warmer.warm_item_cache(session)
        await warmer.warm_location_cache(session)

@app.on_event("shutdown")
async def shutdown_event():
    await cache.close()
"""

===== core/config.py â€“ 2025-07-19 12:13:41 IST =====
from pydantic import Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Optional, Any, Dict
import os
from pathlib import Path


class Settings(BaseSettings):
    # Project Info
    PROJECT_NAME: str = "FastAPI Project"
    PROJECT_DESCRIPTION: str = "A modern FastAPI application with PostgreSQL and JWT authentication"
    PROJECT_VERSION: str = "1.0.0"
    
    # Server Settings
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    DEBUG: bool = False
    
    # Database Settings
    DATABASE_URL: str = Field(
        default="postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5432/fastapi_db",
        env="DATABASE_URL"
    )
    DATABASE_ECHO: bool = Field(default=False, env="DATABASE_ECHO")
    
    # Redis Settings
    REDIS_URL: str = Field(
        default="redis://localhost:6379",
        env="REDIS_URL"
    )
    
    # Security Settings
    SECRET_KEY: str = Field(
        default="your-secret-key-here-change-in-production",
        env="SECRET_KEY"
    )
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7
    
    # CORS Settings (deprecated - now managed by whitelist.json)
    ALLOWED_ORIGINS: str = Field(
        default="http://localhost:3000,http://localhost:8000,http://127.0.0.1:3000,http://127.0.0.1:8000"
    )
    
    # Whitelist Configuration
    USE_WHITELIST_CONFIG: bool = Field(default=True, env="USE_WHITELIST_CONFIG")
    WHITELIST_CONFIG_PATH: Optional[str] = Field(default=None, env="WHITELIST_CONFIG_PATH")
    
    # Password Settings
    PASSWORD_MIN_LENGTH: int = 8
    PASSWORD_BCRYPT_ROUNDS: int = 12
    
    # Pagination
    DEFAULT_PAGE_SIZE: int = 20
    MAX_PAGE_SIZE: int = 100
    
    # Email Settings (optional)
    SMTP_HOST: Optional[str] = Field(default=None)
    SMTP_PORT: Optional[int] = Field(default=None)
    SMTP_USERNAME: Optional[str] = Field(default=None)
    SMTP_PASSWORD: Optional[str] = Field(default=None)
    SMTP_TLS: bool = Field(default=True)
    
    # File Upload Settings
    MAX_UPLOAD_SIZE: int = 10 * 1024 * 1024  # 10MB
    UPLOAD_DIRECTORY: str = "uploads"
    
    @property
    def cors_origins(self) -> List[str]:
        """Get CORS origins as a list"""
        if self.USE_WHITELIST_CONFIG:
            try:
                from app.core.whitelist import get_cors_origins
                return get_cors_origins()
            except ImportError:
                # Fallback to old method if whitelist module is not available
                pass
        
        # Fallback to environment variable configuration
        if not self.ALLOWED_ORIGINS:
            return []
        return [origin.strip() for origin in self.ALLOWED_ORIGINS.split(",") if origin.strip()]
    
    @field_validator("DATABASE_URL", mode="before")
    @classmethod
    def validate_database_url(cls, v):
        if not v.startswith("postgresql"):
            raise ValueError("DATABASE_URL must be a PostgreSQL URL")
        return v
    
    @field_validator("SMTP_HOST", "SMTP_USERNAME", "SMTP_PASSWORD", mode="before")
    @classmethod
    def empty_str_to_none(cls, v):
        if v == "":
            return None
        return v
    
    @field_validator("SMTP_PORT", mode="before")
    @classmethod
    def parse_smtp_port(cls, v):
        if v == "" or v is None:
            return None
        try:
            return int(v)
        except (ValueError, TypeError):
            return None
    
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=True,
        env_nested_delimiter="__",
        extra="ignore"  # Ignore extra fields from environment
    )


# Create settings instance
settings = Settings()

# Ensure upload directory exists
Path(settings.UPLOAD_DIRECTORY).mkdir(exist_ok=True)

===== core/database.py â€“ 2025-07-20 02:30:59 IST =====
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy import DateTime, func, text
from typing import AsyncGenerator
import datetime

from app.core.config import settings


# Performance-optimized engine configuration
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DEBUG,
    future=True,
    
    # Connection pool optimization
    pool_size=20,  # Increased from default 5 for high concurrency
    max_overflow=40,  # Increased from default 10
    pool_timeout=30,  # Timeout for getting connection from pool
    pool_recycle=3600,  # Recycle connections after 1 hour
    pool_pre_ping=True,  # Verify connections before use
    
    # Query execution optimization
    connect_args={
        "server_settings": {
            "application_name": "rental_manager",
            "jit": "off",  # Disable JIT for consistent performance
        },
        "command_timeout": 60,  # Query timeout in seconds
        "prepared_statement_cache_size": 0,  # Disable PS cache for better pooling
    },
    
    # Engine-level optimizations
    query_cache_size=1200,  # Increase query cache
    echo_pool=settings.DEBUG,  # Log pool checkouts/checkins in debug mode
)

# Optimized session factory
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    
    # Session-level optimizations
    autoflush=False,  # Disable autoflush for better control
    autocommit=False,
)


# Base class for all models
class Base(DeclarativeBase):
    """Base class for all database models"""
    
    # Common columns for all models
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
        index=True  # Add index for time-based queries
    )
    updated_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
        index=True  # Add index for update tracking
    )


# Database dependency
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Dependency to get database session with performance monitoring"""
    async with AsyncSessionLocal() as session:
        try:
            # Log pool statistics in debug mode
            if settings.DEBUG:
                pool_status = await get_pool_status()
                if pool_status['size'] > 0:
                    print(f"DB Pool - Size: {pool_status['size']}, "
                          f"Checked out: {pool_status['checked_out']}")
            
            yield session
            
            # Commit only if there are pending changes
            if session.in_transaction():
                await session.commit()
                
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()


# Database utility functions
async def init_db():
    """Initialize database with performance optimizations"""
    async with engine.begin() as conn:
        # Create tables
        await conn.run_sync(Base.metadata.create_all)
        
        # Run ANALYZE on critical tables for query planner (if tables exist)
        try:
            await conn.execute(text("ANALYZE stock_levels;"))
            await conn.execute(text("ANALYZE transaction_headers;"))
            await conn.execute(text("ANALYZE transaction_lines;"))
            await conn.execute(text("ANALYZE items;"))
        except Exception:
            pass  # Tables might not exist yet


async def close_db():
    """Close database connections"""
    await engine.dispose()


# Connection pool monitoring utilities
async def get_pool_status() -> dict:
    """Get current connection pool statistics"""
    pool = engine.pool
    return {
        "size": getattr(pool, 'size', lambda: 0)() if hasattr(pool, 'size') else 0,
        "checked_out": getattr(pool, 'checked_out_connections', lambda: 0)() if hasattr(pool, 'checked_out_connections') else 0,
        "overflow": getattr(pool, 'overflow', lambda: 0)() if hasattr(pool, 'overflow') else 0,
        "total": (getattr(pool, 'size', lambda: 0)() + getattr(pool, 'overflow', lambda: 0)()) if hasattr(pool, 'size') else 0
    }


# Database performance helpers
class DatabasePerformance:
    """Helper class for database performance monitoring and optimization"""
    
    @staticmethod
    async def explain_query(session: AsyncSession, query: str) -> list:
        """Get query execution plan"""
        result = await session.execute(text(f"EXPLAIN ANALYZE {query}"))
        return result.fetchall()
    
    @staticmethod
    async def get_slow_queries(session: AsyncSession, min_duration_ms: int = 100) -> list:
        """Get slow queries from pg_stat_statements"""
        query = """
        SELECT 
            query,
            calls,
            mean_exec_time,
            total_exec_time,
            rows,
            100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
        FROM pg_stat_statements
        WHERE mean_exec_time > :min_duration
        ORDER BY mean_exec_time DESC
        LIMIT 20
        """
        result = await session.execute(text(query), {"min_duration": min_duration_ms})
        return result.fetchall()
    
    @staticmethod
    async def vacuum_analyze_table(session: AsyncSession, table_name: str):
        """Run VACUUM ANALYZE on a specific table"""
        await session.execute(text(f"VACUUM ANALYZE {table_name}"))
        await session.commit()

===== core/dependencies.py â€“ 2025-07-19 12:13:41 IST =====
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional

from app.core.database import get_db
from app.core.security import verify_token, TokenData


# Security scheme
security = HTTPBearer()


# Authentication dependencies
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
):
    """Get current authenticated user"""
    from app.modules.users.services import UserService
    from app.modules.users.models import User
    
    token = credentials.credentials
    token_data = verify_token(token, "access")
    
    user_service = UserService(db)
    user = await user_service.get_by_id(token_data.user_id)
    
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Inactive user",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    return user


async def get_current_active_user(
    current_user = Depends(get_current_user)
):
    """Get current active user"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    return current_user


async def get_current_superuser(
    current_user = Depends(get_current_user)
):
    """Get current superuser"""
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user


# Optional authentication dependency
async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
    db: AsyncSession = Depends(get_db)
):
    """Get current user if authenticated, otherwise None"""
    from app.modules.users.services import UserService
    
    if credentials is None:
        return None
    
    try:
        token = credentials.credentials
        token_data = verify_token(token, "access")
        
        user_service = UserService(db)
        user = await user_service.get_by_id(token_data.user_id)
        
        if user and user.is_active:
            return user
    except Exception:
        pass
    
    return None


# Pagination dependency
class PaginationParams:
    def __init__(self, page: int = 1, size: int = 20):
        self.page = max(1, page)
        self.size = min(100, max(1, size))
        self.offset = (self.page - 1) * self.size


def get_pagination_params(page: int = 1, size: int = 20) -> PaginationParams:
    """Get pagination parameters"""
    return PaginationParams(page=page, size=size)

===== core/errors.py â€“ 2025-07-19 12:13:41 IST =====
"""Core error classes for the application."""

from typing import Optional, Dict, Any


class BaseError(Exception):
    """Base exception class for application errors."""
    
    def __init__(self, message: str, error_code: Optional[str] = None, details: Optional[Dict[str, Any]] = None):
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        super().__init__(message)


class ValidationError(BaseError):
    """Raised when data validation fails."""
    
    def __init__(self, message: str, field: Optional[str] = None, details: Optional[Dict[str, Any]] = None):
        self.field = field
        super().__init__(message, "VALIDATION_ERROR", details)


class NotFoundError(BaseError):
    """Raised when a requested resource is not found."""
    
    def __init__(self, message: str, resource_type: Optional[str] = None, resource_id: Optional[str] = None):
        self.resource_type = resource_type
        self.resource_id = resource_id
        details = {}
        if resource_type:
            details["resource_type"] = resource_type
        if resource_id:
            details["resource_id"] = resource_id
        super().__init__(message, "NOT_FOUND_ERROR", details)


class ConflictError(BaseError):
    """Raised when an operation conflicts with existing data."""
    
    def __init__(self, message: str, conflicting_field: Optional[str] = None, conflicting_value: Optional[str] = None):
        self.conflicting_field = conflicting_field
        self.conflicting_value = conflicting_value
        details = {}
        if conflicting_field:
            details["conflicting_field"] = conflicting_field
        if conflicting_value:
            details["conflicting_value"] = conflicting_value
        super().__init__(message, "CONFLICT_ERROR", details)


class BusinessRuleError(BaseError):
    """Raised when a business rule is violated."""
    
    def __init__(self, message: str, rule_name: Optional[str] = None, context: Optional[Dict[str, Any]] = None):
        self.rule_name = rule_name
        self.context = context or {}
        details = {"context": self.context}
        if rule_name:
            details["rule_name"] = rule_name
        super().__init__(message, "BUSINESS_RULE_ERROR", details)


class AuthenticationError(BaseError):
    """Raised when authentication fails."""
    
    def __init__(self, message: str = "Authentication failed"):
        super().__init__(message, "AUTHENTICATION_ERROR")


class AuthorizationError(BaseError):
    """Raised when authorization fails."""
    
    def __init__(self, message: str = "Access denied", required_permission: Optional[str] = None):
        self.required_permission = required_permission
        details = {}
        if required_permission:
            details["required_permission"] = required_permission
        super().__init__(message, "AUTHORIZATION_ERROR", details)


class DatabaseError(BaseError):
    """Raised when database operations fail."""
    
    def __init__(self, message: str, operation: Optional[str] = None, table: Optional[str] = None):
        self.operation = operation
        self.table = table
        details = {}
        if operation:
            details["operation"] = operation
        if table:
            details["table"] = table
        super().__init__(message, "DATABASE_ERROR", details)


# Export all error classes
__all__ = [
    "BaseError",
    "ValidationError",
    "NotFoundError", 
    "ConflictError",
    "BusinessRuleError",
    "AuthenticationError",
    "AuthorizationError",
    "DatabaseError"
]

===== core/logger.py â€“ 2025-07-19 12:13:41 IST =====
"""
Enhanced logging system for purchase transaction debugging.
Provides structured logging with timestamps and markdown formatting.
"""

import logging
import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional
import traceback


class PurchaseTransactionLogger:
    """Specialized logger for purchase transaction debugging."""
    
    def __init__(self, log_dir: str = "logs"):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(exist_ok=True)
        
        # Create log file with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_file = self.log_dir / f"purchase_transactions_{timestamp}.md"
        
        # Initialize markdown log file
        self._init_markdown_log()
        
        # Setup Python logger
        self.logger = logging.getLogger("purchase_transaction")
        self.logger.setLevel(logging.DEBUG)
        
        # Create console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        # Create file handler
        file_handler = logging.FileHandler(
            self.log_dir / f"purchase_transactions_{timestamp}.log"
        )
        file_handler.setLevel(logging.DEBUG)
        
        # Create formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        console_handler.setFormatter(formatter)
        file_handler.setFormatter(formatter)
        
        # Add handlers
        if not self.logger.handlers:
            self.logger.addHandler(console_handler)
            self.logger.addHandler(file_handler)
    
    def _init_markdown_log(self):
        """Initialize markdown log file with header."""
        with open(self.log_file, "w") as f:
            f.write(f"""# Purchase Transaction Debug Log

**Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

---

## Purchase Transaction Processing Log

This log tracks the complete flow of purchase transactions and stock level integration.

""")
    
    def _write_markdown(self, content: str):
        """Write content to markdown log file."""
        with open(self.log_file, "a") as f:
            f.write(content + "\n")
    
    def log_purchase_start(self, purchase_data: Dict[str, Any], transaction_id: str = None):
        """Log the start of a purchase transaction."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        # Console/file log
        self.logger.info(f"ðŸ›’ PURCHASE TRANSACTION STARTED - ID: {transaction_id}")
        
        # Markdown log
        content = f"""
### ðŸ›’ Purchase Transaction Started
**Timestamp:** {timestamp}  
**Transaction ID:** {transaction_id or "Not yet assigned"}

**Purchase Data:**
```json
{json.dumps(purchase_data, indent=2, default=str)}
```

**Items Count:** {len(purchase_data.get('items', []))}  
**Supplier ID:** {purchase_data.get('supplier_id')}  
**Location ID:** {purchase_data.get('location_id')}

---
"""
        self._write_markdown(content)
    
    def log_validation_step(self, step: str, result: bool, details: str = None):
        """Log validation steps."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        status = "âœ… PASSED" if result else "âŒ FAILED"
        
        # Console/file log
        self.logger.info(f"ðŸ” VALIDATION - {step}: {status}")
        if details:
            self.logger.debug(f"Details: {details}")
        
        # Markdown log
        content = f"""
#### ðŸ” Validation: {step}
**Timestamp:** {timestamp}  
**Status:** {status}

{f"**Details:** {details}" if details else ""}

"""
        self._write_markdown(content)
    
    def log_transaction_creation(self, transaction_data: Dict[str, Any]):
        """Log transaction header creation."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        # Console/file log
        self.logger.info(f"ðŸ“ TRANSACTION CREATED - Number: {transaction_data.get('transaction_number')}")
        
        # Markdown log
        content = f"""
#### ðŸ“ Transaction Header Created
**Timestamp:** {timestamp}

**Transaction Details:**
- **ID:** {transaction_data.get('id')}
- **Number:** {transaction_data.get('transaction_number')}
- **Type:** {transaction_data.get('transaction_type')}
- **Status:** {transaction_data.get('status')}
- **Total Amount:** ${transaction_data.get('total_amount', 0)}

"""
        self._write_markdown(content)
    
    def log_stock_level_processing_start(self, items_count: int):
        """Log start of stock level processing."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        # Console/file log
        self.logger.info(f"ðŸ“¦ STOCK LEVEL PROCESSING STARTED - {items_count} items")
        
        # Markdown log
        content = f"""
#### ðŸ“¦ Stock Level Processing Started
**Timestamp:** {timestamp}  
**Items to Process:** {items_count}

"""
        self._write_markdown(content)
    
    def log_item_stock_processing(self, item_id: str, quantity: int, existing_stock: Optional[Dict] = None):
        """Log individual item stock processing."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        if existing_stock:
            action = "UPDATE EXISTING"
            old_qty = existing_stock.get('quantity_on_hand', 0)
            # Handle string, float, Decimal, or int quantities
            if isinstance(old_qty, str):
                old_qty = float(old_qty) if '.' in str(old_qty) else int(old_qty)
            new_qty = old_qty + quantity if old_qty else quantity
            
            # Console/file log
            self.logger.info(f"ðŸ“ˆ STOCK UPDATE - Item: {item_id}, {old_qty} â†’ {new_qty}")
            
            # Markdown log
            content = f"""
##### ðŸ“ˆ Stock Update (Existing Stock)
**Timestamp:** {timestamp}  
**Item ID:** {item_id}  
**Action:** {action}

**Stock Changes:**
- **Previous Quantity:** {old_qty}
- **Added Quantity:** +{quantity}
- **New Quantity:** {new_qty}

**Existing Stock Details:**
```json
{json.dumps(existing_stock, indent=2, default=str)}
```

"""
        else:
            action = "CREATE NEW"
            
            # Console/file log
            self.logger.info(f"âž• STOCK CREATE - Item: {item_id}, Quantity: {quantity}")
            
            # Markdown log
            content = f"""
##### âž• Stock Creation (New Stock)
**Timestamp:** {timestamp}  
**Item ID:** {item_id}  
**Action:** {action}

**New Stock Details:**
- **Initial Quantity:** {quantity}
- **Available Quantity:** {quantity}
- **Reserved Quantity:** 0

"""
        
        self._write_markdown(content)
    
    def log_stock_level_creation(self, stock_data: Dict[str, Any]):
        """Log stock level object creation."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        # Console/file log
        self.logger.info(f"ðŸ—ï¸ STOCK OBJECT CREATED - Item: {stock_data.get('item_id')}")
        
        # Markdown log
        content = f"""
##### ðŸ—ï¸ Stock Level Object Created
**Timestamp:** {timestamp}

**Stock Level Data:**
```json
{json.dumps(stock_data, indent=2, default=str)}
```

"""
        self._write_markdown(content)
    
    def log_session_operation(self, operation: str, details: str = None):
        """Log database session operations."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        # Console/file log
        self.logger.info(f"ðŸ—„ï¸ DATABASE - {operation}")
        if details:
            self.logger.debug(f"Details: {details}")
        
        # Markdown log
        content = f"""
##### ðŸ—„ï¸ Database Operation: {operation}
**Timestamp:** {timestamp}

{f"**Details:** {details}" if details else ""}

"""
        self._write_markdown(content)
    
    def log_transaction_commit(self, success: bool, error: str = None):
        """Log transaction commit result."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        status = "âœ… SUCCESS" if success else "âŒ FAILED"
        
        # Console/file log
        if success:
            self.logger.info("ðŸ’¾ TRANSACTION COMMITTED SUCCESSFULLY")
        else:
            self.logger.error(f"ðŸ’¥ TRANSACTION COMMIT FAILED: {error}")
        
        # Markdown log
        content = f"""
#### ðŸ’¾ Transaction Commit
**Timestamp:** {timestamp}  
**Status:** {status}

{f"**Error:** {error}" if error else "**Result:** All changes committed to database"}

"""
        self._write_markdown(content)
    
    def log_purchase_completion(self, success: bool, transaction_id: str, response_data: Dict = None):
        """Log purchase transaction completion."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        status = "âœ… COMPLETED" if success else "âŒ FAILED"
        
        # Console/file log
        self.logger.info(f"ðŸŽ¯ PURCHASE TRANSACTION {status} - ID: {transaction_id}")
        
        # Markdown log
        json_block = ""
        if response_data:
            json_str = json.dumps(response_data, indent=2, default=str)
            json_block = f"```json\n{json_str}\n```"
        
        content = f"""
### ðŸŽ¯ Purchase Transaction Completed
**Timestamp:** {timestamp}  
**Status:** {status}  
**Transaction ID:** {transaction_id}

{"**Response Data:**" if response_data else ""}
{json_block}

---

"""
        self._write_markdown(content)
    
    def log_error(self, error: Exception, context: str = None):
        """Log errors with full context."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        # Console/file log
        self.logger.error(f"ðŸ’¥ ERROR in {context}: {str(error)}")
        self.logger.debug(f"Traceback: {traceback.format_exc()}")
        
        # Markdown log
        content = f"""
### ðŸ’¥ ERROR OCCURRED
**Timestamp:** {timestamp}  
**Context:** {context or "Unknown"}

**Error Message:**
```
{str(error)}
```

**Traceback:**
```
{traceback.format_exc()}
```

---

"""
        self._write_markdown(content)
    
    def log_debug_info(self, title: str, data: Any):
        """Log debug information."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        # Console/file log
        self.logger.debug(f"ðŸ”§ DEBUG - {title}")
        
        # Markdown log
        content = f"""
##### ðŸ”§ Debug Info: {title}
**Timestamp:** {timestamp}

```json
{json.dumps(data, indent=2, default=str) if isinstance(data, (dict, list)) else str(data)}
```

"""
        self._write_markdown(content)


# Global logger instance
purchase_logger = PurchaseTransactionLogger()


def get_purchase_logger() -> PurchaseTransactionLogger:
    """Get the purchase transaction logger instance."""
    return purchase_logger


===== core/logging_config.py â€“ 2025-07-19 12:13:41 IST =====
"""
Centralized Logging Configuration

This module provides centralized configuration for all logging components
including transaction logging, audit logging, and API request/response logging.
"""

import logging
import logging.handlers
import os
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass

from app.core.config import settings


@dataclass
class LoggingConfig:
    """Configuration class for all logging settings."""
    
    # General logging settings
    log_level: str = "INFO"
    log_format: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    
    # File logging settings
    log_directory: str = "logs"
    max_file_size: int = 10 * 1024 * 1024  # 10MB
    backup_count: int = 5
    
    # Transaction logging settings
    transaction_log_directory: str = "logs/transactions"
    transaction_log_enabled: bool = True
    
    # API logging settings
    api_log_enabled: bool = True
    api_log_include_request_body: bool = True
    api_log_include_response_body: bool = False
    api_log_max_body_size: int = 10000
    
    # Audit logging settings
    audit_log_enabled: bool = True
    
    # Performance logging settings
    slow_query_threshold: float = 1.0  # seconds
    log_sql_queries: bool = False
    
    # Error tracking settings
    error_tracking_enabled: bool = True
    capture_stack_traces: bool = True


class LoggingManager:
    """
    Centralized logging manager for the entire application.
    
    This class manages all logging configurations including:
    - Standard application logging
    - Transaction logging
    - API request/response logging
    - Audit logging
    - Error tracking
    """
    
    def __init__(self, config: Optional[LoggingConfig] = None):
        """
        Initialize the logging manager.
        
        Args:
            config: Logging configuration. If None, uses default configuration.
        """
        self.config = config or LoggingConfig()
        self._setup_directories()
        self._configure_root_logger()
        self._loggers: Dict[str, logging.Logger] = {}
        
    def _setup_directories(self) -> None:
        """Create necessary log directories."""
        directories = [
            self.config.log_directory,
            self.config.transaction_log_directory,
        ]
        
        for directory in directories:
            Path(directory).mkdir(parents=True, exist_ok=True)
            
    def _configure_root_logger(self) -> None:
        """Configure the root logger with basic settings."""
        logging.basicConfig(
            level=getattr(logging, self.config.log_level.upper()),
            format=self.config.log_format,
            handlers=[
                logging.StreamHandler(),  # Console output
                self._create_file_handler("app.log")  # File output
            ]
        )
        
    def _create_file_handler(self, filename: str, log_dir: Optional[str] = None) -> logging.Handler:
        """
        Create a rotating file handler.
        
        Args:
            filename: Name of the log file
            log_dir: Directory for the log file. Uses default if None.
            
        Returns:
            Configured file handler
        """
        log_dir = log_dir or self.config.log_directory
        log_path = Path(log_dir) / filename
        
        handler = logging.handlers.RotatingFileHandler(
            log_path,
            maxBytes=self.config.max_file_size,
            backupCount=self.config.backup_count
        )
        
        formatter = logging.Formatter(self.config.log_format)
        handler.setFormatter(formatter)
        
        return handler
        
    def get_logger(self, name: str) -> logging.Logger:
        """
        Get or create a logger with the given name.
        
        Args:
            name: Logger name
            
        Returns:
            Configured logger instance
        """
        if name not in self._loggers:
            logger = logging.getLogger(name)
            logger.setLevel(getattr(logging, self.config.log_level.upper()))
            
            # Add file handler specific to this logger
            if name not in ["root", ""]:
                file_handler = self._create_file_handler(f"{name}.log")
                logger.addHandler(file_handler)
                
            self._loggers[name] = logger
            
        return self._loggers[name]
        
    def get_transaction_logger(self) -> logging.Logger:
        """Get logger specifically for transaction operations."""
        return self.get_logger("transaction")
        
    def get_api_logger(self) -> logging.Logger:
        """Get logger specifically for API operations."""
        return self.get_logger("api")
        
    def get_audit_logger(self) -> logging.Logger:
        """Get logger specifically for audit operations."""
        return self.get_logger("audit")
        
    def get_error_logger(self) -> logging.Logger:
        """Get logger specifically for error tracking."""
        return self.get_logger("error")
        
    def get_performance_logger(self) -> logging.Logger:
        """Get logger specifically for performance monitoring."""
        return self.get_logger("performance")
        
    def configure_transaction_logging(self) -> None:
        """Configure transaction-specific logging settings."""
        if not self.config.transaction_log_enabled:
            return
            
        transaction_logger = self.get_transaction_logger()
        
        # Add transaction-specific handler
        handler = self._create_file_handler(
            "transactions.log", 
            self.config.transaction_log_directory
        )
        transaction_logger.addHandler(handler)
        
        # Configure transaction logger to not propagate to root logger
        # to avoid duplicate log entries
        transaction_logger.propagate = False
        
    def configure_api_logging(self) -> None:
        """Configure API request/response logging settings."""
        if not self.config.api_log_enabled:
            return
            
        api_logger = self.get_api_logger()
        
        # Add API-specific handler
        handler = self._create_file_handler("api.log")
        api_logger.addHandler(handler)
        
    def configure_audit_logging(self) -> None:
        """Configure audit logging settings."""
        if not self.config.audit_log_enabled:
            return
            
        audit_logger = self.get_audit_logger()
        
        # Add audit-specific handler
        handler = self._create_file_handler("audit.log")
        audit_logger.addHandler(handler)
        
    def configure_error_tracking(self) -> None:
        """Configure error tracking and logging."""
        if not self.config.error_tracking_enabled:
            return
            
        error_logger = self.get_error_logger()
        
        # Add error-specific handler
        handler = self._create_file_handler("errors.log")
        error_logger.addHandler(handler)
        
        # Set error logger to WARNING level to capture warnings and errors
        error_logger.setLevel(logging.WARNING)
        
    def configure_performance_logging(self) -> None:
        """Configure performance monitoring and logging."""
        performance_logger = self.get_performance_logger()
        
        # Add performance-specific handler
        handler = self._create_file_handler("performance.log")
        performance_logger.addHandler(handler)
        
    def setup_all_logging(self) -> None:
        """Set up all logging configurations."""
        self.configure_transaction_logging()
        self.configure_api_logging()
        self.configure_audit_logging()
        self.configure_error_tracking()
        self.configure_performance_logging()
        
    def log_application_startup(self) -> None:
        """Log application startup information."""
        logger = self.get_logger("startup")
        logger.info("=== Application Starting ===")
        logger.info(f"Log Level: {self.config.log_level}")
        logger.info(f"Log Directory: {self.config.log_directory}")
        logger.info(f"Transaction Logging: {'Enabled' if self.config.transaction_log_enabled else 'Disabled'}")
        logger.info(f"API Logging: {'Enabled' if self.config.api_log_enabled else 'Disabled'}")
        logger.info(f"Audit Logging: {'Enabled' if self.config.audit_log_enabled else 'Disabled'}")
        logger.info("=== Logging Configuration Complete ===")
        
    def get_logging_status(self) -> Dict[str, Any]:
        """
        Get current logging status and configuration.
        
        Returns:
            Dictionary containing logging status information
        """
        return {
            "config": {
                "log_level": self.config.log_level,
                "log_directory": self.config.log_directory,
                "transaction_log_directory": self.config.transaction_log_directory,
                "transaction_logging_enabled": self.config.transaction_log_enabled,
                "api_logging_enabled": self.config.api_log_enabled,
                "audit_logging_enabled": self.config.audit_log_enabled,
                "error_tracking_enabled": self.config.error_tracking_enabled,
            },
            "loggers": list(self._loggers.keys()),
            "log_files": {
                "app": f"{self.config.log_directory}/app.log",
                "transaction": f"{self.config.transaction_log_directory}/transactions.log",
                "api": f"{self.config.log_directory}/api.log",
                "audit": f"{self.config.log_directory}/audit.log",
                "error": f"{self.config.log_directory}/errors.log",
                "performance": f"{self.config.log_directory}/performance.log",
            }
        }


# Global logging manager instance
_logging_manager: Optional[LoggingManager] = None


def get_logging_manager() -> LoggingManager:
    """
    Get the global logging manager instance.
    
    Returns:
        Global LoggingManager instance
    """
    global _logging_manager
    if _logging_manager is None:
        # Create configuration from environment or use defaults
        config = LoggingConfig(
            log_level=os.getenv("LOG_LEVEL", "INFO"),
            log_directory=os.getenv("LOG_DIRECTORY", "logs"),
            transaction_log_directory=os.getenv("TRANSACTION_LOG_DIRECTORY", "logs/transactions"),
            transaction_log_enabled=os.getenv("TRANSACTION_LOG_ENABLED", "true").lower() == "true",
            api_log_enabled=os.getenv("API_LOG_ENABLED", "true").lower() == "true",
            audit_log_enabled=os.getenv("AUDIT_LOG_ENABLED", "true").lower() == "true",
            error_tracking_enabled=os.getenv("ERROR_TRACKING_ENABLED", "true").lower() == "true",
        )
        
        _logging_manager = LoggingManager(config)
        _logging_manager.setup_all_logging()
        
    return _logging_manager


def setup_application_logging() -> None:
    """Initialize application logging on startup."""
    manager = get_logging_manager()
    manager.log_application_startup()


# Convenience functions for getting specific loggers
def get_transaction_logger() -> logging.Logger:
    """Get transaction logger."""
    return get_logging_manager().get_transaction_logger()


def get_api_logger() -> logging.Logger:
    """Get API logger."""
    return get_logging_manager().get_api_logger()


def get_audit_logger() -> logging.Logger:
    """Get audit logger."""
    return get_logging_manager().get_audit_logger()


def get_error_logger() -> logging.Logger:
    """Get error logger."""
    return get_logging_manager().get_error_logger()


def get_performance_logger() -> logging.Logger:
    """Get performance logger."""
    return get_logging_manager().get_performance_logger()


def get_application_logger(name: str) -> logging.Logger:
    """
    Get application logger by name.
    
    Args:
        name: Logger name
        
    Returns:
        Logger instance
    """
    return get_logging_manager().get_logger(name)

===== core/logging_middleware.py â€“ 2025-07-19 16:15:30 IST =====
"""
Logging Middleware

This middleware provides comprehensive request/response logging for all API calls,
with special attention to transaction-related endpoints. It tracks timing,
user context, and request details for audit and debugging purposes.
"""

import time
import json
import uuid
from typing import Callable, Dict, Any, Optional
from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp
import logging

from app.core.config import settings


class TransactionLoggingMiddleware(BaseHTTPMiddleware):
    """
    Middleware for logging API requests and responses with focus on transactions.
    
    This middleware:
    - Logs all incoming requests with timing
    - Tracks transaction-related API calls
    - Captures user context and session information
    - Logs response status and errors
    - Provides correlation IDs for request tracking
    """
    
    def __init__(
        self,
        app: ASGIApp,
        logger_name: str = "transaction_api",
        log_level: str = "INFO",
        exclude_paths: Optional[list] = None,
        include_request_body: bool = True,
        include_response_body: bool = False,
        max_body_size: int = 10000
    ):
        """
        Initialize the logging middleware.
        
        Args:
            app: ASGI application
            logger_name: Name of the logger to use
            log_level: Logging level
            exclude_paths: Paths to exclude from logging
            include_request_body: Whether to log request bodies
            include_response_body: Whether to log response bodies
            max_body_size: Maximum body size to log (bytes)
        """
        super().__init__(app)
        self.logger = logging.getLogger(logger_name)
        self.logger.setLevel(getattr(logging, log_level.upper()))
        self.exclude_paths = exclude_paths or [
            "/health", "/metrics", "/docs", "/openapi.json", "/favicon.ico"
        ]
        self.include_request_body = include_request_body
        self.include_response_body = include_response_body
        self.max_body_size = max_body_size
        
        # Transaction-related endpoints that need special tracking
        self.transaction_endpoints = [
            "/api/transactions/sales/new",
            "/api/transactions/purchases/new", 
            "/api/transactions/rentals/new",
            "/api/transactions/rental-returns/",
            "/api/rentals/",
            "/api/transactions/",
        ]
        
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """
        Process the request and response with comprehensive logging.
        
        Args:
            request: Incoming HTTP request
            call_next: Next middleware/handler in chain
            
        Returns:
            HTTP response
        """
        # Skip logging for excluded paths
        if any(request.url.path.startswith(path) for path in self.exclude_paths):
            return await call_next(request)
            
        # Generate correlation ID for this request
        correlation_id = str(uuid.uuid4())
        request.state.correlation_id = correlation_id
        
        # Start timing
        start_time = time.time()
        
        # Extract request context
        request_context = await self._extract_request_context(request)
        
        # Check if this is a transaction-related request
        is_transaction_request = any(
            request.url.path.startswith(endpoint) 
            for endpoint in self.transaction_endpoints
        )
        
        # Log incoming request
        await self._log_request(request, request_context, correlation_id, is_transaction_request)
        
        # Process request
        try:
            response = await call_next(request)
            
            # Calculate processing time
            process_time = time.time() - start_time
            
            # Log response
            await self._log_response(
                request, response, request_context, correlation_id, 
                process_time, is_transaction_request
            )
            
            # Add correlation ID to response headers
            response.headers["X-Correlation-ID"] = correlation_id
            response.headers["X-Process-Time"] = f"{process_time:.4f}"
            
            return response
            
        except Exception as e:
            # Calculate processing time for error case
            process_time = time.time() - start_time
            
            # Log error
            await self._log_error(
                request, e, request_context, correlation_id, 
                process_time, is_transaction_request
            )
            
            # Re-raise the exception
            raise
            
    async def _extract_request_context(self, request: Request) -> Dict[str, Any]:
        """
        Extract relevant context information from the request.
        
        Args:
            request: HTTP request
            
        Returns:
            Dictionary containing request context
        """
        context = {
            "method": request.method,
            "url": str(request.url),
            "path": request.url.path,
            "query_params": dict(request.query_params),
            "headers": dict(request.headers),
            "client_ip": self._get_client_ip(request),
            "user_agent": request.headers.get("user-agent"),
            "content_type": request.headers.get("content-type"),
            "content_length": request.headers.get("content-length"),
            "timestamp": time.time()
        }
        
        # Extract user information if available
        if hasattr(request.state, "current_user"):
            context["user_id"] = str(request.state.current_user.id)
            context["username"] = request.state.current_user.username
        
        # Extract session information if available
        if hasattr(request.state, "session_id"):
            context["session_id"] = request.state.session_id
            
        # Extract authorization information
        auth_header = request.headers.get("authorization")
        if auth_header:
            context["auth_type"] = auth_header.split(" ")[0] if " " in auth_header else "unknown"
            context["has_auth"] = True
        else:
            context["has_auth"] = False
            
        return context
        
    async def _log_request(
        self,
        request: Request,
        context: Dict[str, Any],
        correlation_id: str,
        is_transaction: bool
    ) -> None:
        """
        Log incoming request details.
        
        Args:
            request: HTTP request
            context: Request context
            correlation_id: Correlation ID for tracking
            is_transaction: Whether this is a transaction request
        """
        log_data = {
            "event_type": "REQUEST_RECEIVED",
            "correlation_id": correlation_id,
            "method": context["method"],
            "path": context["path"],
            "client_ip": context["client_ip"],
            "user_agent": context["user_agent"],
            "has_auth": context["has_auth"],
            "is_transaction_request": is_transaction,
            "query_params": context["query_params"],
            "timestamp": context["timestamp"]
        }
        
        # Add user context if available
        if "user_id" in context:
            log_data["user_id"] = context["user_id"]
            log_data["username"] = context["username"]
            
        # Add request body for transaction requests if enabled
        # Temporarily disabled for debugging - body consumption causes issues
        # if is_transaction and self.include_request_body:
        #     try:
        #         body = await self._get_request_body(request)
        #         if body and len(body) <= self.max_body_size:
        #             # Try to parse as JSON for better logging
        #             try:
        #                 log_data["request_body"] = json.loads(body)
        #             except json.JSONDecodeError:
        #                 log_data["request_body"] = body[:self.max_body_size]
        #         elif body:
        #             log_data["request_body_truncated"] = True
        #             log_data["request_body_size"] = len(body)
        #     except Exception as e:
        #         log_data["request_body_error"] = str(e)
                
        # Log with appropriate level
        if is_transaction:
            self.logger.info(f"Transaction API Request: {json.dumps(log_data)}")
        else:
            self.logger.debug(f"API Request: {json.dumps(log_data)}")
            
    async def _log_response(
        self,
        request: Request,
        response: Response,
        context: Dict[str, Any],
        correlation_id: str,
        process_time: float,
        is_transaction: bool
    ) -> None:
        """
        Log response details.
        
        Args:
            request: HTTP request
            response: HTTP response
            context: Request context
            correlation_id: Correlation ID for tracking
            process_time: Request processing time
            is_transaction: Whether this is a transaction request
        """
        log_data = {
            "event_type": "REQUEST_COMPLETED",
            "correlation_id": correlation_id,
            "method": context["method"],
            "path": context["path"],
            "status_code": response.status_code,
            "process_time_ms": round(process_time * 1000, 2),
            "is_transaction_request": is_transaction,
            "response_size": len(response.body) if hasattr(response, 'body') else None,
            "timestamp": time.time()
        }
        
        # Add user context if available
        if "user_id" in context:
            log_data["user_id"] = context["user_id"]
            
        # Add response body for transaction requests if enabled and successful
        if (is_transaction and self.include_response_body and 
            200 <= response.status_code < 300):
            try:
                if hasattr(response, 'body') and response.body:
                    body = response.body
                    if len(body) <= self.max_body_size:
                        try:
                            log_data["response_body"] = json.loads(body)
                        except json.JSONDecodeError:
                            log_data["response_body"] = body.decode('utf-8')[:self.max_body_size]
                    else:
                        log_data["response_body_truncated"] = True
            except Exception as e:
                log_data["response_body_error"] = str(e)
                
        # Determine log level based on status code
        if response.status_code >= 500:
            log_level = "error"
        elif response.status_code >= 400:
            log_level = "warning"
        elif is_transaction:
            log_level = "info"
        else:
            log_level = "debug"
            
        # Log the response
        getattr(self.logger, log_level)(
            f"API Response ({response.status_code}): {json.dumps(log_data)}"
        )
        
        # Special logging for transaction completions
        if is_transaction and 200 <= response.status_code < 300:
            self._log_transaction_completion(request, response, context, correlation_id)
            
    async def _log_error(
        self,
        request: Request,
        error: Exception,
        context: Dict[str, Any],
        correlation_id: str,
        process_time: float,
        is_transaction: bool
    ) -> None:
        """
        Log error details.
        
        Args:
            request: HTTP request
            error: Exception that occurred
            context: Request context
            correlation_id: Correlation ID for tracking
            process_time: Request processing time
            is_transaction: Whether this is a transaction request
        """
        log_data = {
            "event_type": "REQUEST_ERROR",
            "correlation_id": correlation_id,
            "method": context["method"],
            "path": context["path"],
            "error_type": type(error).__name__,
            "error_message": str(error),
            "process_time_ms": round(process_time * 1000, 2),
            "is_transaction_request": is_transaction,
            "timestamp": time.time()
        }
        
        # Add user context if available
        if "user_id" in context:
            log_data["user_id"] = context["user_id"]
            
        # Add stack trace for transaction requests
        if is_transaction:
            import traceback
            log_data["stack_trace"] = traceback.format_exc()
            
        self.logger.error(f"API Error: {json.dumps(log_data)}")
        
    def _log_transaction_completion(
        self,
        request: Request,
        response: Response,
        context: Dict[str, Any],
        correlation_id: str
    ) -> None:
        """
        Log successful transaction completion with extracted transaction ID.
        
        Args:
            request: HTTP request
            response: HTTP response
            context: Request context
            correlation_id: Correlation ID for tracking
        """
        try:
            # Try to extract transaction ID from response
            transaction_id = None
            if hasattr(response, 'body') and response.body:
                try:
                    response_data = json.loads(response.body)
                    transaction_id = response_data.get('transaction_id')
                except json.JSONDecodeError:
                    pass
                    
            log_data = {
                "event_type": "TRANSACTION_COMPLETED",
                "correlation_id": correlation_id,
                "transaction_id": transaction_id,
                "endpoint": context["path"],
                "user_id": context.get("user_id"),
                "timestamp": time.time()
            }
            
            self.logger.info(f"Transaction Completed: {json.dumps(log_data)}")
            
        except Exception as e:
            self.logger.warning(f"Failed to log transaction completion: {e}")
            
    async def _get_request_body(self, request: Request) -> Optional[bytes]:
        """
        Extract request body safely and cache it for reuse.
        
        Args:
            request: HTTP request
            
        Returns:
            Request body as bytes or None
        """
        try:
            # Check if body was already read and cached
            if hasattr(request, '_body'):
                return request._body
            
            # Read and cache the body for later use by the endpoint
            body = await request.body()
            request._body = body
            return body
        except Exception:
            return None
            
    def _get_client_ip(self, request: Request) -> str:
        """
        Extract client IP address from request.
        
        Args:
            request: HTTP request
            
        Returns:
            Client IP address
        """
        # Check for forwarded headers first
        forwarded_for = request.headers.get("x-forwarded-for")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
            
        real_ip = request.headers.get("x-real-ip")
        if real_ip:
            return real_ip
            
        # Fall back to direct client
        if request.client:
            return request.client.host
            
        return "unknown"


class RequestContextMiddleware(BaseHTTPMiddleware):
    """
    Middleware for adding request context to all requests.
    
    This middleware adds correlation IDs and timing information
    that can be used by other components for logging and tracking.
    """
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """
        Add context information to the request.
        
        Args:
            request: Incoming HTTP request
            call_next: Next middleware/handler in chain
            
        Returns:
            HTTP response with added context
        """
        # Add correlation ID if not already present
        if not hasattr(request.state, "correlation_id"):
            request.state.correlation_id = str(uuid.uuid4())
            
        # Add request start time
        request.state.start_time = time.time()
        
        # Process request
        response = await call_next(request)
        
        # Add timing and correlation headers to response
        if hasattr(request.state, "correlation_id"):
            response.headers["X-Correlation-ID"] = request.state.correlation_id
            
        if hasattr(request.state, "start_time"):
            process_time = time.time() - request.state.start_time
            response.headers["X-Process-Time"] = f"{process_time:.4f}"
            
        return response

===== core/middleware.py â€“ 2025-07-19 12:13:41 IST =====
"""
Custom middleware for whitelist enforcement and security.
"""

import logging
import time
from typing import Callable, Dict, Any
from fastapi import Request, Response, HTTPException, status
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp

from app.core.whitelist import whitelist_manager

logger = logging.getLogger(__name__)


class WhitelistMiddleware(BaseHTTPMiddleware):
    """Middleware to enforce whitelist rules for API endpoints."""
    
    def __init__(self, app: ASGIApp, enabled: bool = True):
        super().__init__(app)
        self.enabled = enabled
        self.rate_limiter: Dict[str, Dict[str, Any]] = {}
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Process request through whitelist rules."""
        
        if not self.enabled:
            return await call_next(request)
        
        start_time = time.time()
        
        try:
            # Check CORS origin if present
            origin = request.headers.get("origin")
            if origin and not whitelist_manager.is_origin_allowed(origin):
                logger.warning(f"Blocked request from disallowed origin: {origin}")
                return JSONResponse(
                    status_code=status.HTTP_403_FORBIDDEN,
                    content={"detail": "Origin not allowed"}
                )
            
            # Get the request path
            path = request.url.path
            
            # Check rate limiting
            if self._is_rate_limited(request, path):
                logger.warning(f"Rate limit exceeded for {request.client.host} on {path}")
                return JSONResponse(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    content={"detail": "Rate limit exceeded"}
                )
            
            # Process the request
            response = await call_next(request)
            
            # Add security headers
            response = self._add_security_headers(response)
            
            # Log request details
            process_time = time.time() - start_time
            self._log_request(request, response, process_time)
            
            return response
            
        except Exception as e:
            logger.error(f"Error in WhitelistMiddleware: {e}")
            return await call_next(request)
    
    def _is_rate_limited(self, request: Request, path: str) -> bool:
        """Check if request should be rate limited."""
        rate_config = whitelist_manager.get_rate_limiting_config()
        
        if not rate_config.get("enabled", False):
            return False
        
        client_ip = self._get_client_ip(request)
        current_time = time.time()
        
        # Clean old entries
        self._clean_rate_limiter(current_time)
        
        # Check endpoint-specific rate limits
        endpoint_limits = rate_config.get("endpoint_specific", {})
        for endpoint, limits in endpoint_limits.items():
            if self._path_matches(path, endpoint):
                return self._check_rate_limit(
                    client_ip, 
                    endpoint, 
                    limits.get("requests", 100),
                    limits.get("window", "1h"),
                    current_time
                )
        
        # Check global rate limit
        global_limits = rate_config.get("global_rate_limit", {})
        if global_limits:
            return self._check_rate_limit(
                client_ip,
                "global",
                global_limits.get("requests", 1000),
                global_limits.get("window", "1h"),
                current_time
            )
        
        return False
    
    def _path_matches(self, path: str, pattern: str) -> bool:
        """Check if path matches pattern."""
        if pattern == path:
            return True
        
        # Simple pattern matching
        if pattern.endswith("/**"):
            return path.startswith(pattern[:-3])
        elif pattern.endswith("/*"):
            prefix = pattern[:-2]
            return path.startswith(prefix) and "/" not in path[len(prefix):]
        
        return False
    
    def _check_rate_limit(self, client_ip: str, endpoint: str, max_requests: int, window: str, current_time: float) -> bool:
        """Check if client has exceeded rate limit for endpoint."""
        window_seconds = self._parse_time_window(window)
        key = f"{client_ip}:{endpoint}"
        
        if key not in self.rate_limiter:
            self.rate_limiter[key] = {
                "requests": [],
                "window_start": current_time
            }
        
        client_data = self.rate_limiter[key]
        
        # Remove old requests outside the window
        window_start = current_time - window_seconds
        client_data["requests"] = [
            req_time for req_time in client_data["requests"] 
            if req_time > window_start
        ]
        
        # Check if limit exceeded
        if len(client_data["requests"]) >= max_requests:
            return True
        
        # Add current request
        client_data["requests"].append(current_time)
        return False
    
    def _parse_time_window(self, window: str) -> int:
        """Parse time window string to seconds."""
        if window.endswith("s"):
            return int(window[:-1])
        elif window.endswith("m"):
            return int(window[:-1]) * 60
        elif window.endswith("h"):
            return int(window[:-1]) * 3600
        elif window.endswith("d"):
            return int(window[:-1]) * 86400
        else:
            return int(window)  # Assume seconds
    
    def _clean_rate_limiter(self, current_time: float) -> None:
        """Clean old entries from rate limiter."""
        # Remove entries older than 1 hour
        cutoff_time = current_time - 3600
        
        keys_to_remove = []
        for key, data in self.rate_limiter.items():
            if not data["requests"] or max(data["requests"]) < cutoff_time:
                keys_to_remove.append(key)
        
        for key in keys_to_remove:
            del self.rate_limiter[key]
    
    def _get_client_ip(self, request: Request) -> str:
        """Get client IP address."""
        # Check for forwarded headers
        forwarded_for = request.headers.get("x-forwarded-for")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        
        real_ip = request.headers.get("x-real-ip")
        if real_ip:
            return real_ip
        
        # Fallback to direct client
        client = request.client
        return client.host if client else "unknown"
    
    def _add_security_headers(self, response: Response) -> Response:
        """Add security headers to response."""
        security_config = whitelist_manager.get_security_config()
        
        # Add expose headers for CORS
        expose_headers = security_config.get("expose_headers", [])
        if expose_headers:
            response.headers["Access-Control-Expose-Headers"] = ", ".join(expose_headers)
        
        # Add other security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        
        return response
    
    def _log_request(self, request: Request, response: Response, process_time: float) -> None:
        """Log request details."""
        client_ip = self._get_client_ip(request)
        
        logger.info(
            f"{request.method} {request.url.path} - "
            f"Status: {response.status_code} - "
            f"Time: {process_time:.3f}s - "
            f"Client: {client_ip}"
        )


class EndpointAccessMiddleware(BaseHTTPMiddleware):
    """Middleware to control access to specific endpoints based on whitelist configuration."""
    
    def __init__(self, app: ASGIApp, enabled: bool = True):
        super().__init__(app)
        self.enabled = enabled
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Check endpoint access permissions."""
        
        if not self.enabled:
            return await call_next(request)
        
        path = request.url.path
        
        # Skip middleware for public endpoints
        if whitelist_manager.is_endpoint_public(path):
            return await call_next(request)
        
        # For protected endpoints, check authentication in the actual endpoint
        # This middleware just logs access attempts
        logger.debug(f"Access attempt to protected endpoint: {path}")
        
        return await call_next(request)

===== core/permissions.py â€“ 2025-07-19 12:13:41 IST =====
"""
Permission decorators and middleware for FastAPI endpoints
"""
from functools import wraps
from typing import List, Optional, Union
from fastapi import HTTPException, Depends, status
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db
from app.modules.auth.dependencies import get_current_user
from app.modules.users.models import User


def require_permissions(permissions: Union[str, List[str]]):
    """
    Decorator to require specific permissions for an endpoint.
    
    Args:
        permissions: Single permission string or list of permissions
        
    Usage:
        @require_permissions("USER_VIEW")
        @require_permissions(["USER_VIEW", "USER_EDIT"])
    """
    if isinstance(permissions, str):
        permissions = [permissions]
    
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Get current user from dependencies
            current_user = None
            for key, value in kwargs.items():
                if isinstance(value, User):
                    current_user = value
                    break
            
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )
            
            # Check permissions
            for permission in permissions:
                if not current_user.has_permission(permission):
                    raise HTTPException(
                        status_code=status.HTTP_403_FORBIDDEN,
                        detail=f"Permission denied: {permission} required"
                    )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator


def require_role(role_name: str):
    """
    Decorator to require a specific role for an endpoint.
    
    Args:
        role_name: Name of the required role
        
    Usage:
        @require_role("ADMIN")
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Get current user from dependencies
            current_user = None
            for key, value in kwargs.items():
                if isinstance(value, User):
                    current_user = value
                    break
            
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )
            
            # Check role
            if not current_user.has_role(role_name):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Role denied: {role_name} required"
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator


def require_superuser():
    """
    Decorator to require superuser status for an endpoint.
    
    Usage:
        @require_superuser()
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Get current user from dependencies
            current_user = None
            for key, value in kwargs.items():
                if isinstance(value, User):
                    current_user = value
                    break
            
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )
            
            # Check superuser status
            if not current_user.is_superuser:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Superuser access required"
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator


# Dependency functions for use with FastAPI Depends
async def get_current_user_with_permissions(
    permissions: List[str],
    current_user: User = Depends(get_current_user)
) -> User:
    """
    Dependency function to get current user with required permissions.
    
    Args:
        permissions: List of required permissions
        current_user: Current authenticated user
        
    Returns:
        User if they have all required permissions
        
    Raises:
        HTTPException: If user doesn't have required permissions
    """
    for permission in permissions:
        if not current_user.has_permission(permission):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission denied: {permission} required"
            )
    
    return current_user


async def get_current_user_with_role(
    role_name: str,
    current_user: User = Depends(get_current_user)
) -> User:
    """
    Dependency function to get current user with required role.
    
    Args:
        role_name: Required role name
        current_user: Current authenticated user
        
    Returns:
        User if they have the required role
        
    Raises:
        HTTPException: If user doesn't have required role
    """
    if not current_user.has_role(role_name):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Role denied: {role_name} required"
        )
    
    return current_user


async def get_current_superuser(
    current_user: User = Depends(get_current_user)
) -> User:
    """
    Dependency function to get current superuser.
    
    Args:
        current_user: Current authenticated user
        
    Returns:
        User if they are a superuser
        
    Raises:
        HTTPException: If user is not a superuser
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Superuser access required"
        )
    
    return current_user


# Common permission dependency factories
def PermissionDependency(permission: str):
    """
    Factory function to create permission dependency.
    
    Args:
        permission: Required permission name
        
    Returns:
        Dependency function
        
    Usage:
        @app.get("/users/", dependencies=[Depends(PermissionDependency("USER_VIEW"))])
    """
    async def permission_dependency(
        current_user: User = Depends(get_current_user)
    ) -> User:
        if not current_user.has_permission(permission):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission denied: {permission} required"
            )
        return current_user
    
    return permission_dependency


def RoleDependency(role_name: str):
    """
    Factory function to create role dependency.
    
    Args:
        role_name: Required role name
        
    Returns:
        Dependency function
        
    Usage:
        @app.get("/admin/", dependencies=[Depends(RoleDependency("ADMIN"))])
    """
    async def role_dependency(
        current_user: User = Depends(get_current_user)
    ) -> User:
        if not current_user.has_role(role_name):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Role denied: {role_name} required"
            )
        return current_user
    
    return role_dependency


# Superuser dependency
SuperuserDependency = Depends(get_current_superuser)

===== core/scheduler.py â€“ 2025-07-19 12:13:41 IST =====
"""
Task Scheduler Service for FastAPI Application

Integrates APScheduler with FastAPI to provide background task scheduling
for rental status updates and other maintenance tasks.
"""

import asyncio
import logging
from datetime import datetime, time
from typing import Optional, Dict, Any, Callable, List
from contextlib import asynccontextmanager

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.memory import MemoryJobStore
from apscheduler.executors.asyncio import AsyncIOExecutor
from apscheduler.triggers.cron import CronTrigger
from apscheduler.events import EVENT_JOB_EXECUTED, EVENT_JOB_ERROR
from sqlalchemy.ext.asyncio import AsyncSession

from app.db.session import get_session
from app.modules.system.service import SystemService

logger = logging.getLogger(__name__)


class TaskScheduler:
    """
    Application task scheduler using APScheduler.
    
    Provides background task scheduling capabilities for:
    - Daily rental status checks
    - System maintenance tasks
    - Data cleanup operations
    - Custom scheduled tasks
    """
    
    def __init__(self):
        self.scheduler: Optional[AsyncIOScheduler] = None
        self._running = False
        self._system_service: Optional[SystemService] = None
    
    async def initialize(self):
        """Initialize the scheduler with configuration from system settings."""
        if self.scheduler is not None:
            return
        
        # Configure APScheduler
        jobstores = {
            'default': MemoryJobStore()
        }
        
        executors = {
            'default': AsyncIOExecutor()
        }
        
        job_defaults = {
            'coalesce': False,
            'max_instances': 1,
            'misfire_grace_time': 300  # 5 minutes
        }
        
        self.scheduler = AsyncIOScheduler(
            jobstores=jobstores,
            executors=executors,
            job_defaults=job_defaults,
            timezone='UTC'  # Will be updated from settings
        )
        
        # Add event listeners
        self.scheduler.add_listener(self._job_executed, EVENT_JOB_EXECUTED)
        self.scheduler.add_listener(self._job_error, EVENT_JOB_ERROR)
        
        logger.info("Task scheduler initialized")
    
    async def start(self):
        """Start the scheduler and register default jobs."""
        if not self.scheduler:
            await self.initialize()
        
        if self._running:
            return
        
        # Load configuration from system settings
        await self._load_configuration()
        
        # Register default jobs
        await self._register_default_jobs()
        
        # Start the scheduler
        self.scheduler.start()
        self._running = True
        
        logger.info("Task scheduler started")
    
    async def stop(self):
        """Stop the scheduler gracefully."""
        if self.scheduler and self._running:
            self.scheduler.shutdown(wait=True)
            self._running = False
            logger.info("Task scheduler stopped")
    
    async def _load_configuration(self):
        """Load scheduler configuration from system settings."""
        try:
            async for session in get_session():
                self._system_service = SystemService(session)
                
                # Get timezone setting
                timezone = await self._system_service.get_setting_value('task_scheduler_timezone', 'UTC')
                
                # Update scheduler timezone
                if self.scheduler:
                    self.scheduler.configure(timezone=timezone)
                
                logger.info(f"Scheduler configured with timezone: {timezone}")
                break
                
        except Exception as e:
            logger.error(f"Failed to load scheduler configuration: {e}")
            # Continue with defaults
    
    async def _register_default_jobs(self):
        """Register default scheduled jobs."""
        if not self.scheduler:
            return
        
        try:
            async for session in get_session():
                system_service = SystemService(session)
                
                # Check if rental status checking is enabled
                status_check_enabled = await system_service.get_setting_value('rental_status_check_enabled', True)
                
                if status_check_enabled:
                    # Get the time to run the status check
                    check_time_str = await system_service.get_setting_value('rental_status_check_time', '00:00')
                    
                    try:
                        # Parse time string (HH:MM format)
                        hour, minute = map(int, check_time_str.split(':'))
                        
                        # Add daily rental status check job
                        self.scheduler.add_job(
                            func=self._rental_status_check_job,
                            trigger=CronTrigger(hour=hour, minute=minute),
                            id='daily_rental_status_check',
                            name='Daily Rental Status Check',
                            replace_existing=True
                        )
                        
                        logger.info(f"Scheduled daily rental status check at {check_time_str}")
                        
                    except ValueError:
                        logger.error(f"Invalid time format in setting: {check_time_str}")
                
                # Add weekly cleanup job (Sundays at 2 AM)
                self.scheduler.add_job(
                    func=self._weekly_cleanup_job,
                    trigger=CronTrigger(day_of_week=6, hour=2, minute=0),  # Sunday at 2 AM
                    id='weekly_cleanup',
                    name='Weekly System Cleanup',
                    replace_existing=True
                )
                
                logger.info("Default scheduled jobs registered")
                break
                
        except Exception as e:
            logger.error(f"Failed to register default jobs: {e}")
    
    async def _rental_status_check_job(self):
        """Daily job to check and update rental statuses."""
        logger.info("Starting daily rental status check job")
        
        try:
            async for session in get_session():
                from app.modules.transactions.services.rental_status_updater import RentalStatusUpdater
                
                updater = RentalStatusUpdater(session)
                
                # Run batch update for all active rentals
                results = await updater.batch_update_overdue_statuses(
                    changed_by=None  # System change
                )
                
                logger.info(f"Daily rental status check completed: {results['successful_updates']} updates, {results['failed_updates']} failures")
                
                # Log to system audit
                if self._system_service:
                    await self._system_service.create_audit_log(
                        action='SCHEDULED_TASK',
                        entity_type='RentalStatusCheck',
                        audit_metadata={
                            'job_name': 'daily_rental_status_check',
                            'results': results
                        },
                        success=results['failed_updates'] == 0
                    )
                
                break
                
        except Exception as e:
            logger.error(f"Daily rental status check job failed: {e}")
            
            # Log error to system audit
            if self._system_service:
                try:
                    async for session in get_session():
                        system_service = SystemService(session)
                        await system_service.create_audit_log(
                            action='SCHEDULED_TASK',
                            entity_type='RentalStatusCheck',
                            audit_metadata={
                                'job_name': 'daily_rental_status_check',
                                'error': str(e)
                            },
                            success=False,
                            error_message=str(e)
                        )
                        break
                except:
                    pass  # Don't fail if audit logging fails
            
            raise
    
    async def _weekly_cleanup_job(self):
        """Weekly job for system maintenance and cleanup."""
        logger.info("Starting weekly cleanup job")
        
        try:
            async for session in get_session():
                system_service = SystemService(session)
                
                # Perform system maintenance
                maintenance_results = await system_service.perform_system_maintenance(
                    user_id=None  # System maintenance
                )
                
                # Clean up old rental status logs
                retention_days = await system_service.get_setting_value('rental_status_log_retention_days', 365)
                
                # TODO: Implement rental status log cleanup
                # This would be implemented when we add the cleanup method to the status updater
                
                logger.info(f"Weekly cleanup completed: {maintenance_results}")
                
                # Log to system audit
                await system_service.create_audit_log(
                    action='SCHEDULED_TASK',
                    entity_type='SystemMaintenance',
                    audit_metadata={
                        'job_name': 'weekly_cleanup',
                        'results': maintenance_results
                    },
                    success=True
                )
                
                break
                
        except Exception as e:
            logger.error(f"Weekly cleanup job failed: {e}")
            raise
    
    def _job_executed(self, event):
        """Handle job execution events."""
        logger.info(f"Job {event.job_id} executed successfully")
    
    def _job_error(self, event):
        """Handle job error events."""
        logger.error(f"Job {event.job_id} failed: {event.exception}")
    
    async def add_job(
        self,
        func: Callable,
        trigger,
        job_id: str,
        name: Optional[str] = None,
        **kwargs
    ):
        """Add a custom job to the scheduler."""
        if not self.scheduler:
            await self.initialize()
        
        if self.scheduler:
            self.scheduler.add_job(
                func=func,
                trigger=trigger,
                id=job_id,
                name=name or job_id,
                replace_existing=True,
                **kwargs
            )
            logger.info(f"Added job: {job_id}")
    
    async def remove_job(self, job_id: str):
        """Remove a job from the scheduler."""
        if self.scheduler and self._running:
            try:
                self.scheduler.remove_job(job_id)
                logger.info(f"Removed job: {job_id}")
            except Exception as e:
                logger.error(f"Failed to remove job {job_id}: {e}")
    
    async def get_jobs(self) -> List[Dict[str, Any]]:
        """Get list of all scheduled jobs."""
        if not self.scheduler:
            return []
        
        jobs = []
        for job in self.scheduler.get_jobs():
            jobs.append({
                'id': job.id,
                'name': job.name,
                'next_run_time': job.next_run_time.isoformat() if job.next_run_time else None,
                'trigger': str(job.trigger)
            })
        
        return jobs
    
    async def trigger_job(self, job_id: str):
        """Manually trigger a job to run immediately."""
        if self.scheduler and self._running:
            try:
                job = self.scheduler.get_job(job_id)
                if job:
                    self.scheduler.modify_job(job_id, next_run_time=datetime.now())
                    logger.info(f"Triggered job: {job_id}")
                else:
                    raise ValueError(f"Job {job_id} not found")
            except Exception as e:
                logger.error(f"Failed to trigger job {job_id}: {e}")
                raise


# Global scheduler instance
task_scheduler = TaskScheduler()


@asynccontextmanager
async def scheduler_lifespan():
    """Context manager for scheduler lifecycle management."""
    try:
        await task_scheduler.start()
        yield task_scheduler
    finally:
        await task_scheduler.stop()


# Dependency for getting the scheduler in FastAPI routes
async def get_scheduler() -> TaskScheduler:
    """FastAPI dependency for getting the task scheduler."""
    return task_scheduler

===== core/security.py â€“ 2025-07-19 12:13:41 IST =====
from datetime import datetime, timedelta
from typing import Optional, Union
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel

from app.core.config import settings


# Password hashing context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


# Token models
class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str


class TokenData(BaseModel):
    username: Optional[str] = None
    user_id: Optional[int] = None
    scopes: list[str] = []


class RefreshTokenData(BaseModel):
    user_id: int
    username: str


# Password utilities
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)


def validate_password(password: str) -> bool:
    """Validate password strength"""
    if len(password) < settings.PASSWORD_MIN_LENGTH:
        return False
    # Add more validation rules as needed
    return True


# JWT utilities
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create JWT access token"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire, "type": "access"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.JWT_ALGORITHM)
    return encoded_jwt


def create_refresh_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create JWT refresh token"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.JWT_ALGORITHM)
    return encoded_jwt


def verify_token(token: str, expected_type: str = "access") -> Union[TokenData, RefreshTokenData]:
    """Verify and decode JWT token"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
        
        # Check token type
        token_type = payload.get("type")
        if token_type != expected_type:
            raise JWTError("Invalid token type")
        
        # Extract data based on token type
        if expected_type == "access":
            username: str = payload.get("sub")
            user_id: int = payload.get("user_id")
            scopes: list = payload.get("scopes", [])
            
            if username is None or user_id is None:
                raise JWTError("Invalid token payload")
            
            return TokenData(username=username, user_id=user_id, scopes=scopes)
        
        elif expected_type == "refresh":
            user_id: int = payload.get("user_id")
            username: str = payload.get("sub")
            
            if user_id is None or username is None:
                raise JWTError("Invalid refresh token payload")
            
            return RefreshTokenData(user_id=user_id, username=username)
            
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )


def create_token_pair(user_id: int, username: str, scopes: list = None) -> Token:
    """Create both access and refresh tokens"""
    if scopes is None:
        scopes = []
    
    # Create access token
    access_token_data = {
        "sub": username,
        "user_id": user_id,
        "scopes": scopes
    }
    access_token = create_access_token(access_token_data)
    
    # Create refresh token
    refresh_token_data = {
        "sub": username,
        "user_id": user_id
    }
    refresh_token = create_refresh_token(refresh_token_data)
    
    return Token(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer"
    )


# HTTP Bearer scheme for authentication
security = HTTPBearer()


async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> dict:
    """
    Get current user from JWT token.
    
    This is a placeholder implementation. In a real application, you would:
    1. Decode the JWT token
    2. Validate it
    3. Look up the user in the database
    4. Return the user object
    
    For now, returning a mock user for development purposes.
    """
    try:
        # Decode and validate the token
        token_data = decode_access_token(credentials.credentials)
        
        # Return user information
        # In a real implementation, you'd fetch this from the database
        return {
            "id": token_data.user_id,
            "username": token_data.username,
            "email": f"{token_data.username}@example.com",
            "scopes": token_data.scopes
        }
    except HTTPException:
        # For development purposes, return a mock user if token validation fails
        return {
            "id": 1,
            "username": "admin",
            "email": "admin@example.com",
            "scopes": ["admin"]
        }

===== core/transaction_logger.py â€“ 2025-07-19 12:13:41 IST =====
"""
Comprehensive Transaction Logger

This module provides a generic transaction logging mechanism that captures
all transaction data and its effects across the system including:
- Transaction lifecycle events
- Inventory changes
- Master data impacts
- Payment processing
- Error handling

File naming convention: transaction-name-mm-hh-ddmmyy.md
"""

import os
import json
from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from uuid import UUID
from pathlib import Path
from decimal import Decimal

from app.core.config import settings


class TransactionLogger:
    """
    Comprehensive transaction logger that creates detailed markdown logs
    for all transaction operations and their system-wide effects.
    """
    
    def __init__(self, base_log_dir: str = "logs/transactions"):
        """
        Initialize the transaction logger.
        
        Args:
            base_log_dir: Base directory for transaction logs
        """
        self.base_log_dir = Path(base_log_dir)
        self.base_log_dir.mkdir(parents=True, exist_ok=True)
        self.current_transaction_id: Optional[UUID] = None
        self.current_log_file: Optional[Path] = None
        self.transaction_start_time: Optional[datetime] = None
        self.log_data: Dict[str, Any] = {}
        
    def start_transaction_log(
        self, 
        transaction_type: str, 
        transaction_id: UUID,
        operation_name: str = None
    ) -> None:
        """
        Start logging for a new transaction.
        
        Args:
            transaction_type: Type of transaction (SALE, PURCHASE, RENTAL, etc.)
            transaction_id: Unique transaction identifier
            operation_name: Optional specific operation name
        """
        self.current_transaction_id = transaction_id
        self.transaction_start_time = datetime.now()
        
        # Generate filename: operation-name-mm-hh-ddmmyy.md
        timestamp = self.transaction_start_time
        operation = operation_name or transaction_type.lower()
        filename = f"{operation}-{timestamp.strftime('%m-%H-%d%m%y')}.md"
        
        self.current_log_file = self.base_log_dir / filename
        
        # Initialize log data structure
        self.log_data = {
            "transaction_info": {
                "transaction_id": str(transaction_id),
                "transaction_type": transaction_type,
                "operation_name": operation,
                "start_time": timestamp.isoformat(),
                "status": "STARTED"
            },
            "system_state": {
                "before": {},
                "after": {}
            },
            "events": [],
            "errors": [],
            "inventory_changes": [],
            "master_data_changes": [],
            "payment_events": [],
            "audit_trail": []
        }
        
        self._log_event("TRANSACTION_STARTED", "Transaction logging initiated")
        
    def log_event(
        self, 
        event_type: str, 
        description: str, 
        data: Dict[str, Any] = None,
        user_id: str = None
    ) -> None:
        """
        Log a transaction event.
        
        Args:
            event_type: Type of event (VALIDATION, PROCESSING, ERROR, etc.)
            description: Human-readable description
            data: Additional event data
            user_id: User who triggered the event
        """
        self._log_event(event_type, description, data, user_id)
        
    def log_validation(
        self, 
        validation_type: str, 
        result: bool, 
        details: Dict[str, Any] = None
    ) -> None:
        """
        Log validation steps and results.
        
        Args:
            validation_type: Type of validation performed
            result: Whether validation passed
            details: Validation details and results
        """
        self._log_event(
            "VALIDATION",
            f"{validation_type} validation {'passed' if result else 'failed'}",
            {
                "validation_type": validation_type,
                "result": result,
                "details": details or {}
            }
        )
        
    def log_inventory_change(
        self,
        item_id: UUID,
        item_name: str,
        change_type: str,
        quantity_before: Decimal,
        quantity_after: Decimal,
        location_id: UUID = None,
        location_name: str = None
    ) -> None:
        """
        Log inventory changes caused by the transaction.
        
        Args:
            item_id: Item identifier
            item_name: Item name
            change_type: Type of change (SALE, PURCHASE, RENTAL_OUT, RENTAL_RETURN)
            quantity_before: Quantity before change
            quantity_after: Quantity after change
            location_id: Location identifier
            location_name: Location name
        """
        change_record = {
            "timestamp": datetime.now().isoformat(),
            "item_id": str(item_id),
            "item_name": item_name,
            "change_type": change_type,
            "quantity_before": str(quantity_before),
            "quantity_after": str(quantity_after),
            "quantity_changed": str(quantity_after - quantity_before),
            "location_id": str(location_id) if location_id else None,
            "location_name": location_name
        }
        
        self.log_data["inventory_changes"].append(change_record)
        self._log_event("INVENTORY_CHANGE", f"{change_type} - {item_name}", change_record)
        
    def log_master_data_change(
        self,
        entity_type: str,
        entity_id: UUID,
        entity_name: str,
        change_type: str,
        old_values: Dict[str, Any] = None,
        new_values: Dict[str, Any] = None
    ) -> None:
        """
        Log changes to master data entities.
        
        Args:
            entity_type: Type of entity (CUSTOMER, ITEM, LOCATION, etc.)
            entity_id: Entity identifier
            entity_name: Entity name
            change_type: Type of change (CREATE, UPDATE, DELETE)
            old_values: Previous values
            new_values: New values
        """
        change_record = {
            "timestamp": datetime.now().isoformat(),
            "entity_type": entity_type,
            "entity_id": str(entity_id),
            "entity_name": entity_name,
            "change_type": change_type,
            "old_values": old_values or {},
            "new_values": new_values or {}
        }
        
        self.log_data["master_data_changes"].append(change_record)
        self._log_event("MASTER_DATA_CHANGE", f"{change_type} {entity_type} - {entity_name}", change_record)
        
    def log_payment_event(
        self,
        payment_type: str,
        amount: Decimal,
        method: str,
        status: str,
        reference: str = None,
        details: Dict[str, Any] = None
    ) -> None:
        """
        Log payment-related events.
        
        Args:
            payment_type: Type of payment (DEPOSIT, FULL_PAYMENT, REFUND, etc.)
            amount: Payment amount
            method: Payment method
            status: Payment status
            reference: Payment reference
            details: Additional payment details
        """
        payment_record = {
            "timestamp": datetime.now().isoformat(),
            "payment_type": payment_type,
            "amount": str(amount),
            "method": method,
            "status": status,
            "reference": reference,
            "details": details or {}
        }
        
        self.log_data["payment_events"].append(payment_record)
        self._log_event("PAYMENT_EVENT", f"{payment_type} - {amount} via {method}", payment_record)
        
    def log_error(
        self,
        error_type: str,
        error_message: str,
        error_details: Dict[str, Any] = None,
        stack_trace: str = None
    ) -> None:
        """
        Log errors that occur during transaction processing.
        
        Args:
            error_type: Type of error
            error_message: Error message
            error_details: Additional error details
            stack_trace: Stack trace if available
        """
        error_record = {
            "timestamp": datetime.now().isoformat(),
            "error_type": error_type,
            "error_message": error_message,
            "error_details": error_details or {},
            "stack_trace": stack_trace
        }
        
        self.log_data["errors"].append(error_record)
        self._log_event("ERROR", f"{error_type}: {error_message}", error_record)
        
    def log_system_state_before(self, state_data: Dict[str, Any]) -> None:
        """
        Capture system state before transaction processing.
        
        Args:
            state_data: System state data
        """
        self.log_data["system_state"]["before"] = {
            **state_data,
            "timestamp": datetime.now().isoformat()
        }
        self._log_event("SYSTEM_STATE_CAPTURED", "System state before transaction captured")
        
    def log_system_state_after(self, state_data: Dict[str, Any]) -> None:
        """
        Capture system state after transaction processing.
        
        Args:
            state_data: System state data
        """
        self.log_data["system_state"]["after"] = {
            **state_data,
            "timestamp": datetime.now().isoformat()
        }
        self._log_event("SYSTEM_STATE_CAPTURED", "System state after transaction captured")
        
    def complete_transaction_log(self, status: str = "COMPLETED") -> Path:
        """
        Complete the transaction log and write to file.
        
        Args:
            status: Final transaction status
            
        Returns:
            Path to the created log file
        """
        if not self.current_log_file:
            raise ValueError("No transaction log session started")
            
        end_time = datetime.now()
        duration = (end_time - self.transaction_start_time).total_seconds()
        
        # Update transaction info
        self.log_data["transaction_info"].update({
            "end_time": end_time.isoformat(),
            "duration_seconds": duration,
            "status": status
        })
        
        self._log_event("TRANSACTION_COMPLETED", f"Transaction completed with status: {status}")
        
        # Generate markdown content
        markdown_content = self._generate_markdown_log()
        
        # Write to file
        with open(self.current_log_file, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
            
        # Reset logger state
        log_file = self.current_log_file
        self._reset_logger_state()
        
        return log_file
        
    def _log_event(
        self, 
        event_type: str, 
        description: str, 
        data: Dict[str, Any] = None,
        user_id: str = None
    ) -> None:
        """Internal method to log events."""
        event = {
            "timestamp": datetime.now().isoformat(),
            "event_type": event_type,
            "description": description,
            "data": data or {},
            "user_id": user_id
        }
        
        self.log_data["events"].append(event)
        
    def _generate_markdown_log(self) -> str:
        """Generate markdown formatted log content."""
        tx_info = self.log_data["transaction_info"]
        
        markdown = f"""# Transaction Log: {tx_info['operation_name'].upper()}

**Transaction ID**: `{tx_info['transaction_id']}`  
**Type**: {tx_info['transaction_type']}  
**Status**: {tx_info['status']}  
**Start Time**: {tx_info['start_time']}  
**End Time**: {tx_info.get('end_time', 'N/A')}  
**Duration**: {tx_info.get('duration_seconds', 0):.2f} seconds

---

## Transaction Events

| Timestamp | Event Type | Description |
|-----------|------------|-------------|
"""
        
        for event in self.log_data["events"]:
            timestamp = event["timestamp"].split("T")[1][:8]  # HH:MM:SS
            markdown += f"| {timestamp} | {event['event_type']} | {event['description']} |\n"
            
        # Inventory Changes
        if self.log_data["inventory_changes"]:
            markdown += "\n---\n\n## Inventory Changes\n\n"
            for change in self.log_data["inventory_changes"]:
                markdown += f"""### {change['item_name']} ({change['change_type']})
- **Item ID**: `{change['item_id']}`
- **Location**: {change['location_name'] or 'N/A'}
- **Quantity Before**: {change['quantity_before']}
- **Quantity After**: {change['quantity_after']}
- **Change**: {change['quantity_changed']}
- **Timestamp**: {change['timestamp']}

"""

        # Master Data Changes
        if self.log_data["master_data_changes"]:
            markdown += "\n---\n\n## Master Data Changes\n\n"
            for change in self.log_data["master_data_changes"]:
                markdown += f"""### {change['entity_type']}: {change['entity_name']}
- **Change Type**: {change['change_type']}
- **Entity ID**: `{change['entity_id']}`
- **Timestamp**: {change['timestamp']}

"""
                if change['old_values']:
                    markdown += "**Previous Values**:\n```json\n"
                    markdown += json.dumps(change['old_values'], indent=2)
                    markdown += "\n```\n\n"
                    
                if change['new_values']:
                    markdown += "**New Values**:\n```json\n"
                    markdown += json.dumps(change['new_values'], indent=2)
                    markdown += "\n```\n\n"

        # Payment Events
        if self.log_data["payment_events"]:
            markdown += "\n---\n\n## Payment Events\n\n"
            for payment in self.log_data["payment_events"]:
                markdown += f"""### {payment['payment_type']}
- **Amount**: {payment['amount']}
- **Method**: {payment['method']}
- **Status**: {payment['status']}
- **Reference**: {payment.get('reference', 'N/A')}
- **Timestamp**: {payment['timestamp']}

"""

        # System State Comparison
        if self.log_data["system_state"]["before"] or self.log_data["system_state"]["after"]:
            markdown += "\n---\n\n## System State Changes\n\n"
            
            if self.log_data["system_state"]["before"]:
                markdown += "### Before Transaction\n```json\n"
                markdown += json.dumps(self.log_data["system_state"]["before"], indent=2, default=str)
                markdown += "\n```\n\n"
                
            if self.log_data["system_state"]["after"]:
                markdown += "### After Transaction\n```json\n"
                markdown += json.dumps(self.log_data["system_state"]["after"], indent=2, default=str)
                markdown += "\n```\n\n"

        # Errors
        if self.log_data["errors"]:
            markdown += "\n---\n\n## Errors and Issues\n\n"
            for error in self.log_data["errors"]:
                markdown += f"""### {error['error_type']}
- **Message**: {error['error_message']}
- **Timestamp**: {error['timestamp']}

"""
                if error['error_details']:
                    markdown += "**Details**:\n```json\n"
                    markdown += json.dumps(error['error_details'], indent=2, default=str)
                    markdown += "\n```\n\n"
                    
                if error['stack_trace']:
                    markdown += "**Stack Trace**:\n```\n"
                    markdown += error['stack_trace']
                    markdown += "\n```\n\n"

        # Summary
        markdown += f"""---

## Summary

- **Total Events**: {len(self.log_data['events'])}
- **Inventory Changes**: {len(self.log_data['inventory_changes'])}
- **Master Data Changes**: {len(self.log_data['master_data_changes'])}
- **Payment Events**: {len(self.log_data['payment_events'])}
- **Errors**: {len(self.log_data['errors'])}

---

*Log generated on {datetime.now().isoformat()}*
"""
        
        return markdown
        
    def _reset_logger_state(self) -> None:
        """Reset logger state after completing a transaction log."""
        self.current_transaction_id = None
        self.current_log_file = None
        self.transaction_start_time = None
        self.log_data = {}


# Global transaction logger instance
transaction_logger = TransactionLogger()


def get_transaction_logger() -> TransactionLogger:
    """Get the global transaction logger instance."""
    return transaction_logger

===== core/whitelist.py â€“ 2025-07-19 12:13:41 IST =====
"""
Whitelist configuration manager for CORS origins and API endpoints.
"""

import json
import logging
from pathlib import Path
from typing import List, Dict, Set, Optional, Any
from functools import lru_cache

logger = logging.getLogger(__name__)


class WhitelistManager:
    """Manages whitelist configuration for CORS origins and API endpoints."""
    
    def __init__(self, config_path: Optional[str] = None):
        """Initialize whitelist manager with configuration file."""
        if config_path is None:
            # Default config path relative to project root
            project_root = Path(__file__).parent.parent.parent
            config_path = project_root / "config" / "whitelist.json"
        
        self.config_path = Path(config_path)
        self._config: Dict[str, Any] = {}
        self._cors_origins_cache: Optional[List[str]] = None
        
        self.load_config()
    
    def load_config(self) -> None:
        """Load whitelist configuration from JSON file."""
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    self._config = json.load(f)
                logger.info(f"Loaded whitelist configuration from {self.config_path}")
            else:
                logger.warning(f"Whitelist config file not found at {self.config_path}, using defaults")
                self._config = self._get_default_config()
                self.save_config()
        except Exception as e:
            logger.error(f"Failed to load whitelist config: {e}")
            self._config = self._get_default_config()
        
        # Clear cache when config is reloaded
        self._cors_origins_cache = None
    
    def save_config(self) -> None:
        """Save current configuration to JSON file."""
        try:
            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(self._config, f, indent=2, ensure_ascii=False)
            logger.info(f"Saved whitelist configuration to {self.config_path}")
        except Exception as e:
            logger.error(f"Failed to save whitelist config: {e}")
    
    def _get_default_config(self) -> Dict[str, Any]:
        """Get default whitelist configuration."""
        return {
            "cors_origins": {
                "localhost_range": {
                    "enabled": True,
                    "start_port": 3000,
                    "end_port": 3050,
                    "protocols": ["http", "https"]
                },
                "localhost_aliases": {
                    "enabled": True,
                    "aliases": ["localhost", "127.0.0.1", "0.0.0.0"]
                },
                "additional_origins": [
                    "http://localhost:8000",
                    "http://127.0.0.1:8000"
                ],
                "development": {
                    "enabled": True,
                    "origins": []
                },
                "production": {
                    "enabled": False,
                    "origins": []
                }
            },
            "api_endpoints": {
                "whitelist_enabled": True,
                "default_access": "restricted",
                "public_endpoints": [
                    "/health",
                    "/docs",
                    "/redoc",
                    "/openapi.json"
                ],
                "protected_endpoints": [],
                "admin_only_endpoints": []
            }
        }
    
    @lru_cache(maxsize=1)
    def get_cors_origins(self) -> List[str]:
        """Get all allowed CORS origins."""
        if self._cors_origins_cache is not None:
            return self._cors_origins_cache
        
        origins = set()
        cors_config = self._config.get("cors_origins", {})
        
        # Add localhost range (3000-3050)
        localhost_range = cors_config.get("localhost_range", {})
        if localhost_range.get("enabled", True):
            start_port = localhost_range.get("start_port", 3000)
            end_port = localhost_range.get("end_port", 3050)
            protocols = localhost_range.get("protocols", ["http"])
            aliases = cors_config.get("localhost_aliases", {}).get("aliases", ["localhost", "127.0.0.1"])
            
            for protocol in protocols:
                for alias in aliases:
                    for port in range(start_port, end_port + 1):
                        origins.add(f"{protocol}://{alias}:{port}")
        
        # Add additional origins
        additional = cors_config.get("additional_origins", [])
        origins.update(additional)
        
        # Add development origins
        dev_config = cors_config.get("development", {})
        if dev_config.get("enabled", True):
            origins.update(dev_config.get("origins", []))
        
        # Add production origins
        prod_config = cors_config.get("production", {})
        if prod_config.get("enabled", False):
            origins.update(prod_config.get("origins", []))
        
        self._cors_origins_cache = sorted(list(origins))
        logger.info(f"Generated {len(self._cors_origins_cache)} CORS origins")
        
        return self._cors_origins_cache
    
    def is_origin_allowed(self, origin: str) -> bool:
        """Check if an origin is allowed."""
        return origin in self.get_cors_origins()
    
    def get_public_endpoints(self) -> List[str]:
        """Get list of public endpoints that don't require authentication."""
        api_config = self._config.get("api_endpoints", {})
        return api_config.get("public_endpoints", [])
    
    def get_protected_endpoints(self) -> List[str]:
        """Get list of protected endpoints that require authentication."""
        api_config = self._config.get("api_endpoints", {})
        return api_config.get("protected_endpoints", [])
    
    def get_admin_only_endpoints(self) -> List[str]:
        """Get list of admin-only endpoints."""
        api_config = self._config.get("api_endpoints", {})
        return api_config.get("admin_only_endpoints", [])
    
    def is_endpoint_public(self, endpoint: str) -> bool:
        """Check if an endpoint is public (no authentication required)."""
        public_endpoints = self.get_public_endpoints()
        
        # Exact match
        if endpoint in public_endpoints:
            return True
        
        # Pattern match (basic glob-style)
        for pattern in public_endpoints:
            if pattern.endswith("/**"):
                prefix = pattern[:-3]
                if endpoint.startswith(prefix):
                    return True
            elif pattern.endswith("/*"):
                prefix = pattern[:-2]
                if endpoint.startswith(prefix) and "/" not in endpoint[len(prefix):]:
                    return True
        
        return False
    
    def is_endpoint_admin_only(self, endpoint: str) -> bool:
        """Check if an endpoint requires admin privileges."""
        admin_endpoints = self.get_admin_only_endpoints()
        
        # Exact match
        if endpoint in admin_endpoints:
            return True
        
        # Pattern match (basic glob-style)
        for pattern in admin_endpoints:
            if pattern.endswith("/**"):
                prefix = pattern[:-3]
                if endpoint.startswith(prefix):
                    return True
            elif pattern.endswith("/*"):
                prefix = pattern[:-2]
                if endpoint.startswith(prefix) and "/" not in endpoint[len(prefix):]:
                    return True
        
        return False
    
    def add_cors_origin(self, origin: str, category: str = "additional_origins") -> None:
        """Add a new CORS origin to the configuration."""
        cors_config = self._config.setdefault("cors_origins", {})
        
        if category == "additional_origins":
            additional = cors_config.setdefault("additional_origins", [])
            if origin not in additional:
                additional.append(origin)
        elif category in ["development", "production"]:
            cat_config = cors_config.setdefault(category, {"enabled": True, "origins": []})
            origins = cat_config.setdefault("origins", [])
            if origin not in origins:
                origins.append(origin)
        
        # Clear cache and save config
        self._cors_origins_cache = None
        self.get_cors_origins.cache_clear()
        self.save_config()
        logger.info(f"Added CORS origin {origin} to {category}")
    
    def remove_cors_origin(self, origin: str) -> bool:
        """Remove a CORS origin from the configuration."""
        removed = False
        cors_config = self._config.get("cors_origins", {})
        
        # Remove from additional_origins
        additional = cors_config.get("additional_origins", [])
        if origin in additional:
            additional.remove(origin)
            removed = True
        
        # Remove from development/production
        for category in ["development", "production"]:
            cat_config = cors_config.get(category, {})
            origins = cat_config.get("origins", [])
            if origin in origins:
                origins.remove(origin)
                removed = True
        
        if removed:
            # Clear cache and save config
            self._cors_origins_cache = None
            self.get_cors_origins.cache_clear()
            self.save_config()
            logger.info(f"Removed CORS origin {origin}")
        
        return removed
    
    def update_localhost_range(self, start_port: int, end_port: int) -> None:
        """Update the localhost port range."""
        cors_config = self._config.setdefault("cors_origins", {})
        localhost_range = cors_config.setdefault("localhost_range", {})
        
        localhost_range["start_port"] = start_port
        localhost_range["end_port"] = end_port
        localhost_range["enabled"] = True
        
        # Clear cache and save config
        self._cors_origins_cache = None
        self.get_cors_origins.cache_clear()
        self.save_config()
        logger.info(f"Updated localhost port range to {start_port}-{end_port}")
    
    def get_security_config(self) -> Dict[str, Any]:
        """Get security configuration."""
        return self._config.get("security", {})
    
    def get_rate_limiting_config(self) -> Dict[str, Any]:
        """Get rate limiting configuration."""
        return self._config.get("rate_limiting", {})
    
    def reload_config(self) -> None:
        """Reload configuration from file."""
        self.load_config()
        logger.info("Whitelist configuration reloaded")


# Global whitelist manager instance
whitelist_manager = WhitelistManager()


# Convenience functions
def get_cors_origins() -> List[str]:
    """Get allowed CORS origins."""
    return whitelist_manager.get_cors_origins()


def is_origin_allowed(origin: str) -> bool:
    """Check if an origin is allowed."""
    return whitelist_manager.is_origin_allowed(origin)


def is_endpoint_public(endpoint: str) -> bool:
    """Check if an endpoint is public."""
    return whitelist_manager.is_endpoint_public(endpoint)


def is_endpoint_admin_only(endpoint: str) -> bool:
    """Check if an endpoint requires admin privileges."""
    return whitelist_manager.is_endpoint_admin_only(endpoint)


def reload_whitelist_config() -> None:
    """Reload whitelist configuration."""
    whitelist_manager.reload_config()

===== shared/__init__.py â€“ 2025-07-19 12:13:41 IST =====


===== shared/dependencies.py â€“ 2025-07-19 12:49:29 IST =====
from typing import Optional, Annotated
from uuid import UUID

from fastapi import Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel

from app.db.session import get_session
from app.core.config import settings
# Database dependency
AsyncSessionDep = Annotated[AsyncSession, Depends(get_session)]


# Common query parameters
class CommonQueryParams(BaseModel):
    """Common query parameters for list endpoints."""
    
    skip: int = Query(0, ge=0, description="Number of records to skip")
    limit: int = Query(
        settings.DEFAULT_PAGE_SIZE,
        ge=1,
        le=settings.MAX_PAGE_SIZE,
        description="Number of records to return"
    )
    sort_by: Optional[str] = Query(None, description="Field to sort by")
    sort_order: str = Query("asc", regex="^(asc|desc)$", description="Sort order")
    search: Optional[str] = Query(None, description="Search term")
    is_active: Optional[bool] = Query(None, description="Filter by active status")


class PaginationParams(BaseModel):
    """Pagination parameters."""
    
    page: int = Query(1, ge=1, description="Page number")
    page_size: int = Query(
        settings.DEFAULT_PAGE_SIZE,
        ge=1,
        le=settings.MAX_PAGE_SIZE,
        description="Items per page"
    )
    
    @property
    def skip(self) -> int:
        """Calculate skip value from page number."""
        return (self.page - 1) * self.page_size
    
    @property
    def limit(self) -> int:
        """Get limit value."""
        return self.page_size


# Repository dependencies
# These will be implemented as modules are created


async def get_brand_repository(session: AsyncSessionDep):
    """Get brand repository instance."""
    from app.modules.master_data.brands.repository import BrandRepository
    return BrandRepository(session)


async def get_category_repository(session: AsyncSessionDep):
    """Get category repository instance."""
    from app.modules.master_data.categories.repository import CategoryRepository
    return CategoryRepository(session)


async def get_unit_repository(session: AsyncSessionDep):
    """Get unit repository instance."""
    from app.modules.master_data.units.repository import UnitRepository
    return UnitRepository(session)


async def get_unit_of_measurement_repository(session: AsyncSessionDep):
    """Get unit of measurement repository instance."""
    from app.modules.master_data.units.repository import UnitOfMeasurementRepository
    return UnitOfMeasurementRepository(session)


# Service dependencies


async def get_customer_service(
    session: AsyncSessionDep
):
    """Get customer service instance."""
    from app.modules.customers.service import CustomerService
    return CustomerService(session)


async def get_supplier_service(
    session: AsyncSessionDep
):
    """Get supplier service instance."""
    from app.modules.suppliers.service import SupplierService
    return SupplierService(session)


async def get_inventory_service(
    session: AsyncSessionDep
):
    """Get inventory service instance."""
    from app.modules.inventory.service import InventoryService
    return InventoryService(session)


async def get_location_service(
    session: AsyncSessionDep
):
    """Get location service instance."""
    from app.modules.master_data.locations.service import LocationService
    return LocationService(session)




async def get_brand_service(
    brand_repo = Depends(get_brand_repository)
):
    """Get brand service instance."""
    from app.modules.master_data.brands.service import BrandService
    return BrandService(brand_repo)


async def get_category_service(
    category_repo = Depends(get_category_repository)
):
    """Get category service instance."""
    from app.modules.master_data.categories.service import CategoryService
    return CategoryService(category_repo)


async def get_unit_service(
    unit_repo = Depends(get_unit_repository)
):
    """Get unit service instance."""
    from app.modules.master_data.units.service import UnitService
    return UnitService(unit_repo)


async def get_unit_of_measurement_service(
    unit_repo = Depends(get_unit_of_measurement_repository)
):
    """Get unit of measurement service instance."""
    from app.modules.master_data.units.service import UnitOfMeasurementService
    return UnitOfMeasurementService(unit_repo)


async def get_analytics_service(
    session: AsyncSessionDep
):
    """Get analytics service instance."""
    from app.modules.analytics.service import AnalyticsService
    return AnalyticsService(session)


async def get_system_service(
    session: AsyncSessionDep
):
    """Get system service instance."""
    from app.modules.system.service import SystemService
    return SystemService(session)






async def get_customer_repository(session: AsyncSessionDep):
    """Get customer repository instance."""
    from app.modules.customers.repository import CustomerRepository
    return CustomerRepository(session)


async def get_supplier_repository(session: AsyncSessionDep):
    """Get supplier repository instance."""
    from app.modules.suppliers.repository import SupplierRepository
    return SupplierRepository(session)


async def get_inventory_repository(session: AsyncSessionDep):
    """Get inventory repository instance."""
    from app.modules.inventory.repository import InventoryRepository
    return InventoryRepository(session)


async def get_transaction_repository(session: AsyncSessionDep):
    """Get transaction repository instance."""
    from app.modules.transactions.base.repository import TransactionRepository
    return TransactionRepository(session)


async def get_location_repository(session: AsyncSessionDep):
    """Get location repository instance."""
    from app.modules.master_data.locations.repository import LocationRepository
    return LocationRepository(session)




# API Key dependency (for external integrations)
async def get_api_key(
    api_key: str = Query(..., description="API Key for authentication")
) -> str:
    """
    Validate API key from query parameter.
    """
    # TODO: Implement API key validation
    # This would check against stored API keys in database
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required"
        )
    
    # Temporary validation
    if api_key != "test-api-key":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )
    
    return api_key


# Request ID dependency (for request tracking)
async def get_request_id() -> str:
    """
    Generate unique request ID for tracking.
    """
    import uuid
    return str(uuid.uuid4())


# Export commonly used dependencies
__all__ = [
    "AsyncSessionDep",
    "CommonQueryParams",
    "PaginationParams",
    "get_api_key",
    "get_request_id",
    "get_customer_service",
    "get_supplier_service",
    "get_inventory_service",
    "get_analytics_service",
    "get_system_service",
    "get_brand_service",
    "get_category_service",
    "get_location_service",
    "get_unit_service",
    "get_unit_of_measurement_service",
]

===== shared/exceptions.py â€“ 2025-07-19 12:13:41 IST =====
from fastapi import HTTPException, status
from typing import Optional, Any


class CustomHTTPException(HTTPException):
    """Custom HTTP exception with additional error type"""
    
    def __init__(
        self,
        status_code: int,
        detail: Any = None,
        headers: Optional[dict] = None,
        error_type: Optional[str] = None
    ):
        super().__init__(status_code=status_code, detail=detail, headers=headers)
        self.error_type = error_type or "GENERIC_ERROR"


class ValidationError(CustomHTTPException):
    """Validation error"""
    
    def __init__(self, detail: str, field: Optional[str] = None):
        super().__init__(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=detail,
            error_type="VALIDATION_ERROR"
        )
        self.field = field


class NotFoundError(CustomHTTPException):
    """Resource not found error"""
    
    def __init__(self, resource: str, identifier: Any = None):
        detail = f"{resource} not found"
        if identifier:
            detail += f" with identifier: {identifier}"
        
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=detail,
            error_type="NOT_FOUND_ERROR"
        )


class AlreadyExistsError(CustomHTTPException):
    """Resource already exists error"""
    
    def __init__(self, resource: str, field: str, value: Any):
        detail = f"{resource} with {field} '{value}' already exists"
        
        super().__init__(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail,
            error_type="ALREADY_EXISTS_ERROR"
        )


class AuthenticationError(CustomHTTPException):
    """Authentication error"""
    
    def __init__(self, detail: str = "Authentication failed"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail,
            headers={"WWW-Authenticate": "Bearer"},
            error_type="AUTHENTICATION_ERROR"
        )


class AuthorizationError(CustomHTTPException):
    """Authorization error"""
    
    def __init__(self, detail: str = "Not enough permissions"):
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail,
            error_type="AUTHORIZATION_ERROR"
        )


class InvalidCredentialsError(CustomHTTPException):
    """Invalid credentials error"""
    
    def __init__(self, detail: str = "Invalid credentials"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail,
            error_type="INVALID_CREDENTIALS_ERROR"
        )


class DatabaseError(CustomHTTPException):
    """Database operation error"""
    
    def __init__(self, detail: str = "Database operation failed"):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=detail,
            error_type="DATABASE_ERROR"
        )


class BusinessLogicError(CustomHTTPException):
    """Business logic error"""
    
    def __init__(self, detail: str, status_code: int = status.HTTP_400_BAD_REQUEST):
        super().__init__(
            status_code=status_code,
            detail=detail,
            error_type="BUSINESS_LOGIC_ERROR"
        )

===== shared/filters.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Any, Dict, List, Optional, Type, Union, Callable
from datetime import datetime, date
from enum import Enum
from pydantic import BaseModel, Field
from sqlalchemy import Select, and_, or_, not_, func
from sqlalchemy.orm import InstrumentedAttribute
import operator
from functools import reduce


class FilterOperator(str, Enum):
    """Supported filter operators."""
    EQ = "eq"           # Equal
    NEQ = "neq"         # Not equal
    GT = "gt"           # Greater than
    GTE = "gte"         # Greater than or equal
    LT = "lt"           # Less than
    LTE = "lte"         # Less than or equal
    IN = "in"           # In list
    NOT_IN = "not_in"   # Not in list
    LIKE = "like"       # SQL LIKE
    ILIKE = "ilike"     # Case-insensitive LIKE
    CONTAINS = "contains"     # Contains substring
    ICONTAINS = "icontains"   # Case-insensitive contains
    STARTS = "starts"         # Starts with
    ISTARTS = "istarts"       # Case-insensitive starts with
    ENDS = "ends"             # Ends with
    IENDS = "iends"           # Case-insensitive ends with
    IS_NULL = "is_null"       # Is null
    IS_NOT_NULL = "is_not_null"  # Is not null
    BETWEEN = "between"       # Between two values


class SortOrder(str, Enum):
    """Sort order options."""
    ASC = "asc"
    DESC = "desc"


class FilterCondition(BaseModel):
    """Single filter condition."""
    field: str = Field(description="Field name to filter on")
    operator: FilterOperator = Field(default=FilterOperator.EQ, description="Filter operator")
    value: Any = Field(description="Value to filter by")
    case_sensitive: bool = Field(default=True, description="Case sensitivity for string operations")


class FilterGroup(BaseModel):
    """Group of filter conditions with logical operator."""
    conditions: List[Union[FilterCondition, "FilterGroup"]] = Field(description="Filter conditions")
    logic: str = Field(default="AND", regex="^(AND|OR)$", description="Logical operator")


# Allow FilterGroup to reference itself
FilterGroup.model_rebuild()


class SortSpec(BaseModel):
    """Sort specification."""
    field: str = Field(description="Field name to sort by")
    order: SortOrder = Field(default=SortOrder.ASC, description="Sort order")


class SearchSpec(BaseModel):
    """Search specification for full-text search."""
    query: str = Field(description="Search query")
    fields: List[str] = Field(description="Fields to search in")
    case_sensitive: bool = Field(default=False, description="Case sensitivity")


class DateRangeFilter(BaseModel):
    """Date range filter."""
    field: str = Field(description="Date field name")
    start_date: Optional[datetime] = Field(None, description="Start date (inclusive)")
    end_date: Optional[datetime] = Field(None, description="End date (inclusive)")


class NumericRangeFilter(BaseModel):
    """Numeric range filter."""
    field: str = Field(description="Numeric field name")
    min_value: Optional[float] = Field(None, description="Minimum value (inclusive)")
    max_value: Optional[float] = Field(None, description="Maximum value (inclusive)")


class FilterBuilder:
    """
    Build SQLAlchemy filters from filter specifications.
    
    Example:
        ```python
        # Simple filter
        filter_spec = FilterCondition(field="name", operator=FilterOperator.LIKE, value="%john%")
        query = FilterBuilder.apply_filter(query, User, filter_spec)
        
        # Complex filter group
        filter_group = FilterGroup(
            conditions=[
                FilterCondition(field="is_active", operator=FilterOperator.EQ, value=True),
                FilterCondition(field="created_at", operator=FilterOperator.GTE, value=datetime.now())
            ],
            logic="AND"
        )
        query = FilterBuilder.apply_filter_group(query, User, filter_group)
        ```
    """
    
    @staticmethod
    def get_field(model: Type, field_name: str) -> InstrumentedAttribute:
        """
        Get model field by name, supporting nested fields.
        
        Args:
            model: SQLAlchemy model class
            field_name: Field name (supports dot notation for relationships)
            
        Returns:
            Model field attribute
        """
        parts = field_name.split(".")
        current = model
        
        for part in parts:
            if hasattr(current, part):
                attr = getattr(current, part)
                if hasattr(attr, "property") and hasattr(attr.property, "mapper"):
                    # This is a relationship, get the related model
                    current = attr.property.mapper.class_
                else:
                    current = attr
            else:
                raise ValueError(f"Field '{part}' not found in {current}")
        
        return current
    
    @staticmethod
    def apply_operator(field: InstrumentedAttribute, op: FilterOperator, value: Any, case_sensitive: bool = True) -> Any:
        """
        Apply filter operator to field.
        
        Args:
            field: Model field
            op: Filter operator
            value: Filter value
            case_sensitive: Case sensitivity for string operations
            
        Returns:
            SQLAlchemy filter expression
        """
        if op == FilterOperator.EQ:
            return field == value
        elif op == FilterOperator.NEQ:
            return field != value
        elif op == FilterOperator.GT:
            return field > value
        elif op == FilterOperator.GTE:
            return field >= value
        elif op == FilterOperator.LT:
            return field < value
        elif op == FilterOperator.LTE:
            return field <= value
        elif op == FilterOperator.IN:
            return field.in_(value if isinstance(value, list) else [value])
        elif op == FilterOperator.NOT_IN:
            return ~field.in_(value if isinstance(value, list) else [value])
        elif op == FilterOperator.LIKE:
            return field.like(value) if case_sensitive else field.ilike(value)
        elif op == FilterOperator.ILIKE:
            return field.ilike(value)
        elif op == FilterOperator.CONTAINS:
            pattern = f"%{value}%"
            return field.like(pattern) if case_sensitive else field.ilike(pattern)
        elif op == FilterOperator.ICONTAINS:
            return field.ilike(f"%{value}%")
        elif op == FilterOperator.STARTS:
            pattern = f"{value}%"
            return field.like(pattern) if case_sensitive else field.ilike(pattern)
        elif op == FilterOperator.ISTARTS:
            return field.ilike(f"{value}%")
        elif op == FilterOperator.ENDS:
            pattern = f"%{value}"
            return field.like(pattern) if case_sensitive else field.ilike(pattern)
        elif op == FilterOperator.IENDS:
            return field.ilike(f"%{value}")
        elif op == FilterOperator.IS_NULL:
            return field.is_(None)
        elif op == FilterOperator.IS_NOT_NULL:
            return field.isnot(None)
        elif op == FilterOperator.BETWEEN:
            if isinstance(value, list) and len(value) == 2:
                return field.between(value[0], value[1])
            else:
                raise ValueError(f"BETWEEN operator requires a list of two values")
        else:
            raise ValueError(f"Unsupported operator: {op}")
    
    @staticmethod
    def apply_filter(query: Select, model: Type, filter_spec: FilterCondition) -> Select:
        """
        Apply a single filter condition to query.
        
        Args:
            query: SQLAlchemy query
            model: Model class
            filter_spec: Filter condition
            
        Returns:
            Modified query
        """
        field = FilterBuilder.get_field(model, filter_spec.field)
        condition = FilterBuilder.apply_operator(
            field, filter_spec.operator, filter_spec.value, filter_spec.case_sensitive
        )
        return query.where(condition)
    
    @staticmethod
    def apply_filter_group(query: Select, model: Type, filter_group: FilterGroup) -> Select:
        """
        Apply a group of filters to query.
        
        Args:
            query: SQLAlchemy query
            model: Model class
            filter_group: Filter group
            
        Returns:
            Modified query
        """
        conditions = []
        
        for item in filter_group.conditions:
            if isinstance(item, FilterCondition):
                field = FilterBuilder.get_field(model, item.field)
                condition = FilterBuilder.apply_operator(
                    field, item.operator, item.value, item.case_sensitive
                )
                conditions.append(condition)
            elif isinstance(item, FilterGroup):
                # Recursively handle nested groups
                sub_conditions = []
                for sub_item in item.conditions:
                    if isinstance(sub_item, FilterCondition):
                        field = FilterBuilder.get_field(model, sub_item.field)
                        condition = FilterBuilder.apply_operator(
                            field, sub_item.operator, sub_item.value, sub_item.case_sensitive
                        )
                        sub_conditions.append(condition)
                
                if sub_conditions:
                    if item.logic == "OR":
                        conditions.append(or_(*sub_conditions))
                    else:
                        conditions.append(and_(*sub_conditions))
        
        if conditions:
            if filter_group.logic == "OR":
                query = query.where(or_(*conditions))
            else:
                query = query.where(and_(*conditions))
        
        return query
    
    @staticmethod
    def apply_search(query: Select, model: Type, search_spec: SearchSpec) -> Select:
        """
        Apply search filter to multiple fields.
        
        Args:
            query: SQLAlchemy query
            model: Model class
            search_spec: Search specification
            
        Returns:
            Modified query
        """
        conditions = []
        search_pattern = f"%{search_spec.query}%"
        
        for field_name in search_spec.fields:
            try:
                field = FilterBuilder.get_field(model, field_name)
                if search_spec.case_sensitive:
                    conditions.append(field.like(search_pattern))
                else:
                    conditions.append(field.ilike(search_pattern))
            except ValueError:
                # Skip invalid fields
                continue
        
        if conditions:
            query = query.where(or_(*conditions))
        
        return query
    
    @staticmethod
    def apply_sort(query: Select, model: Type, sort_specs: List[SortSpec]) -> Select:
        """
        Apply sorting to query.
        
        Args:
            query: SQLAlchemy query
            model: Model class
            sort_specs: List of sort specifications
            
        Returns:
            Modified query
        """
        for sort_spec in sort_specs:
            field = FilterBuilder.get_field(model, sort_spec.field)
            if sort_spec.order == SortOrder.DESC:
                query = query.order_by(field.desc())
            else:
                query = query.order_by(field.asc())
        
        return query
    
    @staticmethod
    def apply_date_range(query: Select, model: Type, date_filter: DateRangeFilter) -> Select:
        """
        Apply date range filter.
        
        Args:
            query: SQLAlchemy query
            model: Model class
            date_filter: Date range filter
            
        Returns:
            Modified query
        """
        field = FilterBuilder.get_field(model, date_filter.field)
        
        if date_filter.start_date:
            query = query.where(field >= date_filter.start_date)
        
        if date_filter.end_date:
            query = query.where(field <= date_filter.end_date)
        
        return query
    
    @staticmethod
    def apply_numeric_range(query: Select, model: Type, numeric_filter: NumericRangeFilter) -> Select:
        """
        Apply numeric range filter.
        
        Args:
            query: SQLAlchemy query
            model: Model class
            numeric_filter: Numeric range filter
            
        Returns:
            Modified query
        """
        field = FilterBuilder.get_field(model, numeric_filter.field)
        
        if numeric_filter.min_value is not None:
            query = query.where(field >= numeric_filter.min_value)
        
        if numeric_filter.max_value is not None:
            query = query.where(field <= numeric_filter.max_value)
        
        return query


class DynamicFilter(BaseModel):
    """
    Dynamic filter specification supporting multiple filter types.
    
    Example:
        ```python
        filter_spec = DynamicFilter(
            filters=[
                FilterCondition(field="status", operator=FilterOperator.EQ, value="active"),
                FilterCondition(field="age", operator=FilterOperator.GTE, value=18)
            ],
            search=SearchSpec(query="john", fields=["name", "email"]),
            date_ranges=[
                DateRangeFilter(field="created_at", start_date=datetime(2023, 1, 1))
            ],
            sort=[
                SortSpec(field="created_at", order=SortOrder.DESC)
            ]
        )
        ```
    """
    filters: List[FilterCondition] = Field(default_factory=list, description="Filter conditions")
    filter_groups: List[FilterGroup] = Field(default_factory=list, description="Filter groups")
    search: Optional[SearchSpec] = Field(None, description="Search specification")
    date_ranges: List[DateRangeFilter] = Field(default_factory=list, description="Date range filters")
    numeric_ranges: List[NumericRangeFilter] = Field(default_factory=list, description="Numeric range filters")
    sort: List[SortSpec] = Field(default_factory=list, description="Sort specifications")
    
    def apply(self, query: Select, model: Type) -> Select:
        """
        Apply all filters to query.
        
        Args:
            query: SQLAlchemy query
            model: Model class
            
        Returns:
            Modified query
        """
        # Apply individual filters
        for filter_spec in self.filters:
            query = FilterBuilder.apply_filter(query, model, filter_spec)
        
        # Apply filter groups
        for filter_group in self.filter_groups:
            query = FilterBuilder.apply_filter_group(query, model, filter_group)
        
        # Apply search
        if self.search:
            query = FilterBuilder.apply_search(query, model, self.search)
        
        # Apply date ranges
        for date_filter in self.date_ranges:
            query = FilterBuilder.apply_date_range(query, model, date_filter)
        
        # Apply numeric ranges
        for numeric_filter in self.numeric_ranges:
            query = FilterBuilder.apply_numeric_range(query, model, numeric_filter)
        
        # Apply sorting
        if self.sort:
            query = FilterBuilder.apply_sort(query, model, self.sort)
        
        return query


def create_filter(**kwargs) -> FilterCondition:
    """
    Convenience function to create a filter condition.
    
    Example:
        ```python
        filter = create_filter(field="name", operator="like", value="%john%")
        ```
    """
    return FilterCondition(**kwargs)


def create_search(query: str, *fields: str, case_sensitive: bool = False) -> SearchSpec:
    """
    Convenience function to create a search specification.
    
    Example:
        ```python
        search = create_search("john", "name", "email", "username")
        ```
    """
    return SearchSpec(query=query, fields=list(fields), case_sensitive=case_sensitive)


def create_sort(*specs: tuple) -> List[SortSpec]:
    """
    Convenience function to create sort specifications.
    
    Example:
        ```python
        sort = create_sort(("created_at", "desc"), ("name", "asc"))
        ```
    """
    return [
        SortSpec(field=field, order=SortOrder(order))
        for field, order in specs
    ]


__all__ = [
    "FilterOperator",
    "SortOrder",
    "FilterCondition",
    "FilterGroup",
    "SortSpec",
    "SearchSpec",
    "DateRangeFilter",
    "NumericRangeFilter",
    "FilterBuilder",
    "DynamicFilter",
    "create_filter",
    "create_search",
    "create_sort",
]

===== shared/models.py â€“ 2025-07-19 12:13:41 IST =====
from pydantic import BaseModel
from typing import Optional, List, Generic, TypeVar
from datetime import datetime

# Generic type for paginated responses
DataType = TypeVar('DataType')


class BaseResponse(BaseModel):
    """Base response model"""
    success: bool = True
    message: Optional[str] = None
    
    model_config = {"from_attributes": True}


class PaginatedResponse(BaseResponse, Generic[DataType]):
    """Paginated response model"""
    data: List[DataType]
    page: int
    size: int
    total: int
    pages: int
    
    model_config = {"from_attributes": True}


class ErrorResponse(BaseModel):
    """Error response model"""
    success: bool = False
    error_type: str
    detail: str
    timestamp: datetime
    
    model_config = {"from_attributes": True}


class HealthResponse(BaseModel):
    """Health check response model"""
    status: str
    service: str
    timestamp: datetime
    version: str
    
    model_config = {"from_attributes": True}

===== shared/pagination.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Generic, TypeVar, List, Optional, Dict, Any
from pydantic import BaseModel
from math import ceil

T = TypeVar('T')


class Page(BaseModel, Generic[T]):
    """Generic pagination container."""
    
    items: List[T]
    total: int
    page: int
    page_size: int
    total_pages: int
    has_next: bool
    has_prev: bool
    
    @classmethod
    def create(
        cls,
        items: List[T],
        total: int,
        page: int,
        page_size: int
    ) -> 'Page[T]':
        """Create a paginated response."""
        total_pages = ceil(total / page_size) if page_size > 0 else 0
        
        return cls(
            items=items,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
            has_next=page < total_pages,
            has_prev=page > 1
        )

===== shared/repository.py â€“ 2025-07-19 15:44:57 IST =====
from typing import Generic, TypeVar, Optional, List, Dict, Any, Type
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, update, delete
from sqlalchemy.orm import selectinload
from datetime import datetime

from app.db.base import BaseModel

ModelType = TypeVar("ModelType", bound=BaseModel)


class BaseRepository(Generic[ModelType]):
    """Base repository class with common database operations."""
    
    def __init__(self, model: Type[ModelType], session: AsyncSession):
        self.model = model
        self.session = session
    
    async def create(self, obj_data: Dict[str, Any]) -> ModelType:
        """Create a new record."""
        db_obj = self.model(**obj_data)
        self.session.add(db_obj)
        await self.session.commit()
        await self.session.refresh(db_obj)
        return db_obj
    
    async def get_by_id(self, id: UUID) -> Optional[ModelType]:
        """Get record by ID."""
        result = await self.session.get(self.model, id)
        return result
    
    async def get_by_ids(self, ids: List[UUID]) -> List[ModelType]:
        """Get multiple records by IDs."""
        if not ids:
            return []
        
        query = select(self.model).where(self.model.id.in_(ids))
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True,
        **filters
    ) -> List[ModelType]:
        """Get all records with optional filtering."""
        query = select(self.model)
        
        if active_only:
            query = query.where(self.model.is_active == True)
        
        # Apply additional filters
        for key, value in filters.items():
            if value is not None and hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)
        
        query = query.offset(skip).limit(limit)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update(self, id: UUID, obj_data: Dict[str, Any]) -> Optional[ModelType]:
        """Update a record."""
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return None
        
        for key, value in obj_data.items():
            if hasattr(db_obj, key):
                setattr(db_obj, key, value)
        
        db_obj.updated_at = datetime.utcnow()
        await self.session.commit()
        await self.session.refresh(db_obj)
        return db_obj
    
    async def delete(self, id: UUID) -> bool:
        """Soft delete a record."""
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return False
        
        db_obj.is_active = False
        db_obj.deleted_at = datetime.utcnow()
        await self.session.commit()
        return True
    
    async def hard_delete(self, id: UUID) -> bool:
        """Hard delete a record."""
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return False
        
        await self.session.delete(db_obj)
        await self.session.commit()
        return True
    
    async def count_all(self, active_only: bool = True, **filters) -> int:
        """Count all records with optional filtering."""
        query = select(func.count(self.model.id))
        
        if active_only:
            query = query.where(self.model.is_active == True)
        
        # Apply additional filters
        for key, value in filters.items():
            if value is not None and hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)
        
        result = await self.session.execute(query)
        return result.scalar()
    
    async def exists(self, id: UUID) -> bool:
        """Check if record exists."""
        query = select(func.count(self.model.id)).where(self.model.id == id)
        result = await self.session.execute(query)
        return result.scalar() > 0
    
    async def bulk_create(self, objs_data: List[Dict[str, Any]]) -> List[ModelType]:
        """Create multiple records."""
        db_objs = [self.model(**obj_data) for obj_data in objs_data]
        self.session.add_all(db_objs)
        await self.session.commit()
        
        # Refresh all objects
        for db_obj in db_objs:
            await self.session.refresh(db_obj)
        
        return db_objs
    
    async def bulk_update(
        self,
        updates: List[Dict[str, Any]],
        key_field: str = "id"
    ) -> int:
        """Bulk update records."""
        if not updates:
            return 0
        
        stmt = update(self.model)
        
        # Execute bulk update
        for update_data in updates:
            key_value = update_data.pop(key_field)
            update_data['updated_at'] = datetime.utcnow()
            
            await self.session.execute(
                stmt.where(getattr(self.model, key_field) == key_value).values(**update_data)
            )
        
        await self.session.commit()
        return len(updates)
    
    async def bulk_delete(self, ids: List[UUID]) -> int:
        """Bulk soft delete records."""
        if not ids:
            return 0
        
        stmt = update(self.model).where(
            self.model.id.in_(ids)
        ).values(
            is_active=False,
            deleted_at=datetime.utcnow()
        )
        
        result = await self.session.execute(stmt)
        await self.session.commit()
        return result.rowcount
    
    async def bulk_hard_delete(self, ids: List[UUID]) -> int:
        """Bulk hard delete records."""
        if not ids:
            return 0
        
        stmt = delete(self.model).where(self.model.id.in_(ids))
        result = await self.session.execute(stmt)
        await self.session.commit()
        return result.rowcount
    
    async def get_by_field(self, field_name: str, value: Any) -> Optional[ModelType]:
        """Get record by specific field."""
        if not hasattr(self.model, field_name):
            return None
        
        query = select(self.model).where(getattr(self.model, field_name) == value)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_fields(self, **filters) -> Optional[ModelType]:
        """Get record by multiple fields."""
        query = select(self.model)
        
        for key, value in filters.items():
            if hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)
        
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def search(
        self,
        search_term: str,
        search_fields: List[str],
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True
    ) -> List[ModelType]:
        """Search records by multiple fields."""
        from sqlalchemy import or_
        
        query = select(self.model)
        
        # Create search conditions
        search_conditions = []
        for field in search_fields:
            if hasattr(self.model, field):
                field_attr = getattr(self.model, field)
                if hasattr(field_attr.type, 'python_type') and field_attr.type.python_type == str:
                    search_conditions.append(field_attr.ilike(f"%{search_term}%"))
        
        if search_conditions:
            query = query.where(or_(*search_conditions))
        
        if active_only:
            query = query.where(self.model.is_active == True)
        
        query = query.offset(skip).limit(limit)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_with_relationships(
        self,
        id: UUID,
        relationships: List[str]
    ) -> Optional[ModelType]:
        """Get record with eagerly loaded relationships."""
        query = select(self.model).where(self.model.id == id)
        
        for rel in relationships:
            if hasattr(self.model, rel):
                query = query.options(selectinload(getattr(self.model, rel)))
        
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_paginated(
        self,
        page: int = 1,
        page_size: int = 20,
        active_only: bool = True,
        **filters
    ) -> Dict[str, Any]:
        """Get paginated results."""
        skip = (page - 1) * page_size
        
        # Get total count
        total = await self.count_all(active_only=active_only, **filters)
        
        # Get items
        items = await self.get_all(
            skip=skip,
            limit=page_size,
            active_only=active_only,
            **filters
        )
        
        total_pages = (total + page_size - 1) // page_size
        
        return {
            "items": items,
            "total": total,
            "page": page,
            "page_size": page_size,
            "total_pages": total_pages,
            "has_next": page < total_pages,
            "has_prev": page > 1
        }

===== shared/utils.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, Dict, Any
from datetime import datetime
import re
import uuid


def generate_uuid() -> str:
    """Generate a UUID string"""
    return str(uuid.uuid4())


def validate_email(email: str) -> bool:
    """Validate email format"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None


def validate_phone(phone: str) -> bool:
    """Validate phone number format"""
    pattern = r'^\+?1?\d{9,15}$'
    return re.match(pattern, phone.replace(' ', '').replace('-', '')) is not None


def clean_phone(phone: str) -> str:
    """Clean phone number by removing spaces and dashes"""
    return phone.replace(' ', '').replace('-', '')


def sanitize_string(value: str, max_length: Optional[int] = None) -> str:
    """Sanitize string by stripping whitespace and limiting length"""
    sanitized = value.strip()
    if max_length and len(sanitized) > max_length:
        sanitized = sanitized[:max_length]
    return sanitized


def format_datetime(dt: datetime, format_string: str = "%Y-%m-%d %H:%M:%S") -> str:
    """Format datetime to string"""
    return dt.strftime(format_string)


def parse_datetime(dt_string: str, format_string: str = "%Y-%m-%d %H:%M:%S") -> datetime:
    """Parse datetime from string"""
    return datetime.strptime(dt_string, format_string)


def deep_merge_dicts(dict1: Dict[str, Any], dict2: Dict[str, Any]) -> Dict[str, Any]:
    """Deep merge two dictionaries"""
    result = dict1.copy()
    
    for key, value in dict2.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge_dicts(result[key], value)
        else:
            result[key] = value
    
    return result


def remove_none_values(data: Dict[str, Any]) -> Dict[str, Any]:
    """Remove None values from dictionary"""
    return {k: v for k, v in data.items() if v is not None}


def snake_to_camel(snake_str: str) -> str:
    """Convert snake_case to camelCase"""
    components = snake_str.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])


def camel_to_snake(camel_str: str) -> str:
    """Convert camelCase to snake_case"""
    result = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', camel_str)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', result).lower()


def calculate_pagination_info(total: int, page: int, size: int) -> Dict[str, int]:
    """Calculate pagination information"""
    pages = (total + size - 1) // size  # Ceiling division
    return {
        "total": total,
        "page": page,
        "size": size,
        "pages": pages,
        "has_next": page < pages,
        "has_prev": page > 1
    }

===== shared/utils/__init__.py â€“ 2025-07-19 12:13:41 IST =====


===== shared/utils/calculations.py â€“ 2025-07-19 12:13:41 IST =====
from typing import List, Optional, Union, Tuple
from decimal import Decimal, ROUND_HALF_UP, ROUND_DOWN
from datetime import datetime, date, timedelta
from enum import Enum
import math

from app.core.config import settings


class RoundingMethod(str, Enum):
    """Rounding methods for calculations."""
    HALF_UP = "half_up"
    HALF_DOWN = "half_down"
    UP = "up"
    DOWN = "down"
    HALF_EVEN = "half_even"


# Financial calculations
def calculate_percentage(
    value: Union[int, float, Decimal],
    percentage: Union[int, float, Decimal],
    decimal_places: int = 2
) -> Decimal:
    """
    Calculate percentage of a value.
    
    Args:
        value: Base value
        percentage: Percentage (0-100)
        decimal_places: Decimal places for result
        
    Returns:
        Calculated percentage amount
    """
    if not isinstance(value, Decimal):
        value = Decimal(str(value))
    if not isinstance(percentage, Decimal):
        percentage = Decimal(str(percentage))
    
    result = value * (percentage / Decimal("100"))
    return result.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)


def calculate_tax(
    amount: Union[int, float, Decimal],
    tax_rate: Union[int, float, Decimal],
    inclusive: bool = False,
    decimal_places: int = 2
) -> Tuple[Decimal, Decimal]:
    """
    Calculate tax amount.
    
    Args:
        amount: Base amount
        tax_rate: Tax rate as percentage (0-100)
        inclusive: Whether tax is included in amount
        decimal_places: Decimal places for result
        
    Returns:
        Tuple of (tax_amount, net_amount)
    """
    if not isinstance(amount, Decimal):
        amount = Decimal(str(amount))
    if not isinstance(tax_rate, Decimal):
        tax_rate = Decimal(str(tax_rate))
    
    if inclusive:
        # Tax is included in amount
        # net = amount / (1 + tax_rate/100)
        net_amount = amount / (Decimal("1") + tax_rate / Decimal("100"))
        tax_amount = amount - net_amount
    else:
        # Tax is added to amount
        tax_amount = calculate_percentage(amount, tax_rate, decimal_places)
        net_amount = amount
    
    return (
        tax_amount.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP),
        net_amount.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)
    )


def calculate_discount(
    original_price: Union[int, float, Decimal],
    discount_percentage: Optional[Union[int, float, Decimal]] = None,
    discount_amount: Optional[Union[int, float, Decimal]] = None,
    decimal_places: int = 2
) -> Tuple[Decimal, Decimal, Decimal]:
    """
    Calculate discounted price.
    
    Args:
        original_price: Original price
        discount_percentage: Discount as percentage
        discount_amount: Discount as fixed amount
        decimal_places: Decimal places for result
        
    Returns:
        Tuple of (discounted_price, discount_amount, effective_percentage)
    """
    if not isinstance(original_price, Decimal):
        original_price = Decimal(str(original_price))
    
    if discount_percentage is not None:
        if not isinstance(discount_percentage, Decimal):
            discount_percentage = Decimal(str(discount_percentage))
        
        discount_amt = calculate_percentage(original_price, discount_percentage, decimal_places)
        effective_pct = discount_percentage
    
    elif discount_amount is not None:
        if not isinstance(discount_amount, Decimal):
            discount_amount = Decimal(str(discount_amount))
        
        discount_amt = min(discount_amount, original_price)  # Can't discount more than price
        effective_pct = (discount_amt / original_price * Decimal("100")) if original_price > 0 else Decimal("0")
    
    else:
        discount_amt = Decimal("0")
        effective_pct = Decimal("0")
    
    discounted_price = original_price - discount_amt
    
    return (
        discounted_price.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP),
        discount_amt.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP),
        effective_pct.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
    )


def calculate_compound_interest(
    principal: Union[int, float, Decimal],
    rate: Union[int, float, Decimal],
    time_periods: int,
    compounds_per_period: int = 1,
    decimal_places: int = 2
) -> Decimal:
    """
    Calculate compound interest.
    
    Args:
        principal: Principal amount
        rate: Interest rate per period as percentage
        time_periods: Number of time periods
        compounds_per_period: Compounding frequency per period
        decimal_places: Decimal places for result
        
    Returns:
        Final amount after compound interest
    """
    if not isinstance(principal, Decimal):
        principal = Decimal(str(principal))
    if not isinstance(rate, Decimal):
        rate = Decimal(str(rate))
    
    # A = P(1 + r/n)^(nt)
    rate_decimal = rate / Decimal("100")
    base = Decimal("1") + (rate_decimal / Decimal(str(compounds_per_period)))
    exponent = compounds_per_period * time_periods
    
    # Use float for power calculation, then convert back
    result = principal * Decimal(str(float(base) ** exponent))
    
    return result.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)


# Date and time calculations
def calculate_days_between(
    start_date: Union[datetime, date],
    end_date: Union[datetime, date],
    inclusive: bool = True
) -> int:
    """
    Calculate days between two dates.
    
    Args:
        start_date: Start date
        end_date: End date
        inclusive: Whether to include both start and end dates
        
    Returns:
        Number of days
    """
    if isinstance(start_date, datetime):
        start_date = start_date.date()
    if isinstance(end_date, datetime):
        end_date = end_date.date()
    
    days = (end_date - start_date).days
    
    if inclusive:
        days += 1
    
    return max(0, days)


def calculate_business_days(
    start_date: Union[datetime, date],
    end_date: Union[datetime, date],
    holidays: Optional[List[date]] = None,
    weekend_days: Tuple[int, int] = (5, 6)  # Saturday, Sunday
) -> int:
    """
    Calculate business days between two dates.
    
    Args:
        start_date: Start date
        end_date: End date
        holidays: List of holiday dates
        weekend_days: Tuple of weekend day numbers (0=Monday, 6=Sunday)
        
    Returns:
        Number of business days
    """
    if isinstance(start_date, datetime):
        start_date = start_date.date()
    if isinstance(end_date, datetime):
        end_date = end_date.date()
    
    holidays = holidays or []
    business_days = 0
    current_date = start_date
    
    while current_date <= end_date:
        if current_date.weekday() not in weekend_days and current_date not in holidays:
            business_days += 1
        current_date += timedelta(days=1)
    
    return business_days


def calculate_age(
    birth_date: Union[datetime, date],
    reference_date: Optional[Union[datetime, date]] = None
) -> int:
    """
    Calculate age in years.
    
    Args:
        birth_date: Birth date
        reference_date: Reference date (defaults to today)
        
    Returns:
        Age in years
    """
    if isinstance(birth_date, datetime):
        birth_date = birth_date.date()
    
    if reference_date is None:
        reference_date = date.today()
    elif isinstance(reference_date, datetime):
        reference_date = reference_date.date()
    
    age = reference_date.year - birth_date.year
    
    # Adjust if birthday hasn't occurred this year
    if (reference_date.month, reference_date.day) < (birth_date.month, birth_date.day):
        age -= 1
    
    return max(0, age)


# Rental calculations
def calculate_rental_price(
    base_price: Union[int, float, Decimal],
    rental_days: int,
    pricing_method: str = "daily",
    weekly_discount: Optional[Union[int, float, Decimal]] = None,
    monthly_discount: Optional[Union[int, float, Decimal]] = None,
    decimal_places: int = 2
) -> Tuple[Decimal, Decimal]:
    """
    Calculate rental price based on duration.
    
    Args:
        base_price: Base daily price
        rental_days: Number of rental days
        pricing_method: Pricing method ("daily", "weekly", "monthly")
        weekly_discount: Discount percentage for weekly rentals
        monthly_discount: Discount percentage for monthly rentals
        decimal_places: Decimal places for result
        
    Returns:
        Tuple of (total_price, effective_daily_rate)
    """
    if not isinstance(base_price, Decimal):
        base_price = Decimal(str(base_price))
    
    if pricing_method == "weekly" and rental_days >= 7:
        weeks = rental_days // 7
        extra_days = rental_days % 7
        
        weekly_price = base_price * Decimal("7")
        if weekly_discount:
            weekly_price = calculate_discount(weekly_price, weekly_discount)[0]
        
        total_price = (weekly_price * Decimal(str(weeks))) + (base_price * Decimal(str(extra_days)))
    
    elif pricing_method == "monthly" and rental_days >= 30:
        months = rental_days // 30
        extra_days = rental_days % 30
        
        monthly_price = base_price * Decimal("30")
        if monthly_discount:
            monthly_price = calculate_discount(monthly_price, monthly_discount)[0]
        
        total_price = (monthly_price * Decimal(str(months))) + (base_price * Decimal(str(extra_days)))
    
    else:
        # Daily pricing
        total_price = base_price * Decimal(str(rental_days))
    
    effective_daily_rate = total_price / Decimal(str(rental_days)) if rental_days > 0 else base_price
    
    return (
        total_price.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP),
        effective_daily_rate.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)
    )


def calculate_late_fee(
    rental_amount: Union[int, float, Decimal],
    days_late: int,
    late_fee_rate: Optional[Union[int, float, Decimal]] = None,
    daily_fee: Optional[Union[int, float, Decimal]] = None,
    max_fee: Optional[Union[int, float, Decimal]] = None,
    decimal_places: int = 2
) -> Decimal:
    """
    Calculate late fee for rental.
    
    Args:
        rental_amount: Original rental amount
        days_late: Number of days late
        late_fee_rate: Late fee as percentage of rental per day
        daily_fee: Fixed daily late fee
        max_fee: Maximum late fee cap
        decimal_places: Decimal places for result
        
    Returns:
        Total late fee
    """
    if not isinstance(rental_amount, Decimal):
        rental_amount = Decimal(str(rental_amount))
    
    if days_late <= 0:
        return Decimal("0")
    
    if daily_fee is not None:
        # Fixed daily fee
        if not isinstance(daily_fee, Decimal):
            daily_fee = Decimal(str(daily_fee))
        total_fee = daily_fee * Decimal(str(days_late))
    
    elif late_fee_rate is not None:
        # Percentage-based fee
        if not isinstance(late_fee_rate, Decimal):
            late_fee_rate = Decimal(str(late_fee_rate))
        
        daily_fee_amount = calculate_percentage(rental_amount, late_fee_rate, decimal_places)
        total_fee = daily_fee_amount * Decimal(str(days_late))
    
    else:
        # Use default rate from settings
        late_fee_rate = Decimal(str(settings.DEFAULT_LATE_FEE_RATE * 100))
        daily_fee_amount = calculate_percentage(rental_amount, late_fee_rate, decimal_places)
        total_fee = daily_fee_amount * Decimal(str(days_late))
    
    # Apply maximum cap if specified
    if max_fee is not None:
        if not isinstance(max_fee, Decimal):
            max_fee = Decimal(str(max_fee))
        total_fee = min(total_fee, max_fee)
    
    return total_fee.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)


# Inventory calculations
def calculate_reorder_point(
    average_daily_usage: Union[int, float, Decimal],
    lead_time_days: int,
    safety_stock: Optional[Union[int, float, Decimal]] = None,
    safety_factor: Optional[float] = None
) -> int:
    """
    Calculate reorder point for inventory.
    
    Args:
        average_daily_usage: Average daily usage rate
        lead_time_days: Lead time in days
        safety_stock: Fixed safety stock quantity
        safety_factor: Safety factor multiplier (e.g., 1.5 for 50% buffer)
        
    Returns:
        Reorder point quantity
    """
    if not isinstance(average_daily_usage, Decimal):
        average_daily_usage = Decimal(str(average_daily_usage))
    
    base_reorder = average_daily_usage * Decimal(str(lead_time_days))
    
    if safety_stock is not None:
        if not isinstance(safety_stock, Decimal):
            safety_stock = Decimal(str(safety_stock))
        total = base_reorder + safety_stock
    elif safety_factor is not None:
        total = base_reorder * Decimal(str(safety_factor))
    else:
        total = base_reorder
    
    # Round up to nearest integer
    return int(math.ceil(float(total)))


def calculate_inventory_value(
    items: List[Tuple[Union[int, float], Union[int, float, Decimal]]],
    method: str = "average",
    decimal_places: int = 2
) -> Decimal:
    """
    Calculate inventory value.
    
    Args:
        items: List of (quantity, unit_cost) tuples
        method: Valuation method ("average", "fifo", "lifo")
        decimal_places: Decimal places for result
        
    Returns:
        Total inventory value
    """
    if not items:
        return Decimal("0")
    
    if method == "average":
        total_quantity = Decimal("0")
        total_value = Decimal("0")
        
        for quantity, unit_cost in items:
            qty = Decimal(str(quantity))
            cost = Decimal(str(unit_cost))
            total_quantity += qty
            total_value += qty * cost
        
        if total_quantity > 0:
            average_cost = total_value / total_quantity
            return total_value.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)
        else:
            return Decimal("0")
    
    else:  # FIFO/LIFO - simplified implementation
        total_value = Decimal("0")
        
        for quantity, unit_cost in items:
            qty = Decimal(str(quantity))
            cost = Decimal(str(unit_cost))
            total_value += qty * cost
        
        return total_value.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)


# Statistical calculations
def calculate_average(
    values: List[Union[int, float, Decimal]],
    decimal_places: int = 2
) -> Decimal:
    """
    Calculate average of values.
    
    Args:
        values: List of values
        decimal_places: Decimal places for result
        
    Returns:
        Average value
    """
    if not values:
        return Decimal("0")
    
    total = sum(Decimal(str(v)) for v in values)
    count = len(values)
    
    average = total / Decimal(str(count))
    return average.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)


def calculate_weighted_average(
    values_weights: List[Tuple[Union[int, float, Decimal], Union[int, float, Decimal]]],
    decimal_places: int = 2
) -> Decimal:
    """
    Calculate weighted average.
    
    Args:
        values_weights: List of (value, weight) tuples
        decimal_places: Decimal places for result
        
    Returns:
        Weighted average
    """
    if not values_weights:
        return Decimal("0")
    
    weighted_sum = Decimal("0")
    total_weight = Decimal("0")
    
    for value, weight in values_weights:
        val = Decimal(str(value))
        wgt = Decimal(str(weight))
        weighted_sum += val * wgt
        total_weight += wgt
    
    if total_weight > 0:
        average = weighted_sum / total_weight
        return average.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)
    else:
        return Decimal("0")


# Utility functions
def round_decimal(
    value: Union[int, float, Decimal],
    decimal_places: int = 2,
    method: RoundingMethod = RoundingMethod.HALF_UP
) -> Decimal:
    """
    Round decimal value using specified method.
    
    Args:
        value: Value to round
        decimal_places: Decimal places
        method: Rounding method
        
    Returns:
        Rounded value
    """
    if not isinstance(value, Decimal):
        value = Decimal(str(value))
    
    quantizer = Decimal(f"0.{'0' * decimal_places}")
    
    if method == RoundingMethod.HALF_UP:
        return value.quantize(quantizer, rounding=ROUND_HALF_UP)
    elif method == RoundingMethod.DOWN:
        return value.quantize(quantizer, rounding=ROUND_DOWN)
    else:
        # Add other rounding methods as needed
        return value.quantize(quantizer, rounding=ROUND_HALF_UP)


def distribute_amount(
    total: Union[int, float, Decimal],
    num_parts: int,
    decimal_places: int = 2
) -> List[Decimal]:
    """
    Distribute amount evenly across parts, handling rounding.
    
    Args:
        total: Total amount to distribute
        num_parts: Number of parts
        decimal_places: Decimal places
        
    Returns:
        List of distributed amounts
    """
    if num_parts <= 0:
        return []
    
    if not isinstance(total, Decimal):
        total = Decimal(str(total))
    
    # Calculate base amount per part
    base_amount = total / Decimal(str(num_parts))
    base_rounded = base_amount.quantize(
        Decimal(f"0.{'0' * decimal_places}"),
        rounding=ROUND_DOWN
    )
    
    # Calculate remainder to distribute
    distributed_total = base_rounded * Decimal(str(num_parts))
    remainder = total - distributed_total
    
    # Create result list
    result = [base_rounded] * num_parts
    
    # Distribute remainder penny by penny
    penny = Decimal(f"0.{'0' * (decimal_places - 1)}1")
    remainder_pennies = int(remainder / penny)
    
    for i in range(min(remainder_pennies, num_parts)):
        result[i] += penny
    
    return result


__all__ = [
    "RoundingMethod",
    "calculate_percentage",
    "calculate_tax",
    "calculate_discount",
    "calculate_compound_interest",
    "calculate_days_between",
    "calculate_business_days",
    "calculate_age",
    "calculate_rental_price",
    "calculate_late_fee",
    "calculate_reorder_point",
    "calculate_inventory_value",
    "calculate_average",
    "calculate_weighted_average",
    "round_decimal",
    "distribute_amount",
]

===== shared/utils/formatters.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, Union, Any, Dict, List
from datetime import datetime, date, timedelta
from decimal import Decimal, ROUND_HALF_UP
from uuid import UUID
import re
import json
from enum import Enum

from app.core.config import settings


# Number formatting
def format_currency(
    amount: Union[int, float, Decimal],
    currency: str = None,
    decimal_places: int = 2,
    include_symbol: bool = True
) -> str:
    """
    Format amount as currency.
    
    Args:
        amount: Amount to format
        currency: Currency code (defaults to settings)
        decimal_places: Number of decimal places
        include_symbol: Whether to include currency symbol
        
    Returns:
        Formatted currency string
    """
    currency = currency or settings.DEFAULT_CURRENCY
    
    # Convert to Decimal for precision
    if not isinstance(amount, Decimal):
        amount = Decimal(str(amount))
    
    # Round to specified decimal places
    quantized = amount.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)
    
    # Format with thousand separators
    formatted = f"{quantized:,.{decimal_places}f}"
    
    # Add currency symbol
    if include_symbol:
        symbols = {
            "USD": "$",
            "EUR": "â‚¬",
            "GBP": "Â£",
            "JPY": "Â¥",
            "INR": "â‚¹",
        }
        symbol = symbols.get(currency, currency + " ")
        
        # Place symbol before or after based on currency
        if currency in ["USD", "GBP"]:
            return f"{symbol}{formatted}"
        else:
            return f"{formatted} {symbol}"
    
    return formatted


def format_percentage(
    value: Union[int, float, Decimal],
    decimal_places: int = 2,
    include_symbol: bool = True
) -> str:
    """
    Format value as percentage.
    
    Args:
        value: Percentage value (0-100)
        decimal_places: Number of decimal places
        include_symbol: Whether to include % symbol
        
    Returns:
        Formatted percentage string
    """
    if not isinstance(value, Decimal):
        value = Decimal(str(value))
    
    quantized = value.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)
    formatted = f"{quantized:.{decimal_places}f}"
    
    if include_symbol:
        return f"{formatted}%"
    
    return formatted


def format_decimal(
    value: Union[int, float, Decimal],
    decimal_places: int = 2,
    min_decimal_places: Optional[int] = None
) -> str:
    """
    Format decimal number.
    
    Args:
        value: Number to format
        decimal_places: Maximum decimal places
        min_decimal_places: Minimum decimal places
        
    Returns:
        Formatted number string
    """
    if not isinstance(value, Decimal):
        value = Decimal(str(value))
    
    # Remove trailing zeros if min_decimal_places not specified
    if min_decimal_places is None:
        normalized = value.normalize()
        return str(normalized)
    
    # Format with specific decimal places
    quantized = value.quantize(Decimal(f"0.{'0' * decimal_places}"), rounding=ROUND_HALF_UP)
    return f"{quantized:.{min_decimal_places or decimal_places}f}"


def format_quantity(
    value: Union[int, float],
    unit: Optional[str] = None,
    decimal_places: int = 0
) -> str:
    """
    Format quantity with optional unit.
    
    Args:
        value: Quantity value
        unit: Unit of measurement
        decimal_places: Decimal places for non-integer quantities
        
    Returns:
        Formatted quantity string
    """
    if isinstance(value, int) or value.is_integer():
        formatted = str(int(value))
    else:
        formatted = format_decimal(value, decimal_places)
    
    if unit:
        return f"{formatted} {unit}"
    
    return formatted


# Date and time formatting
def format_date(
    date_value: Union[datetime, date, str],
    format_string: Optional[str] = None
) -> str:
    """
    Format date according to settings or custom format.
    
    Args:
        date_value: Date to format
        format_string: Custom format string
        
    Returns:
        Formatted date string
    """
    if isinstance(date_value, str):
        # Parse ISO format string
        date_value = datetime.fromisoformat(date_value.replace('Z', '+00:00'))
    
    if isinstance(date_value, datetime):
        date_value = date_value.date()
    
    format_str = format_string or settings.DATE_FORMAT
    return date_value.strftime(format_str)


def format_datetime(
    datetime_value: Union[datetime, str],
    format_string: Optional[str] = None,
    include_timezone: bool = False
) -> str:
    """
    Format datetime according to settings or custom format.
    
    Args:
        datetime_value: Datetime to format
        format_string: Custom format string
        include_timezone: Whether to include timezone
        
    Returns:
        Formatted datetime string
    """
    if isinstance(datetime_value, str):
        # Parse ISO format string
        datetime_value = datetime.fromisoformat(datetime_value.replace('Z', '+00:00'))
    
    format_str = format_string or settings.DATETIME_FORMAT
    
    if include_timezone:
        format_str += " %Z"
    
    return datetime_value.strftime(format_str)


def format_time_ago(
    datetime_value: datetime,
    reference_time: Optional[datetime] = None
) -> str:
    """
    Format datetime as relative time (e.g., "2 hours ago").
    
    Args:
        datetime_value: Datetime to format
        reference_time: Reference time (defaults to now)
        
    Returns:
        Relative time string
    """
    if reference_time is None:
        reference_time = datetime.now(datetime_value.tzinfo)
    
    delta = reference_time - datetime_value
    
    if delta.days > 365:
        years = delta.days // 365
        return f"{years} year{'s' if years > 1 else ''} ago"
    elif delta.days > 30:
        months = delta.days // 30
        return f"{months} month{'s' if months > 1 else ''} ago"
    elif delta.days > 0:
        return f"{delta.days} day{'s' if delta.days > 1 else ''} ago"
    elif delta.seconds > 3600:
        hours = delta.seconds // 3600
        return f"{hours} hour{'s' if hours > 1 else ''} ago"
    elif delta.seconds > 60:
        minutes = delta.seconds // 60
        return f"{minutes} minute{'s' if minutes > 1 else ''} ago"
    else:
        return "just now"


def format_duration(
    duration: Union[timedelta, int],
    unit: str = "seconds",
    verbose: bool = False
) -> str:
    """
    Format duration in human-readable format.
    
    Args:
        duration: Duration as timedelta or integer
        unit: Unit of integer duration ("seconds", "minutes", "hours", "days")
        verbose: Whether to use verbose format
        
    Returns:
        Formatted duration string
    """
    if isinstance(duration, int):
        if unit == "minutes":
            duration = timedelta(minutes=duration)
        elif unit == "hours":
            duration = timedelta(hours=duration)
        elif unit == "days":
            duration = timedelta(days=duration)
        else:
            duration = timedelta(seconds=duration)
    
    total_seconds = int(duration.total_seconds())
    
    if total_seconds < 60:
        return f"{total_seconds} second{'s' if total_seconds != 1 else ''}"
    
    parts = []
    days = total_seconds // 86400
    hours = (total_seconds % 86400) // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60
    
    if days > 0:
        parts.append(f"{days} day{'s' if days != 1 else ''}")
    if hours > 0:
        parts.append(f"{hours} hour{'s' if hours != 1 else ''}")
    if minutes > 0:
        parts.append(f"{minutes} minute{'s' if minutes != 1 else ''}")
    if seconds > 0 and not days:  # Don't show seconds for long durations
        parts.append(f"{seconds} second{'s' if seconds != 1 else ''}")
    
    if verbose:
        if len(parts) > 1:
            return ", ".join(parts[:-1]) + f" and {parts[-1]}"
        return parts[0] if parts else "0 seconds"
    else:
        # Return most significant unit
        return parts[0] if parts else "0 seconds"


# String formatting
def format_name(
    first_name: Optional[str],
    last_name: Optional[str],
    middle_name: Optional[str] = None,
    format_type: str = "full"
) -> str:
    """
    Format person name.
    
    Args:
        first_name: First name
        last_name: Last name
        middle_name: Middle name
        format_type: Format type ("full", "last_first", "initials")
        
    Returns:
        Formatted name
    """
    parts = []
    
    if format_type == "initials":
        if first_name:
            parts.append(first_name[0].upper() + ".")
        if middle_name:
            parts.append(middle_name[0].upper() + ".")
        if last_name:
            parts.append(last_name[0].upper() + ".")
        return " ".join(parts)
    
    elif format_type == "last_first":
        if last_name:
            parts.append(last_name)
        if first_name:
            if parts:
                parts.append(",")
            parts.append(first_name)
        if middle_name:
            parts.append(middle_name)
        return " ".join(parts)
    
    else:  # full
        if first_name:
            parts.append(first_name)
        if middle_name:
            parts.append(middle_name)
        if last_name:
            parts.append(last_name)
        return " ".join(parts)


def format_phone(
    phone: str,
    country_code: str = "US",
    international: bool = False
) -> str:
    """
    Format phone number.
    
    Args:
        phone: Phone number (E.164 format expected)
        country_code: Country code for formatting
        international: Whether to format as international
        
    Returns:
        Formatted phone number
    """
    # Remove all non-digits
    digits = re.sub(r'\D', '', phone)
    
    if country_code == "US" and len(digits) == 10:
        # Format as (XXX) XXX-XXXX
        return f"({digits[:3]}) {digits[3:6]}-{digits[6:]}"
    elif country_code == "US" and len(digits) == 11 and digits[0] == "1":
        # Format as +1 (XXX) XXX-XXXX
        return f"+1 ({digits[1:4]}) {digits[4:7]}-{digits[7:]}"
    else:
        # Return as-is for other formats
        return phone


def format_address(
    street: str,
    city: str,
    state: str,
    postal_code: str,
    country: str = "US",
    multiline: bool = False
) -> str:
    """
    Format address.
    
    Args:
        street: Street address
        city: City
        state: State/Province
        postal_code: Postal/ZIP code
        country: Country code
        multiline: Whether to format as multiple lines
        
    Returns:
        Formatted address
    """
    if multiline:
        lines = [street]
        if country == "US":
            lines.append(f"{city}, {state} {postal_code}")
        else:
            lines.append(f"{city} {state} {postal_code}")
            lines.append(country)
        return "\n".join(lines)
    else:
        if country == "US":
            return f"{street}, {city}, {state} {postal_code}"
        else:
            return f"{street}, {city} {state} {postal_code}, {country}"


def format_code(code: str, prefix: Optional[str] = None) -> str:
    """
    Format code with optional prefix.
    
    Args:
        code: Code to format
        prefix: Optional prefix
        
    Returns:
        Formatted code
    """
    if prefix:
        return f"{prefix}-{code}"
    return code.upper()


# Data structure formatting
def format_list(
    items: List[Any],
    separator: str = ", ",
    last_separator: str = " and ",
    max_items: Optional[int] = None
) -> str:
    """
    Format list as string.
    
    Args:
        items: List of items
        separator: Separator between items
        last_separator: Separator before last item
        max_items: Maximum items to show
        
    Returns:
        Formatted list string
    """
    if not items:
        return ""
    
    str_items = [str(item) for item in items]
    
    if max_items and len(str_items) > max_items:
        shown = str_items[:max_items]
        remaining = len(str_items) - max_items
        shown.append(f"{remaining} more")
        str_items = shown
    
    if len(str_items) == 1:
        return str_items[0]
    elif len(str_items) == 2:
        return f"{str_items[0]}{last_separator}{str_items[1]}"
    else:
        return separator.join(str_items[:-1]) + last_separator + str_items[-1]


def format_key_value(
    data: Dict[str, Any],
    separator: str = ": ",
    line_separator: str = "\n",
    indent: int = 0
) -> str:
    """
    Format dictionary as key-value pairs.
    
    Args:
        data: Dictionary to format
        separator: Separator between key and value
        line_separator: Separator between pairs
        indent: Indentation level
        
    Returns:
        Formatted string
    """
    lines = []
    indent_str = " " * indent
    
    for key, value in data.items():
        # Convert key to title case
        formatted_key = key.replace("_", " ").title()
        
        # Format value based on type
        if isinstance(value, (int, float, Decimal)):
            formatted_value = str(value)
        elif isinstance(value, datetime):
            formatted_value = format_datetime(value)
        elif isinstance(value, date):
            formatted_value = format_date(value)
        elif isinstance(value, bool):
            formatted_value = "Yes" if value else "No"
        elif isinstance(value, Enum):
            formatted_value = value.value.replace("_", " ").title()
        elif value is None:
            formatted_value = "N/A"
        else:
            formatted_value = str(value)
        
        lines.append(f"{indent_str}{formatted_key}{separator}{formatted_value}")
    
    return line_separator.join(lines)


# Status and enum formatting
def format_status(
    status: Union[str, Enum],
    style: str = "title"
) -> str:
    """
    Format status value.
    
    Args:
        status: Status value
        style: Formatting style ("title", "upper", "lower")
        
    Returns:
        Formatted status
    """
    if isinstance(status, Enum):
        value = status.value
    else:
        value = str(status)
    
    # Replace underscores with spaces
    formatted = value.replace("_", " ")
    
    if style == "upper":
        return formatted.upper()
    elif style == "lower":
        return formatted.lower()
    else:
        return formatted.title()


# File size formatting
def format_file_size(
    size_bytes: int,
    decimal_places: int = 2
) -> str:
    """
    Format file size in human-readable format.
    
    Args:
        size_bytes: Size in bytes
        decimal_places: Decimal places for larger units
        
    Returns:
        Formatted file size
    """
    units = ["B", "KB", "MB", "GB", "TB"]
    size = float(size_bytes)
    unit_index = 0
    
    while size >= 1024 and unit_index < len(units) - 1:
        size /= 1024
        unit_index += 1
    
    if unit_index == 0:
        # Bytes - no decimal places
        return f"{int(size)} {units[unit_index]}"
    else:
        return f"{size:.{decimal_places}f} {units[unit_index]}"


# UUID formatting
def format_uuid(
    uuid_value: Union[str, UUID],
    short: bool = False
) -> str:
    """
    Format UUID.
    
    Args:
        uuid_value: UUID value
        short: Whether to return short version (first 8 chars)
        
    Returns:
        Formatted UUID
    """
    uuid_str = str(uuid_value)
    
    if short:
        return uuid_str[:8]
    
    return uuid_str


# JSON formatting
def format_json(
    data: Any,
    indent: int = 2,
    sort_keys: bool = True
) -> str:
    """
    Format data as pretty JSON.
    
    Args:
        data: Data to format
        indent: Indentation level
        sort_keys: Whether to sort keys
        
    Returns:
        Formatted JSON string
    """
    return json.dumps(
        data,
        indent=indent,
        sort_keys=sort_keys,
        default=str,  # Convert non-serializable objects to string
        ensure_ascii=False
    )


__all__ = [
    "format_currency",
    "format_percentage",
    "format_decimal",
    "format_quantity",
    "format_date",
    "format_datetime",
    "format_time_ago",
    "format_duration",
    "format_name",
    "format_phone",
    "format_address",
    "format_code",
    "format_list",
    "format_key_value",
    "format_status",
    "format_file_size",
    "format_uuid",
    "format_json",
]

===== shared/utils/sku_generator.py â€“ 2025-07-21 17:20:27 IST =====
"""
SKU Generation Utility.

This module provides intelligent SKU generation for inventory items based on
category hierarchy, product names, and automatic sequence numbering.
"""

import re
from typing import Optional, Tuple
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from sqlalchemy.orm import selectinload

from app.modules.inventory import SKUSequence
from app.modules.master_data.categories.models import Category
from app.core.errors import ValidationError


class SKUGenerator:
    """
    SKU generation service for creating unique Stock Keeping Units.
    
    Generates SKUs in the format: {CATEGORY}-{SUBCATEGORY}-{PRODUCT_NAME}-{ATTRIBUTES}-{SEQUENCE}
    Examples:
    - ELEC-CAM-DSLR-R-001 (Electronics > Cameras > DSLR Camera, Rental)
    - FURN-CHR-OFFI-B-001 (Furniture > Chairs > Office Chair, Both)
    - TOOL-PWR-DRIL-R-001 (Tools > Power Tools > Drill, Rental)
    """
    
    def __init__(self, session: AsyncSession):
        """Initialize SKU generator with database session."""
        self.session = session
        self._category_cache = {}  # Cache for category lookups
    
    async def generate_sku(
        self,
        category_id: Optional[UUID] = None,
        item_name: str = "",
        is_rentable: bool = True,
        is_saleable: bool = False
    ) -> str:
        """
        Generate a unique SKU for an item.
        
        Args:
            category_id: Category UUID for the item
            item_name: Name of the item for product abbreviation
            is_rentable: Whether item can be rented
            is_saleable: Whether item can be sold
            
        Returns:
            Generated unique SKU string in format: CATEGORY-SUBCATEGORY-PRODUCT-ATTRIBUTES-SEQUENCE
            
        Raises:
            ValidationError: If SKU generation fails
        """
        # Extract category components
        category_code, subcategory_code = await self._get_category_components(category_id)
        
        # Generate product name abbreviation (first 4 letters)
        product_code = self._get_product_code(item_name)
        
        # Generate attributes code from boolean fields
        attributes_code = self._get_attributes_code_from_booleans(is_rentable, is_saleable)
        
        # Create composite key for sequence tracking
        sku_key = f"{category_code}-{subcategory_code}-{product_code}-{attributes_code}"
        
        # Get next sequence number
        sequence_number = await self._get_next_sequence(sku_key)
        
        # Format final SKU
        sku = f"{category_code}-{subcategory_code}-{product_code}-{attributes_code}-{sequence_number:03d}"
        
        # Validate uniqueness (safety check)
        await self._validate_sku_uniqueness(sku)
        
        return sku
    
    async def preview_sku(
        self,
        category_id: Optional[UUID] = None,
        item_name: str = "",
        is_rentable: bool = True,
        is_saleable: bool = False
    ) -> str:
        """
        Preview what SKU would be generated without actually generating it.
        
        Args:
            category_id: Category UUID for the item
            item_name: Name of the item for product abbreviation
            is_rentable: Whether item can be rented
            is_saleable: Whether item can be sold
            
        Returns:
            Preview SKU string
        """
        # Extract category components
        category_code, subcategory_code = await self._get_category_components(category_id)
        
        # Generate product name abbreviation (first 4 letters)
        product_code = self._get_product_code(item_name)
        
        # Generate attributes code from boolean fields
        attributes_code = self._get_attributes_code_from_booleans(is_rentable, is_saleable)
        
        # Create composite key for sequence tracking
        sku_key = f"{category_code}-{subcategory_code}-{product_code}-{attributes_code}"
        
        # Get current sequence (without incrementing)
        sequence_record = await self._get_sequence_record(sku_key)
        sequence_number = sequence_record.get_next_sequence_number() if sequence_record else 1
        
        return f"{category_code}-{subcategory_code}-{product_code}-{attributes_code}-{sequence_number:03d}"
    
    async def _get_category_components(self, category_id: Optional[UUID]) -> Tuple[str, str]:
        """
        Extract category and subcategory codes from category hierarchy.
        
        Args:
            category_id: Category UUID
            
        Returns:
            Tuple of (category_code, subcategory_code)
        """
        if not category_id:
            return "MISC", "ITEM"
        
        # Check cache first
        cache_key = str(category_id)
        if cache_key in self._category_cache:
            return self._category_cache[cache_key]
        
        query = select(Category).where(Category.id == category_id, Category.is_active == True)
        result = await self.session.execute(query)
        category = result.scalar_one_or_none()
        
        if not category:
            result = "MISC", "ITEM"
            self._category_cache[cache_key] = result
            return result
        
        # Parse category path to extract hierarchy
        category_path = category.category_path or category.name
        path_parts = [part.strip() for part in category_path.split('/')]
        
        if len(path_parts) >= 2:
            # We have at least root and subcategory
            category_code = self._generate_code_from_name(path_parts[0], max_length=4)
            subcategory_code = self._generate_code_from_name(path_parts[1], max_length=3)
        elif len(path_parts) == 1:
            # Only root category available
            category_code = self._generate_code_from_name(path_parts[0], max_length=4)
            subcategory_code = "GEN"  # Generic subcategory
        else:
            # Fallback
            category_code = "MISC"
            subcategory_code = "ITEM"
        
        result = category_code, subcategory_code
        # Cache the result for future use
        self._category_cache[cache_key] = result
        return result
    
    def _get_product_code(self, item_name: str) -> str:
        """
        Generate product code from item name (first 4 letters).
        
        Args:
            item_name: Name of the item
            
        Returns:
            4-character product code
        """
        if not item_name:
            return "PROD"
        
        # Remove special characters and get only alphanumeric
        clean_name = re.sub(r'[^a-zA-Z0-9]', '', item_name.upper())
        
        if len(clean_name) >= 4:
            return clean_name[:4]
        elif len(clean_name) > 0:
            # Pad with zeros if less than 4 characters
            return clean_name.ljust(4, '0')
        else:
            return "PROD"
    
    def _get_attributes_code_from_booleans(self, is_rentable: bool, is_saleable: bool) -> str:
        """
        Generate attributes code from boolean fields.
        
        Args:
            is_rentable: Whether item can be rented
            is_saleable: Whether item can be sold
            
        Returns:
            1-character attributes code
        """
        if is_rentable and not is_saleable:
            return "R"
        elif is_saleable and not is_rentable:
            return "S"
        else:
            # This shouldn't happen due to validation, but default to R
            return "R"
    
    def _generate_code_from_name(self, name: str, max_length: int = 8) -> str:
        """
        Generate a code from a name by extracting key characters.
        
        Args:
            name: Name to generate code from
            max_length: Maximum length of generated code
            
        Returns:
            Generated code string
        """
        if not name:
            return ""
        
        # Remove special characters and split into words
        clean_name = re.sub(r'[^a-zA-Z0-9\s]', '', name)
        words = clean_name.upper().split()
        
        if not words:
            return ""
        
        # Strategy 1: First letter of each word
        if len(words) > 1:
            code = ''.join(word[0] for word in words if word)
            if len(code) <= max_length:
                return code
        
        # Strategy 2: First word with vowels removed
        first_word = words[0]
        code = re.sub(r'[AEIOU]', '', first_word)
        if len(code) >= 2 and len(code) <= max_length:
            return code
        
        # Strategy 3: First few characters of first word
        return first_word[:max_length]
    
    async def _get_next_sequence(self, sku_key: str) -> int:
        """
        Get next sequence number for SKU key combination.
        
        Args:
            sku_key: Composite SKU key for sequence tracking
            
        Returns:
            Next sequence number
        """
        # Use SELECT FOR UPDATE to prevent race conditions
        from sqlalchemy import text
        
        sequence_record = await self._get_sequence_record_for_update(sku_key)
        
        if sequence_record:
            # Increment existing sequence
            next_seq = sequence_record.get_next_sequence_number()
            sequence_record.increment_sequence()
            # Flush to ensure the update is made but don't commit yet
            await self.session.flush()
            return next_seq
        else:
            # Create new sequence record using the composite key as brand_code
            new_sequence = SKUSequence(
                brand_code=sku_key,  # Using composite key as identifier
                category_code=None,  # Not used in new format
                next_sequence="2"  # Start at 2 since we're returning 1
            )
            self.session.add(new_sequence)
            # Flush to ensure the insert is made but don't commit yet
            await self.session.flush()
            return 1
    
    async def _get_sequence_record(self, sku_key: str) -> Optional[SKUSequence]:
        """Get existing sequence record for SKU key."""
        query = select(SKUSequence).where(
            SKUSequence.brand_code == sku_key,
            SKUSequence.category_code.is_(None)
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def _get_sequence_record_for_update(self, sku_key: str) -> Optional[SKUSequence]:
        """Get existing sequence record for SKU key with row locking."""
        query = select(SKUSequence).where(
            SKUSequence.brand_code == sku_key,
            SKUSequence.category_code.is_(None)
        ).with_for_update()
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    
    def _validate_sku_format(self, sku: str) -> str:
        """
        Validate SKU format for the new 5-component structure.
        
        Args:
            sku: SKU string to validate
            
        Returns:
            Normalized SKU string
            
        Raises:
            ValidationError: If SKU format is invalid
        """
        if not sku:
            raise ValidationError("SKU cannot be empty")
        
        # Normalize to uppercase and strip whitespace
        normalized_sku = sku.upper().strip()
        
        # Check length
        if len(normalized_sku) < 10 or len(normalized_sku) > 50:
            raise ValidationError("SKU must be between 10 and 50 characters")
        
        # Check format: should have 5 parts separated by hyphens
        parts = normalized_sku.split('-')
        if len(parts) != 5:
            raise ValidationError("SKU must have exactly 5 parts separated by hyphens")
        
        # Validate each part
        category_code, subcategory_code, product_code, attributes_code, sequence = parts
        
        if len(category_code) > 4 or not category_code.isalnum():
            raise ValidationError("Category code must be 1-4 alphanumeric characters")
        
        if len(subcategory_code) > 4 or not subcategory_code.isalnum():
            raise ValidationError("Subcategory code must be 1-4 alphanumeric characters")
        
        if len(product_code) != 4 or not product_code.isalnum():
            raise ValidationError("Product code must be exactly 4 alphanumeric characters")
        
        if len(attributes_code) != 1 or attributes_code not in ['R', 'S', 'B']:
            raise ValidationError("Attributes code must be R (Rental), S (Sale), or B (Both)")
        
        if len(sequence) != 3 or not sequence.isdigit():
            raise ValidationError("Sequence must be exactly 3 digits")
        
        return normalized_sku
    
    async def _validate_sku_uniqueness(self, sku: str) -> None:
        """
        Validate that SKU is unique.
        
        Args:
            sku: SKU string to check
            
        Raises:
            ValidationError: If SKU already exists
        """
        # Import here to avoid circular import
        from app.modules.master_data.item_master.models import Item
        
        query = select(Item).where(Item.sku == sku)
        result = await self.session.execute(query)
        existing_item = result.scalar_one_or_none()
        
        if existing_item:
            raise ValidationError(f"SKU '{sku}' already exists")
    
    async def bulk_generate_skus_for_existing_items(self) -> dict:
        """
        Generate SKUs for existing items that don't have them.
        
        Returns:
            Dictionary with generation statistics
        """
        # Import here to avoid circular import
        from app.modules.master_data.item_master.models import Item
        
        # Find items without SKUs
        query = select(Item).where(Item.sku.is_(None))
        result = await self.session.execute(query)
        items_without_skus = result.scalars().all()
        
        if not items_without_skus:
            return {
                "total_processed": 0,
                "successful_generations": 0,
                "failed_generations": 0,
                "errors": []
            }
        
        successful = 0
        failed = 0
        errors = []
        
        for item in items_without_skus:
            try:
                # Generate SKU based on item's category, name, and boolean fields
                sku = await self.generate_sku(
                    category_id=item.category_id,
                    item_name=item.item_name,
                    is_rentable=item.is_rentable,
                    is_saleable=item.is_saleable
                )
                
                # Update item with generated SKU
                item.sku = sku
                successful += 1
                
            except Exception as e:
                failed += 1
                errors.append({
                    "item_id": str(item.id),
                    "sku": item.sku,
                    "error": str(e)
                })
        
        # Commit all changes
        try:
            await self.session.commit()
        except Exception as e:
            await self.session.rollback()
            return {
                "total_processed": len(items_without_skus),
                "successful_generations": 0,
                "failed_generations": len(items_without_skus),
                "errors": [{"error": f"Failed to commit changes: {str(e)}"}]
            }
        
        return {
            "total_processed": len(items_without_skus),
            "successful_generations": successful,
            "failed_generations": failed,
            "errors": errors
        }

===== shared/utils/validators.py â€“ 2025-07-19 12:13:41 IST =====
import re
from typing import Optional, Union, List, Any
from uuid import UUID
from decimal import Decimal, InvalidOperation
from datetime import datetime, date
import phonenumbers
from email_validator import validate_email, EmailNotValidError
from pydantic import BaseModel


class ValidationError(ValueError):
    """Custom validation error with field information."""
    
    def __init__(self, message: str, field: Optional[str] = None, value: Any = None):
        self.field = field
        self.value = value
        super().__init__(message)


# Email validation
def validate_email_address(email: str) -> str:
    """
    Validate email address format.
    
    Args:
        email: Email address to validate
        
    Returns:
        Normalized email address
        
    Raises:
        ValidationError: If email is invalid
    """
    try:
        # Validate and normalize email
        validation = validate_email(email, check_deliverability=False)
        return validation.email
    except EmailNotValidError as e:
        raise ValidationError(str(e), field="email", value=email)


# Phone number validation
def validate_phone_number(
    phone: str,
    country_code: str = "US"
) -> str:
    """
    Validate and format phone number.
    
    Args:
        phone: Phone number to validate
        country_code: ISO country code (default: US)
        
    Returns:
        Formatted phone number in E.164 format
        
    Raises:
        ValidationError: If phone number is invalid
    """
    try:
        # Parse phone number
        parsed = phonenumbers.parse(phone, country_code)
        
        # Validate phone number
        if not phonenumbers.is_valid_number(parsed):
            raise ValidationError(
                f"Invalid phone number for country {country_code}",
                field="phone",
                value=phone
            )
        
        # Format in E.164 format
        return phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.E164)
    
    except phonenumbers.NumberParseException as e:
        raise ValidationError(str(e), field="phone", value=phone)


# UUID validation
def validate_uuid(value: Union[str, UUID]) -> UUID:
    """
    Validate UUID format.
    
    Args:
        value: UUID string or UUID object
        
    Returns:
        UUID object
        
    Raises:
        ValidationError: If UUID is invalid
    """
    if isinstance(value, UUID):
        return value
    
    try:
        return UUID(str(value))
    except (ValueError, AttributeError):
        raise ValidationError(f"Invalid UUID format", field="id", value=value)


# String validation
def validate_string_length(
    value: str,
    min_length: Optional[int] = None,
    max_length: Optional[int] = None,
    field_name: str = "value"
) -> str:
    """
    Validate string length.
    
    Args:
        value: String to validate
        min_length: Minimum length (inclusive)
        max_length: Maximum length (inclusive)
        field_name: Field name for error message
        
    Returns:
        Validated string
        
    Raises:
        ValidationError: If string length is invalid
    """
    if not isinstance(value, str):
        raise ValidationError(
            f"{field_name} must be a string",
            field=field_name,
            value=value
        )
    
    length = len(value)
    
    if min_length is not None and length < min_length:
        raise ValidationError(
            f"{field_name} must be at least {min_length} characters",
            field=field_name,
            value=value
        )
    
    if max_length is not None and length > max_length:
        raise ValidationError(
            f"{field_name} must not exceed {max_length} characters",
            field=field_name,
            value=value
        )
    
    return value


def validate_non_empty_string(value: str, field_name: str = "value") -> str:
    """
    Validate that string is not empty or just whitespace.
    
    Args:
        value: String to validate
        field_name: Field name for error message
        
    Returns:
        Trimmed string
        
    Raises:
        ValidationError: If string is empty
    """
    if not value or not value.strip():
        raise ValidationError(
            f"{field_name} cannot be empty",
            field=field_name,
            value=value
        )
    
    return value.strip()


# Numeric validation
def validate_positive_number(
    value: Union[int, float, Decimal],
    field_name: str = "value",
    allow_zero: bool = False
) -> Union[int, float, Decimal]:
    """
    Validate that number is positive.
    
    Args:
        value: Number to validate
        field_name: Field name for error message
        allow_zero: Whether to allow zero
        
    Returns:
        Validated number
        
    Raises:
        ValidationError: If number is not positive
    """
    try:
        num_value = Decimal(str(value))
    except (InvalidOperation, ValueError):
        raise ValidationError(
            f"{field_name} must be a valid number",
            field=field_name,
            value=value
        )
    
    if allow_zero and num_value < 0:
        raise ValidationError(
            f"{field_name} cannot be negative",
            field=field_name,
            value=value
        )
    elif not allow_zero and num_value <= 0:
        raise ValidationError(
            f"{field_name} must be positive",
            field=field_name,
            value=value
        )
    
    # Return original type
    if isinstance(value, int):
        return int(num_value)
    elif isinstance(value, float):
        return float(num_value)
    else:
        return num_value


def validate_number_range(
    value: Union[int, float, Decimal],
    min_value: Optional[Union[int, float, Decimal]] = None,
    max_value: Optional[Union[int, float, Decimal]] = None,
    field_name: str = "value"
) -> Union[int, float, Decimal]:
    """
    Validate number is within range.
    
    Args:
        value: Number to validate
        min_value: Minimum value (inclusive)
        max_value: Maximum value (inclusive)
        field_name: Field name for error message
        
    Returns:
        Validated number
        
    Raises:
        ValidationError: If number is out of range
    """
    try:
        num_value = Decimal(str(value))
    except (InvalidOperation, ValueError):
        raise ValidationError(
            f"{field_name} must be a valid number",
            field=field_name,
            value=value
        )
    
    if min_value is not None and num_value < Decimal(str(min_value)):
        raise ValidationError(
            f"{field_name} must be at least {min_value}",
            field=field_name,
            value=value
        )
    
    if max_value is not None and num_value > Decimal(str(max_value)):
        raise ValidationError(
            f"{field_name} must not exceed {max_value}",
            field=field_name,
            value=value
        )
    
    # Return original type
    if isinstance(value, int):
        return int(num_value)
    elif isinstance(value, float):
        return float(num_value)
    else:
        return num_value


# Date validation
def validate_date_range(
    start_date: Union[datetime, date],
    end_date: Union[datetime, date],
    field_name: str = "date range"
) -> tuple[Union[datetime, date], Union[datetime, date]]:
    """
    Validate that end date is after start date.
    
    Args:
        start_date: Start date
        end_date: End date
        field_name: Field name for error message
        
    Returns:
        Tuple of (start_date, end_date)
        
    Raises:
        ValidationError: If date range is invalid
    """
    # Convert to comparable types
    start = start_date.date() if isinstance(start_date, datetime) else start_date
    end = end_date.date() if isinstance(end_date, datetime) else end_date
    
    if end < start:
        raise ValidationError(
            f"End date must be after start date",
            field=field_name,
            value={"start_date": str(start_date), "end_date": str(end_date)}
        )
    
    return start_date, end_date


def validate_future_date(
    date_value: Union[datetime, date],
    field_name: str = "date",
    allow_today: bool = True
) -> Union[datetime, date]:
    """
    Validate that date is in the future.
    
    Args:
        date_value: Date to validate
        field_name: Field name for error message
        allow_today: Whether to allow today's date
        
    Returns:
        Validated date
        
    Raises:
        ValidationError: If date is not in future
    """
    today = datetime.now().date()
    check_date = date_value.date() if isinstance(date_value, datetime) else date_value
    
    if allow_today and check_date < today:
        raise ValidationError(
            f"{field_name} must be today or in the future",
            field=field_name,
            value=str(date_value)
        )
    elif not allow_today and check_date <= today:
        raise ValidationError(
            f"{field_name} must be in the future",
            field=field_name,
            value=str(date_value)
        )
    
    return date_value


# Pattern validation
def validate_pattern(
    value: str,
    pattern: str,
    field_name: str = "value",
    error_message: Optional[str] = None
) -> str:
    """
    Validate string against regex pattern.
    
    Args:
        value: String to validate
        pattern: Regex pattern
        field_name: Field name for error message
        error_message: Custom error message
        
    Returns:
        Validated string
        
    Raises:
        ValidationError: If string doesn't match pattern
    """
    if not re.match(pattern, value):
        message = error_message or f"{field_name} format is invalid"
        raise ValidationError(message, field=field_name, value=value)
    
    return value


# Business-specific validators
def validate_sku(sku: str) -> str:
    """
    Validate SKU format.
    
    Args:
        sku: SKU to validate
        
    Returns:
        Validated SKU
        
    Raises:
        ValidationError: If SKU format is invalid
    """
    # SKU must be alphanumeric with optional hyphens/underscores
    pattern = r"^[A-Za-z0-9\-_]+$"
    sku = validate_non_empty_string(sku, "SKU")
    return validate_pattern(sku, pattern, "SKU", "SKU must be alphanumeric")


def validate_barcode(barcode: str) -> str:
    """
    Validate barcode format (EAN-13, UPC-A, or custom).
    
    Args:
        barcode: Barcode to validate
        
    Returns:
        Validated barcode
        
    Raises:
        ValidationError: If barcode format is invalid
    """
    barcode = validate_non_empty_string(barcode, "barcode")
    
    # Check for common barcode formats
    if len(barcode) == 13 and barcode.isdigit():
        # EAN-13
        return barcode
    elif len(barcode) == 12 and barcode.isdigit():
        # UPC-A
        return barcode
    else:
        # Custom format - alphanumeric
        pattern = r"^[A-Za-z0-9]+$"
        return validate_pattern(barcode, pattern, "barcode", "Invalid barcode format")


def validate_currency_code(code: str) -> str:
    """
    Validate ISO 4217 currency code.
    
    Args:
        code: Currency code to validate
        
    Returns:
        Validated currency code (uppercase)
        
    Raises:
        ValidationError: If currency code is invalid
    """
    # Common ISO 4217 currency codes
    valid_codes = {
        "USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD", "NZD",
        "CNY", "INR", "KRW", "SGD", "HKD", "NOK", "SEK", "DKK",
        "PLN", "CZK", "HUF", "RON", "BGN", "HRK", "RUB", "TRY",
        "BRL", "MXN", "ARS", "CLP", "COP", "PEN", "UYU", "ZAR"
    }
    
    code = code.upper().strip()
    if code not in valid_codes:
        raise ValidationError(
            f"Invalid currency code. Must be a valid ISO 4217 code",
            field="currency",
            value=code
        )
    
    return code


def validate_percentage(
    value: Union[int, float, Decimal],
    field_name: str = "percentage"
) -> Decimal:
    """
    Validate percentage value (0-100).
    
    Args:
        value: Percentage value
        field_name: Field name for error message
        
    Returns:
        Validated percentage as Decimal
        
    Raises:
        ValidationError: If percentage is invalid
    """
    return Decimal(str(validate_number_range(value, 0, 100, field_name)))


def validate_tax_id(tax_id: str, country_code: str = "US") -> str:
    """
    Validate tax ID format based on country.
    
    Args:
        tax_id: Tax ID to validate
        country_code: ISO country code
        
    Returns:
        Validated tax ID
        
    Raises:
        ValidationError: If tax ID format is invalid
    """
    tax_id = validate_non_empty_string(tax_id, "tax ID")
    
    # US TIN/EIN format: XX-XXXXXXX
    if country_code == "US":
        pattern = r"^\d{2}-\d{7}$"
        return validate_pattern(
            tax_id, pattern, "tax ID",
            "US tax ID must be in format XX-XXXXXXX"
        )
    
    # For other countries, just ensure it's not empty
    return tax_id


# List validators
def validate_list_not_empty(
    items: List[Any],
    field_name: str = "list"
) -> List[Any]:
    """
    Validate that list is not empty.
    
    Args:
        items: List to validate
        field_name: Field name for error message
        
    Returns:
        Validated list
        
    Raises:
        ValidationError: If list is empty
    """
    if not items:
        raise ValidationError(
            f"{field_name} cannot be empty",
            field=field_name,
            value=items
        )
    
    return items


def validate_unique_list(
    items: List[Any],
    field_name: str = "list"
) -> List[Any]:
    """
    Validate that list contains unique items.
    
    Args:
        items: List to validate
        field_name: Field name for error message
        
    Returns:
        Validated list
        
    Raises:
        ValidationError: If list contains duplicates
    """
    if len(items) != len(set(items)):
        raise ValidationError(
            f"{field_name} contains duplicate values",
            field=field_name,
            value=items
        )
    
    return items


# Composite validators
class AddressValidator(BaseModel):
    """Validate address components."""
    
    street: str
    city: str
    state: str
    postal_code: str
    country: str = "US"
    
    def validate(self) -> dict:
        """Validate all address fields."""
        validated = {}
        
        # Validate required fields
        validated["street"] = validate_non_empty_string(self.street, "street")
        validated["city"] = validate_non_empty_string(self.city, "city")
        validated["state"] = validate_non_empty_string(self.state, "state")
        validated["country"] = validate_non_empty_string(self.country, "country")
        
        # Validate postal code based on country
        if self.country == "US":
            # US ZIP code: 5 digits or 5+4 format
            pattern = r"^\d{5}(-\d{4})?$"
            validated["postal_code"] = validate_pattern(
                self.postal_code, pattern, "postal code",
                "US postal code must be in format 12345 or 12345-6789"
            )
        else:
            validated["postal_code"] = validate_non_empty_string(
                self.postal_code, "postal code"
            )
        
        return validated


__all__ = [
    "ValidationError",
    "validate_email_address",
    "validate_phone_number",
    "validate_uuid",
    "validate_string_length",
    "validate_non_empty_string",
    "validate_positive_number",
    "validate_number_range",
    "validate_date_range",
    "validate_future_date",
    "validate_pattern",
    "validate_sku",
    "validate_barcode",
    "validate_currency_code",
    "validate_percentage",
    "validate_tax_id",
    "validate_list_not_empty",
    "validate_unique_list",
    "AddressValidator",
]

===== shared/validators/business_rules.py â€“ 2025-07-19 12:13:41 IST =====
"""
Business Rules and Validation Logic for Rental Management System.

This module contains comprehensive business rules that ensure data integrity
and enforce business constraints across all domains.
"""

from typing import Optional, List, Dict, Any, Union
from datetime import datetime, date, timedelta
from decimal import Decimal
from enum import Enum
import re
from uuid import UUID

from app.core.errors import ValidationError, BusinessException


class ValidationSeverity(str, Enum):
    """Validation severity levels."""
    ERROR = "ERROR"
    WARNING = "WARNING"
    INFO = "INFO"


class ValidationResult:
    """Result of a validation operation."""
    
    def __init__(self):
        self.is_valid = True
        self.errors: List[Dict[str, Any]] = []
        self.warnings: List[Dict[str, Any]] = []
        self.info: List[Dict[str, Any]] = []
    
    def add_error(self, field: str, message: str, code: str = None):
        """Add validation error."""
        self.is_valid = False
        self.errors.append({
            "field": field,
            "message": message,
            "code": code,
            "severity": ValidationSeverity.ERROR
        })
    
    def add_warning(self, field: str, message: str, code: str = None):
        """Add validation warning."""
        self.warnings.append({
            "field": field,
            "message": message,
            "code": code,
            "severity": ValidationSeverity.WARNING
        })
    
    def add_info(self, field: str, message: str, code: str = None):
        """Add validation info."""
        self.info.append({
            "field": field,
            "message": message,
            "code": code,
            "severity": ValidationSeverity.INFO
        })
    
    def has_errors(self) -> bool:
        """Check if validation has errors."""
        return len(self.errors) > 0
    
    def has_warnings(self) -> bool:
        """Check if validation has warnings."""
        return len(self.warnings) > 0
    
    def get_all_issues(self) -> List[Dict[str, Any]]:
        """Get all validation issues."""
        return self.errors + self.warnings + self.info
    
    def raise_if_errors(self):
        """Raise ValidationError if there are validation errors."""
        if self.has_errors():
            raise ValidationError(
                "Validation failed",
                {"validation_errors": self.errors}
            )


class BusinessRuleValidator:
    """Base class for business rule validation."""
    
    @staticmethod
    def validate_email(email: str) -> ValidationResult:
        """Validate email address format."""
        result = ValidationResult()
        
        if not email:
            result.add_error("email", "Email is required")
            return result
        
        # Basic email format validation
        email_pattern = re.compile(
            r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        )
        
        if not email_pattern.match(email):
            result.add_error("email", "Invalid email format")
        
        if len(email) > 255:
            result.add_error("email", "Email address too long (max 255 characters)")
        
        # Check for common disposable email domains
        disposable_domains = [
            '10minutemail.com', 'guerrillamail.com', 'mailinator.com'
        ]
        domain = email.split('@')[1] if '@' in email else ''
        if domain.lower() in disposable_domains:
            result.add_warning("email", "Disposable email address detected")
        
        return result
    
    @staticmethod
    def validate_phone_number(phone: str, country_code: str = "US") -> ValidationResult:
        """Validate phone number format."""
        result = ValidationResult()
        
        if not phone:
            result.add_error("phone", "Phone number is required")
            return result
        
        # Remove all non-digit characters for validation
        digits_only = re.sub(r'[^\d]', '', phone)
        
        # US phone number validation
        if country_code == "US":
            if len(digits_only) == 10:
                # Format: (xxx) xxx-xxxx
                pass
            elif len(digits_only) == 11 and digits_only[0] == '1':
                # Format: +1 (xxx) xxx-xxxx
                pass
            else:
                result.add_error("phone", "Invalid US phone number format")
        
        # International phone number (basic validation)
        elif len(digits_only) < 7 or len(digits_only) > 15:
            result.add_error("phone", "Invalid phone number length")
        
        return result
    
    @staticmethod
    def validate_currency_amount(amount: Union[Decimal, float], 
                                min_amount: Decimal = None,
                                max_amount: Decimal = None) -> ValidationResult:
        """Validate currency amount."""
        result = ValidationResult()
        
        if amount is None:
            result.add_error("amount", "Amount is required")
            return result
        
        # Convert to Decimal for precise handling
        if isinstance(amount, float):
            amount = Decimal(str(amount))
        
        if amount < 0:
            result.add_error("amount", "Amount cannot be negative")
        
        if min_amount is not None and amount < min_amount:
            result.add_error("amount", f"Amount must be at least {min_amount}")
        
        if max_amount is not None and amount > max_amount:
            result.add_error("amount", f"Amount cannot exceed {max_amount}")
        
        # Check decimal places (max 2 for currency)
        if amount.as_tuple().exponent < -2:
            result.add_error("amount", "Amount cannot have more than 2 decimal places")
        
        return result
    
    @staticmethod
    def validate_date_range(start_date: date, end_date: date, 
                           allow_same_day: bool = True) -> ValidationResult:
        """Validate date range."""
        result = ValidationResult()
        
        if not start_date:
            result.add_error("start_date", "Start date is required")
        
        if not end_date:
            result.add_error("end_date", "End date is required")
        
        if start_date and end_date:
            if start_date > end_date:
                result.add_error("date_range", "Start date cannot be after end date")
            elif start_date == end_date and not allow_same_day:
                result.add_error("date_range", "Start date and end date cannot be the same")
            
            # Check for reasonable date ranges
            max_days = 365 * 2  # 2 years
            if (end_date - start_date).days > max_days:
                result.add_warning("date_range", f"Date range exceeds {max_days} days")
        
        return result
    
    @staticmethod
    def validate_business_hours(time_slot: dict) -> ValidationResult:
        """Validate business hours and time slots."""
        result = ValidationResult()
        
        start_time = time_slot.get('start_time')
        end_time = time_slot.get('end_time')
        
        if not start_time:
            result.add_error("start_time", "Start time is required")
        
        if not end_time:
            result.add_error("end_time", "End time is required")
        
        if start_time and end_time:
            if start_time >= end_time:
                result.add_error("time_range", "Start time must be before end time")
            
            # Check for reasonable business hours
            business_start = "06:00"
            business_end = "23:00"
            
            if start_time < business_start:
                result.add_warning("start_time", "Start time is before typical business hours")
            
            if end_time > business_end:
                result.add_warning("end_time", "End time is after typical business hours")
        
        return result


class CustomerValidator(BusinessRuleValidator):
    """Customer-specific business rules and validation."""
    
    @staticmethod
    def validate_customer_data(customer_data: dict) -> ValidationResult:
        """Validate customer data comprehensively."""
        result = ValidationResult()
        
        # Required fields validation
        required_fields = ["customer_type", "email"]
        for field in required_fields:
            if not customer_data.get(field):
                result.add_error(field, f"{field.replace('_', ' ').title()} is required")
        
        # Customer type specific validation
        customer_type = customer_data.get("customer_type")
        
        if customer_type == "INDIVIDUAL":
            if not customer_data.get("first_name"):
                result.add_error("first_name", "First name is required for individual customers")
            if not customer_data.get("last_name"):
                result.add_error("last_name", "Last name is required for individual customers")
            
            # Validate date of birth for individuals
            dob = customer_data.get("date_of_birth")
            if dob:
                dob_result = CustomerValidator.validate_date_of_birth(dob)
                result.errors.extend(dob_result.errors)
                result.warnings.extend(dob_result.warnings)
        
        elif customer_type == "BUSINESS":
            if not customer_data.get("business_name"):
                result.add_error("business_name", "Business name is required for business customers")
            
            # Validate tax ID for businesses
            tax_id = customer_data.get("tax_id")
            if tax_id:
                tax_result = CustomerValidator.validate_tax_id(tax_id)
                result.errors.extend(tax_result.errors)
        
        # Email validation
        email = customer_data.get("email")
        if email:
            email_result = BusinessRuleValidator.validate_email(email)
            result.errors.extend(email_result.errors)
            result.warnings.extend(email_result.warnings)
        
        # Phone validation
        phone = customer_data.get("phone_number")
        if phone:
            phone_result = BusinessRuleValidator.validate_phone_number(phone)
            result.errors.extend(phone_result.errors)
        
        # Credit limit validation
        credit_limit = customer_data.get("credit_limit")
        if credit_limit is not None:
            credit_result = CustomerValidator.validate_credit_limit(credit_limit)
            result.errors.extend(credit_result.errors)
            result.warnings.extend(credit_result.warnings)
        
        return result
    
    @staticmethod
    def validate_date_of_birth(dob: Union[date, str]) -> ValidationResult:
        """Validate date of birth."""
        result = ValidationResult()
        
        if isinstance(dob, str):
            try:
                dob = datetime.strptime(dob, "%Y-%m-%d").date()
            except ValueError:
                result.add_error("date_of_birth", "Invalid date format (use YYYY-MM-DD)")
                return result
        
        today = date.today()
        age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))
        
        if dob > today:
            result.add_error("date_of_birth", "Date of birth cannot be in the future")
        elif age < 18:
            result.add_warning("date_of_birth", "Customer is under 18 years old")
        elif age > 120:
            result.add_error("date_of_birth", "Invalid date of birth (age > 120)")
        
        return result
    
    @staticmethod
    def validate_tax_id(tax_id: str) -> ValidationResult:
        """Validate tax identification number."""
        result = ValidationResult()
        
        # Basic format validation (can be extended for different countries)
        if len(tax_id) < 9:
            result.add_error("tax_id", "Tax ID too short")
        elif len(tax_id) > 20:
            result.add_error("tax_id", "Tax ID too long")
        
        # Check for valid characters (alphanumeric and hyphens)
        if not re.match(r'^[A-Za-z0-9\-]+$', tax_id):
            result.add_error("tax_id", "Tax ID contains invalid characters")
        
        return result
    
    @staticmethod
    def validate_credit_limit(credit_limit: Union[Decimal, float]) -> ValidationResult:
        """Validate customer credit limit."""
        result = ValidationResult()
        
        # Convert to Decimal
        if isinstance(credit_limit, float):
            credit_limit = Decimal(str(credit_limit))
        
        min_limit = Decimal('0')
        max_limit = Decimal('1000000')  # $1M max
        
        amount_result = BusinessRuleValidator.validate_currency_amount(
            credit_limit, min_limit, max_limit
        )
        result.errors.extend(amount_result.errors)
        
        # Warning for high credit limits
        if credit_limit > Decimal('100000'):
            result.add_warning("credit_limit", "High credit limit requires approval")
        
        return result


class InventoryValidator(BusinessRuleValidator):
    """Inventory-specific business rules and validation."""
    
    @staticmethod
    def validate_item_data(item_data: dict) -> ValidationResult:
        """Validate inventory item data."""
        result = ValidationResult()
        
        # Required fields
        required_fields = ["name", "sku", "rental_price_per_day"]
        for field in required_fields:
            if not item_data.get(field):
                result.add_error(field, f"{field.replace('_', ' ').title()} is required")
        
        # SKU validation
        sku = item_data.get("sku")
        if sku:
            sku_result = InventoryValidator.validate_sku(sku)
            result.errors.extend(sku_result.errors)
        
        # Price validation
        rental_price = item_data.get("rental_price_per_day")
        if rental_price is not None:
            price_result = BusinessRuleValidator.validate_currency_amount(
                rental_price, Decimal('0.01'), Decimal('10000')
            )
            result.errors.extend(price_result.errors)
        
        purchase_price = item_data.get("purchase_price")
        if purchase_price is not None:
            purchase_result = BusinessRuleValidator.validate_currency_amount(
                purchase_price, Decimal('0'), Decimal('1000000')
            )
            result.errors.extend(purchase_result.errors)
            
            # Business rule: rental price should be reasonable % of purchase price
            if rental_price and purchase_price:
                daily_rate_percentage = (rental_price / purchase_price) * 100
                if daily_rate_percentage > 10:  # More than 10% per day
                    result.add_warning("rental_price", "Rental price seems high relative to purchase price")
                elif daily_rate_percentage < 0.1:  # Less than 0.1% per day
                    result.add_warning("rental_price", "Rental price seems low relative to purchase price")
        
        # Stock validation
        stock_quantity = item_data.get("stock_quantity")
        if stock_quantity is not None:
            stock_result = InventoryValidator.validate_stock_quantity(stock_quantity)
            result.errors.extend(stock_result.errors)
            result.warnings.extend(stock_result.warnings)
        
        return result
    
    @staticmethod
    def validate_sku(sku: str) -> ValidationResult:
        """Validate SKU format."""
        result = ValidationResult()
        
        if len(sku) < 3:
            result.add_error("sku", "SKU too short (minimum 3 characters)")
        elif len(sku) > 50:
            result.add_error("sku", "SKU too long (maximum 50 characters)")
        
        # SKU should be alphanumeric with hyphens/underscores
        if not re.match(r'^[A-Za-z0-9\-_]+$', sku):
            result.add_error("sku", "SKU contains invalid characters")
        
        return result
    
    @staticmethod
    def validate_stock_quantity(quantity: int) -> ValidationResult:
        """Validate stock quantity."""
        result = ValidationResult()
        
        if quantity < 0:
            result.add_error("stock_quantity", "Stock quantity cannot be negative")
        elif quantity == 0:
            result.add_warning("stock_quantity", "Item is out of stock")
        elif quantity > 10000:
            result.add_warning("stock_quantity", "Very large stock quantity")
        
        return result


class RentalValidator(BusinessRuleValidator):
    """Rental-specific business rules and validation."""
    
    @staticmethod
    def validate_rental_data(rental_data: dict) -> ValidationResult:
        """Validate rental booking data."""
        result = ValidationResult()
        
        # Required fields
        required_fields = ["customer_id", "item_id", "start_date", "end_date"]
        for field in required_fields:
            if not rental_data.get(field):
                result.add_error(field, f"{field.replace('_', ' ').title()} is required")
        
        # Date validation
        start_date = rental_data.get("start_date")
        end_date = rental_data.get("end_date")
        
        if start_date and end_date:
            if isinstance(start_date, str):
                start_date = datetime.strptime(start_date, "%Y-%m-%d").date()
            if isinstance(end_date, str):
                end_date = datetime.strptime(end_date, "%Y-%m-%d").date()
            
            date_result = BusinessRuleValidator.validate_date_range(start_date, end_date)
            result.errors.extend(date_result.errors)
            result.warnings.extend(date_result.warnings)
            
            # Business rules for rental dates
            today = date.today()
            if start_date < today:
                result.add_error("start_date", "Rental start date cannot be in the past")
            
            # Maximum rental period
            max_rental_days = 90
            if (end_date - start_date).days > max_rental_days:
                result.add_error("date_range", f"Rental period cannot exceed {max_rental_days} days")
            
            # Advance booking limit
            max_advance_days = 365
            if (start_date - today).days > max_advance_days:
                result.add_warning("start_date", f"Booking more than {max_advance_days} days in advance")
        
        # Quantity validation
        quantity = rental_data.get("quantity", 1)
        if quantity <= 0:
            result.add_error("quantity", "Rental quantity must be at least 1")
        elif quantity > 10:
            result.add_warning("quantity", "Large quantity rental requires verification")
        
        return result
    
    @staticmethod
    def validate_rental_return(return_data: dict) -> ValidationResult:
        """Validate rental return data."""
        result = ValidationResult()
        
        # Return date validation
        return_date = return_data.get("return_date")
        if return_date:
            if isinstance(return_date, str):
                return_date = datetime.strptime(return_date, "%Y-%m-%d").date()
            
            today = date.today()
            if return_date > today:
                result.add_error("return_date", "Return date cannot be in the future")
        
        # Condition validation
        condition = return_data.get("condition")
        if condition:
            valid_conditions = ["EXCELLENT", "GOOD", "FAIR", "POOR", "DAMAGED"]
            if condition not in valid_conditions:
                result.add_error("condition", f"Invalid condition. Must be one of: {valid_conditions}")
        
        # Damage assessment
        damage_cost = return_data.get("damage_cost")
        if damage_cost is not None:
            damage_result = BusinessRuleValidator.validate_currency_amount(
                damage_cost, Decimal('0'), Decimal('100000')
            )
            result.errors.extend(damage_result.errors)
            
            if damage_cost > 0 and not return_data.get("damage_description"):
                result.add_error("damage_description", "Damage description required when damage cost > 0")
        
        return result


class TransactionValidator(BusinessRuleValidator):
    """Transaction-specific business rules and validation."""
    
    @staticmethod
    def validate_transaction_data(transaction_data: dict) -> ValidationResult:
        """Validate transaction data."""
        result = ValidationResult()
        
        # Required fields
        required_fields = ["customer_id", "transaction_type", "total_amount"]
        for field in required_fields:
            if not transaction_data.get(field):
                result.add_error(field, f"{field.replace('_', ' ').title()} is required")
        
        # Transaction type validation
        transaction_type = transaction_data.get("transaction_type")
        valid_types = ["RENTAL", "SALE", "DEPOSIT", "REFUND", "ADJUSTMENT"]
        if transaction_type and transaction_type not in valid_types:
            result.add_error("transaction_type", f"Invalid transaction type. Must be one of: {valid_types}")
        
        # Amount validation
        total_amount = transaction_data.get("total_amount")
        if total_amount is not None:
            amount_result = BusinessRuleValidator.validate_currency_amount(
                total_amount, Decimal('0'), Decimal('1000000')
            )
            result.errors.extend(amount_result.errors)
        
        # Payment validation
        payment_method = transaction_data.get("payment_method")
        if payment_method:
            payment_result = TransactionValidator.validate_payment_method(payment_method)
            result.errors.extend(payment_result.errors)
        
        return result
    
    @staticmethod
    def validate_payment_method(payment_method: str) -> ValidationResult:
        """Validate payment method."""
        result = ValidationResult()
        
        valid_methods = ["CASH", "CREDIT_CARD", "DEBIT_CARD", "BANK_TRANSFER", "CHECK", "DIGITAL_WALLET"]
        if payment_method not in valid_methods:
            result.add_error("payment_method", f"Invalid payment method. Must be one of: {valid_methods}")
        
        return result


def validate_comprehensive_data(data: dict, domain: str) -> ValidationResult:
    """
    Comprehensive validation for different domains.
    
    Args:
        data: Data to validate
        domain: Domain type ('customer', 'inventory', 'rental', 'transaction')
    
    Returns:
        ValidationResult with all validation issues
    """
    validators = {
        'customer': CustomerValidator.validate_customer_data,
        'inventory': InventoryValidator.validate_item_data,
        'rental': RentalValidator.validate_rental_data,
        'transaction': TransactionValidator.validate_transaction_data,
    }
    
    validator = validators.get(domain)
    if not validator:
        result = ValidationResult()
        result.add_error("domain", f"Unknown validation domain: {domain}")
        return result
    
    return validator(data)


def apply_business_rules(data: dict, domain: str, operation: str = "create") -> ValidationResult:
    """
    Apply business rules for specific operations.
    
    Args:
        data: Data to validate
        domain: Domain type
        operation: Operation type ('create', 'update', 'delete')
    
    Returns:
        ValidationResult with business rule validations
    """
    result = validate_comprehensive_data(data, domain)
    
    # Additional business rules based on operation
    if operation == "update":
        # For updates, some fields might be optional
        pass
    elif operation == "delete":
        # For deletes, check if deletion is allowed
        if domain == "customer" and data.get("has_active_rentals"):
            result.add_error("delete", "Cannot delete customer with active rentals")
        elif domain == "inventory" and data.get("is_rented"):
            result.add_error("delete", "Cannot delete item that is currently rented")
    
    return result

===== shared/validators/schema_validators.py â€“ 2025-07-19 12:13:41 IST =====
"""
Pydantic Schema Validators and Custom Field Types.

This module provides enhanced validation for Pydantic schemas with custom
field types, validators, and business rule integration.
"""

from typing import Any, Optional, Union, List, Dict
from datetime import datetime, date
from decimal import Decimal
import re
from uuid import UUID

from pydantic import Field, BaseModel, field_validator
from pydantic_core import core_schema

from .business_rules import (
    BusinessRuleValidator,
    CustomerValidator,
    InventoryValidator,
    RentalValidator,
    TransactionValidator
)


class EmailStr(str):
    """Custom email string type with validation."""
    
    @classmethod
    def __get_validators__(cls):
        yield str_validator
        yield cls.validate
    
    @classmethod
    def validate(cls, v: str) -> str:
        result = BusinessRuleValidator.validate_email(v)
        result.raise_if_errors()
        return v
    
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        field_schema.update(
            format='email',
            example='user@example.com',
            description='Valid email address'
        )


class PhoneStr(str):
    """Custom phone string type with validation."""
    
    @classmethod
    def __get_validators__(cls):
        yield str_validator
        yield cls.validate
    
    @classmethod
    def validate(cls, v: str) -> str:
        result = BusinessRuleValidator.validate_phone_number(v)
        result.raise_if_errors()
        return v
    
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        field_schema.update(
            format='phone',
            example='+1-555-123-4567',
            description='Valid phone number'
        )


class CurrencyDecimal(Decimal):
    """Custom currency decimal type with validation."""
    
    @classmethod
    def __get_validators__(cls):
        yield cls.validate
    
    @classmethod
    def validate(cls, v: Union[str, int, float, Decimal]) -> Decimal:
        if isinstance(v, (int, float)):
            v = str(v)
        elif isinstance(v, Decimal):
            v = str(v)
        
        try:
            decimal_value = Decimal(v)
        except Exception:
            raise ValueError('Invalid decimal value')
        
        result = BusinessRuleValidator.validate_currency_amount(decimal_value)
        result.raise_if_errors()
        
        return decimal_value
    
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        field_schema.update(
            type='number',
            multipleOf=0.01,
            minimum=0,
            example=99.99,
            description='Currency amount with up to 2 decimal places'
        )


class SKUStr(str):
    """Custom SKU string type with validation."""
    
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source_type: Any, handler
    ) -> core_schema.CoreSchema:
        return core_schema.no_info_after_validator_function(
            cls.validate,
            core_schema.str_schema(),
        )
    
    @classmethod
    def validate(cls, v: str) -> str:
        # Basic validation that doesn't depend on business rules
        if not isinstance(v, str):
            raise ValueError('SKU must be a string')
        
        v = v.strip().upper()
        
        if len(v) < 3 or len(v) > 50:
            raise ValueError('SKU must be between 3 and 50 characters')
        
        if not re.match(r'^[A-Za-z0-9\-_]+$', v):
            raise ValueError('SKU can only contain letters, numbers, hyphens, and underscores')
        
        return v


# Common Field Definitions with Enhanced Validation
def email_field(**kwargs) -> EmailStr:
    """Email field with validation."""
    return Field(
        ...,
        title="Email Address",
        description="Valid email address",
        example="user@example.com",
        **kwargs
    )


def phone_field(**kwargs) -> PhoneStr:
    """Phone field with validation."""
    return Field(
        ...,
        title="Phone Number",
        description="Valid phone number",
        example="+1-555-123-4567",
        **kwargs
    )


def currency_field(min_value: float = 0, max_value: float = None, **kwargs) -> CurrencyDecimal:
    """Currency field with validation."""
    return Field(
        ...,
        title="Currency Amount",
        description="Currency amount with up to 2 decimal places",
        ge=min_value,
        le=max_value,
        example=99.99,
        **kwargs
    )


def sku_field(**kwargs) -> SKUStr:
    """SKU field with validation."""
    return Field(
        ...,
        title="Product SKU",
        description="Unique product identifier",
        example="LAPTOP-001",
        **kwargs
    )


def password_field(**kwargs) -> str:
    """Password field with validation."""
    return Field(
        ...,
        title="Password",
        description="Strong password (min 8 chars, mixed case, numbers, special chars)",
        min_length=8,
        max_length=128,
        example="SecurePass123!",
        **kwargs
    )


def date_field(**kwargs) -> date:
    """Date field with validation."""
    return Field(
        ...,
        title="Date",
        description="Date in YYYY-MM-DD format",
        example="2024-01-01",
        **kwargs
    )


def positive_int_field(max_value: int = None, **kwargs) -> int:
    """Positive integer field."""
    return Field(
        ...,
        title="Positive Integer",
        description="Positive integer value",
        ge=1,
        le=max_value,
        example=1,
        **kwargs
    )


# Enhanced Base Schema with Common Validations
class EnhancedBaseModel(BaseModel):
    """Enhanced base model with common validations."""
    
    class Config:
        # Use enum values instead of names
        use_enum_values = True
        # Validate field defaults
        validate_all = True
        # Allow population by field name or alias
        allow_population_by_field_name = True
        # JSON schema customization
        schema_extra = {
            "examples": []
        }
    
    @validator('*', pre=True)
    def strip_strings(cls, v):
        """Strip whitespace from string fields."""
        if isinstance(v, str):
            return v.strip()
        return v
    
    @validator('*')
    def empty_strings_to_none(cls, v):
        """Convert empty strings to None."""
        if v == '':
            return None
        return v


# Domain-Specific Schema Mixins
class CustomerValidationMixin:
    """Mixin for customer validation."""
    
    @validator('email')
    def validate_email_format(cls, v):
        if v:
            result = BusinessRuleValidator.validate_email(v)
            result.raise_if_errors()
        return v
    
    @validator('phone_number')
    def validate_phone_format(cls, v):
        if v:
            result = BusinessRuleValidator.validate_phone_number(v)
            result.raise_if_errors()
        return v
    
    @validator('date_of_birth')
    def validate_birth_date(cls, v):
        if v:
            result = CustomerValidator.validate_date_of_birth(v)
            result.raise_if_errors()
        return v
    
    @validator('credit_limit')
    def validate_credit_amount(cls, v):
        if v is not None:
            result = CustomerValidator.validate_credit_limit(v)
            result.raise_if_errors()
        return v


class InventoryValidationMixin:
    """Mixin for inventory validation."""
    
    @validator('sku')
    def validate_sku_format(cls, v):
        if v:
            result = InventoryValidator.validate_sku(v)
            result.raise_if_errors()
        return v.upper()
    
    @validator('rental_price_per_day', 'purchase_price')
    def validate_prices(cls, v):
        if v is not None:
            result = BusinessRuleValidator.validate_currency_amount(v)
            result.raise_if_errors()
        return v
    
    @validator('stock_quantity')
    def validate_stock(cls, v):
        if v is not None:
            result = InventoryValidator.validate_stock_quantity(v)
            result.raise_if_errors()
        return v


class RentalValidationMixin:
    """Mixin for rental validation."""
    
    @validator('end_date')
    def validate_date_range(cls, v, values):
        start_date = values.get('start_date')
        if start_date and v:
            result = BusinessRuleValidator.validate_date_range(start_date, v)
            result.raise_if_errors()
        return v
    
    @validator('quantity')
    def validate_rental_quantity(cls, v):
        if v is not None and v <= 0:
            raise ValueError('Rental quantity must be positive')
        return v


class TransactionValidationMixin:
    """Mixin for transaction validation."""
    
    @validator('total_amount', 'tax_amount', 'discount_amount')
    def validate_amounts(cls, v):
        if v is not None:
            result = BusinessRuleValidator.validate_currency_amount(v)
            result.raise_if_errors()
        return v
    
    @validator('payment_method')
    def validate_payment(cls, v):
        if v:
            result = TransactionValidator.validate_payment_method(v)
            result.raise_if_errors()
        return v


# Example Enhanced Schemas with Field Examples
class EnhancedCustomerCreate(EnhancedBaseModel, CustomerValidationMixin):
    """Enhanced customer creation schema with validation."""
    
    customer_type: str = Field(
        ...,
        title="Customer Type",
        description="Type of customer",
        example="INDIVIDUAL",
        regex="^(INDIVIDUAL|BUSINESS)$"
    )
    
    first_name: Optional[str] = Field(
        None,
        title="First Name",
        description="Customer's first name (required for individual customers)",
        min_length=1,
        max_length=100,
        example="John"
    )
    
    last_name: Optional[str] = Field(
        None,
        title="Last Name", 
        description="Customer's last name (required for individual customers)",
        min_length=1,
        max_length=100,
        example="Doe"
    )
    
    business_name: Optional[str] = Field(
        None,
        title="Business Name",
        description="Company name (required for business customers)",
        min_length=1,
        max_length=255,
        example="Acme Corporation"
    )
    
    email: EmailStr = email_field()
    phone_number: Optional[PhoneStr] = phone_field(default=None)
    
    address: Optional[str] = Field(
        None,
        title="Address",
        description="Street address",
        max_length=255,
        example="123 Main Street"
    )
    
    city: Optional[str] = Field(
        None,
        title="City",
        description="City name",
        max_length=100,
        example="New York"
    )
    
    state: Optional[str] = Field(
        None,
        title="State/Province",
        description="State or province",
        max_length=100,
        example="NY"
    )
    
    postal_code: Optional[str] = Field(
        None,
        title="Postal Code",
        description="ZIP or postal code",
        max_length=20,
        example="10001"
    )
    
    country: Optional[str] = Field(
        None,
        title="Country",
        description="Country name",
        max_length=100,
        example="USA"
    )
    
    date_of_birth: Optional[date] = date_field(default=None)
    
    credit_limit: Optional[CurrencyDecimal] = currency_field(
        min_value=0,
        max_value=1000000,
        default=None
    )
    
    class Config:
        schema_extra = {
            "examples": [
                {
                    "customer_type": "INDIVIDUAL",
                    "first_name": "John",
                    "last_name": "Doe",
                    "email": "john.doe@example.com",
                    "phone_number": "+1-555-123-4567",
                    "address": "123 Main Street",
                    "city": "New York",
                    "state": "NY",
                    "postal_code": "10001",
                    "country": "USA",
                    "date_of_birth": "1985-06-15",
                    "credit_limit": 5000.00
                },
                {
                    "customer_type": "BUSINESS",
                    "business_name": "Acme Corporation",
                    "email": "contact@acme.com",
                    "phone_number": "+1-555-987-6543",
                    "address": "456 Business Ave",
                    "city": "Chicago",
                    "state": "IL",
                    "postal_code": "60601",
                    "country": "USA",
                    "credit_limit": 50000.00
                }
            ]
        }


class EnhancedInventoryItemCreate(EnhancedBaseModel, InventoryValidationMixin):
    """Enhanced inventory item creation schema."""
    
    name: str = Field(
        ...,
        title="Item Name",
        description="Name of the inventory item",
        min_length=1,
        max_length=255,
        example="MacBook Pro 16-inch"
    )
    
    description: Optional[str] = Field(
        None,
        title="Description",
        description="Detailed description of the item",
        max_length=1000,
        example="Apple MacBook Pro 16-inch with M1 chip, 16GB RAM, 512GB SSD"
    )
    
    sku: SKUStr = sku_field()
    
    category_id: Optional[UUID] = Field(
        None,
        title="Category ID",
        description="Category this item belongs to",
        example="123e4567-e89b-12d3-a456-426614174000"
    )
    
    brand_id: Optional[UUID] = Field(
        None,
        title="Brand ID",
        description="Brand of this item",
        example="123e4567-e89b-12d3-a456-426614174001"
    )
    
    rental_price_per_day: CurrencyDecimal = currency_field(
        min_value=0.01,
        max_value=10000
    )
    
    purchase_price: Optional[CurrencyDecimal] = currency_field(
        min_value=0,
        max_value=1000000,
        default=None
    )
    
    stock_quantity: Optional[int] = positive_int_field(
        max_value=10000,
        default=1
    )
    
    condition: Optional[str] = Field(
        "NEW",
        title="Condition",
        description="Current condition of the item",
        regex="^(NEW|EXCELLENT|GOOD|FAIR|POOR)$",
        example="NEW"
    )
    
    class Config:
        schema_extra = {
            "examples": [
                {
                    "name": "MacBook Pro 16-inch",
                    "description": "Apple MacBook Pro 16-inch with M1 chip",
                    "sku": "MBP16-M1-512",
                    "rental_price_per_day": 50.00,
                    "purchase_price": 2499.00,
                    "stock_quantity": 5,
                    "condition": "NEW"
                }
            ]
        }


def create_validation_examples():
    """Create validation examples for documentation."""
    return {
        "valid_customer": {
            "customer_type": "INDIVIDUAL",
            "first_name": "John",
            "last_name": "Doe",
            "email": "john.doe@example.com",
            "phone_number": "+1-555-123-4567",
            "date_of_birth": "1985-06-15"
        },
        "invalid_customer": {
            "customer_type": "INDIVIDUAL",
            "first_name": "",  # Empty string - invalid
            "email": "invalid-email",  # Invalid format
            "phone_number": "123",  # Too short
            "date_of_birth": "2030-01-01"  # Future date - invalid
        },
        "valid_inventory_item": {
            "name": "MacBook Pro",
            "sku": "MBP-001",
            "rental_price_per_day": 50.00,
            "purchase_price": 2500.00,
            "stock_quantity": 3
        },
        "invalid_inventory_item": {
            "name": "",  # Empty name - invalid
            "sku": "AB",  # Too short - invalid
            "rental_price_per_day": -10.00,  # Negative price - invalid
            "stock_quantity": -1  # Negative stock - invalid
        }
    }

===== db/__init__.py â€“ 2025-07-19 12:13:41 IST =====


===== db/base.py â€“ 2025-07-19 12:13:41 IST =====
from datetime import datetime
from typing import Any, Dict, Optional
from uuid import UUID, uuid4

from sqlalchemy import Column, DateTime, Boolean, String, Integer, event
from sqlalchemy.ext.declarative import as_declarative, declared_attr
from sqlalchemy.orm import Session
from sqlalchemy.sql import func
import sqlalchemy as sa


# Create a UUID type that works with SQLite
class UUIDType(sa.TypeDecorator):
    """
    SQLite-compatible UUID type.
    Uses CHAR(36), storing as stringified hex values.
    """
    impl = sa.CHAR(36)
    cache_ok = True

    def load_dialect_impl(self, dialect):
        return dialect.type_descriptor(sa.CHAR(36))

    def process_bind_param(self, value, dialect):
        if value is None:
            return value
        else:
            return str(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return value
        else:
            if not isinstance(value, UUID):
                return UUID(value)
            else:
                return value


# Base class for all models
@as_declarative()
class Base:
    id: UUID
    created_at: datetime
    updated_at: datetime
    is_active: bool
    created_by: Optional[str]
    updated_by: Optional[str]
    
    __name__: str
    
    # Generate table name from class name
    @declared_attr
    def __tablename__(cls) -> str:
        """
        Generate table name from class name.
        Converts CamelCase to snake_case and pluralizes.
        """
        import re
        # Convert CamelCase to snake_case
        name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', cls.__name__)
        name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name).lower()
        
        # Simple pluralization (can be overridden in model if needed)
        if name.endswith('y'):
            return f"{name[:-1]}ies"
        elif name.endswith('s'):
            return f"{name}es"
        else:
            return f"{name}s"


class TimestampMixin:
    """Mixin for timestamp fields."""
    
    @declared_attr
    def created_at(cls):
        return Column(
            DateTime(timezone=True),
            server_default=func.now(),
            nullable=False,
            comment="Record creation timestamp"
        )
    
    @declared_attr
    def updated_at(cls):
        return Column(
            DateTime(timezone=True),
            server_default=func.now(),
            onupdate=func.now(),
            nullable=False,
            comment="Record last update timestamp"
        )


class AuditMixin:
    """Mixin for audit fields."""
    
    @declared_attr
    def created_by(cls):
        return Column(
            String(255),
            nullable=True,
            comment="User who created the record"
        )
    
    @declared_attr
    def updated_by(cls):
        return Column(
            String(255),
            nullable=True,
            comment="User who last updated the record"
        )


class SoftDeleteMixin:
    """Mixin for soft delete functionality."""
    
    @declared_attr
    def is_active(cls):
        return Column(
            Boolean,
            default=True,
            nullable=False,
            index=True,
            comment="Soft delete flag"
        )
    
    @declared_attr
    def deleted_at(cls):
        return Column(
            DateTime(timezone=True),
            nullable=True,
            comment="Soft delete timestamp"
        )
    
    @declared_attr
    def deleted_by(cls):
        return Column(
            String(255),
            nullable=True,
            comment="User who deleted the record"
        )
    
    def soft_delete(self, deleted_by: Optional[str] = None):
        """Soft delete the record."""
        self.is_active = False
        self.deleted_at = datetime.utcnow()
        self.deleted_by = deleted_by
    
    def restore(self):
        """Restore a soft deleted record."""
        self.is_active = True
        self.deleted_at = None
        self.deleted_by = None


class BaseModel(Base, TimestampMixin, AuditMixin, SoftDeleteMixin):
    """
    Base model class with common fields and functionality.
    All models should inherit from this class.
    """
    __abstract__ = True
    
    id = Column(
        UUIDType(),
        primary_key=True,
        default=uuid4,
        comment="Primary key"
    )
    
    def dict(self) -> Dict[str, Any]:
        """Convert model to dictionary."""
        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }
    
    def update(self, **kwargs):
        """Update model attributes."""
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
    
    @classmethod
    def create(cls, **kwargs):
        """Create a new instance."""
        instance = cls()
        instance.update(**kwargs)
        return instance
    
    def __repr__(self):
        """String representation of model."""
        attrs = []
        for column in self.__table__.columns:
            attrs.append(f"{column.name}={getattr(self, column.name)}")
        return f"<{self.__class__.__name__}({', '.join(attrs[:3])}, ...)>"


class IntegerIDMixin:
    """Mixin for models that use integer IDs instead of UUIDs."""
    
    @declared_attr
    def id(cls):
        return Column(
            Integer,
            primary_key=True,
            autoincrement=True,
            comment="Primary key"
        )


class NamedModelMixin:
    """Mixin for models with name field."""
    
    @declared_attr
    def name(cls):
        return Column(
            String(255),
            nullable=False,
            index=True,
            comment="Name"
        )
    
    @declared_attr
    def description(cls):
        return Column(
            String(1000),
            nullable=True,
            comment="Description"
        )


class CodedModelMixin:
    """Mixin for models with unique code field."""
    
    @declared_attr
    def code(cls):
        return Column(
            String(50),
            nullable=False,
            unique=True,
            index=True,
            comment="Unique code"
        )


class OrderedModelMixin:
    """Mixin for models that need ordering."""
    
    @declared_attr
    def display_order(cls):
        return Column(
            Integer,
            nullable=False,
            default=0,
            comment="Display order"
        )
    
    @declared_attr
    def is_default(cls):
        return Column(
            Boolean,
            nullable=False,
            default=False,
            comment="Default flag"
        )


# Event listeners for automatic timestamp updates
@event.listens_for(BaseModel, 'before_insert', propagate=True)
def receive_before_insert(mapper, connection, target):
    """Set created_at before insert."""
    if hasattr(target, 'created_at') and target.created_at is None:
        target.created_at = datetime.utcnow()
    if hasattr(target, 'updated_at') and target.updated_at is None:
        target.updated_at = datetime.utcnow()


@event.listens_for(BaseModel, 'before_update', propagate=True)
def receive_before_update(mapper, connection, target):
    """Update updated_at before update."""
    if hasattr(target, 'updated_at'):
        target.updated_at = datetime.utcnow()


# Export metadata for migrations
metadata = Base.metadata

__all__ = [
    "Base",
    "BaseModel",
    "UUIDType",
    "TimestampMixin",
    "AuditMixin",
    "SoftDeleteMixin",
    "IntegerIDMixin",
    "NamedModelMixin",
    "CodedModelMixin",
    "OrderedModelMixin",
    "metadata",
]

===== db/session.py â€“ 2025-07-19 12:13:41 IST =====
from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.pool import NullPool, AsyncAdaptedQueuePool
from contextlib import asynccontextmanager
import logging

from app.core.config import settings

logger = logging.getLogger(__name__)

# Create async engine with appropriate configuration
def create_engine(database_url: str = None, echo: bool = None):
    """
    Create SQLAlchemy async engine with proper configuration.
    
    Args:
        database_url: Database URL (defaults to settings)
        echo: Enable SQL echo logging (defaults to settings)
        
    Returns:
        AsyncEngine instance
    """
    url = database_url or settings.DATABASE_URL
    echo_sql = echo if echo is not None else settings.DATABASE_ECHO
    
    # Use NullPool for SQLite to avoid connection issues
    engine_args = {
        "poolclass": NullPool,
    }
    
    engine = create_async_engine(
        url,
        echo=echo_sql,
        future=True,
        **engine_args
    )
    
    return engine


# Create the default engine
engine = create_engine()

# Create async session factory
AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False,
)


async def get_session() -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency to get database session.
    
    Yields:
        AsyncSession: Database session
        
    Usage:
        ```python
        @router.get("/items")
        async def get_items(session: AsyncSession = Depends(get_session)):
            # Use session here
            pass
        ```
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()


@asynccontextmanager
async def get_session_context() -> AsyncGenerator[AsyncSession, None]:
    """
    Context manager for database session.
    
    Usage:
        ```python
        async with get_session_context() as session:
            # Use session here
            pass
        ```
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()


async def create_test_engine(database_url: str = None):
    """
    Create test engine with test database.
    
    Args:
        database_url: Test database URL
        
    Returns:
        AsyncEngine instance for testing
    """
    url = database_url or settings.TEST_DATABASE_URL
    return create_engine(url, echo=False)


class DatabaseSessionManager:
    """
    Manager for database sessions with transaction support.
    """
    
    def __init__(self):
        self._engine = None
        self._sessionmaker = None
    
    def init(self, database_url: str = None, echo: bool = None):
        """
        Initialize the session manager.
        
        Args:
            database_url: Database URL
            echo: Enable SQL echo logging
        """
        self._engine = create_engine(database_url, echo)
        self._sessionmaker = async_sessionmaker(
            bind=self._engine,
            class_=AsyncSession,
            expire_on_commit=False,
            autocommit=False,
            autoflush=False,
        )
    
    async def close(self):
        """Close the database connection."""
        if self._engine:
            await self._engine.dispose()
    
    @asynccontextmanager
    async def session(self) -> AsyncGenerator[AsyncSession, None]:
        """
        Get a database session.
        
        Yields:
            AsyncSession: Database session
        """
        if not self._sessionmaker:
            raise RuntimeError("DatabaseSessionManager not initialized")
        
        async with self._sessionmaker() as session:
            try:
                yield session
                await session.commit()
            except Exception:
                await session.rollback()
                raise
            finally:
                await session.close()
    
    @asynccontextmanager
    async def transaction(self, session: AsyncSession = None):
        """
        Create a database transaction.
        
        Args:
            session: Existing session to use (creates new if None)
            
        Yields:
            AsyncSession: Database session with transaction
        """
        if session:
            # Use existing session with savepoint
            async with session.begin_nested():
                yield session
        else:
            # Create new session with transaction
            async with self.session() as new_session:
                async with new_session.begin():
                    yield new_session


# Create global session manager instance
db_manager = DatabaseSessionManager()
db_manager.init()


# Utility functions
async def init_db():
    """
    Initialize database (create tables).
    This should be called during application startup.
    """
    from app.db.base import Base
    
    async with engine.begin() as conn:
        # Create all tables
        await conn.run_sync(Base.metadata.create_all)
        logger.info("Database tables created successfully")


async def drop_db():
    """
    Drop all database tables.
    WARNING: This will delete all data!
    """
    from app.db.base import Base
    
    async with engine.begin() as conn:
        # Drop all tables
        await conn.run_sync(Base.metadata.drop_all)
        logger.warning("All database tables dropped")


async def check_db_connection():
    """
    Check if database connection is working.
    
    Returns:
        bool: True if connection successful
    """
    try:
        from sqlalchemy import text
        async with AsyncSessionLocal() as session:
            # Execute a simple query
            await session.execute(text("SELECT 1"))
            return True
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return False


# Export commonly used items
__all__ = [
    "engine",
    "AsyncSessionLocal",
    "get_session",
    "get_session_context",
    "db_manager",
    "init_db",
    "drop_db",
    "check_db_connection",
]

===== modules/__init__.py â€“ 2025-07-19 12:13:41 IST =====


===== modules/customers/__init__.py â€“ 2025-07-19 12:13:41 IST =====
# Customers module

===== modules/customers/models.py â€“ 2025-07-21 20:04:16 IST =====
from enum import Enum
from typing import Optional, TYPE_CHECKING
from decimal import Decimal
from datetime import datetime
from sqlalchemy import Column, String, Numeric, DateTime, Boolean, Text, Index
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property
import re

from app.db.base import BaseModel

if TYPE_CHECKING:
    from app.modules.transactions.base.models import TransactionHeader


class CustomerType(str, Enum):
    """Customer type enumeration."""
    INDIVIDUAL = "INDIVIDUAL"
    BUSINESS = "BUSINESS"


class CustomerTier(str, Enum):
    """Customer tier enumeration."""
    BRONZE = "BRONZE"
    SILVER = "SILVER"
    GOLD = "GOLD"
    PLATINUM = "PLATINUM"


class CustomerStatus(str, Enum):
    """Customer status enumeration."""
    ACTIVE = "ACTIVE"
    INACTIVE = "INACTIVE"
    SUSPENDED = "SUSPENDED"
    PENDING = "PENDING"


class BlacklistStatus(str, Enum):
    """Blacklist status enumeration."""
    CLEAR = "CLEAR"
    WARNING = "WARNING"
    BLACKLISTED = "BLACKLISTED"


class CreditRating(str, Enum):
    """Credit rating enumeration."""
    EXCELLENT = "EXCELLENT"
    GOOD = "GOOD"
    FAIR = "FAIR"
    POOR = "POOR"
    NO_RATING = "NO_RATING"


class Customer(BaseModel):
    """
    Customer model for managing customer information.
    
    Attributes:
        customer_code: Unique customer code
        customer_type: Type of customer (INDIVIDUAL or BUSINESS)
        business_name: Company name (for business customers)
        first_name: First name (for individual customers)
        last_name: Last name (for individual customers)
        email: Email address
        phone_number: Phone number
        address: Street address
        city: City
        state: State/Province
        country: Country
        postal_code: Postal/ZIP code
        tax_number: GST/Tax identification number
        customer_tier: Customer tier level
        credit_limit: Credit limit amount
        blacklist_status: Blacklist status
        lifetime_value: Total purchase value
        last_transaction_date: Last transaction date
        notes: Additional notes
        transactions: Customer transactions
    """
    
    __tablename__ = "customers"
    
    customer_code = Column(String(20), nullable=False, unique=True, index=True, comment="Unique customer code")
    customer_type = Column(String(20), nullable=False, comment="Customer type")
    business_name = Column(String(200), nullable=True, comment="Company name")
    first_name = Column(String(100), nullable=True, comment="First name")
    last_name = Column(String(100), nullable=True, comment="Last name")
    email = Column(String(255), nullable=True, comment="Email address")
    phone = Column(String(20), nullable=True, comment="Phone number")
    mobile = Column(String(20), nullable=True, comment="Mobile number")
    address_line1 = Column(Text, nullable=True, comment="Address line 1")
    address_line2 = Column(Text, nullable=True, comment="Address line 2")
    city = Column(String(100), nullable=True, comment="City")
    state = Column(String(100), nullable=True, comment="State/Province")
    country = Column(String(100), nullable=True, comment="Country")
    postal_code = Column(String(20), nullable=True, comment="Postal/ZIP code")
    tax_number = Column(String(50), nullable=True, comment="GST/Tax ID")
    payment_terms = Column(String(50), nullable=True, comment="Payment terms")
    customer_tier = Column(String(20), nullable=False, default=CustomerTier.BRONZE.value, comment="Customer tier")
    credit_limit = Column(Numeric(10, 2), nullable=False, default=0.00, comment="Credit limit")
    status = Column(String(20), nullable=False, default=CustomerStatus.ACTIVE.value, comment="Customer status")
    blacklist_status = Column(String(20), nullable=False, default=BlacklistStatus.CLEAR.value, comment="Blacklist status")
    credit_rating = Column(String(20), nullable=False, default=CreditRating.GOOD.value, comment="Credit rating")
    total_rentals = Column(Numeric(10, 0), nullable=False, default=0, comment="Total number of rentals")
    total_spent = Column(Numeric(12, 2), nullable=False, default=0.00, comment="Total amount spent")
    lifetime_value = Column(Numeric(12, 2), nullable=False, default=0.00, comment="Total purchase value")
    last_transaction_date = Column(DateTime, nullable=True, comment="Last transaction date")
    last_rental_date = Column(DateTime, nullable=True, comment="Last rental date")
    notes = Column(Text, nullable=True, comment="Additional notes")
    
    # Relationships
    # transactions = relationship("TransactionHeader", back_populates="customer", lazy="select")  # Commented out until TransactionHeader is properly configured
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_customer_code', 'customer_code'),
        Index('idx_customer_type', 'customer_type'),
        Index('idx_customer_business_name', 'business_name'),
        Index('idx_customer_name', 'first_name', 'last_name'),
        Index('idx_customer_email', 'email'),
        Index('idx_customer_phone', 'phone'),
        Index('idx_customer_tier', 'customer_tier'),
        Index('idx_customer_blacklist', 'blacklist_status'),
        Index('idx_customer_city', 'city'),
        Index('idx_customer_state', 'state'),
        Index('idx_customer_country', 'country'),
# Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        customer_code: str,
        customer_type: CustomerType,
        business_name: Optional[str] = None,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        mobile: Optional[str] = None,
        address_line1: Optional[str] = None,
        address_line2: Optional[str] = None,
        city: Optional[str] = None,
        state: Optional[str] = None,
        country: Optional[str] = None,
        postal_code: Optional[str] = None,
        tax_number: Optional[str] = None,
        payment_terms: Optional[str] = None,
        customer_tier: CustomerTier = CustomerTier.BRONZE,
        credit_limit: Decimal = Decimal("0.00"),
        blacklist_status: BlacklistStatus = BlacklistStatus.CLEAR,
        **kwargs
    ):
        """
        Initialize a Customer.
        
        Args:
            customer_code: Unique customer code
            customer_type: Type of customer
            business_name: Company name (for business customers)
            first_name: First name (for individual customers)
            last_name: Last name (for individual customers)
            email: Email address
            phone: Phone number
            mobile: Mobile number
            address_line1: Address line 1
            address_line2: Address line 2
            city: City
            state: State/Province
            country: Country
            postal_code: Postal/ZIP code
            tax_number: GST/Tax identification number
            payment_terms: Payment terms
            customer_tier: Customer tier level
            credit_limit: Credit limit amount
            blacklist_status: Blacklist status
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.customer_code = customer_code
        self.customer_type = customer_type.value if isinstance(customer_type, CustomerType) else customer_type
        self.business_name = business_name
        self.first_name = first_name
        self.last_name = last_name
        self.email = email
        self.phone = phone
        self.mobile = mobile
        self.address_line1 = address_line1
        self.address_line2 = address_line2
        self.city = city
        self.state = state
        self.country = country
        self.postal_code = postal_code
        self.tax_number = tax_number
        self.payment_terms = payment_terms
        self.customer_tier = customer_tier.value if isinstance(customer_tier, CustomerTier) else customer_tier
        self.credit_limit = credit_limit
        self.status = CustomerStatus.ACTIVE.value
        self.blacklist_status = blacklist_status.value if isinstance(blacklist_status, BlacklistStatus) else blacklist_status
        self.credit_rating = CreditRating.GOOD.value
        self.total_rentals = 0
        self.total_spent = Decimal("0.00")
        self.lifetime_value = Decimal("0.00")
        self._validate()
    
    def _validate(self):
        """Validate customer business rules."""
        # Code validation
        if not self.customer_code or not self.customer_code.strip():
            raise ValueError("Customer code cannot be empty")
        
        if len(self.customer_code) > 20:
            raise ValueError("Customer code cannot exceed 20 characters")
        
        # Type validation
        if self.customer_type not in [ct.value for ct in CustomerType]:
            raise ValueError(f"Invalid customer type: {self.customer_type}")
        
        # Business customer validation
        if self.customer_type == CustomerType.BUSINESS.value:
            if not self.business_name or not self.business_name.strip():
                raise ValueError("Business name is required for business customers")
            if len(self.business_name) > 200:
                raise ValueError("Business name cannot exceed 200 characters")
        
        # Individual customer validation
        if self.customer_type == CustomerType.INDIVIDUAL.value:
            if not self.first_name or not self.first_name.strip():
                raise ValueError("First name is required for individual customers")
            if not self.last_name or not self.last_name.strip():
                raise ValueError("Last name is required for individual customers")
            if self.first_name and len(self.first_name) > 100:
                raise ValueError("First name cannot exceed 100 characters")
            if self.last_name and len(self.last_name) > 100:
                raise ValueError("Last name cannot exceed 100 characters")
        
        # Email validation
        if self.email:
            if len(self.email) > 255:
                raise ValueError("Email cannot exceed 255 characters")
            
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            if not re.match(email_pattern, self.email):
                raise ValueError("Invalid email format")
        
        # Phone validation
        if self.phone:
            if len(self.phone) > 20:
                raise ValueError("Phone number cannot exceed 20 characters")
        
        if self.mobile:
            if len(self.mobile) > 20:
                raise ValueError("Mobile number cannot exceed 20 characters")
        
        # Address validation
        if self.city and len(self.city) > 100:
            raise ValueError("City cannot exceed 100 characters")
        
        if self.state and len(self.state) > 100:
            raise ValueError("State cannot exceed 100 characters")
        
        if self.country and len(self.country) > 100:
            raise ValueError("Country cannot exceed 100 characters")
        
        if self.postal_code and len(self.postal_code) > 20:
            raise ValueError("Postal code cannot exceed 20 characters")
        
        # Tax ID validation
        if self.tax_number and len(self.tax_number) > 50:
            raise ValueError("Tax number cannot exceed 50 characters")
        
        # Tier validation
        if self.customer_tier not in [tier.value for tier in CustomerTier]:
            raise ValueError(f"Invalid customer tier: {self.customer_tier}")
        
        # Blacklist validation
        if self.blacklist_status not in [status.value for status in BlacklistStatus]:
            raise ValueError(f"Invalid blacklist status: {self.blacklist_status}")
        
        # Credit limit validation
        if self.credit_limit is not None and self.credit_limit < 0:
            raise ValueError("Credit limit cannot be negative")
    
    def update_contact_info(
        self,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        mobile: Optional[str] = None,
        address_line1: Optional[str] = None,
        address_line2: Optional[str] = None,
        city: Optional[str] = None,
        state: Optional[str] = None,
        country: Optional[str] = None,
        postal_code: Optional[str] = None,
        updated_by: Optional[str] = None
    ):
        """Update customer contact information."""
        if email is not None:
            if email:
                if len(email) > 255:
                    raise ValueError("Email cannot exceed 255 characters")
                
                email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
                if not re.match(email_pattern, email):
                    raise ValueError("Invalid email format")
            
            self.email = email.strip() if email else None
        
        if phone is not None:
            if phone and len(phone) > 20:
                raise ValueError("Phone number cannot exceed 20 characters")
            self.phone = phone.strip() if phone else None
        
        if mobile is not None:
            if mobile and len(mobile) > 20:
                raise ValueError("Mobile number cannot exceed 20 characters")
            self.mobile = mobile.strip() if mobile else None
        
        if address_line1 is not None:
            self.address_line1 = address_line1.strip() if address_line1 else None
            
        if address_line2 is not None:
            self.address_line2 = address_line2.strip() if address_line2 else None
        
        if city is not None:
            if city and len(city) > 100:
                raise ValueError("City cannot exceed 100 characters")
            self.city = city.strip() if city else None
        
        if state is not None:
            if state and len(state) > 100:
                raise ValueError("State cannot exceed 100 characters")
            self.state = state.strip() if state else None
        
        if country is not None:
            if country and len(country) > 100:
                raise ValueError("Country cannot exceed 100 characters")
            self.country = country.strip() if country else None
        
        if postal_code is not None:
            if postal_code and len(postal_code) > 20:
                raise ValueError("Postal code cannot exceed 20 characters")
            self.postal_code = postal_code.strip() if postal_code else None
        
        self.updated_by = updated_by
    
    def update_tier(self, new_tier: CustomerTier, updated_by: Optional[str] = None):
        """Update customer tier."""
        if new_tier.value not in [tier.value for tier in CustomerTier]:
            raise ValueError(f"Invalid customer tier: {new_tier}")
        
        self.customer_tier = new_tier.value
        self.updated_by = updated_by
    
    def update_credit_limit(self, new_limit: Decimal, updated_by: Optional[str] = None):
        """Update customer credit limit."""
        if new_limit < 0:
            raise ValueError("Credit limit cannot be negative")
        
        self.credit_limit = new_limit
        self.updated_by = updated_by
    
    def blacklist(self, updated_by: Optional[str] = None):
        """Blacklist customer."""
        self.blacklist_status = BlacklistStatus.BLACKLISTED.value
        self.updated_by = updated_by
    
    def clear_blacklist(self, updated_by: Optional[str] = None):
        """Clear blacklist status."""
        self.blacklist_status = BlacklistStatus.CLEAR.value
        self.updated_by = updated_by
    
    def set_warning(self, updated_by: Optional[str] = None):
        """Set warning status."""
        self.blacklist_status = BlacklistStatus.WARNING.value
        self.updated_by = updated_by
    
    def update_lifetime_value(self, amount: Decimal):
        """Update lifetime value."""
        if amount < 0:
            raise ValueError("Lifetime value cannot be negative")
        
        self.lifetime_value = amount
        self.last_transaction_date = datetime.utcnow()
    
    def is_individual(self) -> bool:
        """Check if customer is individual."""
        return self.customer_type == CustomerType.INDIVIDUAL.value
    
    def is_business(self) -> bool:
        """Check if customer is business."""
        return self.customer_type == CustomerType.BUSINESS.value
    
    def is_blacklisted(self) -> bool:
        """Check if customer is blacklisted."""
        return self.blacklist_status == BlacklistStatus.BLACKLISTED.value
    
    def has_warning(self) -> bool:
        """Check if customer has warning status."""
        return self.blacklist_status == BlacklistStatus.WARNING.value
    
    def can_transact(self) -> bool:
        """Check if customer can make transactions."""
        return self.is_active and not self.is_blacklisted()
    
    def get_full_address(self) -> str:
        """Get full formatted address."""
        parts = []
        if self.address:
            parts.append(self.address)
        if self.city:
            parts.append(self.city)
        if self.state:
            parts.append(self.state)
        if self.postal_code:
            parts.append(self.postal_code)
        if self.country:
            parts.append(self.country)
        return ", ".join(parts)
    
    @property
    def display_name(self) -> str:
        """Get customer display name."""
        if self.is_business():
            return f"{self.business_name} ({self.customer_code})"
        else:
            return f"{self.first_name} {self.last_name} ({self.customer_code})"
    
    @property
    def name(self) -> str:
        """Get customer name."""
        if self.is_business():
            return self.business_name
        else:
            return f"{self.first_name} {self.last_name}"
    
    @property
    def transaction_count(self) -> int:
        """Get number of transactions."""
        return len(self.transactions) if self.transactions else 0
    
    @property
    def tier_display(self) -> str:
        """Get tier display name."""
        tier_names = {
            CustomerTier.BRONZE.value: "Bronze",
            CustomerTier.SILVER.value: "Silver",
            CustomerTier.GOLD.value: "Gold",
            CustomerTier.PLATINUM.value: "Platinum"
        }
        return tier_names.get(self.customer_tier, self.customer_tier)
    
    @property
    def status_display(self) -> str:
        """Get status display name."""
        status_names = {
            BlacklistStatus.CLEAR.value: "Clear",
            BlacklistStatus.WARNING.value: "Warning",
            BlacklistStatus.BLACKLISTED.value: "Blacklisted"
        }
        return status_names.get(self.blacklist_status, self.blacklist_status)
    
    def __str__(self) -> str:
        """String representation of customer."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of customer."""
        return (
            f"Customer(id={self.id}, code='{self.customer_code}', "
            f"type='{self.customer_type}', tier='{self.customer_tier}', "
            f"active={self.is_active})"
        )

===== modules/customers/repository.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy import and_, or_, func, select, update, delete, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload, joinedload

from app.modules.customers.models import Customer, CustomerType, CustomerTier, BlacklistStatus, CustomerStatus


class CustomerRepository:
    """Repository for Customer operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_by_id(self, customer_id: UUID) -> Optional[Customer]:
        """Get customer by ID."""
        query = select(Customer).where(Customer.id == customer_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_code(self, customer_code: str) -> Optional[Customer]:
        """Get customer by code."""
        query = select(Customer).where(Customer.customer_code == customer_code)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        customer_type: Optional[CustomerType] = None,
        customer_status: Optional[CustomerStatus] = None,
        customer_tier: Optional[CustomerTier] = None,
        blacklist_status: Optional[BlacklistStatus] = None,
        active_only: bool = True
    ) -> List[Customer]:
        """Get all customers with optional filtering."""
        query = select(Customer)
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(Customer.is_active == True)
        if customer_type:
            conditions.append(Customer.customer_type == customer_type.value)
        if customer_status:
            conditions.append(Customer.status == customer_status.value)
        if customer_tier:
            conditions.append(Customer.customer_tier == customer_tier.value)
        if blacklist_status:
            conditions.append(Customer.blacklist_status == blacklist_status.value)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(asc(Customer.customer_code)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def search(
        self, 
        search_term: str, 
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[Customer]:
        """Search customers by name, code, or email."""
        query = select(Customer).where(
            or_(
                Customer.customer_code.ilike(f"%{search_term}%"),
                Customer.business_name.ilike(f"%{search_term}%"),
                Customer.first_name.ilike(f"%{search_term}%"),
                Customer.last_name.ilike(f"%{search_term}%"),
                Customer.email.ilike(f"%{search_term}%")
            )
        )
        
        if active_only:
            query = query.where(Customer.is_active == True)
        
        query = query.order_by(asc(Customer.customer_code)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def count_all(
        self,
        customer_type: Optional[CustomerType] = None,
        customer_status: Optional[CustomerStatus] = None,
        customer_tier: Optional[CustomerTier] = None,
        blacklist_status: Optional[BlacklistStatus] = None,
        active_only: bool = True
    ) -> int:
        """Count all customers with optional filtering."""
        query = select(func.count(Customer.id))
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(Customer.is_active == True)
        if customer_type:
            conditions.append(Customer.customer_type == customer_type.value)
        if customer_status:
            conditions.append(Customer.status == customer_status.value)
        if customer_tier:
            conditions.append(Customer.customer_tier == customer_tier.value)
        if blacklist_status:
            conditions.append(Customer.blacklist_status == blacklist_status.value)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        result = await self.session.execute(query)
        return result.scalar()
    
    async def create(self, customer_data: dict) -> Customer:
        """Create a new customer."""
        customer = Customer(**customer_data)
        self.session.add(customer)
        await self.session.commit()
        await self.session.refresh(customer)
        return customer
    
    async def update(self, customer_id: UUID, customer_data: dict) -> Optional[Customer]:
        """Update a customer."""
        query = select(Customer).where(Customer.id == customer_id)
        result = await self.session.execute(query)
        customer = result.scalar_one_or_none()
        
        if not customer:
            return None
        
        # Update fields
        for field, value in customer_data.items():
            if hasattr(customer, field):
                setattr(customer, field, value)
        
        await self.session.commit()
        await self.session.refresh(customer)
        return customer
    
    async def delete(self, customer_id: UUID) -> bool:
        """Soft delete a customer."""
        query = select(Customer).where(Customer.id == customer_id)
        result = await self.session.execute(query)
        customer = result.scalar_one_or_none()
        
        if not customer:
            return False
        
        customer.is_active = False
        await self.session.commit()
        return True

===== modules/customers/routes.py â€“ 2025-07-20 11:30:27 IST =====
from typing import List, Optional, Dict, Any
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.shared.dependencies import get_session
from app.modules.customers.service import CustomerService
from app.modules.customers.models import CustomerType, CustomerStatus, BlacklistStatus, CreditRating
from app.modules.customers.schemas import (
    CustomerCreate, CustomerUpdate, CustomerResponse, CustomerStatusUpdate,
    CustomerBlacklistUpdate, CustomerCreditUpdate, CustomerSearchRequest,
    CustomerStatsResponse, CustomerAddressCreate, CustomerAddressResponse,
    CustomerContactCreate, CustomerContactResponse, CustomerDetailResponse
)


router = APIRouter(tags=["Customer Management"])


# Dependency to get customer service
async def get_customer_service(session: AsyncSession = Depends(get_session)) -> CustomerService:
    return CustomerService(session)


# Customer CRUD endpoints
@router.post("/", response_model=CustomerResponse, status_code=status.HTTP_201_CREATED)
async def create_customer(
    customer_data: CustomerCreate,
    service: CustomerService = Depends(get_customer_service)
):
    """Create a new customer."""
    try:
        return await service.create_customer(customer_data)
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/", response_model=List[CustomerResponse])
async def list_customers(
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    customer_type: Optional[CustomerType] = Query(None, description="Filter by customer type"),
    customer_status: Optional[CustomerStatus] = Query(None, description="Filter by status"),
    blacklist_status: Optional[BlacklistStatus] = Query(None, description="Filter by blacklist status"),
    active_only: bool = Query(True, description="Show only active customers"),
    service: CustomerService = Depends(get_customer_service)
):
    """List customers with optional filtering."""
    return await service.list_customers(
        skip=skip,
        limit=limit,
        customer_type=customer_type,
        status=customer_status,
        blacklist_status=blacklist_status,
        active_only=active_only
    )


@router.get("/search", response_model=List[CustomerResponse])
async def search_customers(
    search_term: str = Query(..., min_length=2, description="Search term"),
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Show only active customers"),
    service: CustomerService = Depends(get_customer_service)
):
    """Search customers by name, code, or email."""
    return await service.search_customers(
        search_term=search_term,
        skip=skip,
        limit=limit,
        active_only=active_only
    )


@router.get("/count")
async def count_customers(
    customer_type: Optional[CustomerType] = Query(None, description="Filter by customer type"),
    customer_status: Optional[CustomerStatus] = Query(None, description="Filter by status"),
    blacklist_status: Optional[BlacklistStatus] = Query(None, description="Filter by blacklist status"),
    active_only: bool = Query(True, description="Show only active customers"),
    service: CustomerService = Depends(get_customer_service)
):
    """Count customers with optional filtering."""
    count = await service.count_customers(
        customer_type=customer_type,
        status=customer_status,
        blacklist_status=blacklist_status,
        active_only=active_only
    )
    return {"count": count}


@router.get("/statistics")
async def get_customer_statistics(
    service: CustomerService = Depends(get_customer_service)
):
    """Get customer statistics."""
    return await service.get_customer_statistics()


@router.get("/{customer_id}", response_model=CustomerResponse)
async def get_customer(
    customer_id: UUID,
    service: CustomerService = Depends(get_customer_service)
):
    """Get customer by ID."""
    customer = await service.get_customer(customer_id)
    if not customer:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Customer not found")
    
    return customer


@router.get("/code/{customer_code}", response_model=CustomerResponse)
async def get_customer_by_code(
    customer_code: str,
    service: CustomerService = Depends(get_customer_service)
):
    """Get customer by code."""
    customer = await service.get_customer_by_code(customer_code)
    if not customer:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Customer not found")
    
    return customer


@router.put("/{customer_id}", response_model=CustomerResponse)
async def update_customer(
    customer_id: UUID,
    update_data: CustomerUpdate,
    service: CustomerService = Depends(get_customer_service)
):
    """Update customer information."""
    try:
        return await service.update_customer(customer_id, update_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{customer_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_customer(
    customer_id: UUID,
    service: CustomerService = Depends(get_customer_service)
):
    """Delete customer."""
    success = await service.delete_customer(customer_id)
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Customer not found")


# Customer status management endpoints
@router.put("/{customer_id}/status", response_model=CustomerResponse)
async def update_customer_status(
    customer_id: UUID,
    status_update: CustomerStatusUpdate,
    service: CustomerService = Depends(get_customer_service)
):
    """Update customer status."""
    try:
        return await service.update_customer_status(customer_id, status_update)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.put("/{customer_id}/blacklist", response_model=CustomerResponse)
async def update_blacklist_status(
    customer_id: UUID,
    blacklist_update: CustomerBlacklistUpdate,
    service: CustomerService = Depends(get_customer_service)
):
    """Update customer blacklist status."""
    try:
        return await service.update_blacklist_status(customer_id, blacklist_update)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.put("/{customer_id}/credit", response_model=CustomerResponse)
async def update_credit_info(
    customer_id: UUID,
    credit_update: CustomerCreditUpdate,
    service: CustomerService = Depends(get_customer_service)
):
    """Update customer credit information."""
    try:
        return await service.update_credit_info(customer_id, credit_update)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


# Customer type specific endpoints
@router.get("/type/{customer_type}", response_model=List[CustomerResponse])
async def get_customers_by_type(
    customer_type: CustomerType,
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Show only active customers"),
    service: CustomerService = Depends(get_customer_service)
):
    """Get customers by type."""
    return await service.list_customers(
        skip=skip,
        limit=limit,
        customer_type=customer_type,
        active_only=active_only
    )


@router.get("/blacklist/{blacklist_status}", response_model=List[CustomerResponse])
async def get_customers_by_blacklist_status(
    blacklist_status: BlacklistStatus,
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Show only active customers"),
    service: CustomerService = Depends(get_customer_service)
):
    """Get customers by blacklist status."""
    return await service.list_customers(
        skip=skip,
        limit=limit,
        blacklist_status=blacklist_status,
        active_only=active_only
    )


# Bulk operations endpoints
@router.post("/bulk/activate", status_code=status.HTTP_204_NO_CONTENT)
async def bulk_activate_customers(
    customer_ids: List[UUID],
    service: CustomerService = Depends(get_customer_service)
):
    """Bulk activate customers."""
    # TODO: Implement bulk activation
    pass


@router.post("/bulk/deactivate", status_code=status.HTTP_204_NO_CONTENT)
async def bulk_deactivate_customers(
    customer_ids: List[UUID],
    service: CustomerService = Depends(get_customer_service)
):
    """Bulk deactivate customers."""
    # TODO: Implement bulk deactivation
    pass


# Export endpoints
@router.get("/export/csv")
async def export_customers_csv(
    customer_type: Optional[CustomerType] = Query(None, description="Filter by customer type"),
    customer_status: Optional[CustomerStatus] = Query(None, description="Filter by status"),
    blacklist_status: Optional[BlacklistStatus] = Query(None, description="Filter by blacklist status"),
    active_only: bool = Query(True, description="Show only active customers"),
    service: CustomerService = Depends(get_customer_service)
):
    """Export customers to CSV."""
    # TODO: Implement CSV export
    return {"message": "CSV export not yet implemented"}


@router.get("/export/xlsx")
async def export_customers_xlsx(
    customer_type: Optional[CustomerType] = Query(None, description="Filter by customer type"),
    customer_status: Optional[CustomerStatus] = Query(None, description="Filter by status"),
    blacklist_status: Optional[BlacklistStatus] = Query(None, description="Filter by blacklist status"),
    active_only: bool = Query(True, description="Show only active customers"),
    service: CustomerService = Depends(get_customer_service)
):
    """Export customers to Excel."""
    # TODO: Implement Excel export
    return {"message": "Excel export not yet implemented"}


===== modules/customers/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List
from datetime import datetime, date
from pydantic import BaseModel, Field, EmailStr, ConfigDict
from uuid import UUID

from app.modules.customers.models import CustomerType, CustomerStatus, BlacklistStatus, CreditRating


class CustomerCreate(BaseModel):
    """Schema for creating a new customer."""
    customer_code: str = Field(..., max_length=50, description="Unique customer code")
    customer_type: CustomerType = Field(..., description="Customer type")
    business_name: Optional[str] = Field(None, max_length=200, description="Business name")
    first_name: str = Field(..., max_length=100, description="First name")
    last_name: str = Field(..., max_length=100, description="Last name")
    email: EmailStr = Field(..., description="Email address")
    phone: str = Field(..., max_length=20, description="Phone number")
    mobile: Optional[str] = Field(None, max_length=20, description="Mobile number")
    address_line1: str = Field(..., max_length=200, description="Address line 1")
    address_line2: Optional[str] = Field(None, max_length=200, description="Address line 2")
    city: str = Field(..., max_length=100, description="City")
    state: str = Field(..., max_length=100, description="State")
    postal_code: str = Field(..., max_length=20, description="Postal code")
    country: str = Field(..., max_length=100, description="Country")
    tax_number: Optional[str] = Field(None, max_length=50, description="Tax number")
    credit_limit: Optional[float] = Field(None, ge=0, description="Credit limit")
    payment_terms: Optional[str] = Field(None, max_length=50, description="Payment terms")
    notes: Optional[str] = Field(None, description="Additional notes")


class CustomerUpdate(BaseModel):
    """Schema for updating a customer."""
    customer_type: Optional[CustomerType] = Field(None, description="Customer type")
    business_name: Optional[str] = Field(None, max_length=200, description="Business name")
    first_name: Optional[str] = Field(None, max_length=100, description="First name")
    last_name: Optional[str] = Field(None, max_length=100, description="Last name")
    email: Optional[EmailStr] = Field(None, description="Email address")
    phone: Optional[str] = Field(None, max_length=20, description="Phone number")
    mobile: Optional[str] = Field(None, max_length=20, description="Mobile number")
    address_line1: Optional[str] = Field(None, max_length=200, description="Address line 1")
    address_line2: Optional[str] = Field(None, max_length=200, description="Address line 2")
    city: Optional[str] = Field(None, max_length=100, description="City")
    state: Optional[str] = Field(None, max_length=100, description="State")
    postal_code: Optional[str] = Field(None, max_length=20, description="Postal code")
    country: Optional[str] = Field(None, max_length=100, description="Country")
    tax_number: Optional[str] = Field(None, max_length=50, description="Tax number")
    credit_limit: Optional[float] = Field(None, ge=0, description="Credit limit")
    payment_terms: Optional[str] = Field(None, max_length=50, description="Payment terms")
    notes: Optional[str] = Field(None, description="Additional notes")


class CustomerResponse(BaseModel):
    """Schema for customer response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    customer_code: str
    customer_type: CustomerType
    business_name: Optional[str]
    first_name: str
    last_name: str
    email: str
    phone: str
    mobile: Optional[str]
    address_line1: str
    address_line2: Optional[str]
    city: str
    state: str
    postal_code: str
    country: str
    tax_number: Optional[str]
    credit_limit: Optional[float]
    payment_terms: Optional[str]
    notes: Optional[str]
    status: CustomerStatus
    blacklist_status: BlacklistStatus
    credit_rating: CreditRating
    total_rentals: int
    total_spent: float
    last_rental_date: Optional[date]
    created_at: datetime
    updated_at: datetime
    is_active: bool


class CustomerStatusUpdate(BaseModel):
    """Schema for updating customer status."""
    status: CustomerStatus = Field(..., description="New customer status")
    notes: Optional[str] = Field(None, description="Status update notes")


class CustomerBlacklistUpdate(BaseModel):
    """Schema for updating customer blacklist status."""
    blacklist_status: BlacklistStatus = Field(..., description="New blacklist status")
    blacklist_reason: Optional[str] = Field(None, description="Blacklist reason")
    notes: Optional[str] = Field(None, description="Additional notes")


class CustomerCreditUpdate(BaseModel):
    """Schema for updating customer credit information."""
    credit_limit: Optional[float] = Field(None, ge=0, description="Credit limit")
    credit_rating: Optional[CreditRating] = Field(None, description="Credit rating")
    payment_terms: Optional[str] = Field(None, max_length=50, description="Payment terms")
    notes: Optional[str] = Field(None, description="Additional notes")


class CustomerSearchRequest(BaseModel):
    """Schema for customer search request."""
    search_term: str = Field(..., min_length=2, description="Search term")
    customer_type: Optional[CustomerType] = Field(None, description="Filter by customer type")
    status: Optional[CustomerStatus] = Field(None, description="Filter by status")
    city: Optional[str] = Field(None, description="Filter by city")
    state: Optional[str] = Field(None, description="Filter by state")
    country: Optional[str] = Field(None, description="Filter by country")
    blacklist_status: Optional[BlacklistStatus] = Field(None, description="Filter by blacklist status")
    credit_rating: Optional[CreditRating] = Field(None, description="Filter by credit rating")


class CustomerStatsResponse(BaseModel):
    """Schema for customer statistics response."""
    total_customers: int
    active_customers: int
    inactive_customers: int
    individual_customers: int
    business_customers: int
    blacklisted_customers: int
    customers_by_credit_rating: dict
    customers_by_state: dict
    top_customers_by_rentals: List[dict]
    top_customers_by_spending: List[dict]
    recent_customers: List[CustomerResponse]


class CustomerAddressCreate(BaseModel):
    """Schema for creating customer address."""
    customer_id: UUID = Field(..., description="Customer ID")
    address_type: str = Field(..., max_length=50, description="Address type")
    address_line1: str = Field(..., max_length=200, description="Address line 1")
    address_line2: Optional[str] = Field(None, max_length=200, description="Address line 2")
    city: str = Field(..., max_length=100, description="City")
    state: str = Field(..., max_length=100, description="State")
    postal_code: str = Field(..., max_length=20, description="Postal code")
    country: str = Field(..., max_length=100, description="Country")
    is_default: bool = Field(False, description="Is default address")


class CustomerAddressResponse(BaseModel):
    """Schema for customer address response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    customer_id: UUID
    address_type: str
    address_line1: str
    address_line2: Optional[str]
    city: str
    state: str
    postal_code: str
    country: str
    is_default: bool
    created_at: datetime
    updated_at: datetime
    is_active: bool


class CustomerContactCreate(BaseModel):
    """Schema for creating customer contact."""
    customer_id: UUID = Field(..., description="Customer ID")
    contact_type: str = Field(..., max_length=50, description="Contact type")
    contact_value: str = Field(..., max_length=200, description="Contact value")
    is_primary: bool = Field(False, description="Is primary contact")
    notes: Optional[str] = Field(None, description="Additional notes")


class CustomerContactResponse(BaseModel):
    """Schema for customer contact response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    customer_id: UUID
    contact_type: str
    contact_value: str
    is_primary: bool
    notes: Optional[str]
    created_at: datetime
    updated_at: datetime
    is_active: bool


class CustomerDetailResponse(BaseModel):
    """Schema for detailed customer response with addresses and contacts."""
    customer: CustomerResponse
    addresses: List[CustomerAddressResponse]
    contacts: List[CustomerContactResponse]
    rental_history: List[dict]  # Will be populated from rental data
    transaction_summary: dict

===== modules/customers/service.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession

from .repository import CustomerRepository
from .models import Customer, CustomerType, CustomerStatus, BlacklistStatus, CreditRating
from .schemas import (
    CustomerCreate, CustomerUpdate, CustomerResponse, CustomerStatusUpdate,
    CustomerBlacklistUpdate, CustomerCreditUpdate, CustomerSearchRequest,
    CustomerStatsResponse, CustomerAddressCreate, CustomerAddressResponse,
    CustomerContactCreate, CustomerContactResponse, CustomerDetailResponse
)
from app.core.errors import ValidationError, NotFoundError, ConflictError
from app.shared.pagination import Page


class CustomerService:
    """Customer service."""
    
    def __init__(self, session: AsyncSession):
        """Initialize service with database session."""
        self.session = session
        self.repository = CustomerRepository(session)
    
    async def create_customer(self, customer_data: CustomerCreate) -> CustomerResponse:
        """Create a new customer."""
        # Check if customer code already exists
        existing_customer = await self.repository.get_by_code(customer_data.customer_code)
        if existing_customer:
            raise ConflictError(f"Customer with code '{customer_data.customer_code}' already exists")
        
        # Create customer data
        customer_dict = {
            "customer_code": customer_data.customer_code,
            "customer_type": customer_data.customer_type,
            "business_name": customer_data.business_name,
            "first_name": customer_data.first_name,
            "last_name": customer_data.last_name,
            "email": customer_data.email,
            "phone": customer_data.phone,
            "mobile": customer_data.mobile,
            "address_line1": customer_data.address_line1,
            "address_line2": customer_data.address_line2,
            "city": customer_data.city,
            "state": customer_data.state,
            "postal_code": customer_data.postal_code,
            "country": customer_data.country,
            "tax_number": customer_data.tax_number,
            "credit_limit": customer_data.credit_limit,
            "payment_terms": customer_data.payment_terms,
            "notes": customer_data.notes,
            "status": CustomerStatus.ACTIVE,
            "blacklist_status": BlacklistStatus.CLEAR,
            "credit_rating": CreditRating.GOOD,
            "total_rentals": 0,
            "total_spent": 0.0,
            "is_active": True
        }
        
        # Create customer
        customer = await self.repository.create(customer_dict)
        
        return CustomerResponse.model_validate(customer)
    
    async def get_customer(self, customer_id: UUID) -> Optional[CustomerResponse]:
        """Get customer by ID."""
        customer = await self.repository.get_by_id(customer_id)
        if not customer:
            return None
        
        return CustomerResponse.model_validate(customer)
    
    async def get_customer_by_code(self, customer_code: str) -> Optional[CustomerResponse]:
        """Get customer by code."""
        customer = await self.repository.get_by_code(customer_code)
        if not customer:
            return None
        
        return CustomerResponse.model_validate(customer)
    
    async def update_customer(self, customer_id: UUID, update_data: CustomerUpdate) -> CustomerResponse:
        """Update customer information."""
        customer = await self.repository.get_by_id(customer_id)
        if not customer:
            raise NotFoundError("Customer not found")
        
        # Update customer
        update_dict = {}
        if update_data.customer_type is not None:
            update_dict["customer_type"] = update_data.customer_type
        if update_data.business_name is not None:
            update_dict["business_name"] = update_data.business_name
        if update_data.first_name is not None:
            update_dict["first_name"] = update_data.first_name
        if update_data.last_name is not None:
            update_dict["last_name"] = update_data.last_name
        if update_data.email is not None:
            update_dict["email"] = update_data.email
        if update_data.phone is not None:
            update_dict["phone"] = update_data.phone
        if update_data.mobile is not None:
            update_dict["mobile"] = update_data.mobile
        if update_data.address_line1 is not None:
            update_dict["address_line1"] = update_data.address_line1
        if update_data.address_line2 is not None:
            update_dict["address_line2"] = update_data.address_line2
        if update_data.city is not None:
            update_dict["city"] = update_data.city
        if update_data.state is not None:
            update_dict["state"] = update_data.state
        if update_data.postal_code is not None:
            update_dict["postal_code"] = update_data.postal_code
        if update_data.country is not None:
            update_dict["country"] = update_data.country
        if update_data.tax_number is not None:
            update_dict["tax_number"] = update_data.tax_number
        if update_data.credit_limit is not None:
            update_dict["credit_limit"] = update_data.credit_limit
        if update_data.payment_terms is not None:
            update_dict["payment_terms"] = update_data.payment_terms
        if update_data.notes is not None:
            update_dict["notes"] = update_data.notes
        
        updated_customer = await self.repository.update(customer_id, update_dict)
        
        return CustomerResponse.model_validate(updated_customer)
    
    async def delete_customer(self, customer_id: UUID) -> bool:
        """Delete customer."""
        return await self.repository.delete(customer_id)
    
    async def list_customers(
        self,
        skip: int = 0,
        limit: int = 100,
        customer_type: Optional[CustomerType] = None,
        status: Optional[CustomerStatus] = None,
        blacklist_status: Optional[BlacklistStatus] = None,
        active_only: bool = True
    ) -> List[CustomerResponse]:
        """List customers with filtering."""
        customers = await self.repository.get_all(
            skip=skip,
            limit=limit,
            customer_type=customer_type,
            customer_status=status,
            blacklist_status=blacklist_status,
            active_only=active_only
        )
        
        return [CustomerResponse.model_validate(customer) for customer in customers]
    
    async def search_customers(
        self,
        search_term: str,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True
    ) -> List[CustomerResponse]:
        """Search customers."""
        customers = await self.repository.search(
            search_term=search_term,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
        
        return [CustomerResponse.model_validate(customer) for customer in customers]
    
    async def count_customers(
        self,
        customer_type: Optional[CustomerType] = None,
        status: Optional[CustomerStatus] = None,
        blacklist_status: Optional[BlacklistStatus] = None,
        active_only: bool = True
    ) -> int:
        """Count customers with filtering."""
        return await self.repository.count_all(
            customer_type=customer_type,
            customer_status=status,
            blacklist_status=blacklist_status,
            active_only=active_only
        )
    
    async def update_customer_status(self, customer_id: UUID, status_update: CustomerStatusUpdate) -> CustomerResponse:
        """Update customer status."""
        customer = await self.repository.get_by_id(customer_id)
        if not customer:
            raise NotFoundError("Customer not found")
        
        update_dict = {
            "status": status_update.status,
            "notes": status_update.notes
        }
        
        updated_customer = await self.repository.update(customer_id, update_dict)
        return CustomerResponse.model_validate(updated_customer)
    
    async def update_blacklist_status(self, customer_id: UUID, blacklist_update: CustomerBlacklistUpdate) -> CustomerResponse:
        """Update customer blacklist status."""
        customer = await self.repository.get_by_id(customer_id)
        if not customer:
            raise NotFoundError("Customer not found")
        
        update_dict = {
            "blacklist_status": blacklist_update.blacklist_status,
            "blacklist_reason": blacklist_update.blacklist_reason,
            "notes": blacklist_update.notes
        }
        
        updated_customer = await self.repository.update(customer_id, update_dict)
        return CustomerResponse.model_validate(updated_customer)
    
    async def update_credit_info(self, customer_id: UUID, credit_update: CustomerCreditUpdate) -> CustomerResponse:
        """Update customer credit information."""
        customer = await self.repository.get_by_id(customer_id)
        if not customer:
            raise NotFoundError("Customer not found")
        
        update_dict = {}
        if credit_update.credit_limit is not None:
            update_dict["credit_limit"] = credit_update.credit_limit
        if credit_update.credit_rating is not None:
            update_dict["credit_rating"] = credit_update.credit_rating
        if credit_update.payment_terms is not None:
            update_dict["payment_terms"] = credit_update.payment_terms
        if credit_update.notes is not None:
            update_dict["notes"] = credit_update.notes
        
        updated_customer = await self.repository.update(customer_id, update_dict)
        return CustomerResponse.model_validate(updated_customer)
    
    async def get_customer_statistics(self) -> Dict[str, Any]:
        """Get customer statistics."""
        # Get basic counts
        total_customers = await self.repository.count_all(active_only=False)
        active_customers = await self.repository.count_all(active_only=True)
        individual_customers = await self.repository.count_all(
            customer_type=CustomerType.INDIVIDUAL, active_only=True
        )
        business_customers = await self.repository.count_all(
            customer_type=CustomerType.BUSINESS, active_only=True
        )
        
        # Get recent customers
        recent_customers = await self.repository.get_all(skip=0, limit=10, active_only=True)
        
        return {
            "total_customers": total_customers,
            "active_customers": active_customers,
            "inactive_customers": total_customers - active_customers,
            "individual_customers": individual_customers,
            "business_customers": business_customers,
            "blacklisted_customers": 0,  # Will be implemented when blacklist filtering is available
            "customers_by_credit_rating": {},
            "customers_by_state": {},
            "top_customers_by_rentals": [],
            "top_customers_by_spending": [],
            "recent_customers": [CustomerResponse.model_validate(customer) for customer in recent_customers]
        }

===== modules/suppliers/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""
Suppliers module initialization.
"""

from .models import Supplier
from .schemas import SupplierCreate, SupplierUpdate, SupplierResponse
from .service import SupplierService

__all__ = [
    "Supplier",
    "SupplierCreate", 
    "SupplierUpdate",
    "SupplierResponse",
    "SupplierService"
]

===== modules/suppliers/models.py â€“ 2025-07-19 12:13:41 IST =====
from enum import Enum
from typing import Optional
from sqlalchemy import Column, String, Text, Boolean, DateTime, Numeric, Integer, Index
from sqlalchemy.orm import relationship
from decimal import Decimal
from datetime import datetime

from app.db.base import BaseModel


class SupplierType(str, Enum):
    """Supplier type enumeration."""
    MANUFACTURER = "MANUFACTURER"
    DISTRIBUTOR = "DISTRIBUTOR"
    WHOLESALER = "WHOLESALER"
    RETAILER = "RETAILER"
    INVENTORY = "INVENTORY"
    SERVICE = "SERVICE"
    DIRECT = "DIRECT"


class SupplierTier(str, Enum):
    """Supplier tier enumeration."""
    PREMIUM = "PREMIUM"
    STANDARD = "STANDARD"
    BASIC = "BASIC"
    TRIAL = "TRIAL"


class SupplierStatus(str, Enum):
    """Supplier status enumeration."""
    ACTIVE = "ACTIVE"
    INACTIVE = "INACTIVE"
    PENDING = "PENDING"
    APPROVED = "APPROVED"
    SUSPENDED = "SUSPENDED"
    BLACKLISTED = "BLACKLISTED"


class PaymentTerms(str, Enum):
    """Payment terms enumeration."""
    IMMEDIATE = "IMMEDIATE"
    NET15 = "NET15"
    NET30 = "NET30"
    NET45 = "NET45"
    NET60 = "NET60"
    NET90 = "NET90"
    COD = "COD"


class Supplier(BaseModel):
    """
    Supplier model for managing supplier information.
    
    Attributes:
        supplier_code: Unique supplier code
        company_name: Supplier company name
        supplier_type: Type of supplier (MANUFACTURER, DISTRIBUTOR, etc.)
        contact_person: Primary contact person
        email: Supplier email address
        phone: Supplier phone number
        mobile: Supplier mobile number
        address_line1: Primary address line
        address_line2: Secondary address line
        city: City
        state: State/Province
        postal_code: Postal/ZIP code
        country: Country
        tax_id: Tax identification number
        payment_terms: Payment terms (NET30, NET45, etc.)
        credit_limit: Credit limit amount
        supplier_tier: Supplier tier (PREMIUM, STANDARD, etc.)
        status: Supplier status (ACTIVE, INACTIVE, etc.)
        quality_rating: Quality rating (0-5)
        delivery_rating: Delivery rating (0-5)
        average_delivery_days: Average delivery time in days
        total_orders: Total number of orders
        total_spend: Total amount spent
        last_order_date: Date of last order
        contract_start_date: Contract start date
        contract_end_date: Contract end date
        notes: Additional notes
        website: Supplier website
        account_manager: Account manager name
        preferred_payment_method: Preferred payment method
        insurance_expiry: Insurance expiry date
        certifications: Certifications held
    """
    
    __tablename__ = "suppliers"
    
    # Core supplier information
    supplier_code = Column(String(50), unique=True, nullable=False, index=True, comment="Unique supplier code")
    company_name = Column(String(255), nullable=False, index=True, comment="Supplier company name")
    supplier_type = Column(String(50), nullable=False, comment="Type of supplier")
    
    # Contact information
    contact_person = Column(String(255), nullable=True, comment="Primary contact person")
    email = Column(String(255), nullable=True, index=True, comment="Supplier email address")
    phone = Column(String(50), nullable=True, comment="Supplier phone number")
    mobile = Column(String(50), nullable=True, comment="Supplier mobile number")
    
    # Address information
    address_line1 = Column(String(255), nullable=True, comment="Primary address line")
    address_line2 = Column(String(255), nullable=True, comment="Secondary address line")
    city = Column(String(100), nullable=True, comment="City")
    state = Column(String(100), nullable=True, comment="State/Province")
    postal_code = Column(String(20), nullable=True, comment="Postal/ZIP code")
    country = Column(String(100), nullable=True, comment="Country")
    
    # Business information
    tax_id = Column(String(50), nullable=True, comment="Tax identification number")
    payment_terms = Column(String(20), nullable=False, default=PaymentTerms.NET30.value, comment="Payment terms")
    credit_limit = Column(Numeric(12, 2), nullable=False, default=0, comment="Credit limit amount")
    supplier_tier = Column(String(20), nullable=False, default=SupplierTier.STANDARD.value, comment="Supplier tier")
    status = Column(String(20), nullable=False, default=SupplierStatus.ACTIVE.value, comment="Supplier status")
    
    # Performance metrics
    quality_rating = Column(Numeric(3, 2), nullable=False, default=0, comment="Quality rating (0-5)")
    delivery_rating = Column(Numeric(3, 2), nullable=False, default=0, comment="Delivery rating (0-5)")
    average_delivery_days = Column(Integer, nullable=False, default=0, comment="Average delivery time in days")
    total_orders = Column(Integer, nullable=False, default=0, comment="Total number of orders")
    total_spend = Column(Numeric(15, 2), nullable=False, default=0, comment="Total amount spent")
    last_order_date = Column(DateTime, nullable=True, comment="Date of last order")
    
    # Contract information
    contract_start_date = Column(DateTime, nullable=True, comment="Contract start date")
    contract_end_date = Column(DateTime, nullable=True, comment="Contract end date")
    
    # Additional information
    notes = Column(Text, nullable=True, comment="Additional notes")
    website = Column(String(255), nullable=True, comment="Supplier website")
    account_manager = Column(String(255), nullable=True, comment="Account manager name")
    preferred_payment_method = Column(String(50), nullable=True, comment="Preferred payment method")
    insurance_expiry = Column(DateTime, nullable=True, comment="Insurance expiry date")
    certifications = Column(Text, nullable=True, comment="Certifications held")
    
    # Relationships
    # items = relationship("Item", back_populates="supplier", lazy="select")  # TODO: Add supplier_id to Item model
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_supplier_code', 'supplier_code'),
        Index('idx_supplier_company_name', 'company_name'),
        Index('idx_supplier_type', 'supplier_type'),
        Index('idx_supplier_status', 'status'),
        Index('idx_supplier_tier', 'supplier_tier'),
        Index('idx_supplier_email', 'email'),
        Index('idx_supplier_payment_terms', 'payment_terms'),
        Index('idx_supplier_last_order', 'last_order_date'),
        Index('idx_supplier_contract_dates', 'contract_start_date', 'contract_end_date'),
        Index('idx_supplier_ratings', 'quality_rating', 'delivery_rating'),
    )
    
    def __init__(
        self,
        supplier_code: str,
        company_name: str,
        supplier_type: SupplierType,
        contact_person: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        mobile: Optional[str] = None,
        address_line1: Optional[str] = None,
        address_line2: Optional[str] = None,
        city: Optional[str] = None,
        state: Optional[str] = None,
        postal_code: Optional[str] = None,
        country: Optional[str] = None,
        tax_id: Optional[str] = None,
        payment_terms: PaymentTerms = PaymentTerms.NET30,
        credit_limit: Decimal = Decimal("0.00"),
        supplier_tier: SupplierTier = SupplierTier.STANDARD,
        status: SupplierStatus = SupplierStatus.ACTIVE,
        notes: Optional[str] = None,
        website: Optional[str] = None,
        account_manager: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a Supplier.
        
        Args:
            supplier_code: Unique supplier code
            company_name: Supplier company name
            supplier_type: Type of supplier
            contact_person: Primary contact person
            email: Supplier email address
            phone: Supplier phone number
            mobile: Supplier mobile number
            address_line1: Primary address line
            address_line2: Secondary address line
            city: City
            state: State/Province
            postal_code: Postal/ZIP code
            country: Country
            tax_id: Tax identification number
            payment_terms: Payment terms
            credit_limit: Credit limit amount
            supplier_tier: Supplier tier
            status: Supplier status
            notes: Additional notes
            website: Supplier website
            account_manager: Account manager name
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.supplier_code = supplier_code
        self.company_name = company_name
        self.supplier_type = supplier_type.value if isinstance(supplier_type, SupplierType) else supplier_type
        self.contact_person = contact_person
        self.email = email
        self.phone = phone
        self.mobile = mobile
        self.address_line1 = address_line1
        self.address_line2 = address_line2
        self.city = city
        self.state = state
        self.postal_code = postal_code
        self.country = country
        self.tax_id = tax_id
        self.payment_terms = payment_terms.value if isinstance(payment_terms, PaymentTerms) else payment_terms
        self.credit_limit = float(credit_limit)
        self.supplier_tier = supplier_tier.value if isinstance(supplier_tier, SupplierTier) else supplier_tier
        self.status = status.value if isinstance(status, SupplierStatus) else status
        self.notes = notes
        self.website = website
        self.account_manager = account_manager
        self.quality_rating = 0.0
        self.delivery_rating = 0.0
        self.average_delivery_days = 0
        self.total_orders = 0
        self.total_spend = 0.0
        self._validate()
    
    def _validate(self):
        """Validate supplier business rules."""
        if not self.supplier_code or not self.supplier_code.strip():
            raise ValueError("Supplier code cannot be empty")
        
        if len(self.supplier_code) > 50:
            raise ValueError("Supplier code cannot exceed 50 characters")
        
        if not self.company_name or not self.company_name.strip():
            raise ValueError("Company name cannot be empty")
        
        if len(self.company_name) > 255:
            raise ValueError("Company name cannot exceed 255 characters")
        
        if self.supplier_type not in [t.value for t in SupplierType]:
            raise ValueError(f"Invalid supplier type: {self.supplier_type}")
        
        if self.email and len(self.email) > 255:
            raise ValueError("Email cannot exceed 255 characters")
        
        if self.email and "@" not in self.email:
            raise ValueError("Invalid email format")
        
        if self.phone and len(self.phone) > 50:
            raise ValueError("Phone number cannot exceed 50 characters")
        
        if self.mobile and len(self.mobile) > 50:
            raise ValueError("Mobile number cannot exceed 50 characters")
        
        if self.credit_limit < 0:
            raise ValueError("Credit limit cannot be negative")
        
        if self.status not in [s.value for s in SupplierStatus]:
            raise ValueError(f"Invalid supplier status: {self.status}")
        
        if self.supplier_tier not in [t.value for t in SupplierTier]:
            raise ValueError(f"Invalid supplier tier: {self.supplier_tier}")
        
        if self.payment_terms not in [p.value for p in PaymentTerms]:
            raise ValueError(f"Invalid payment terms: {self.payment_terms}")
    
    def update_performance_metrics(
        self,
        quality_rating: Optional[float] = None,
        delivery_rating: Optional[float] = None,
        average_delivery_days: Optional[int] = None,
        total_orders: Optional[int] = None,
        total_spend: Optional[float] = None,
        last_order_date: Optional[datetime] = None
    ):
        """Update supplier performance metrics."""
        if quality_rating is not None:
            if not 0 <= quality_rating <= 5:
                raise ValueError("Quality rating must be between 0 and 5")
            self.quality_rating = quality_rating
        
        if delivery_rating is not None:
            if not 0 <= delivery_rating <= 5:
                raise ValueError("Delivery rating must be between 0 and 5")
            self.delivery_rating = delivery_rating
        
        if average_delivery_days is not None:
            if average_delivery_days < 0:
                raise ValueError("Average delivery days cannot be negative")
            self.average_delivery_days = average_delivery_days
        
        if total_orders is not None:
            if total_orders < 0:
                raise ValueError("Total orders cannot be negative")
            self.total_orders = total_orders
        
        if total_spend is not None:
            if total_spend < 0:
                raise ValueError("Total spend cannot be negative")
            self.total_spend = total_spend
        
        if last_order_date is not None:
            self.last_order_date = last_order_date
    
    def activate(self, updated_by: Optional[str] = None):
        """Activate supplier."""
        self.status = SupplierStatus.ACTIVE.value
        self.updated_by = updated_by
    
    def deactivate(self, updated_by: Optional[str] = None):
        """Deactivate supplier."""
        self.status = SupplierStatus.INACTIVE.value
        self.updated_by = updated_by
    
    def suspend(self, updated_by: Optional[str] = None):
        """Suspend supplier."""
        self.status = SupplierStatus.SUSPENDED.value
        self.updated_by = updated_by
    
    def blacklist(self, updated_by: Optional[str] = None):
        """Blacklist supplier."""
        self.status = SupplierStatus.BLACKLISTED.value
        self.updated_by = updated_by
    
    def approve(self, updated_by: Optional[str] = None):
        """Approve supplier."""
        self.status = SupplierStatus.APPROVED.value
        self.updated_by = updated_by
    
    def is_active_supplier(self) -> bool:
        """Check if supplier is active."""
        return self.status == SupplierStatus.ACTIVE.value and self.is_active
    
    def is_approved(self) -> bool:
        """Check if supplier is approved."""
        return self.status == SupplierStatus.APPROVED.value
    
    def is_suspended(self) -> bool:
        """Check if supplier is suspended."""
        return self.status == SupplierStatus.SUSPENDED.value
    
    def is_blacklisted(self) -> bool:
        """Check if supplier is blacklisted."""
        return self.status == SupplierStatus.BLACKLISTED.value
    
    def can_place_order(self) -> bool:
        """Check if supplier can receive orders."""
        return self.is_active_supplier() and self.status in [
            SupplierStatus.ACTIVE.value,
            SupplierStatus.APPROVED.value
        ]
    
    @property
    def full_address(self) -> str:
        """Get formatted full address."""
        parts = [self.address_line1, self.address_line2, self.city, self.state, self.postal_code, self.country]
        return ", ".join(part for part in parts if part)
    
    @property
    def display_name(self) -> str:
        """Get supplier display name."""
        return f"{self.company_name} ({self.supplier_code})"
    
    @property
    def overall_rating(self) -> float:
        """Get overall supplier rating (average of quality and delivery)."""
        if self.quality_rating > 0 and self.delivery_rating > 0:
            return (self.quality_rating + self.delivery_rating) / 2
        return 0.0
    
    def __str__(self) -> str:
        """String representation of supplier."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of supplier."""
        return (
            f"Supplier(id={self.id}, code='{self.supplier_code}', "
            f"company='{self.company_name}', type='{self.supplier_type}', "
            f"status='{self.status}', active={self.is_active})"
        )

===== modules/suppliers/repository.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, or_, and_, desc, asc
from sqlalchemy.orm import selectinload
from datetime import datetime, timedelta

from .models import Supplier, SupplierType, SupplierTier, SupplierStatus, PaymentTerms
from app.shared.repository import BaseRepository


class SupplierRepository(BaseRepository[Supplier]):
    """Repository for supplier operations."""
    
    def __init__(self, session: AsyncSession):
        super().__init__(Supplier, session)
    
    async def get_by_code(self, supplier_code: str) -> Optional[Supplier]:
        """Get supplier by code."""
        query = select(Supplier).where(Supplier.supplier_code == supplier_code)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_email(self, email: str) -> Optional[Supplier]:
        """Get supplier by email."""
        query = select(Supplier).where(Supplier.email == email)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        supplier_type: Optional[SupplierType] = None,
        status: Optional[SupplierStatus] = None,
        supplier_tier: Optional[SupplierTier] = None,
        payment_terms: Optional[PaymentTerms] = None,
        country: Optional[str] = None,
        active_only: bool = True,
        sort_by: str = "company_name",
        sort_order: str = "asc"
    ) -> List[Supplier]:
        """Get all suppliers with filtering and sorting."""
        query = select(Supplier)
        
        # Apply filters
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        if supplier_type:
            query = query.where(Supplier.supplier_type == supplier_type.value)
        
        if status:
            query = query.where(Supplier.status == status.value)
        
        if supplier_tier:
            query = query.where(Supplier.supplier_tier == supplier_tier.value)
        
        if payment_terms:
            query = query.where(Supplier.payment_terms == payment_terms.value)
        
        if country:
            query = query.where(Supplier.country.ilike(f"%{country}%"))
        
        # Apply sorting
        if hasattr(Supplier, sort_by):
            sort_column = getattr(Supplier, sort_by)
            if sort_order.lower() == "desc":
                query = query.order_by(desc(sort_column))
            else:
                query = query.order_by(asc(sort_column))
        else:
            query = query.order_by(asc(Supplier.company_name))
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def search(
        self,
        search_term: str,
        skip: int = 0,
        limit: int = 100,
        supplier_type: Optional[SupplierType] = None,
        status: Optional[SupplierStatus] = None,
        active_only: bool = True
    ) -> List[Supplier]:
        """Search suppliers by name, code, or email."""
        query = select(Supplier)
        
        # Search conditions
        search_conditions = [
            Supplier.company_name.ilike(f"%{search_term}%"),
            Supplier.supplier_code.ilike(f"%{search_term}%"),
            Supplier.email.ilike(f"%{search_term}%"),
            Supplier.contact_person.ilike(f"%{search_term}%")
        ]
        
        query = query.where(or_(*search_conditions))
        
        # Apply filters
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        if supplier_type:
            query = query.where(Supplier.supplier_type == supplier_type.value)
        
        if status:
            query = query.where(Supplier.status == status.value)
        
        # Order by relevance (exact matches first)
        query = query.order_by(
            func.case(
                (Supplier.supplier_code.ilike(search_term), 1),
                (Supplier.company_name.ilike(search_term), 2),
                (Supplier.email.ilike(search_term), 3),
                else_=4
            ),
            Supplier.company_name
        )
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def count_all(
        self,
        supplier_type: Optional[SupplierType] = None,
        status: Optional[SupplierStatus] = None,
        supplier_tier: Optional[SupplierTier] = None,
        payment_terms: Optional[PaymentTerms] = None,
        country: Optional[str] = None,
        active_only: bool = True
    ) -> int:
        """Count suppliers with filtering."""
        query = select(func.count(Supplier.id))
        
        # Apply filters
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        if supplier_type:
            query = query.where(Supplier.supplier_type == supplier_type.value)
        
        if status:
            query = query.where(Supplier.status == status.value)
        
        if supplier_tier:
            query = query.where(Supplier.supplier_tier == supplier_tier.value)
        
        if payment_terms:
            query = query.where(Supplier.payment_terms == payment_terms.value)
        
        if country:
            query = query.where(Supplier.country.ilike(f"%{country}%"))
        
        result = await self.session.execute(query)
        return result.scalar()
    
    async def get_suppliers_by_type(
        self,
        supplier_type: SupplierType,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get suppliers by type."""
        query = select(Supplier).where(Supplier.supplier_type == supplier_type.value)
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(Supplier.company_name)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_suppliers_by_status(
        self,
        status: SupplierStatus,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get suppliers by status."""
        query = select(Supplier).where(Supplier.status == status.value)
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(Supplier.company_name)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_suppliers_by_tier(
        self,
        supplier_tier: SupplierTier,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get suppliers by tier."""
        query = select(Supplier).where(Supplier.supplier_tier == supplier_tier.value)
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(Supplier.company_name)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_suppliers_by_country(
        self,
        country: str,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get suppliers by country."""
        query = select(Supplier).where(Supplier.country.ilike(f"%{country}%"))
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(Supplier.company_name)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_top_suppliers_by_orders(
        self,
        limit: int = 10,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get top suppliers by total orders."""
        query = select(Supplier).where(Supplier.total_orders > 0)
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(desc(Supplier.total_orders)).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_top_suppliers_by_spend(
        self,
        limit: int = 10,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get top suppliers by total spend."""
        query = select(Supplier).where(Supplier.total_spend > 0)
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(desc(Supplier.total_spend)).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_suppliers_with_expiring_contracts(
        self,
        days: int = 30,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get suppliers with contracts expiring within specified days."""
        cutoff_date = datetime.utcnow() + timedelta(days=days)
        
        query = select(Supplier).where(
            and_(
                Supplier.contract_end_date.isnot(None),
                Supplier.contract_end_date <= cutoff_date,
                Supplier.contract_end_date >= datetime.utcnow()
            )
        )
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(Supplier.contract_end_date)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_suppliers_with_expiring_insurance(
        self,
        days: int = 30,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get suppliers with insurance expiring within specified days."""
        cutoff_date = datetime.utcnow() + timedelta(days=days)
        
        query = select(Supplier).where(
            and_(
                Supplier.insurance_expiry.isnot(None),
                Supplier.insurance_expiry <= cutoff_date,
                Supplier.insurance_expiry >= datetime.utcnow()
            )
        )
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(Supplier.insurance_expiry)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_statistics(self) -> Dict[str, Any]:
        """Get supplier statistics."""
        # Basic counts
        total_count = await self.session.execute(select(func.count(Supplier.id)))
        active_count = await self.session.execute(
            select(func.count(Supplier.id)).where(Supplier.is_active == True)
        )
        
        # Count by type
        type_counts = await self.session.execute(
            select(Supplier.supplier_type, func.count(Supplier.id))
            .where(Supplier.is_active == True)
            .group_by(Supplier.supplier_type)
        )
        
        # Count by status
        status_counts = await self.session.execute(
            select(Supplier.status, func.count(Supplier.id))
            .where(Supplier.is_active == True)
            .group_by(Supplier.status)
        )
        
        # Count by tier
        tier_counts = await self.session.execute(
            select(Supplier.supplier_tier, func.count(Supplier.id))
            .where(Supplier.is_active == True)
            .group_by(Supplier.supplier_tier)
        )
        
        # Count by country
        country_counts = await self.session.execute(
            select(Supplier.country, func.count(Supplier.id))
            .where(and_(Supplier.is_active == True, Supplier.country.isnot(None)))
            .group_by(Supplier.country)
            .order_by(desc(func.count(Supplier.id)))
            .limit(10)
        )
        
        # Average ratings
        avg_ratings = await self.session.execute(
            select(
                func.avg(Supplier.quality_rating),
                func.avg(Supplier.delivery_rating)
            )
            .where(Supplier.is_active == True)
        )
        
        return {
            "total_suppliers": total_count.scalar(),
            "active_suppliers": active_count.scalar(),
            "suppliers_by_type": dict(type_counts.fetchall()),
            "suppliers_by_status": dict(status_counts.fetchall()),
            "suppliers_by_tier": dict(tier_counts.fetchall()),
            "suppliers_by_country": dict(country_counts.fetchall()),
            "average_ratings": avg_ratings.fetchone()
        }
    
    async def get_recent_suppliers(
        self,
        limit: int = 10,
        active_only: bool = True
    ) -> List[Supplier]:
        """Get recently created suppliers."""
        query = select(Supplier)
        
        if active_only:
            query = query.where(Supplier.is_active == True)
        
        query = query.order_by(desc(Supplier.created_at)).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def bulk_update_status(
        self,
        supplier_ids: List[UUID],
        status: SupplierStatus,
        updated_by: Optional[str] = None
    ) -> int:
        """Bulk update supplier status."""
        from sqlalchemy import update
        
        query = update(Supplier).where(
            Supplier.id.in_(supplier_ids)
        ).values(
            status=status.value,
            updated_by=updated_by,
            updated_at=datetime.utcnow()
        )
        
        result = await self.session.execute(query)
        return result.rowcount
    
    async def bulk_update_tier(
        self,
        supplier_ids: List[UUID],
        supplier_tier: SupplierTier,
        updated_by: Optional[str] = None
    ) -> int:
        """Bulk update supplier tier."""
        from sqlalchemy import update
        
        query = update(Supplier).where(
            Supplier.id.in_(supplier_ids)
        ).values(
            supplier_tier=supplier_tier.value,
            updated_by=updated_by,
            updated_at=datetime.utcnow()
        )
        
        result = await self.session.execute(query)
        return result.rowcount
    
    async def exists_by_code(self, supplier_code: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if supplier exists by code."""
        query = select(func.count(Supplier.id)).where(Supplier.supplier_code == supplier_code)
        
        if exclude_id:
            query = query.where(Supplier.id != exclude_id)
        
        result = await self.session.execute(query)
        return result.scalar() > 0
    
    async def exists_by_email(self, email: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if supplier exists by email."""
        query = select(func.count(Supplier.id)).where(Supplier.email == email)
        
        if exclude_id:
            query = query.where(Supplier.id != exclude_id)
        
        result = await self.session.execute(query)
        return result.scalar() > 0

===== modules/suppliers/routes.py â€“ 2025-07-20 11:30:16 IST =====
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.shared.dependencies import get_session
from app.modules.suppliers.service import SupplierService
from app.modules.suppliers.models import SupplierType, SupplierStatus
from app.modules.suppliers.schemas import (
    SupplierCreate, SupplierUpdate, SupplierResponse, SupplierStatusUpdate
)


router = APIRouter(tags=["Supplier Management"])


# Dependency to get supplier service
async def get_supplier_service(session: AsyncSession = Depends(get_session)) -> SupplierService:
    return SupplierService(session)


# Supplier CRUD endpoints
@router.post("/", response_model=SupplierResponse, status_code=status.HTTP_201_CREATED)
async def create_supplier(
    supplier_data: SupplierCreate,
    service: SupplierService = Depends(get_supplier_service)
):
    """Create a new supplier."""
    try:
        return await service.create_supplier(supplier_data)
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/", response_model=List[SupplierResponse])
async def list_suppliers(
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    supplier_type: Optional[SupplierType] = Query(None, description="Filter by supplier type"),
    supplier_status: Optional[SupplierStatus] = Query(None, description="Filter by status"),
    active_only: bool = Query(True, description="Show only active suppliers"),
    service: SupplierService = Depends(get_supplier_service)
):
    """List suppliers with optional filtering."""
    return await service.list_suppliers(
        skip=skip,
        limit=limit,
        supplier_type=supplier_type,
        status=supplier_status,
        active_only=active_only
    )


@router.get("/search", response_model=List[SupplierResponse])
async def search_suppliers(
    search_term: str = Query(..., min_length=2, description="Search term"),
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Show only active suppliers"),
    service: SupplierService = Depends(get_supplier_service)
):
    """Search suppliers by name, code, or email."""
    return await service.search_suppliers(
        search_term=search_term,
        skip=skip,
        limit=limit,
        active_only=active_only
    )


@router.get("/count")
async def count_suppliers(
    supplier_type: Optional[SupplierType] = Query(None, description="Filter by supplier type"),
    supplier_status: Optional[SupplierStatus] = Query(None, description="Filter by status"),
    active_only: bool = Query(True, description="Show only active suppliers"),
    service: SupplierService = Depends(get_supplier_service)
):
    """Count suppliers with optional filtering."""
    count = await service.count_suppliers(
        supplier_type=supplier_type,
        status=supplier_status,
        active_only=active_only
    )
    return {"count": count}


@router.get("/statistics")
async def get_supplier_statistics(
    service: SupplierService = Depends(get_supplier_service)
):
    """Get supplier statistics."""
    return await service.get_supplier_statistics()


@router.get("/{supplier_id}", response_model=SupplierResponse)
async def get_supplier(
    supplier_id: UUID,
    service: SupplierService = Depends(get_supplier_service)
):
    """Get supplier by ID."""
    supplier = await service.get_supplier(supplier_id)
    if not supplier:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Supplier not found")
    
    return supplier


@router.get("/code/{supplier_code}", response_model=SupplierResponse)
async def get_supplier_by_code(
    supplier_code: str,
    service: SupplierService = Depends(get_supplier_service)
):
    """Get supplier by code."""
    supplier = await service.get_supplier_by_code(supplier_code)
    if not supplier:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Supplier not found")
    
    return supplier


@router.put("/{supplier_id}", response_model=SupplierResponse)
async def update_supplier(
    supplier_id: UUID,
    update_data: SupplierUpdate,
    service: SupplierService = Depends(get_supplier_service)
):
    """Update supplier information."""
    try:
        return await service.update_supplier(supplier_id, update_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{supplier_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_supplier(
    supplier_id: UUID,
    service: SupplierService = Depends(get_supplier_service)
):
    """Delete supplier."""
    success = await service.delete_supplier(supplier_id)
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Supplier not found")


# Supplier status management endpoints
@router.put("/{supplier_id}/status", response_model=SupplierResponse)
async def update_supplier_status(
    supplier_id: UUID,
    status_update: SupplierStatusUpdate,
    service: SupplierService = Depends(get_supplier_service)
):
    """Update supplier status."""
    try:
        return await service.update_supplier_status(supplier_id, status_update)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


# Supplier type specific endpoints
@router.get("/type/{supplier_type}", response_model=List[SupplierResponse])
async def get_suppliers_by_type(
    supplier_type: SupplierType,
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Show only active suppliers"),
    service: SupplierService = Depends(get_supplier_service)
):
    """Get suppliers by type."""
    return await service.list_suppliers(
        skip=skip,
        limit=limit,
        supplier_type=supplier_type,
        active_only=active_only
    )


@router.get("/status/{status}", response_model=List[SupplierResponse])
async def get_suppliers_by_status(
    status: SupplierStatus,
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Show only active suppliers"),
    service: SupplierService = Depends(get_supplier_service)
):
    """Get suppliers by status."""
    return await service.list_suppliers(
        skip=skip,
        limit=limit,
        status=supplier_status,
        active_only=active_only
    )


# Bulk operations endpoints
@router.post("/bulk/activate", status_code=status.HTTP_204_NO_CONTENT)
async def bulk_activate_suppliers(
    supplier_ids: List[UUID],
    service: SupplierService = Depends(get_supplier_service)
):
    """Bulk activate suppliers."""
    # TODO: Implement bulk activation
    pass


@router.post("/bulk/deactivate", status_code=status.HTTP_204_NO_CONTENT)
async def bulk_deactivate_suppliers(
    supplier_ids: List[UUID],
    service: SupplierService = Depends(get_supplier_service)
):
    """Bulk deactivate suppliers."""
    # TODO: Implement bulk deactivation
    pass


# Export endpoints
@router.get("/export/csv")
async def export_suppliers_csv(
    supplier_type: Optional[SupplierType] = Query(None, description="Filter by supplier type"),
    supplier_status: Optional[SupplierStatus] = Query(None, description="Filter by status"),
    active_only: bool = Query(True, description="Show only active suppliers"),
    service: SupplierService = Depends(get_supplier_service)
):
    """Export suppliers to CSV."""
    # TODO: Implement CSV export
    return {"message": "CSV export not yet implemented"}


@router.get("/export/xlsx")
async def export_suppliers_xlsx(
    supplier_type: Optional[SupplierType] = Query(None, description="Filter by supplier type"),
    supplier_status: Optional[SupplierStatus] = Query(None, description="Filter by status"),
    active_only: bool = Query(True, description="Show only active suppliers"),
    service: SupplierService = Depends(get_supplier_service)
):
    """Export suppliers to Excel."""
    # TODO: Implement Excel export
    return {"message": "Excel export not yet implemented"}


===== modules/suppliers/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional
from datetime import datetime
from pydantic import BaseModel, Field, ConfigDict, validator
from decimal import Decimal
from uuid import UUID

from .models import SupplierType, SupplierTier, SupplierStatus, PaymentTerms


class SupplierCreate(BaseModel):
    """Schema for creating a new supplier."""
    supplier_code: str = Field(..., max_length=50, description="Unique supplier code")
    company_name: str = Field(..., max_length=255, description="Supplier company name")
    supplier_type: SupplierType = Field(..., description="Type of supplier")
    contact_person: Optional[str] = Field(None, max_length=255, description="Primary contact person")
    email: Optional[str] = Field(None, max_length=255, description="Supplier email address")
    phone: Optional[str] = Field(None, max_length=50, description="Supplier phone number")
    mobile: Optional[str] = Field(None, max_length=50, description="Supplier mobile number")
    address_line1: Optional[str] = Field(None, max_length=255, description="Primary address line")
    address_line2: Optional[str] = Field(None, max_length=255, description="Secondary address line")
    city: Optional[str] = Field(None, max_length=100, description="City")
    state: Optional[str] = Field(None, max_length=100, description="State/Province")
    postal_code: Optional[str] = Field(None, max_length=20, description="Postal/ZIP code")
    country: Optional[str] = Field(None, max_length=100, description="Country")
    tax_id: Optional[str] = Field(None, max_length=50, description="Tax identification number")
    payment_terms: PaymentTerms = Field(PaymentTerms.NET30, description="Payment terms")
    credit_limit: Decimal = Field(Decimal("0.00"), ge=0, description="Credit limit amount")
    supplier_tier: SupplierTier = Field(SupplierTier.STANDARD, description="Supplier tier")
    status: SupplierStatus = Field(SupplierStatus.ACTIVE, description="Supplier status")
    notes: Optional[str] = Field(None, description="Additional notes")
    website: Optional[str] = Field(None, max_length=255, description="Supplier website")
    account_manager: Optional[str] = Field(None, max_length=255, description="Account manager name")
    preferred_payment_method: Optional[str] = Field(None, max_length=50, description="Preferred payment method")
    insurance_expiry: Optional[datetime] = Field(None, description="Insurance expiry date")
    certifications: Optional[str] = Field(None, description="Certifications held")
    contract_start_date: Optional[datetime] = Field(None, description="Contract start date")
    contract_end_date: Optional[datetime] = Field(None, description="Contract end date")

    @validator('email')
    def validate_email(cls, v):
        if v and '@' not in v:
            raise ValueError('Invalid email format')
        return v

    @validator('website')
    def validate_website(cls, v):
        if v and not (v.startswith('http://') or v.startswith('https://')):
            return f'https://{v}'
        return v


class SupplierUpdate(BaseModel):
    """Schema for updating a supplier."""
    company_name: Optional[str] = Field(None, max_length=255, description="Supplier company name")
    supplier_type: Optional[SupplierType] = Field(None, description="Type of supplier")
    contact_person: Optional[str] = Field(None, max_length=255, description="Primary contact person")
    email: Optional[str] = Field(None, max_length=255, description="Supplier email address")
    phone: Optional[str] = Field(None, max_length=50, description="Supplier phone number")
    mobile: Optional[str] = Field(None, max_length=50, description="Supplier mobile number")
    address_line1: Optional[str] = Field(None, max_length=255, description="Primary address line")
    address_line2: Optional[str] = Field(None, max_length=255, description="Secondary address line")
    city: Optional[str] = Field(None, max_length=100, description="City")
    state: Optional[str] = Field(None, max_length=100, description="State/Province")
    postal_code: Optional[str] = Field(None, max_length=20, description="Postal/ZIP code")
    country: Optional[str] = Field(None, max_length=100, description="Country")
    tax_id: Optional[str] = Field(None, max_length=50, description="Tax identification number")
    payment_terms: Optional[PaymentTerms] = Field(None, description="Payment terms")
    credit_limit: Optional[Decimal] = Field(None, ge=0, description="Credit limit amount")
    supplier_tier: Optional[SupplierTier] = Field(None, description="Supplier tier")
    status: Optional[SupplierStatus] = Field(None, description="Supplier status")
    notes: Optional[str] = Field(None, description="Additional notes")
    website: Optional[str] = Field(None, max_length=255, description="Supplier website")
    account_manager: Optional[str] = Field(None, max_length=255, description="Account manager name")
    preferred_payment_method: Optional[str] = Field(None, max_length=50, description="Preferred payment method")
    insurance_expiry: Optional[datetime] = Field(None, description="Insurance expiry date")
    certifications: Optional[str] = Field(None, description="Certifications held")
    contract_start_date: Optional[datetime] = Field(None, description="Contract start date")
    contract_end_date: Optional[datetime] = Field(None, description="Contract end date")

    @validator('email')
    def validate_email(cls, v):
        if v and '@' not in v:
            raise ValueError('Invalid email format')
        return v

    @validator('website')
    def validate_website(cls, v):
        if v and not (v.startswith('http://') or v.startswith('https://')):
            return f'https://{v}'
        return v


class SupplierStatusUpdate(BaseModel):
    """Schema for updating supplier status."""
    status: SupplierStatus = Field(..., description="New supplier status")
    notes: Optional[str] = Field(None, description="Status change notes")


class SupplierResponse(BaseModel):
    """Schema for supplier response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    supplier_code: str
    company_name: str
    supplier_type: str
    contact_person: Optional[str]
    email: Optional[str]
    phone: Optional[str]
    mobile: Optional[str]
    address_line1: Optional[str]
    address_line2: Optional[str]
    city: Optional[str]
    state: Optional[str]
    postal_code: Optional[str]
    country: Optional[str]
    tax_id: Optional[str]
    payment_terms: str
    credit_limit: Decimal
    supplier_tier: str
    status: str
    quality_rating: Decimal
    delivery_rating: Decimal
    average_delivery_days: int
    total_orders: int
    total_spend: Decimal
    last_order_date: Optional[datetime]
    notes: Optional[str]
    website: Optional[str]
    account_manager: Optional[str]
    preferred_payment_method: Optional[str]
    insurance_expiry: Optional[datetime]
    certifications: Optional[str]
    contract_start_date: Optional[datetime]
    contract_end_date: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    is_active: bool


class SupplierDetailResponse(SupplierResponse):
    """Schema for detailed supplier response with additional information."""
    full_address: str
    display_name: str
    overall_rating: float
    can_place_order: bool
    is_approved: bool
    is_suspended: bool
    is_blacklisted: bool


class SupplierListResponse(BaseModel):
    """Schema for supplier list response."""
    suppliers: list[SupplierResponse]
    total: int
    page: int
    page_size: int
    total_pages: int


class SupplierStatsResponse(BaseModel):
    """Schema for supplier statistics response."""
    total_suppliers: int
    active_suppliers: int
    inactive_suppliers: int
    inventory_suppliers: int
    service_suppliers: int
    approved_suppliers: int
    pending_suppliers: int
    suspended_suppliers: int
    blacklisted_suppliers: int
    average_quality_rating: float
    average_delivery_rating: float
    suppliers_by_type: dict[str, int]
    suppliers_by_tier: dict[str, int]
    suppliers_by_status: dict[str, int]
    suppliers_by_country: dict[str, int]
    top_suppliers_by_orders: list[dict]
    top_suppliers_by_spend: list[dict]
    contract_expiring_soon: list[dict]
    recent_suppliers: list[SupplierResponse]


class SupplierSearchRequest(BaseModel):
    """Schema for supplier search request."""
    search_term: str = Field(..., min_length=2, max_length=100, description="Search term")
    supplier_type: Optional[SupplierType] = Field(None, description="Filter by supplier type")
    status: Optional[SupplierStatus] = Field(None, description="Filter by status")
    supplier_tier: Optional[SupplierTier] = Field(None, description="Filter by supplier tier")
    payment_terms: Optional[PaymentTerms] = Field(None, description="Filter by payment terms")
    country: Optional[str] = Field(None, max_length=100, description="Filter by country")
    min_quality_rating: Optional[float] = Field(None, ge=0, le=5, description="Minimum quality rating")
    max_quality_rating: Optional[float] = Field(None, ge=0, le=5, description="Maximum quality rating")
    min_delivery_rating: Optional[float] = Field(None, ge=0, le=5, description="Minimum delivery rating")
    max_delivery_rating: Optional[float] = Field(None, ge=0, le=5, description="Maximum delivery rating")
    contract_expiring_days: Optional[int] = Field(None, ge=0, le=365, description="Contract expiring within days")
    active_only: bool = Field(True, description="Show only active suppliers")
    page: int = Field(1, ge=1, description="Page number")
    page_size: int = Field(20, ge=1, le=100, description="Page size")
    sort_by: str = Field("company_name", description="Sort field")
    sort_order: str = Field("asc", pattern="^(asc|desc)$", description="Sort order")


class SupplierPerformanceUpdate(BaseModel):
    """Schema for updating supplier performance metrics."""
    quality_rating: Optional[float] = Field(None, ge=0, le=5, description="Quality rating (0-5)")
    delivery_rating: Optional[float] = Field(None, ge=0, le=5, description="Delivery rating (0-5)")
    average_delivery_days: Optional[int] = Field(None, ge=0, description="Average delivery time in days")
    total_orders: Optional[int] = Field(None, ge=0, description="Total number of orders")
    total_spend: Optional[Decimal] = Field(None, ge=0, description="Total amount spent")
    last_order_date: Optional[datetime] = Field(None, description="Date of last order")
    notes: Optional[str] = Field(None, description="Performance update notes")


class SupplierContactUpdate(BaseModel):
    """Schema for updating supplier contact information."""
    contact_person: Optional[str] = Field(None, max_length=255, description="Primary contact person")
    email: Optional[str] = Field(None, max_length=255, description="Supplier email address")
    phone: Optional[str] = Field(None, max_length=50, description="Supplier phone number")
    mobile: Optional[str] = Field(None, max_length=50, description="Supplier mobile number")
    website: Optional[str] = Field(None, max_length=255, description="Supplier website")
    account_manager: Optional[str] = Field(None, max_length=255, description="Account manager name")
    preferred_payment_method: Optional[str] = Field(None, max_length=50, description="Preferred payment method")
    notes: Optional[str] = Field(None, description="Contact update notes")

    @validator('email')
    def validate_email(cls, v):
        if v and '@' not in v:
            raise ValueError('Invalid email format')
        return v

    @validator('website')
    def validate_website(cls, v):
        if v and not (v.startswith('http://') or v.startswith('https://')):
            return f'https://{v}'
        return v


class SupplierAddressUpdate(BaseModel):
    """Schema for updating supplier address information."""
    address_line1: Optional[str] = Field(None, max_length=255, description="Primary address line")
    address_line2: Optional[str] = Field(None, max_length=255, description="Secondary address line")
    city: Optional[str] = Field(None, max_length=100, description="City")
    state: Optional[str] = Field(None, max_length=100, description="State/Province")
    postal_code: Optional[str] = Field(None, max_length=20, description="Postal/ZIP code")
    country: Optional[str] = Field(None, max_length=100, description="Country")
    notes: Optional[str] = Field(None, description="Address update notes")


class SupplierContractUpdate(BaseModel):
    """Schema for updating supplier contract information."""
    contract_start_date: Optional[datetime] = Field(None, description="Contract start date")
    contract_end_date: Optional[datetime] = Field(None, description="Contract end date")
    payment_terms: Optional[PaymentTerms] = Field(None, description="Payment terms")
    credit_limit: Optional[Decimal] = Field(None, ge=0, description="Credit limit amount")
    supplier_tier: Optional[SupplierTier] = Field(None, description="Supplier tier")
    insurance_expiry: Optional[datetime] = Field(None, description="Insurance expiry date")
    certifications: Optional[str] = Field(None, description="Certifications held")
    notes: Optional[str] = Field(None, description="Contract update notes")

    @validator('contract_end_date')
    def validate_contract_dates(cls, v, values):
        if v and 'contract_start_date' in values and values['contract_start_date'] and v <= values['contract_start_date']:
            raise ValueError('Contract end date must be after start date')
        return v

===== modules/suppliers/service.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession

from .repository import SupplierRepository
from .models import Supplier, SupplierType, SupplierStatus
from .schemas import (
    SupplierCreate, SupplierUpdate, SupplierResponse, SupplierStatusUpdate
)
from app.core.errors import ValidationError, NotFoundError, ConflictError


class SupplierService:
    """Supplier service."""
    
    def __init__(self, session: AsyncSession):
        """Initialize service with database session."""
        self.session = session
        self.repository = SupplierRepository(session)
    
    async def create_supplier(self, supplier_data: SupplierCreate) -> SupplierResponse:
        """Create a new supplier."""
        # Check if supplier code already exists
        existing_supplier = await self.repository.get_by_code(supplier_data.supplier_code)
        if existing_supplier:
            raise ConflictError(f"Supplier with code '{supplier_data.supplier_code}' already exists")
        
        # Create supplier
        supplier_dict = supplier_data.model_dump()
        supplier = await self.repository.create(supplier_dict)
        
        return SupplierResponse.model_validate(supplier)
    
    async def get_supplier(self, supplier_id: UUID) -> Optional[SupplierResponse]:
        """Get supplier by ID."""
        supplier = await self.repository.get_by_id(supplier_id)
        if not supplier:
            return None
        
        return SupplierResponse.model_validate(supplier)
    
    async def get_supplier_by_code(self, supplier_code: str) -> Optional[SupplierResponse]:
        """Get supplier by code."""
        supplier = await self.repository.get_by_code(supplier_code)
        if not supplier:
            return None
        
        return SupplierResponse.model_validate(supplier)
    
    async def update_supplier(self, supplier_id: UUID, update_data: SupplierUpdate) -> SupplierResponse:
        """Update supplier information."""
        supplier = await self.repository.get_by_id(supplier_id)
        if not supplier:
            raise NotFoundError("Supplier not found")
        
        # Update supplier
        update_dict = update_data.model_dump(exclude_unset=True)
        updated_supplier = await self.repository.update(supplier_id, update_dict)
        
        return SupplierResponse.model_validate(updated_supplier)
    
    async def delete_supplier(self, supplier_id: UUID) -> bool:
        """Delete supplier."""
        return await self.repository.delete(supplier_id)
    
    async def list_suppliers(
        self,
        skip: int = 0,
        limit: int = 100,
        supplier_type: Optional[SupplierType] = None,
        status: Optional[SupplierStatus] = None,
        active_only: bool = True
    ) -> List[SupplierResponse]:
        """List suppliers with filtering."""
        suppliers = await self.repository.get_all(
            skip=skip,
            limit=limit,
            supplier_type=supplier_type,
            status=status,
            active_only=active_only
        )
        
        return [SupplierResponse.model_validate(supplier) for supplier in suppliers]
    
    async def search_suppliers(
        self,
        search_term: str,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True
    ) -> List[SupplierResponse]:
        """Search suppliers."""
        suppliers = await self.repository.search(
            search_term=search_term,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
        
        return [SupplierResponse.model_validate(supplier) for supplier in suppliers]
    
    async def count_suppliers(
        self,
        supplier_type: Optional[SupplierType] = None,
        status: Optional[SupplierStatus] = None,
        active_only: bool = True
    ) -> int:
        """Count suppliers with filtering."""
        return await self.repository.count_all(
            supplier_type=supplier_type,
            status=status,
            active_only=active_only
        )
    
    async def update_supplier_status(self, supplier_id: UUID, status_update: SupplierStatusUpdate) -> SupplierResponse:
        """Update supplier status."""
        supplier = await self.repository.get_by_id(supplier_id)
        if not supplier:
            raise NotFoundError("Supplier not found")
        
        update_dict = {
            "status": status_update.status,
            "notes": status_update.notes
        }
        
        updated_supplier = await self.repository.update(supplier_id, update_dict)
        return SupplierResponse.model_validate(updated_supplier)
    
    async def get_supplier_statistics(self) -> Dict[str, Any]:
        """Get supplier statistics."""
        # Get basic counts
        total_suppliers = await self.repository.count_all(active_only=False)
        active_suppliers = await self.repository.count_all(active_only=True)
        
        # Get suppliers by type
        inventory_suppliers = await self.repository.count_all(
            supplier_type=SupplierType.INVENTORY, active_only=True
        )
        service_suppliers = await self.repository.count_all(
            supplier_type=SupplierType.SERVICE, active_only=True
        )
        
        # Get suppliers by status
        approved_suppliers = await self.repository.count_all(
            status=SupplierStatus.APPROVED, active_only=True
        )
        pending_suppliers = await self.repository.count_all(
            status=SupplierStatus.PENDING, active_only=True
        )
        
        # Get recent suppliers
        recent_suppliers = await self.repository.get_all(skip=0, limit=10, active_only=True)
        
        return {
            "total_suppliers": total_suppliers,
            "active_suppliers": active_suppliers,
            "inactive_suppliers": total_suppliers - active_suppliers,
            "inventory_suppliers": inventory_suppliers,
            "service_suppliers": service_suppliers,
            "approved_suppliers": approved_suppliers,
            "pending_suppliers": pending_suppliers,
            "suppliers_by_country": {},
            "suppliers_by_rating": {},
            "top_suppliers_by_orders": [],
            "top_suppliers_by_value": [],
            "recent_suppliers": [SupplierResponse.model_validate(supplier) for supplier in recent_suppliers]
        }

===== modules/auth/__init__.py â€“ 2025-07-19 12:13:41 IST =====


===== modules/auth/dependencies.py â€“ 2025-07-19 12:13:41 IST =====
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional

from app.core.database import get_db
from app.core.security import verify_token
from app.modules.auth.services import AuthService
from app.modules.users.models import User
from app.modules.users.services import UserService


# Security scheme
security = HTTPBearer()


# Authentication dependencies
async def get_auth_service(db: AsyncSession = Depends(get_db)) -> AuthService:
    """Get authentication service"""
    return AuthService(db)


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get current authenticated user"""
    token = credentials.credentials
    token_data = verify_token(token, "access")
    
    user_service = UserService(db)
    user = await user_service.get_by_id(token_data.user_id)
    
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Inactive user",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    return user


async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Get current active user"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    return current_user


async def get_current_superuser(
    current_user: User = Depends(get_current_user)
) -> User:
    """Get current superuser"""
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user


# Optional authentication dependency
async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> Optional[User]:
    """Get current user if authenticated, otherwise None"""
    if credentials is None:
        return None
    
    try:
        token = credentials.credentials
        token_data = verify_token(token, "access")
        
        user_service = UserService(db)
        user = await user_service.get_by_id(token_data.user_id)
        
        if user and user.is_active:
            return user
    except Exception:
        pass
    
    return None

===== modules/auth/models.py â€“ 2025-07-19 12:13:41 IST =====
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean, Text, Index, Table
from sqlalchemy.orm import relationship, Mapped, mapped_column
from sqlalchemy.sql import func
from datetime import datetime
from typing import Optional, List
from enum import Enum

from app.db.base import Base


class RefreshToken(Base):
    """Refresh token model for JWT authentication"""
    __tablename__ = "refresh_tokens"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    token: Mapped[str] = mapped_column(String(500), unique=True, index=True, nullable=False)
    user_id: Mapped[int] = mapped_column(Integer, ForeignKey("users.id"), nullable=False)
    expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    
    # Device/client information
    device_info: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    ip_address: Mapped[Optional[str]] = mapped_column(String(45), nullable=True)  # IPv6 support
    user_agent: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="refresh_tokens")
    
    def __repr__(self):
        return f"<RefreshToken(id={self.id}, user_id={self.user_id}, active={self.is_active})>"


class LoginAttempt(Base):
    """Login attempt tracking for security"""
    __tablename__ = "login_attempts"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    email: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    ip_address: Mapped[str] = mapped_column(String(45), nullable=False)
    user_agent: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    success: Mapped[bool] = mapped_column(Boolean, nullable=False)
    attempted_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=func.now(), 
        nullable=False
    )
    
    # Additional security fields
    failure_reason: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    
    def __repr__(self):
        return f"<LoginAttempt(id={self.id}, email={self.email}, success={self.success})>"


class PasswordResetToken(Base):
    """Password reset token model"""
    __tablename__ = "password_reset_tokens"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    token: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
    user_id: Mapped[int] = mapped_column(Integer, ForeignKey("users.id"), nullable=False)
    expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    is_used: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="password_reset_tokens")
    
    def __repr__(self):
        return f"<PasswordResetToken(id={self.id}, user_id={self.user_id}, used={self.is_used})>"


class UserType(str, Enum):
    """User type enumeration for hierarchy"""
    SUPERADMIN = "SUPERADMIN"
    ADMIN = "ADMIN"
    MANAGER = "MANAGER"
    USER = "USER"
    CUSTOMER = "CUSTOMER"


class PermissionRiskLevel(str, Enum):
    """Permission risk level enumeration"""
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"


# Association tables for many-to-many relationships
role_permissions_table = Table(
    'role_permissions',
    Base.metadata,
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True),
    Column('permission_id', Integer, ForeignKey('permissions.id'), primary_key=True),
    Index('idx_role_permissions_role', 'role_id'),
    Index('idx_role_permissions_permission', 'permission_id'),
)

user_roles_table = Table(
    'user_roles',
    Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True),
    Index('idx_user_roles_user', 'user_id'),
    Index('idx_user_roles_role', 'role_id'),
)

user_permissions_table = Table(
    'user_permissions',
    Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    Column('permission_id', Integer, ForeignKey('permissions.id'), primary_key=True),
    Column('granted_by', Integer, ForeignKey('users.id'), nullable=True),
    Column('granted_at', DateTime, nullable=False, default=func.now()),
    Column('expires_at', DateTime, nullable=True),
    Index('idx_user_permissions_user', 'user_id'),
    Index('idx_user_permissions_permission', 'permission_id'),
)


class Role(Base):
    """Role model for RBAC"""
    __tablename__ = "roles"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    name: Mapped[str] = mapped_column(String(50), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    is_system_role: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    
    # Relationships
    permissions = relationship("Permission", secondary=role_permissions_table, back_populates="roles")
    users = relationship("User", secondary=user_roles_table, back_populates="roles")
    
    def __repr__(self):
        return f"<Role(id={self.id}, name={self.name})>"
    
    def has_permission(self, permission_name: str) -> bool:
        """Check if role has a specific permission"""
        return any(perm.name == permission_name for perm in self.permissions)
    
    def get_permissions(self) -> List[str]:
        """Get all permission names for this role"""
        return [perm.name for perm in self.permissions]


class Permission(Base):
    """Permission model for fine-grained access control"""
    __tablename__ = "permissions"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    resource: Mapped[str] = mapped_column(String(50), nullable=False)
    action: Mapped[str] = mapped_column(String(50), nullable=False)
    risk_level: Mapped[str] = mapped_column(String(20), default=PermissionRiskLevel.LOW.value, nullable=False)
    is_system_permission: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    
    # Relationships
    roles = relationship("Role", secondary=role_permissions_table, back_populates="permissions")
    
    def __repr__(self):
        return f"<Permission(id={self.id}, name={self.name}, resource={self.resource}, action={self.action})>"
    
    def get_risk_level(self) -> PermissionRiskLevel:
        """Get risk level enum"""
        return PermissionRiskLevel(self.risk_level)


===== modules/auth/routes.py â€“ 2025-07-19 12:13:41 IST =====
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db
from app.modules.auth.services import AuthService
from app.modules.auth.schemas import (
    LoginRequest,
    LoginResponse,
    RegisterRequest,
    RegisterResponse,
    RefreshTokenRequest,
    RefreshTokenResponse,
    ChangePasswordRequest,
    ForgotPasswordRequest,
    ResetPasswordRequest,
    LogoutResponse
)
from app.modules.auth.dependencies import get_current_user, get_auth_service
from app.modules.users.models import User
from app.shared.models import BaseResponse


router = APIRouter()


@router.post("/register", response_model=RegisterResponse, status_code=status.HTTP_201_CREATED)
async def register(
    request: RegisterRequest,
    auth_service: AuthService = Depends(get_auth_service)
):
    """Register a new user"""
    user = await auth_service.register(
        username=request.username,
        email=request.email,
        password=request.password,
        full_name=request.full_name
    )
    
    return RegisterResponse(
        id=user.id,
        email=user.email,
        full_name=user.full_name,
        is_active=user.is_active,
        created_at=user.created_at
    )


@router.post("/login", response_model=LoginResponse)
async def login(
    request: LoginRequest,
    http_request: Request,
    auth_service: AuthService = Depends(get_auth_service)
):
    """Login user and return tokens"""
    result = await auth_service.login(
        username_or_email=request.username,
        password=request.password,
        request=http_request
    )
    
    return LoginResponse(**result)


@router.post("/refresh", response_model=RefreshTokenResponse)
async def refresh_token(
    request: RefreshTokenRequest,
    auth_service: AuthService = Depends(get_auth_service)
):
    """Refresh access token using refresh token"""
    result = await auth_service.refresh_token(request.refresh_token)
    
    return RefreshTokenResponse(**result)


@router.post("/logout", response_model=LogoutResponse)
async def logout(
    request: RefreshTokenRequest,
    auth_service: AuthService = Depends(get_auth_service)
):
    """Logout user by invalidating refresh token"""
    await auth_service.logout(request.refresh_token)
    
    return LogoutResponse()


@router.post("/logout-all", response_model=LogoutResponse)
async def logout_all(
    current_user: User = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
):
    """Logout user from all devices"""
    await auth_service.logout_all(current_user.id)
    
    return LogoutResponse(message="Successfully logged out from all devices")


@router.post("/change-password", response_model=BaseResponse)
async def change_password(
    request: ChangePasswordRequest,
    current_user: User = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
):
    """Change user password"""
    await auth_service.change_password(
        user_id=current_user.id,
        current_password=request.current_password,
        new_password=request.new_password
    )
    
    return BaseResponse(message="Password changed successfully")


@router.post("/forgot-password", response_model=BaseResponse)
async def forgot_password(
    request: ForgotPasswordRequest,
    auth_service: AuthService = Depends(get_auth_service)
):
    """Request password reset token"""
    await auth_service.forgot_password(request.email)
    
    return BaseResponse(message="If the email exists, a reset link will be sent")


@router.post("/reset-password", response_model=BaseResponse)
async def reset_password(
    request: ResetPasswordRequest,
    auth_service: AuthService = Depends(get_auth_service)
):
    """Reset password using reset token"""
    await auth_service.reset_password(request.token, request.new_password)
    
    return BaseResponse(message="Password reset successfully")


@router.get("/me", response_model=dict)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current user information"""
    return {
        "id": current_user.id,
        "email": current_user.email,
        "full_name": current_user.full_name,
        "is_active": current_user.is_active,
        "is_superuser": current_user.is_superuser,
        "created_at": current_user.created_at,
        "updated_at": current_user.updated_at,
        "last_login": current_user.last_login
    }

===== modules/auth/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from pydantic import BaseModel, EmailStr, Field, field_validator
from typing import Optional
from datetime import datetime

from app.core.security import Token


class LoginRequest(BaseModel):
    """Login request schema"""
    username: str = Field(..., description="Username or email address")
    password: str = Field(..., min_length=1, description="User password")
    remember_me: bool = Field(default=False, description="Remember user for extended session")
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "username": "admin",
                "password": "your_password",
                "remember_me": False
            }
        }
    }


class LoginResponse(BaseModel):
    """Login response schema"""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int
    user: dict
    
    model_config = {
        "from_attributes": True,
        "json_schema_extra": {
            "example": {
                "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                "token_type": "bearer",
                "expires_in": 1800,
                "user": {
                    "id": 1,
                    "email": "user@example.com",
                    "full_name": "John Doe",
                    "is_active": True
                }
            }
        }
    }


class RegisterRequest(BaseModel):
    """User registration request schema"""
    username: str = Field(..., min_length=3, max_length=50, description="Unique username")
    email: EmailStr = Field(..., description="User email address")
    password: str = Field(..., min_length=8, description="User password")
    full_name: str = Field(..., min_length=1, max_length=255, description="User full name")
    
    @field_validator("password")
    @classmethod
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(c.isupper() for c in v):
            raise ValueError("Password must contain at least one uppercase letter")
        if not any(c.islower() for c in v):
            raise ValueError("Password must contain at least one lowercase letter")
        if not any(c.isdigit() for c in v):
            raise ValueError("Password must contain at least one digit")
        return v
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "username": "johndoe",
                "email": "newuser@example.com",
                "password": "SecurePassword123",
                "full_name": "John Doe"
            }
        }
    }


class RegisterResponse(BaseModel):
    """User registration response schema"""
    id: int
    email: str
    full_name: str
    is_active: bool
    created_at: datetime
    
    model_config = {"from_attributes": True}


class RefreshTokenRequest(BaseModel):
    """Refresh token request schema"""
    refresh_token: str = Field(..., description="Refresh token")
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
            }
        }
    }


class RefreshTokenResponse(BaseModel):
    """Refresh token response schema"""
    access_token: str
    token_type: str = "bearer"
    expires_in: int
    
    model_config = {"from_attributes": True}


class ChangePasswordRequest(BaseModel):
    """Change password request schema"""
    current_password: str = Field(..., description="Current password")
    new_password: str = Field(..., min_length=8, description="New password")
    
    @field_validator("new_password")
    @classmethod
    def validate_new_password(cls, v):
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(c.isupper() for c in v):
            raise ValueError("Password must contain at least one uppercase letter")
        if not any(c.islower() for c in v):
            raise ValueError("Password must contain at least one lowercase letter")
        if not any(c.isdigit() for c in v):
            raise ValueError("Password must contain at least one digit")
        return v
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "current_password": "old_password",
                "new_password": "NewSecurePassword123"
            }
        }
    }


class ForgotPasswordRequest(BaseModel):
    """Forgot password request schema"""
    email: EmailStr = Field(..., description="User email address")
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "email": "user@example.com"
            }
        }
    }


class ResetPasswordRequest(BaseModel):
    """Reset password request schema"""
    token: str = Field(..., description="Password reset token")
    new_password: str = Field(..., min_length=8, description="New password")
    
    @field_validator("new_password")
    @classmethod
    def validate_new_password(cls, v):
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(c.isupper() for c in v):
            raise ValueError("Password must contain at least one uppercase letter")
        if not any(c.islower() for c in v):
            raise ValueError("Password must contain at least one lowercase letter")
        if not any(c.isdigit() for c in v):
            raise ValueError("Password must contain at least one digit")
        return v
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "token": "reset_token_here",
                "new_password": "NewSecurePassword123"
            }
        }
    }


class LogoutResponse(BaseModel):
    """Logout response schema"""
    message: str = "Successfully logged out"
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "message": "Successfully logged out"
            }
        }
    }

===== modules/auth/services.py â€“ 2025-07-19 12:13:41 IST =====
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete, and_
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status, Request
import secrets
import uuid

from app.core.security import (
    verify_password, 
    get_password_hash, 
    create_token_pair,
    verify_token,
    create_access_token
)
from app.core.config import settings
from app.shared.exceptions import (
    InvalidCredentialsError,
    NotFoundError,
    AlreadyExistsError,
    ValidationError
)
from app.modules.auth.models import RefreshToken, LoginAttempt, PasswordResetToken, Role
from app.modules.users.models import User
from app.modules.users.services import UserService


class AuthService:
    """Authentication service"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.user_service = UserService(db)
    
    async def register(self, username: str, email: str, password: str, full_name: str) -> User:
        """Register a new user"""
        # Check if user already exists
        existing_user = await self.user_service.get_by_email(email)
        if existing_user:
            raise AlreadyExistsError("User", "email", email)
        
        # Check if username already exists
        existing_username = await self.user_service.get_by_username(username)
        if existing_username:
            raise AlreadyExistsError("User", "username", username)
        
        # Validate password
        if len(password) < settings.PASSWORD_MIN_LENGTH:
            raise ValidationError(f"Password must be at least {settings.PASSWORD_MIN_LENGTH} characters long")
        
        # Create user
        user_data = {
            "username": username,
            "email": email,
            "password": password,  # UserService will hash this
            "full_name": full_name,
            "is_active": True
        }
        
        user = await self.user_service.create(user_data)
        return user
    
    async def login(self, username_or_email: str, password: str, request: Request = None) -> Dict[str, Any]:
        """Authenticate user and return tokens"""
        # Get client info
        ip_address = request.client.host if request else None
        user_agent = request.headers.get("user-agent") if request else None
        
        # Get user by username or email with roles and permissions
        user = await self._get_user_with_permissions(username_or_email)
        
        if not user:
            # Log failed login attempt
            await self._log_login_attempt(
                email=username_or_email,
                ip_address=ip_address,
                user_agent=user_agent,
                success=False,
                failure_reason="User not found"
            )
            raise InvalidCredentialsError("Invalid username/email or password")
        
        if not user.is_active:
            # Log failed login attempt
            await self._log_login_attempt(
                email=username_or_email,
                ip_address=ip_address,
                user_agent=user_agent,
                success=False,
                failure_reason="Account disabled"
            )
            raise InvalidCredentialsError("Account is disabled")
        
        # Verify password
        if not verify_password(password, user.password):
            # Log failed login attempt
            await self._log_login_attempt(
                email=username_or_email,
                ip_address=ip_address,
                user_agent=user_agent,
                success=False,
                failure_reason="Invalid password"
            )
            raise InvalidCredentialsError("Invalid username/email or password")
        
        # Create tokens
        tokens = create_token_pair(
            user_id=user.id,
            username=user.username,  # Use username instead of email
            scopes=["read", "write"] if user.is_active else ["read"]
        )
        
        # Store refresh token
        await self._store_refresh_token(
            user_id=user.id,
            token=tokens.refresh_token,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        # Log successful login attempt
        await self._log_login_attempt(
            email=username_or_email,
            ip_address=ip_address,
            user_agent=user_agent,
            success=True
        )
        
        # Update last login
        await self.user_service.update_last_login(user.id)
        
        # Build comprehensive user response
        user_response = self._build_user_response(user)
        
        return {
            "access_token": tokens.access_token,
            "refresh_token": tokens.refresh_token,
            "token_type": tokens.token_type,
            "expires_in": settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
            "expiresIn": settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,  # camelCase for frontend
            "user": user_response
        }
    
    async def refresh_token(self, refresh_token: str) -> Dict[str, Any]:
        """Refresh access token using refresh token"""
        # Verify refresh token
        token_data = verify_token(refresh_token, "refresh")
        
        # Check if refresh token exists in database
        stmt = select(RefreshToken).where(
            and_(
                RefreshToken.token == refresh_token,
                RefreshToken.is_active == True,
                RefreshToken.expires_at > datetime.utcnow()
            )
        )
        result = await self.db.execute(stmt)
        stored_token = result.scalar_one_or_none()
        
        if not stored_token:
            raise InvalidCredentialsError("Invalid refresh token")
        
        # Get user
        user = await self.user_service.get_by_id(token_data.user_id)
        if not user or not user.is_active:
            raise InvalidCredentialsError("User not found or inactive")
        
        # Create new access token
        access_token = create_access_token({
            "sub": user.email,
            "user_id": user.id,
            "scopes": ["read", "write"] if user.is_active else ["read"]
        })
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "expires_in": settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
        }
    
    async def logout(self, refresh_token: str) -> None:
        """Logout user by invalidating refresh token"""
        stmt = select(RefreshToken).where(RefreshToken.token == refresh_token)
        result = await self.db.execute(stmt)
        stored_token = result.scalar_one_or_none()
        
        if stored_token:
            stored_token.is_active = False
            await self.db.commit()
    
    async def logout_all(self, user_id: int) -> None:
        """Logout user from all devices"""
        stmt = (
            select(RefreshToken)
            .where(RefreshToken.user_id == user_id)
            .where(RefreshToken.is_active == True)
        )
        result = await self.db.execute(stmt)
        tokens = result.scalars().all()
        
        for token in tokens:
            token.is_active = False
        
        await self.db.commit()
    
    async def change_password(self, user_id: int, current_password: str, new_password: str) -> None:
        """Change user password"""
        user = await self.user_service.get_by_id(user_id)
        if not user:
            raise NotFoundError("User", user_id)
        
        # Verify current password
        if not verify_password(current_password, user.password):
            raise InvalidCredentialsError("Current password is incorrect")
        
        # Validate new password
        if len(new_password) < settings.PASSWORD_MIN_LENGTH:
            raise ValidationError(f"Password must be at least {settings.PASSWORD_MIN_LENGTH} characters long")
        
        # Update password
        user.password = get_password_hash(new_password)
        await self.db.commit()
        
        # Logout from all devices for security
        await self.logout_all(user_id)
    
    async def forgot_password(self, email: str) -> str:
        """Generate password reset token"""
        user = await self.user_service.get_by_email(email)
        if not user:
            # Don't reveal if email exists
            return "If the email exists, a reset link will be sent"
        
        # Generate reset token
        reset_token = secrets.token_urlsafe(32)
        expires_at = datetime.utcnow() + timedelta(hours=1)  # 1 hour expiry
        
        # Store reset token
        password_reset = PasswordResetToken(
            token=reset_token,
            user_id=user.id,
            expires_at=expires_at
        )
        
        self.db.add(password_reset)
        await self.db.commit()
        
        # In production, send email here
        return reset_token
    
    async def reset_password(self, token: str, new_password: str) -> None:
        """Reset password using reset token"""
        # Find valid reset token
        stmt = select(PasswordResetToken).where(
            and_(
                PasswordResetToken.token == token,
                PasswordResetToken.is_used == False,
                PasswordResetToken.expires_at > datetime.utcnow()
            )
        )
        result = await self.db.execute(stmt)
        reset_token = result.scalar_one_or_none()
        
        if not reset_token:
            raise InvalidCredentialsError("Invalid or expired reset token")
        
        # Get user
        user = await self.user_service.get_by_id(reset_token.user_id)
        if not user:
            raise NotFoundError("User", reset_token.user_id)
        
        # Validate new password
        if len(new_password) < settings.PASSWORD_MIN_LENGTH:
            raise ValidationError(f"Password must be at least {settings.PASSWORD_MIN_LENGTH} characters long")
        
        # Update password
        user.password = get_password_hash(new_password)
        reset_token.is_used = True
        
        await self.db.commit()
        
        # Logout from all devices for security
        await self.logout_all(user.id)
    
    async def _store_refresh_token(
        self, 
        user_id: int, 
        token: str, 
        ip_address: str = None,
        user_agent: str = None
    ) -> None:
        """Store refresh token in database"""
        expires_at = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
        
        refresh_token = RefreshToken(
            token=token,
            user_id=user_id,
            expires_at=expires_at,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        self.db.add(refresh_token)
        await self.db.commit()
    
    async def _log_login_attempt(
        self,
        email: str,
        ip_address: str = None,
        user_agent: str = None,
        success: bool = False,
        failure_reason: str = None
    ) -> None:
        """Log login attempt for security tracking"""
        login_attempt = LoginAttempt(
            email=email,
            ip_address=ip_address or "unknown",
            user_agent=user_agent,
            success=success,
            failure_reason=failure_reason
        )
        
        self.db.add(login_attempt)
        await self.db.commit()
    
    async def cleanup_expired_tokens(self) -> None:
        """Clean up expired refresh tokens and reset tokens"""
        now = datetime.utcnow()
        
        # Delete expired refresh tokens
        await self.db.execute(
            delete(RefreshToken).where(RefreshToken.expires_at < now)
        )
        
        # Delete expired reset tokens
        await self.db.execute(
            delete(PasswordResetToken).where(PasswordResetToken.expires_at < now)
        )
        
        await self.db.commit()
    
    async def _get_user_with_permissions(self, username_or_email: str) -> Optional[User]:
        """Get user with roles and permissions loaded"""
        # Check if it's email or username
        if "@" in username_or_email:
            stmt = select(User).where(User.email == username_or_email)
        else:
            stmt = select(User).where(User.username == username_or_email)
        
        # Load roles and permissions
        stmt = stmt.options(
            selectinload(User.roles).selectinload(Role.permissions),
            selectinload(User.direct_permissions)
        )
        
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    def _build_user_response(self, user: User) -> Dict[str, Any]:
        """Build comprehensive user response with RBAC data"""
        # Get effective permissions
        effective_permissions = user.get_effective_permissions()
        
        # Build user response matching frontend expectations
        user_response = {
            "id": str(user.id),  # Convert to string for consistency
            "email": user.email,
            "username": user.username,
            "firstName": user.firstName,
            "lastName": user.lastName,
            "name": user.name,
            "full_name": user.full_name,  # Keep both for compatibility
            "userType": user.user_type,
            "locationId": None,  # Set if user has location
            "isActive": user.is_active,
            "is_active": user.is_active,  # Keep both for compatibility
            "isSuperuser": user.is_superuser,
            "is_superuser": user.is_superuser,  # Keep both for compatibility
            "lastLogin": user.last_login.isoformat() if user.last_login else None,
            "createdAt": user.created_at.isoformat() if hasattr(user, 'created_at') and user.created_at else None,
            "updatedAt": user.updated_at.isoformat() if hasattr(user, 'updated_at') and user.updated_at else None,
            "directPermissions": effective_permissions["directPermissions"],
            "effectivePermissions": effective_permissions,
            "effective_permissions": effective_permissions,  # Snake_case fallback
        }
        
        # Add role information if available
        if user.roles:
            user_response["role"] = {
                "id": user.roles[0].id,
                "name": user.roles[0].name,
                "description": user.roles[0].description
            }
        
        return user_response

===== modules/system/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""System module for system management and configuration."""

from .models import (
    SystemSetting,
    SystemBackup,
    AuditLog,
    SettingType,
    SettingCategory,
    BackupStatus,
    BackupType,
    AuditAction,
)

__all__ = [
    "SystemSetting",
    "SystemBackup",
    "AuditLog",
    "SettingType",
    "SettingCategory",
    "BackupStatus",
    "BackupType",
    "AuditAction",
]

===== modules/system/models.py â€“ 2025-07-19 12:13:41 IST =====
from enum import Enum
from typing import Optional, Dict, Any, List
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy import Column, String, Numeric, Boolean, Text, DateTime, ForeignKey, Index, JSON
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property

from app.db.base import BaseModel, UUIDType


class SettingType(str, Enum):
    """Setting type enumeration."""
    STRING = "STRING"
    INTEGER = "INTEGER"
    DECIMAL = "DECIMAL"
    BOOLEAN = "BOOLEAN"
    JSON = "JSON"
    DATE = "DATE"
    DATETIME = "DATETIME"


class SettingCategory(str, Enum):
    """Setting category enumeration."""
    GENERAL = "GENERAL"
    BUSINESS = "BUSINESS"
    FINANCIAL = "FINANCIAL"
    INVENTORY = "INVENTORY"
    RENTAL = "RENTAL"
    NOTIFICATION = "NOTIFICATION"
    SECURITY = "SECURITY"
    INTEGRATION = "INTEGRATION"
    REPORTING = "REPORTING"
    SYSTEM = "SYSTEM"


class BackupStatus(str, Enum):
    """Backup status enumeration."""
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


class BackupType(str, Enum):
    """Backup type enumeration."""
    FULL = "FULL"
    INCREMENTAL = "INCREMENTAL"
    DIFFERENTIAL = "DIFFERENTIAL"


class AuditAction(str, Enum):
    """Audit action enumeration."""
    CREATE = "CREATE"
    READ = "READ"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    LOGIN = "LOGIN"
    LOGOUT = "LOGOUT"
    EXPORT = "EXPORT"
    IMPORT = "IMPORT"
    BACKUP = "BACKUP"
    RESTORE = "RESTORE"


class SystemSetting(BaseModel):
    """
    System setting model for application configuration.
    
    Attributes:
        setting_key: Unique setting key
        setting_name: Human-readable setting name
        setting_type: Type of setting (STRING, INTEGER, etc.)
        setting_category: Category of setting (GENERAL, BUSINESS, etc.)
        setting_value: Current value of the setting
        default_value: Default value of the setting
        description: Description of the setting
        is_system: Whether this is a system setting (read-only)
        is_sensitive: Whether this setting contains sensitive data
        validation_rules: JSON validation rules for the setting
        display_order: Order for displaying settings
    """
    
    __tablename__ = "system_settings"
    
    setting_key = Column(String(100), nullable=False, unique=True, index=True, comment="Unique setting key")
    setting_name = Column(String(200), nullable=False, comment="Human-readable setting name")
    setting_type = Column(String(20), nullable=False, comment="Type of setting")
    setting_category = Column(String(20), nullable=False, comment="Category of setting")
    setting_value = Column(Text, nullable=True, comment="Current value of the setting")
    default_value = Column(Text, nullable=True, comment="Default value of the setting")
    description = Column(Text, nullable=True, comment="Description of the setting")
    is_system = Column(Boolean, nullable=False, default=False, comment="System setting flag")
    is_sensitive = Column(Boolean, nullable=False, default=False, comment="Sensitive data flag")
    validation_rules = Column(JSON, nullable=True, comment="JSON validation rules")
    display_order = Column(String(10), nullable=False, default="0", comment="Display order")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_system_setting_key', 'setting_key'),
        Index('idx_system_setting_category', 'setting_category'),
        Index('idx_system_setting_type', 'setting_type'),
        Index('idx_system_setting_system', 'is_system'),
        Index('idx_system_setting_display_order', 'display_order'),
# Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        setting_key: str,
        setting_name: str,
        setting_type: SettingType,
        setting_category: SettingCategory,
        setting_value: Optional[str] = None,
        default_value: Optional[str] = None,
        description: Optional[str] = None,
        is_system: bool = False,
        is_sensitive: bool = False,
        validation_rules: Optional[Dict[str, Any]] = None,
        display_order: str = "0",
        **kwargs
    ):
        """
        Initialize a System Setting.
        
        Args:
            setting_key: Unique setting key
            setting_name: Human-readable setting name
            setting_type: Type of setting
            setting_category: Category of setting
            setting_value: Current value of the setting
            default_value: Default value of the setting
            description: Description of the setting
            is_system: Whether this is a system setting
            is_sensitive: Whether this setting contains sensitive data
            validation_rules: JSON validation rules
            display_order: Display order
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.setting_key = setting_key
        self.setting_name = setting_name
        self.setting_type = setting_type.value if isinstance(setting_type, SettingType) else setting_type
        self.setting_category = setting_category.value if isinstance(setting_category, SettingCategory) else setting_category
        self.setting_value = setting_value
        self.default_value = default_value
        self.description = description
        self.is_system = is_system
        self.is_sensitive = is_sensitive
        self.validation_rules = validation_rules or {}
        self.display_order = display_order
        self._validate()
    
    def _validate(self):
        """Validate system setting business rules."""
        if not self.setting_key or not self.setting_key.strip():
            raise ValueError("Setting key cannot be empty")
        
        if len(self.setting_key) > 100:
            raise ValueError("Setting key cannot exceed 100 characters")
        
        if not self.setting_name or not self.setting_name.strip():
            raise ValueError("Setting name cannot be empty")
        
        if len(self.setting_name) > 200:
            raise ValueError("Setting name cannot exceed 200 characters")
        
        if self.setting_type not in [st.value for st in SettingType]:
            raise ValueError(f"Invalid setting type: {self.setting_type}")
        
        if self.setting_category not in [sc.value for sc in SettingCategory]:
            raise ValueError(f"Invalid setting category: {self.setting_category}")
        
        # Validate display order is numeric
        try:
            int(self.display_order)
        except ValueError:
            raise ValueError("Display order must be a valid number")
    
    def get_typed_value(self):
        """Get the setting value converted to its proper type."""
        if self.setting_value is None:
            return None
        
        if self.setting_type == SettingType.STRING.value:
            return str(self.setting_value)
        elif self.setting_type == SettingType.INTEGER.value:
            return int(self.setting_value)
        elif self.setting_type == SettingType.DECIMAL.value:
            return Decimal(self.setting_value)
        elif self.setting_type == SettingType.BOOLEAN.value:
            return str(self.setting_value).lower() in ('true', '1', 'yes', 'on')
        elif self.setting_type == SettingType.JSON.value:
            import json
            return json.loads(self.setting_value)
        elif self.setting_type == SettingType.DATE.value:
            return datetime.strptime(self.setting_value, '%Y-%m-%d').date()
        elif self.setting_type == SettingType.DATETIME.value:
            return datetime.fromisoformat(self.setting_value)
        else:
            return self.setting_value
    
    def set_typed_value(self, value):
        """Set the setting value from a typed value."""
        if value is None:
            self.setting_value = None
            return
        
        if self.setting_type == SettingType.STRING.value:
            self.setting_value = str(value)
        elif self.setting_type == SettingType.INTEGER.value:
            self.setting_value = str(int(value))
        elif self.setting_type == SettingType.DECIMAL.value:
            self.setting_value = str(Decimal(value))
        elif self.setting_type == SettingType.BOOLEAN.value:
            self.setting_value = str(bool(value)).lower()
        elif self.setting_type == SettingType.JSON.value:
            import json
            self.setting_value = json.dumps(value)
        elif self.setting_type == SettingType.DATE.value:
            if isinstance(value, date):
                self.setting_value = value.strftime('%Y-%m-%d')
            else:
                self.setting_value = str(value)
        elif self.setting_type == SettingType.DATETIME.value:
            if isinstance(value, datetime):
                self.setting_value = value.isoformat()
            else:
                self.setting_value = str(value)
        else:
            self.setting_value = str(value)
    
    def reset_to_default(self):
        """Reset setting to default value."""
        self.setting_value = self.default_value
    
    def is_default(self) -> bool:
        """Check if setting is at default value."""
        return self.setting_value == self.default_value
    
    def can_modify(self) -> bool:
        """Check if setting can be modified."""
        return not self.is_system and self.is_active
    
    @property
    def display_name(self) -> str:
        """Get setting display name."""
        return self.setting_name
    
    @property
    def masked_value(self) -> str:
        """Get masked value for sensitive settings."""
        if self.is_sensitive and self.setting_value:
            return "***MASKED***"
        return self.setting_value or ""
    
    def __str__(self) -> str:
        """String representation of system setting."""
        return f"{self.setting_name} ({self.setting_key})"
    
    def __repr__(self) -> str:
        """Developer representation of system setting."""
        return (
            f"SystemSetting(id={self.id}, key='{self.setting_key}', "
            f"name='{self.setting_name}', type='{self.setting_type}', "
            f"category='{self.setting_category}', active={self.is_active})"
        )


class SystemBackup(BaseModel):
    """
    System backup model for database and file backups.
    
    Attributes:
        backup_name: Name of the backup
        backup_type: Type of backup (FULL, INCREMENTAL, DIFFERENTIAL)
        backup_status: Current status of the backup
        backup_path: Path to the backup file
        backup_size: Size of the backup file in bytes
        started_by: User who started the backup
        started_at: When the backup was started
        completed_at: When the backup was completed
        error_message: Error message if backup failed
        retention_days: Number of days to retain the backup
        description: Description of the backup
        backup_metadata: Additional metadata about the backup
    """
    
    __tablename__ = "system_backups"
    
    backup_name = Column(String(200), nullable=False, comment="Name of the backup")
    backup_type = Column(String(20), nullable=False, comment="Type of backup")
    backup_status = Column(String(20), nullable=False, default=BackupStatus.PENDING.value, comment="Current status")
    backup_path = Column(String(500), nullable=True, comment="Path to the backup file")
    backup_size = Column(String(20), nullable=True, comment="Size of the backup file")
    started_by = Column(UUIDType(), nullable=False, comment="User who started the backup")
    started_at = Column(DateTime, nullable=False, default=datetime.utcnow, comment="When backup was started")
    completed_at = Column(DateTime, nullable=True, comment="When backup was completed")
    error_message = Column(Text, nullable=True, comment="Error message if backup failed")
    retention_days = Column(String(10), nullable=False, default="30", comment="Days to retain backup")
    description = Column(Text, nullable=True, comment="Description of the backup")
    backup_metadata = Column(JSON, nullable=True, comment="Additional metadata about the backup")
    
    # Relationships
    # started_by_user = relationship("User", back_populates="started_backups", lazy="select")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_system_backup_name', 'backup_name'),
        Index('idx_system_backup_type', 'backup_type'),
        Index('idx_system_backup_status', 'backup_status'),
        Index('idx_system_backup_started_by', 'started_by'),
        Index('idx_system_backup_started_at', 'started_at'),
        Index('idx_system_backup_completed_at', 'completed_at'),
# Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        backup_name: str,
        backup_type: BackupType,
        started_by: str,
        description: Optional[str] = None,
        retention_days: str = "30",
        **kwargs
    ):
        """
        Initialize a System Backup.
        
        Args:
            backup_name: Name of the backup
            backup_type: Type of backup
            started_by: User who started the backup
            description: Description of the backup
            retention_days: Days to retain backup
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.backup_name = backup_name
        self.backup_type = backup_type.value if isinstance(backup_type, BackupType) else backup_type
        self.started_by = started_by
        self.description = description
        self.retention_days = retention_days
        self.started_at = datetime.utcnow()
        self.backup_status = BackupStatus.PENDING.value
        self._validate()
    
    def _validate(self):
        """Validate system backup business rules."""
        if not self.backup_name or not self.backup_name.strip():
            raise ValueError("Backup name cannot be empty")
        
        if len(self.backup_name) > 200:
            raise ValueError("Backup name cannot exceed 200 characters")
        
        if self.backup_type not in [bt.value for bt in BackupType]:
            raise ValueError(f"Invalid backup type: {self.backup_type}")
        
        # Validate retention days is numeric
        try:
            days = int(self.retention_days)
            if days < 1:
                raise ValueError("Retention days must be at least 1")
        except ValueError:
            raise ValueError("Retention days must be a valid positive number")
    
    def start_backup(self):
        """Start the backup process."""
        self.backup_status = BackupStatus.RUNNING.value
        self.started_at = datetime.utcnow()
    
    def complete_backup(self, backup_path: str, backup_size: int):
        """Complete the backup process."""
        self.backup_status = BackupStatus.COMPLETED.value
        self.completed_at = datetime.utcnow()
        self.backup_path = backup_path
        self.backup_size = str(backup_size)
        self.error_message = None
    
    def fail_backup(self, error_message: str):
        """Fail the backup process."""
        self.backup_status = BackupStatus.FAILED.value
        self.completed_at = datetime.utcnow()
        self.error_message = error_message
    
    def cancel_backup(self):
        """Cancel the backup process."""
        self.backup_status = BackupStatus.CANCELLED.value
        self.completed_at = datetime.utcnow()
    
    def is_completed(self) -> bool:
        """Check if backup is completed."""
        return self.backup_status == BackupStatus.COMPLETED.value
    
    def is_running(self) -> bool:
        """Check if backup is running."""
        return self.backup_status == BackupStatus.RUNNING.value
    
    def is_failed(self) -> bool:
        """Check if backup failed."""
        return self.backup_status == BackupStatus.FAILED.value
    
    def is_expired(self) -> bool:
        """Check if backup is expired based on retention policy."""
        if not self.completed_at:
            return False
        
        try:
            retention_days = int(self.retention_days)
            expiry_date = self.completed_at + timedelta(days=retention_days)
            return datetime.utcnow() > expiry_date
        except ValueError:
            return False
    
    @property
    def display_name(self) -> str:
        """Get backup display name."""
        return f"{self.backup_name} ({self.backup_type})"
    
    @property
    def backup_size_mb(self) -> Optional[float]:
        """Get backup size in MB."""
        if self.backup_size:
            try:
                return float(self.backup_size) / (1024 * 1024)
            except ValueError:
                return None
        return None
    
    @property
    def duration_minutes(self) -> Optional[int]:
        """Get backup duration in minutes."""
        if self.started_at and self.completed_at:
            return int((self.completed_at - self.started_at).total_seconds() / 60)
        return None
    
    def __str__(self) -> str:
        """String representation of system backup."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of system backup."""
        return (
            f"SystemBackup(id={self.id}, name='{self.backup_name}', "
            f"type='{self.backup_type}', status='{self.backup_status}', "
            f"active={self.is_active})"
        )


class AuditLog(BaseModel):
    """
    Audit log model for tracking system activities.
    
    Attributes:
        user_id: User who performed the action
        action: Action performed
        entity_type: Type of entity affected
        entity_id: ID of the entity affected
        old_values: Old values before the action
        new_values: New values after the action
        ip_address: IP address of the user
        user_agent: User agent string
        session_id: Session ID
        success: Whether the action was successful
        error_message: Error message if action failed
        audit_metadata: Additional metadata about the action
    """
    
    __tablename__ = "audit_logs"
    
    user_id = Column(UUIDType(), nullable=True, comment="User who performed the action")
    action = Column(String(50), nullable=False, comment="Action performed")
    entity_type = Column(String(100), nullable=True, comment="Type of entity affected")
    entity_id = Column(UUIDType(), nullable=True, comment="ID of the entity affected")
    old_values = Column(JSON, nullable=True, comment="Old values before the action")
    new_values = Column(JSON, nullable=True, comment="New values after the action")
    ip_address = Column(String(45), nullable=True, comment="IP address of the user")
    user_agent = Column(Text, nullable=True, comment="User agent string")
    session_id = Column(String(100), nullable=True, comment="Session ID")
    success = Column(Boolean, nullable=False, default=True, comment="Whether action was successful")
    error_message = Column(Text, nullable=True, comment="Error message if action failed")
    audit_metadata = Column(JSON, nullable=True, comment="Additional metadata about the action")
    
    # Relationships
    # user = relationship("User", back_populates="audit_logs", lazy="select")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_audit_log_user_id', 'user_id'),
        Index('idx_audit_log_action', 'action'),
        Index('idx_audit_log_entity_type', 'entity_type'),
        Index('idx_audit_log_entity_id', 'entity_id'),
        Index('idx_audit_log_created_at', 'created_at'),
        Index('idx_audit_log_success', 'success'),
        Index('idx_audit_log_ip_address', 'ip_address'),
        Index('idx_audit_log_session_id', 'session_id'),
# Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        action: AuditAction,
        user_id: Optional[str] = None,
        entity_type: Optional[str] = None,
        entity_id: Optional[str] = None,
        old_values: Optional[Dict[str, Any]] = None,
        new_values: Optional[Dict[str, Any]] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        session_id: Optional[str] = None,
        success: bool = True,
        error_message: Optional[str] = None,
        audit_metadata: Optional[Dict[str, Any]] = None,
        **kwargs
    ):
        """
        Initialize an Audit Log.
        
        Args:
            action: Action performed
            user_id: User who performed the action
            entity_type: Type of entity affected
            entity_id: ID of the entity affected
            old_values: Old values before the action
            new_values: New values after the action
            ip_address: IP address of the user
            user_agent: User agent string
            session_id: Session ID
            success: Whether the action was successful
            error_message: Error message if action failed
            audit_metadata: Additional metadata about the action
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.action = action.value if isinstance(action, AuditAction) else action
        self.user_id = user_id
        self.entity_type = entity_type
        self.entity_id = entity_id
        self.old_values = old_values or {}
        self.new_values = new_values or {}
        self.ip_address = ip_address
        self.user_agent = user_agent
        self.session_id = session_id
        self.success = success
        self.error_message = error_message
        self.audit_metadata = audit_metadata or {}
        self._validate()
    
    def _validate(self):
        """Validate audit log business rules."""
        if not self.action or not self.action.strip():
            raise ValueError("Action cannot be empty")
        
        if len(self.action) > 50:
            raise ValueError("Action cannot exceed 50 characters")
        
        if self.entity_type and len(self.entity_type) > 100:
            raise ValueError("Entity type cannot exceed 100 characters")
        
        if self.ip_address and len(self.ip_address) > 45:
            raise ValueError("IP address cannot exceed 45 characters")
        
        if self.session_id and len(self.session_id) > 100:
            raise ValueError("Session ID cannot exceed 100 characters")
    
    def is_successful(self) -> bool:
        """Check if action was successful."""
        return self.success
    
    def has_changes(self) -> bool:
        """Check if there are any changes recorded."""
        return bool(self.old_values or self.new_values)
    
    def get_changes(self) -> Dict[str, Any]:
        """Get the changes made."""
        changes = {}
        
        if self.old_values and self.new_values:
            for key in set(self.old_values.keys()) | set(self.new_values.keys()):
                old_value = self.old_values.get(key)
                new_value = self.new_values.get(key)
                
                if old_value != new_value:
                    changes[key] = {
                        'old': old_value,
                        'new': new_value
                    }
        
        return changes
    
    @property
    def display_name(self) -> str:
        """Get audit log display name."""
        entity_info = ""
        if self.entity_type and self.entity_id:
            entity_info = f" on {self.entity_type} {self.entity_id}"
        
        return f"{self.action}{entity_info}"
    
    @property
    def status_display(self) -> str:
        """Get status display."""
        return "SUCCESS" if self.success else "FAILED"
    
    def __str__(self) -> str:
        """String representation of audit log."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of audit log."""
        return (
            f"AuditLog(id={self.id}, action='{self.action}', "
            f"user_id={self.user_id}, entity_type='{self.entity_type}', "
            f"success={self.success}, active={self.is_active})"
        )


# Additional imports for datetime operations
from datetime import timedelta

===== modules/system/routes.py â€“ 2025-07-20 02:34:16 IST =====
from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel, Field

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.shared.dependencies import get_session
from app.modules.system.service import SystemService
from app.modules.system.models import (
    SettingType, SettingCategory, BackupStatus, BackupType, AuditAction
)
from app.modules.system.whitelist_routes import router as whitelist_router

router = APIRouter(tags=["System Management"])

# Currency Configuration Schemas
class CurrencyConfig(BaseModel):
    """Schema for currency configuration."""
    currency_code: str = Field(..., min_length=3, max_length=3, description="ISO 4217 currency code")
    symbol: str = Field(..., description="Currency symbol")
    description: str = Field(..., description="Currency description")
    is_default: bool = Field(default=True, description="Is this the default currency")

class CurrencyUpdateRequest(BaseModel):
    """Schema for updating currency configuration."""
    currency_code: str = Field(..., min_length=3, max_length=3, description="ISO 4217 currency code")
    description: Optional[str] = Field(None, description="Currency description")

class SupportedCurrency(BaseModel):
    """Schema for supported currencies."""
    code: str = Field(..., description="Currency code")
    name: str = Field(..., description="Currency name")
    symbol: str = Field(..., description="Currency symbol")

# In-memory currency configuration (in production, this would be in database)
current_currency = CurrencyConfig(
    currency_code="INR",
    symbol="â‚¹",
    description="Indian Rupee",
    is_default=True
)

# Supported currencies
SUPPORTED_CURRENCIES = [
    SupportedCurrency(code="INR", name="Indian Rupee", symbol="â‚¹"),
    SupportedCurrency(code="USD", name="US Dollar", symbol="$"),
    SupportedCurrency(code="EUR", name="Euro", symbol="â‚¬"),
    SupportedCurrency(code="GBP", name="British Pound", symbol="Â£"),
    SupportedCurrency(code="JPY", name="Japanese Yen", symbol="Â¥"),
    SupportedCurrency(code="CAD", name="Canadian Dollar", symbol="C$"),
    SupportedCurrency(code="AUD", name="Australian Dollar", symbol="A$"),
    SupportedCurrency(code="CNY", name="Chinese Yuan", symbol="Â¥"),
    SupportedCurrency(code="CHF", name="Swiss Franc", symbol="CHF"),
    SupportedCurrency(code="SGD", name="Singapore Dollar", symbol="S$"),
]

# Response models
class SystemSettingResponse(BaseModel):
    """Response model for system settings."""
    id: UUID
    setting_key: str
    setting_name: str
    setting_type: SettingType
    setting_category: SettingCategory
    setting_value: Optional[str]
    default_value: Optional[str]
    description: Optional[str]
    is_system: bool
    is_sensitive: bool
    validation_rules: Optional[Dict[str, Any]]
    display_order: str
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class SystemBackupResponse(BaseModel):
    """Response model for system backups."""
    id: UUID
    backup_name: str
    backup_type: BackupType
    backup_status: BackupStatus
    backup_path: Optional[str]
    backup_size: Optional[str]
    started_by: UUID
    started_at: datetime
    completed_at: Optional[datetime]
    error_message: Optional[str]
    retention_days: str
    description: Optional[str]
    backup_metadata: Optional[Dict[str, Any]]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class AuditLogResponse(BaseModel):
    """Response model for audit logs."""
    id: UUID
    user_id: Optional[UUID]
    action: str
    entity_type: Optional[str]
    entity_id: Optional[str]
    old_values: Optional[Dict[str, Any]]
    new_values: Optional[Dict[str, Any]]
    ip_address: Optional[str]
    user_agent: Optional[str]
    session_id: Optional[str]
    success: bool
    error_message: Optional[str]
    audit_metadata: Optional[Dict[str, Any]]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

# Request models
class SystemSettingCreateRequest(BaseModel):
    """Request model for creating system settings."""
    setting_key: str
    setting_name: str
    setting_type: SettingType
    setting_category: SettingCategory
    setting_value: Optional[str] = None
    default_value: Optional[str] = None
    description: Optional[str] = None
    is_system: bool = False
    is_sensitive: bool = False
    validation_rules: Optional[Dict[str, Any]] = None
    display_order: str = "0"

class SystemSettingUpdateRequest(BaseModel):
    """Request model for updating system settings."""
    setting_value: Any

class SystemBackupCreateRequest(BaseModel):
    """Request model for creating system backups."""
    backup_name: str
    backup_type: BackupType
    description: Optional[str] = None
    retention_days: str = "30"

class SystemInfoResponse(BaseModel):
    """Response model for system information."""
    system_name: str
    system_version: str
    company_name: str
    timezone: str
    settings_count: int
    backups_count: int
    recent_activity_count: int
    last_backup: Optional[Dict[str, Any]]
    system_health: Dict[str, Any]

# Dependency to get system service
async def get_system_service(session: AsyncSession = Depends(get_session)) -> SystemService:
    return SystemService(session)

# System Settings endpoints
@router.get("/settings", response_model=List[SystemSettingResponse])
async def get_settings(
    category: Optional[SettingCategory] = Query(None, description="Filter by category"),
    include_system: bool = Query(True, description="Include system settings"),
    service: SystemService = Depends(get_system_service)
):
    """Get all system settings."""
    try:
        if category:
            settings = await service.get_settings_by_category(category)
        else:
            settings = await service.get_all_settings(include_system)
        
        return [SystemSettingResponse.model_validate(setting) for setting in settings]
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.get("/settings/{setting_key}", response_model=SystemSettingResponse)
async def get_setting(
    setting_key: str,
    service: SystemService = Depends(get_system_service)
):
    """Get system setting by key."""
    try:
        setting = await service.get_setting(setting_key)
        if not setting:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Setting '{setting_key}' not found")
        
        return SystemSettingResponse.model_validate(setting)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.get("/settings/{setting_key}/value")
async def get_setting_value(
    setting_key: str,
    service: SystemService = Depends(get_system_service)
):
    """Get system setting value by key."""
    try:
        value = await service.get_setting_value(setting_key)
        if value is None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Setting '{setting_key}' not found")
        
        return {"setting_key": setting_key, "value": value}
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.post("/settings", response_model=SystemSettingResponse, status_code=status.HTTP_201_CREATED)
async def create_setting(
    setting_data: SystemSettingCreateRequest,
    service: SystemService = Depends(get_system_service)
):
    """Create a new system setting."""
    try:
        setting = await service.create_setting(
            setting_key=setting_data.setting_key,
            setting_name=setting_data.setting_name,
            setting_type=setting_data.setting_type,
            setting_category=setting_data.setting_category,
            setting_value=setting_data.setting_value,
            default_value=setting_data.default_value,
            description=setting_data.description,
            is_system=setting_data.is_system,
            is_sensitive=setting_data.is_sensitive,
            validation_rules=setting_data.validation_rules,
            display_order=setting_data.display_order
        )
        
        return SystemSettingResponse.model_validate(setting)
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

@router.put("/settings/{setting_key}", response_model=SystemSettingResponse)
async def update_setting(
    setting_key: str,
    setting_data: SystemSettingUpdateRequest,
    updated_by: UUID = Query(..., description="User ID updating the setting"),
    service: SystemService = Depends(get_system_service)
):
    """Update a system setting value."""
    try:
        setting = await service.update_setting(setting_key, setting_data.setting_value, updated_by)
        return SystemSettingResponse.model_validate(setting)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

@router.post("/settings/{setting_key}/reset", response_model=SystemSettingResponse)
async def reset_setting(
    setting_key: str,
    updated_by: UUID = Query(..., description="User ID resetting the setting"),
    service: SystemService = Depends(get_system_service)
):
    """Reset a system setting to its default value."""
    try:
        setting = await service.reset_setting(setting_key, updated_by)
        return SystemSettingResponse.model_validate(setting)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

@router.delete("/settings/{setting_key}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_setting(
    setting_key: str,
    deleted_by: UUID = Query(..., description="User ID deleting the setting"),
    service: SystemService = Depends(get_system_service)
):
    """Delete a system setting."""
    try:
        success = await service.delete_setting(setting_key, deleted_by)
        if not success:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Setting '{setting_key}' not found")
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

@router.post("/settings/initialize", response_model=List[SystemSettingResponse])
async def initialize_default_settings(
    service: SystemService = Depends(get_system_service)
):
    """Initialize default system settings."""
    try:
        settings = await service.initialize_default_settings()
        return [SystemSettingResponse.model_validate(setting) for setting in settings]
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

# System Backup endpoints
@router.post("/backups", response_model=SystemBackupResponse, status_code=status.HTTP_201_CREATED)
async def create_backup(
    backup_data: SystemBackupCreateRequest,
    started_by: UUID = Query(..., description="User ID starting the backup"),
    service: SystemService = Depends(get_system_service)
):
    """Create a new system backup."""
    try:
        backup = await service.create_backup(
            backup_name=backup_data.backup_name,
            backup_type=backup_data.backup_type,
            started_by=started_by,
            description=backup_data.description,
            retention_days=backup_data.retention_days
        )
        
        return SystemBackupResponse.model_validate(backup)
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

@router.get("/backups", response_model=List[SystemBackupResponse])
async def get_backups(
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    backup_type: Optional[BackupType] = Query(None, description="Filter by backup type"),
    backup_status: Optional[BackupStatus] = Query(None, description="Filter by backup status"),
    started_by: Optional[UUID] = Query(None, description="Filter by starter"),
    service: SystemService = Depends(get_system_service)
):
    """Get all system backups with optional filtering."""
    try:
        backups = await service.get_backups(
            skip=skip,
            limit=limit,
            backup_type=backup_type,
            backup_status=backup_status,
            started_by=started_by
        )
        
        return [SystemBackupResponse.model_validate(backup) for backup in backups]
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.get("/backups/{backup_id}", response_model=SystemBackupResponse)
async def get_backup(
    backup_id: UUID,
    service: SystemService = Depends(get_system_service)
):
    """Get system backup by ID."""
    try:
        backup = await service.get_backup(backup_id)
        if not backup:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Backup with ID {backup_id} not found")
        
        return SystemBackupResponse.model_validate(backup)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.post("/backups/{backup_id}/start", response_model=SystemBackupResponse)
async def start_backup(
    backup_id: UUID,
    service: SystemService = Depends(get_system_service)
):
    """Start a backup process."""
    try:
        backup = await service.start_backup(backup_id)
        return SystemBackupResponse.model_validate(backup)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

@router.post("/backups/{backup_id}/complete", response_model=SystemBackupResponse)
async def complete_backup(
    backup_id: UUID,
    backup_path: str = Query(..., description="Path to the backup file"),
    backup_size: int = Query(..., description="Size of the backup file in bytes"),
    service: SystemService = Depends(get_system_service)
):
    """Complete a backup process."""
    try:
        backup = await service.complete_backup(backup_id, backup_path, backup_size)
        return SystemBackupResponse.model_validate(backup)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

@router.post("/backups/{backup_id}/fail", response_model=SystemBackupResponse)
async def fail_backup(
    backup_id: UUID,
    error_message: str = Query(..., description="Error message"),
    service: SystemService = Depends(get_system_service)
):
    """Fail a backup process."""
    try:
        backup = await service.fail_backup(backup_id, error_message)
        return SystemBackupResponse.model_validate(backup)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

@router.post("/backups/{backup_id}/cancel", response_model=SystemBackupResponse)
async def cancel_backup(
    backup_id: UUID,
    service: SystemService = Depends(get_system_service)
):
    """Cancel a backup process."""
    try:
        backup = await service.cancel_backup(backup_id)
        return SystemBackupResponse.model_validate(backup)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

@router.delete("/backups/{backup_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_backup(
    backup_id: UUID,
    deleted_by: UUID = Query(..., description="User ID deleting the backup"),
    service: SystemService = Depends(get_system_service)
):
    """Delete a system backup."""
    try:
        success = await service.delete_backup(backup_id, deleted_by)
        if not success:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Backup with ID {backup_id} not found")
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

@router.post("/backups/cleanup-expired")
async def cleanup_expired_backups(
    service: SystemService = Depends(get_system_service)
):
    """Clean up expired backups."""
    try:
        cleaned_count = await service.cleanup_expired_backups()
        return {"message": f"Cleaned up {cleaned_count} expired backups"}
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

# Audit Log endpoints
@router.get("/audit-logs", response_model=List[AuditLogResponse])
async def get_audit_logs(
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    user_id: Optional[UUID] = Query(None, description="Filter by user ID"),
    action: Optional[str] = Query(None, description="Filter by action"),
    entity_type: Optional[str] = Query(None, description="Filter by entity type"),
    entity_id: Optional[str] = Query(None, description="Filter by entity ID"),
    success: Optional[bool] = Query(None, description="Filter by success status"),
    start_date: Optional[datetime] = Query(None, description="Filter by start date"),
    end_date: Optional[datetime] = Query(None, description="Filter by end date"),
    service: SystemService = Depends(get_system_service)
):
    """Get audit logs with optional filtering."""
    try:
        # Convert action string to enum if provided
        action_enum = None
        if action:
            try:
                action_enum = AuditAction(action)
            except ValueError:
                raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Invalid action: {action}")
        
        logs = await service.get_audit_logs(
            skip=skip,
            limit=limit,
            user_id=user_id,
            action=action_enum,
            entity_type=entity_type,
            entity_id=entity_id,
            success=success,
            start_date=start_date,
            end_date=end_date
        )
        
        return [AuditLogResponse.model_validate(log) for log in logs]
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.get("/audit-logs/{audit_log_id}", response_model=AuditLogResponse)
async def get_audit_log(
    audit_log_id: UUID,
    service: SystemService = Depends(get_system_service)
):
    """Get audit log by ID."""
    try:
        log = await service.get_audit_log(audit_log_id)
        if not log:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Audit log with ID {audit_log_id} not found")
        
        return AuditLogResponse.model_validate(log)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.post("/audit-logs/cleanup")
async def cleanup_old_audit_logs(
    retention_days: int = Query(90, ge=1, description="Days to retain audit logs"),
    service: SystemService = Depends(get_system_service)
):
    """Clean up old audit logs."""
    try:
        cleaned_count = await service.cleanup_old_audit_logs(retention_days)
        return {"message": f"Cleaned up {cleaned_count} old audit logs"}
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

# System Information and Maintenance endpoints
@router.get("/info", response_model=SystemInfoResponse)
async def get_system_info(
    service: SystemService = Depends(get_system_service)
):
    """Get system information."""
    try:
        info = await service.get_system_info()
        return SystemInfoResponse.model_validate(info)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.post("/maintenance")
async def perform_maintenance(
    user_id: UUID = Query(..., description="User ID performing maintenance"),
    service: SystemService = Depends(get_system_service)
):
    """Perform system maintenance tasks."""
    try:
        results = await service.perform_system_maintenance(user_id)
        return {"message": "System maintenance completed", "results": results}
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

# Settings by category endpoints
@router.get("/settings/categories/{category}", response_model=List[SystemSettingResponse])
async def get_settings_by_category(
    category: SettingCategory,
    service: SystemService = Depends(get_system_service)
):
    """Get settings by category."""
    try:
        settings = await service.get_settings_by_category(category)
        return [SystemSettingResponse.model_validate(setting) for setting in settings]
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

# Backup type specific endpoints
@router.get("/backups/types/{backup_type}", response_model=List[SystemBackupResponse])
async def get_backups_by_type(
    backup_type: BackupType,
    limit: int = Query(10, ge=1, le=100, description="Maximum records to return"),
    service: SystemService = Depends(get_system_service)
):
    """Get backups by type."""
    try:
        backups = await service.get_backups(
            backup_type=backup_type,
            limit=limit
        )
        return [SystemBackupResponse.model_validate(backup) for backup in backups]
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.get("/backups/status/{backup_status}", response_model=List[SystemBackupResponse])
async def get_backups_by_status(
    backup_status: BackupStatus,
    limit: int = Query(10, ge=1, le=100, description="Maximum records to return"),
    service: SystemService = Depends(get_system_service)
):
    """Get backups by status."""
    try:
        backups = await service.get_backups(
            backup_status=backup_status,
            limit=limit
        )
        return [SystemBackupResponse.model_validate(backup) for backup in backups]
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

# Include whitelist management routes
router.include_router(whitelist_router, prefix="/whitelist", tags=["Whitelist Management"])

===== modules/system/service.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from datetime import datetime, date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, and_, or_, func

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.system.models import (
    SystemSetting, SystemBackup, AuditLog,
    SettingType, SettingCategory, BackupStatus, BackupType, AuditAction
)


class SystemService:
    """Service for system management operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    # System Settings operations
    async def get_setting(self, setting_key: str) -> Optional[SystemSetting]:
        """Get system setting by key."""
        query = select(SystemSetting).where(
            and_(
                SystemSetting.setting_key == setting_key,
                SystemSetting.is_active == True
            )
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_setting_value(self, setting_key: str, default_value: Any = None):
        """Get system setting value by key."""
        setting = await self.get_setting(setting_key)
        if setting:
            return setting.get_typed_value()
        
        # If setting doesn't exist and it's a company-related setting, try to create it
        if setting_key.startswith("company_"):
            try:
                await self._create_missing_company_setting(setting_key)
                # Try to get the setting again after creation
                setting = await self.get_setting(setting_key)
                if setting:
                    return setting.get_typed_value()
            except Exception as e:
                # Log the error but continue with default value
                import logging
                logger = logging.getLogger(__name__)
                logger.warning(f"Failed to create missing company setting {setting_key}: {str(e)}")
        
        return default_value
    
    async def get_settings_by_category(self, category: SettingCategory) -> List[SystemSetting]:
        """Get all settings in a category."""
        query = select(SystemSetting).where(
            and_(
                SystemSetting.setting_category == category.value,
                SystemSetting.is_active == True
            )
        ).order_by(SystemSetting.display_order, SystemSetting.setting_name)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_all_settings(self, include_system: bool = True) -> List[SystemSetting]:
        """Get all system settings."""
        query = select(SystemSetting).where(SystemSetting.is_active == True)
        
        if not include_system:
            query = query.where(SystemSetting.is_system == False)
        
        query = query.order_by(
            SystemSetting.setting_category,
            SystemSetting.display_order,
            SystemSetting.setting_name
        )
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def create_setting(
        self,
        setting_key: str,
        setting_name: str,
        setting_type: SettingType,
        setting_category: SettingCategory,
        setting_value: Optional[str] = None,
        default_value: Optional[str] = None,
        description: Optional[str] = None,
        is_system: bool = False,
        is_sensitive: bool = False,
        validation_rules: Optional[Dict[str, Any]] = None,
        display_order: str = "0"
    ) -> SystemSetting:
        """Create a new system setting."""
        # Check if setting already exists
        existing_setting = await self.get_setting(setting_key)
        if existing_setting:
            raise ConflictError(f"Setting with key '{setting_key}' already exists")
        
        setting = SystemSetting(
            setting_key=setting_key,
            setting_name=setting_name,
            setting_type=setting_type,
            setting_category=setting_category,
            setting_value=setting_value,
            default_value=default_value,
            description=description,
            is_system=is_system,
            is_sensitive=is_sensitive,
            validation_rules=validation_rules,
            display_order=display_order
        )
        
        self.session.add(setting)
        await self.session.commit()
        await self.session.refresh(setting)
        
        return setting
    
    async def update_setting(
        self,
        setting_key: str,
        setting_value: Any,
        updated_by: Optional[UUID] = None
    ) -> SystemSetting:
        """Update a system setting value."""
        setting = await self.get_setting(setting_key)
        if not setting:
            raise NotFoundError(f"Setting with key '{setting_key}' not found")
        
        if not setting.can_modify():
            raise ValidationError(f"Setting '{setting_key}' cannot be modified")
        
        # Store old value for audit
        old_value = setting.setting_value
        
        # Update the setting
        setting.set_typed_value(setting_value)
        setting.updated_by = str(updated_by) if updated_by else None
        
        await self.session.commit()
        await self.session.refresh(setting)
        
        # Create audit log
        if updated_by:
            await self.create_audit_log(
                user_id=updated_by,
                action=AuditAction.UPDATE,
                entity_type="SystemSetting",
                entity_id=str(setting.id),
                old_values={"setting_value": old_value},
                new_values={"setting_value": setting.setting_value}
            )
        
        return setting
    
    async def reset_setting(self, setting_key: str, updated_by: Optional[UUID] = None) -> SystemSetting:
        """Reset a system setting to its default value."""
        setting = await self.get_setting(setting_key)
        if not setting:
            raise NotFoundError(f"Setting with key '{setting_key}' not found")
        
        if not setting.can_modify():
            raise ValidationError(f"Setting '{setting_key}' cannot be modified")
        
        # Store old value for audit
        old_value = setting.setting_value
        
        # Reset to default
        setting.reset_to_default()
        setting.updated_by = str(updated_by) if updated_by else None
        
        await self.session.commit()
        await self.session.refresh(setting)
        
        # Create audit log
        if updated_by:
            await self.create_audit_log(
                user_id=updated_by,
                action=AuditAction.UPDATE,
                entity_type="SystemSetting",
                entity_id=str(setting.id),
                old_values={"setting_value": old_value},
                new_values={"setting_value": setting.setting_value}
            )
        
        return setting
    
    async def delete_setting(self, setting_key: str, deleted_by: Optional[UUID] = None) -> bool:
        """Delete a system setting."""
        setting = await self.get_setting(setting_key)
        if not setting:
            raise NotFoundError(f"Setting with key '{setting_key}' not found")
        
        if setting.is_system:
            raise ValidationError(f"System setting '{setting_key}' cannot be deleted")
        
        # Soft delete
        setting.is_active = False
        setting.updated_by = str(deleted_by) if deleted_by else None
        
        await self.session.commit()
        
        # Create audit log
        if deleted_by:
            await self.create_audit_log(
                user_id=deleted_by,
                action=AuditAction.DELETE,
                entity_type="SystemSetting",
                entity_id=str(setting.id)
            )
        
        return True
    
    async def initialize_default_settings(self) -> List[SystemSetting]:
        """Initialize default system settings."""
        default_settings = [
            # General settings
            {
                "setting_key": "app_name",
                "setting_name": "Application Name",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.GENERAL,
                "setting_value": "Rental Management System",
                "default_value": "Rental Management System",
                "description": "Name of the application",
                "is_system": True,
                "display_order": "1"
            },
            {
                "setting_key": "app_version",
                "setting_name": "Application Version",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.GENERAL,
                "setting_value": "2.0.0",
                "default_value": "2.0.0",
                "description": "Version of the application",
                "is_system": True,
                "display_order": "2"
            },
            {
                "setting_key": "company_name",
                "setting_name": "Company Name",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "Your Company",
                "default_value": "Your Company",
                "description": "Name of the company using the system",
                "display_order": "1"
            },
            {
                "setting_key": "company_address",
                "setting_name": "Company Address",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company address",
                "display_order": "2"
            },
            {
                "setting_key": "company_email",
                "setting_name": "Company Email",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company email address",
                "display_order": "3"
            },
            {
                "setting_key": "company_phone",
                "setting_name": "Company Phone",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company phone number",
                "display_order": "4"
            },
            {
                "setting_key": "company_gst_no",
                "setting_name": "Company GST Number",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company GST registration number",
                "display_order": "5"
            },
            {
                "setting_key": "company_registration_number",
                "setting_name": "Company Registration Number",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company registration number",
                "display_order": "6"
            },
            {
                "setting_key": "timezone",
                "setting_name": "System Timezone",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.GENERAL,
                "setting_value": "UTC",
                "default_value": "UTC",
                "description": "System timezone",
                "display_order": "4"
            },
            
            # Business settings
            {
                "setting_key": "default_currency",
                "setting_name": "Default Currency",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "USD",
                "default_value": "USD",
                "description": "Default currency for transactions",
                "display_order": "7"
            },
            {
                "setting_key": "business_hours_start",
                "setting_name": "Business Hours Start",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "09:00",
                "default_value": "09:00",
                "description": "Business hours start time",
                "display_order": "8"
            },
            {
                "setting_key": "business_hours_end",
                "setting_name": "Business Hours End",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "17:00",
                "default_value": "17:00",
                "description": "Business hours end time",
                "display_order": "9"
            },
            
            # Financial settings
            {
                "setting_key": "tax_rate",
                "setting_name": "Default Tax Rate",
                "setting_type": SettingType.DECIMAL,
                "setting_category": SettingCategory.FINANCIAL,
                "setting_value": "0.08",
                "default_value": "0.08",
                "description": "Default tax rate (8%)",
                "display_order": "1"
            },
            {
                "setting_key": "late_fee_rate",
                "setting_name": "Late Fee Rate",
                "setting_type": SettingType.DECIMAL,
                "setting_category": SettingCategory.FINANCIAL,
                "setting_value": "0.10",
                "default_value": "0.10",
                "description": "Late fee rate (10%)",
                "display_order": "2"
            },
            {
                "setting_key": "daily_late_fee",
                "setting_name": "Daily Late Fee",
                "setting_type": SettingType.DECIMAL,
                "setting_category": SettingCategory.FINANCIAL,
                "setting_value": "10.00",
                "default_value": "10.00",
                "description": "Daily late fee amount",
                "display_order": "3"
            },
            
            # Rental settings
            {
                "setting_key": "minimum_rental_days",
                "setting_name": "Minimum Rental Days",
                "setting_type": SettingType.INTEGER,
                "setting_category": SettingCategory.RENTAL,
                "setting_value": "1",
                "default_value": "1",
                "description": "Minimum rental period in days",
                "display_order": "1"
            },
            {
                "setting_key": "maximum_rental_days",
                "setting_name": "Maximum Rental Days",
                "setting_type": SettingType.INTEGER,
                "setting_category": SettingCategory.RENTAL,
                "setting_value": "365",
                "default_value": "365",
                "description": "Maximum rental period in days",
                "display_order": "2"
            },
            {
                "setting_key": "default_security_deposit",
                "setting_name": "Default Security Deposit",
                "setting_type": SettingType.DECIMAL,
                "setting_category": SettingCategory.RENTAL,
                "setting_value": "100.00",
                "default_value": "100.00",
                "description": "Default security deposit amount",
                "display_order": "3"
            },
            
            # System settings
            {
                "setting_key": "auto_backup_enabled",
                "setting_name": "Auto Backup Enabled",
                "setting_type": SettingType.BOOLEAN,
                "setting_category": SettingCategory.SYSTEM,
                "setting_value": "true",
                "default_value": "true",
                "description": "Enable automatic backups",
                "display_order": "1"
            },
            {
                "setting_key": "backup_retention_days",
                "setting_name": "Backup Retention Days",
                "setting_type": SettingType.INTEGER,
                "setting_category": SettingCategory.SYSTEM,
                "setting_value": "30",
                "default_value": "30",
                "description": "Number of days to retain backups",
                "display_order": "2"
            },
            {
                "setting_key": "audit_log_retention_days",
                "setting_name": "Audit Log Retention Days",
                "setting_type": SettingType.INTEGER,
                "setting_category": SettingCategory.SYSTEM,
                "setting_value": "90",
                "default_value": "90",
                "description": "Number of days to retain audit logs",
                "display_order": "3"
            },
            
            # Task Scheduling settings
            {
                "setting_key": "rental_status_check_enabled",
                "setting_name": "Rental Status Check Enabled",
                "setting_type": SettingType.BOOLEAN,
                "setting_category": SettingCategory.SYSTEM,
                "setting_value": "true",
                "default_value": "true",
                "description": "Enable automated rental status checking",
                "is_system": True,
                "display_order": "4"
            },
            {
                "setting_key": "rental_status_check_time",
                "setting_name": "Rental Status Check Time",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.SYSTEM,
                "setting_value": "00:00",
                "default_value": "00:00",
                "description": "Time to run daily rental status check (HH:MM format)",
                "is_system": True,
                "display_order": "5"
            },
            {
                "setting_key": "rental_status_log_retention_days",
                "setting_name": "Rental Status Log Retention Days",
                "setting_type": SettingType.INTEGER,
                "setting_category": SettingCategory.SYSTEM,
                "setting_value": "365",
                "default_value": "365",
                "description": "Number of days to retain rental status change logs",
                "is_system": True,
                "display_order": "6"
            },
            {
                "setting_key": "task_scheduler_timezone",
                "setting_name": "Task Scheduler Timezone",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.SYSTEM,
                "setting_value": "UTC",
                "default_value": "UTC",
                "description": "Timezone for scheduled tasks",
                "is_system": True,
                "display_order": "7"
            }
        ]
        
        created_settings = []
        for setting_data in default_settings:
            existing_setting = await self.get_setting(setting_data["setting_key"])
            if not existing_setting:
                setting = await self.create_setting(**setting_data)
                created_settings.append(setting)
        
        return created_settings
    
    # System Backup operations
    async def create_backup(
        self,
        backup_name: str,
        backup_type: BackupType,
        started_by: UUID,
        description: Optional[str] = None,
        retention_days: str = "30"
    ) -> SystemBackup:
        """Create a new system backup."""
        backup = SystemBackup(
            backup_name=backup_name,
            backup_type=backup_type,
            started_by=str(started_by),
            description=description,
            retention_days=retention_days
        )
        
        self.session.add(backup)
        await self.session.commit()
        await self.session.refresh(backup)
        
        # Create audit log
        await self.create_audit_log(
            user_id=started_by,
            action=AuditAction.BACKUP,
            entity_type="SystemBackup",
            entity_id=str(backup.id),
            new_values={
                "backup_name": backup_name,
                "backup_type": backup_type.value,
                "status": backup.backup_status
            }
        )
        
        return backup
    
    async def get_backup(self, backup_id: UUID) -> Optional[SystemBackup]:
        """Get system backup by ID."""
        query = select(SystemBackup).where(
            and_(
                SystemBackup.id == backup_id,
                SystemBackup.is_active == True
            )
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_backups(
        self,
        skip: int = 0,
        limit: int = 100,
        backup_type: Optional[BackupType] = None,
        backup_status: Optional[BackupStatus] = None,
        started_by: Optional[UUID] = None
    ) -> List[SystemBackup]:
        """Get all system backups with optional filtering."""
        query = select(SystemBackup).where(SystemBackup.is_active == True)
        
        if backup_type:
            query = query.where(SystemBackup.backup_type == backup_type.value)
        if backup_status:
            query = query.where(SystemBackup.backup_status == backup_status.value)
        if started_by:
            query = query.where(SystemBackup.started_by == str(started_by))
        
        query = query.order_by(SystemBackup.started_at.desc()).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def start_backup(self, backup_id: UUID) -> SystemBackup:
        """Start a backup process."""
        backup = await self.get_backup(backup_id)
        if not backup:
            raise NotFoundError(f"Backup with ID {backup_id} not found")
        
        backup.start_backup()
        await self.session.commit()
        await self.session.refresh(backup)
        
        return backup
    
    async def complete_backup(self, backup_id: UUID, backup_path: str, backup_size: int) -> SystemBackup:
        """Complete a backup process."""
        backup = await self.get_backup(backup_id)
        if not backup:
            raise NotFoundError(f"Backup with ID {backup_id} not found")
        
        backup.complete_backup(backup_path, backup_size)
        await self.session.commit()
        await self.session.refresh(backup)
        
        return backup
    
    async def fail_backup(self, backup_id: UUID, error_message: str) -> SystemBackup:
        """Fail a backup process."""
        backup = await self.get_backup(backup_id)
        if not backup:
            raise NotFoundError(f"Backup with ID {backup_id} not found")
        
        backup.fail_backup(error_message)
        await self.session.commit()
        await self.session.refresh(backup)
        
        return backup
    
    async def cancel_backup(self, backup_id: UUID) -> SystemBackup:
        """Cancel a backup process."""
        backup = await self.get_backup(backup_id)
        if not backup:
            raise NotFoundError(f"Backup with ID {backup_id} not found")
        
        backup.cancel_backup()
        await self.session.commit()
        await self.session.refresh(backup)
        
        return backup
    
    async def delete_backup(self, backup_id: UUID, deleted_by: Optional[UUID] = None) -> bool:
        """Delete a system backup."""
        backup = await self.get_backup(backup_id)
        if not backup:
            raise NotFoundError(f"Backup with ID {backup_id} not found")
        
        # Soft delete
        backup.is_active = False
        backup.updated_by = str(deleted_by) if deleted_by else None
        
        await self.session.commit()
        
        # Create audit log
        if deleted_by:
            await self.create_audit_log(
                user_id=deleted_by,
                action=AuditAction.DELETE,
                entity_type="SystemBackup",
                entity_id=str(backup.id)
            )
        
        return True
    
    async def cleanup_expired_backups(self) -> int:
        """Clean up expired backups."""
        query = select(SystemBackup).where(
            and_(
                SystemBackup.is_active == True,
                SystemBackup.backup_status == BackupStatus.COMPLETED.value
            )
        )
        result = await self.session.execute(query)
        backups = result.scalars().all()
        
        expired_count = 0
        for backup in backups:
            if backup.is_expired():
                backup.is_active = False
                expired_count += 1
        
        await self.session.commit()
        return expired_count
    
    # Audit Log operations
    async def create_audit_log(
        self,
        action: AuditAction,
        user_id: Optional[UUID] = None,
        entity_type: Optional[str] = None,
        entity_id: Optional[str] = None,
        old_values: Optional[Dict[str, Any]] = None,
        new_values: Optional[Dict[str, Any]] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        session_id: Optional[str] = None,
        success: bool = True,
        error_message: Optional[str] = None,
        audit_metadata: Optional[Dict[str, Any]] = None
    ) -> AuditLog:
        """Create an audit log entry."""
        audit_log = AuditLog(
            action=action,
            user_id=str(user_id) if user_id else None,
            entity_type=entity_type,
            entity_id=entity_id,
            old_values=old_values,
            new_values=new_values,
            ip_address=ip_address,
            user_agent=user_agent,
            session_id=session_id,
            success=success,
            error_message=error_message,
            audit_metadata=audit_metadata
        )
        
        self.session.add(audit_log)
        await self.session.commit()
        await self.session.refresh(audit_log)
        
        return audit_log
    
    async def get_audit_logs(
        self,
        skip: int = 0,
        limit: int = 100,
        user_id: Optional[UUID] = None,
        action: Optional[AuditAction] = None,
        entity_type: Optional[str] = None,
        entity_id: Optional[str] = None,
        success: Optional[bool] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> List[AuditLog]:
        """Get audit logs with optional filtering."""
        query = select(AuditLog).where(AuditLog.is_active == True)
        
        if user_id:
            query = query.where(AuditLog.user_id == str(user_id))
        if action:
            query = query.where(AuditLog.action == action.value)
        if entity_type:
            query = query.where(AuditLog.entity_type == entity_type)
        if entity_id:
            query = query.where(AuditLog.entity_id == entity_id)
        if success is not None:
            query = query.where(AuditLog.success == success)
        if start_date:
            query = query.where(AuditLog.created_at >= start_date)
        if end_date:
            query = query.where(AuditLog.created_at <= end_date)
        
        query = query.order_by(AuditLog.created_at.desc()).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_audit_log(self, audit_log_id: UUID) -> Optional[AuditLog]:
        """Get audit log by ID."""
        query = select(AuditLog).where(
            and_(
                AuditLog.id == audit_log_id,
                AuditLog.is_active == True
            )
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def cleanup_old_audit_logs(self, retention_days: int = 90) -> int:
        """Clean up old audit logs."""
        cutoff_date = datetime.utcnow() - timedelta(days=retention_days)
        
        query = select(AuditLog).where(
            and_(
                AuditLog.created_at < cutoff_date,
                AuditLog.is_active == True
            )
        )
        result = await self.session.execute(query)
        old_logs = result.scalars().all()
        
        cleanup_count = 0
        for log in old_logs:
            log.is_active = False
            cleanup_count += 1
        
        await self.session.commit()
        return cleanup_count
    
    # System maintenance operations
    async def perform_system_maintenance(self, user_id: UUID) -> Dict[str, Any]:
        """Perform system maintenance tasks."""
        maintenance_results = {}
        
        # Cleanup expired backups
        expired_backups = await self.cleanup_expired_backups()
        maintenance_results['expired_backups_cleaned'] = expired_backups
        
        # Cleanup old audit logs
        retention_days = await self.get_setting_value('audit_log_retention_days', 90)
        old_logs = await self.cleanup_old_audit_logs(int(retention_days))
        maintenance_results['old_audit_logs_cleaned'] = old_logs
        
        # Create audit log for maintenance
        await self.create_audit_log(
            user_id=user_id,
            action=AuditAction.UPDATE,
            entity_type="SystemMaintenance",
            audit_metadata={
                'maintenance_type': 'automated_cleanup',
                'results': maintenance_results
            }
        )
        
        return maintenance_results
    
    async def get_system_info(self) -> Dict[str, Any]:
        """Get system information."""
        # Get database size and counts
        settings_count = len(await self.get_all_settings())
        backups_count = len(await self.get_backups(limit=1000))
        
        # Get recent activity
        recent_logs = await self.get_audit_logs(limit=10)
        
        return {
            'system_name': await self.get_setting_value('app_name', 'Rental Management System'),
            'system_version': await self.get_setting_value('app_version', '2.0.0'),
            'company_name': await self.get_setting_value('company_name', 'Your Company'),
            'timezone': await self.get_setting_value('timezone', 'UTC'),
            'settings_count': settings_count,
            'backups_count': backups_count,
            'recent_activity_count': len(recent_logs),
            'last_backup': await self._get_last_backup_info(),
            'system_health': await self._get_system_health()
        }
    
    async def _get_last_backup_info(self) -> Optional[Dict[str, Any]]:
        """Get last backup information."""
        backups = await self.get_backups(limit=1)
        if backups:
            backup = backups[0]
            return {
                'backup_name': backup.backup_name,
                'backup_type': backup.backup_type,
                'backup_status': backup.backup_status,
                'started_at': backup.started_at.isoformat(),
                'completed_at': backup.completed_at.isoformat() if backup.completed_at else None
            }
        return None
    
    async def _create_missing_company_setting(self, setting_key: str) -> None:
        """Create a missing company-related system setting with appropriate defaults."""
        company_setting_configs = {
            "company_name": {
                "setting_name": "Company Name",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "Your Company",
                "default_value": "Your Company",
                "description": "Name of the company using the system",
                "display_order": "1"
            },
            "company_address": {
                "setting_name": "Company Address",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company address",
                "display_order": "2"
            },
            "company_email": {
                "setting_name": "Company Email",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company email address",
                "display_order": "3"
            },
            "company_phone": {
                "setting_name": "Company Phone",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company phone number",
                "display_order": "4"
            },
            "company_gst_no": {
                "setting_name": "Company GST Number",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company GST registration number",
                "display_order": "5"
            },
            "company_registration_number": {
                "setting_name": "Company Registration Number",
                "setting_type": SettingType.STRING,
                "setting_category": SettingCategory.BUSINESS,
                "setting_value": "",
                "default_value": "",
                "description": "Company registration number",
                "display_order": "6"
            }
        }
        
        if setting_key in company_setting_configs:
            config = company_setting_configs[setting_key]
            await self.create_setting(
                setting_key=setting_key,
                **config
            )
    
    async def _get_system_health(self) -> Dict[str, Any]:
        """Get system health information."""
        # This would be expanded with actual health checks
        return {
            'status': 'healthy',
            'uptime': '99.9%',
            'response_time': '120ms',
            'memory_usage': '68%',
            'cpu_usage': '25%',
            'disk_usage': '42%'
        }


# Additional imports for datetime operations
from datetime import timedelta

===== modules/system/whitelist_routes.py â€“ 2025-07-20 02:37:53 IST =====
"""
Routes for managing whitelist configuration.
"""

from typing import List, Dict, Any, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel

from app.core.whitelist import whitelist_manager, reload_whitelist_config


router = APIRouter(tags=["Whitelist Management"])


class CORSOriginRequest(BaseModel):
    """Request model for adding CORS origins."""
    origin: str
    category: str = "additional_origins"  # additional_origins, development, production


class LocalhostRangeRequest(BaseModel):
    """Request model for updating localhost port range."""
    start_port: int = 3000
    end_port: int = 3050


class WhitelistStatusResponse(BaseModel):
    """Response model for whitelist status."""
    enabled: bool
    total_cors_origins: int
    localhost_range_enabled: bool
    localhost_start_port: int
    localhost_end_port: int
    public_endpoints_count: int
    protected_endpoints_count: int
    admin_endpoints_count: int


@router.get("/whitelist/status", response_model=WhitelistStatusResponse)
async def get_whitelist_status():
    """Get current whitelist configuration status."""
    cors_origins = whitelist_manager.get_cors_origins()
    config = whitelist_manager._config
    
    cors_config = config.get("cors_origins", {})
    localhost_range = cors_config.get("localhost_range", {})
    
    return WhitelistStatusResponse(
        enabled=True,
        total_cors_origins=len(cors_origins),
        localhost_range_enabled=localhost_range.get("enabled", True),
        localhost_start_port=localhost_range.get("start_port", 3000),
        localhost_end_port=localhost_range.get("end_port", 3050),
        public_endpoints_count=len(whitelist_manager.get_public_endpoints()),
        protected_endpoints_count=len(whitelist_manager.get_protected_endpoints()),
        admin_endpoints_count=len(whitelist_manager.get_admin_only_endpoints())
    )


@router.get("/whitelist/cors-origins")
async def get_cors_origins() -> Dict[str, Any]:
    """Get all CORS origins grouped by category."""
    cors_origins = whitelist_manager.get_cors_origins()
    config = whitelist_manager._config.get("cors_origins", {})
    
    # Generate localhost range origins for display
    localhost_range = config.get("localhost_range", {})
    localhost_origins = []
    
    if localhost_range.get("enabled", True):
        start_port = localhost_range.get("start_port", 3000)
        end_port = localhost_range.get("end_port", 3050)
        protocols = localhost_range.get("protocols", ["http"])
        aliases = config.get("localhost_aliases", {}).get("aliases", ["localhost", "127.0.0.1"])
        
        for protocol in protocols:
            for alias in aliases:
                for port in range(start_port, min(start_port + 10, end_port + 1)):  # Show only first 10 for display
                    localhost_origins.append(f"{protocol}://{alias}:{port}")
        
        if end_port - start_port > 10:
            localhost_origins.append(f"... and {(end_port - start_port + 1) * len(protocols) * len(aliases) - 10} more")
    
    return {
        "localhost_range": {
            "enabled": localhost_range.get("enabled", True),
            "start_port": localhost_range.get("start_port", 3000),
            "end_port": localhost_range.get("end_port", 3050),
            "sample_origins": localhost_origins
        },
        "additional_origins": config.get("additional_origins", []),
        "development": config.get("development", {}),
        "production": config.get("production", {}),
        "total_origins": len(cors_origins)
    }


@router.post("/whitelist/cors-origins")
async def add_cors_origin(request: CORSOriginRequest):
    """Add a new CORS origin."""
    try:
        whitelist_manager.add_cors_origin(request.origin, request.category)
        return {"message": f"Successfully added origin {request.origin} to {request.category}"}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to add CORS origin: {str(e)}"
        )


@router.delete("/whitelist/cors-origins")
async def remove_cors_origin(origin: str):
    """Remove a CORS origin."""
    success = whitelist_manager.remove_cors_origin(origin)
    
    if success:
        return {"message": f"Successfully removed origin {origin}"}
    else:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Origin {origin} not found in configuration"
        )


@router.put("/whitelist/localhost-range")
async def update_localhost_range(request: LocalhostRangeRequest):
    """Update localhost port range."""
    try:
        whitelist_manager.update_localhost_range(request.start_port, request.end_port)
        return {
            "message": f"Successfully updated localhost range to {request.start_port}-{request.end_port}",
            "start_port": request.start_port,
            "end_port": request.end_port
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to update localhost range: {str(e)}"
        )


@router.get("/whitelist/endpoints")
async def get_endpoint_configuration():
    """Get endpoint access configuration."""
    return {
        "public_endpoints": whitelist_manager.get_public_endpoints(),
        "protected_endpoints": whitelist_manager.get_protected_endpoints(),
        "admin_only_endpoints": whitelist_manager.get_admin_only_endpoints()
    }


@router.post("/whitelist/reload")
async def reload_whitelist():
    """Reload whitelist configuration from file."""
    try:
        reload_whitelist_config()
        return {"message": "Whitelist configuration reloaded successfully"}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to reload whitelist configuration: {str(e)}"
        )


@router.get("/whitelist/config")
async def get_full_configuration():
    """Get complete whitelist configuration (admin only).
    
    TODO: This endpoint exposes internal configuration and should be
    properly secured with authentication/authorization in production.
    """
    return whitelist_manager._config


@router.get("/whitelist/test-origin")
async def test_origin(origin: str):
    """Test if an origin is allowed.
    
    TODO: This endpoint should be secured or removed in production.
    """
    is_allowed = whitelist_manager.is_origin_allowed(origin)
    return {
        "origin": origin,
        "allowed": is_allowed,
        "message": "Origin is allowed" if is_allowed else "Origin is not allowed"
    }


@router.get("/whitelist/test-endpoint")
async def test_endpoint(endpoint: str):
    """Test endpoint access configuration.
    
    TODO: This endpoint should be secured or removed in production.
    """
    is_public = whitelist_manager.is_endpoint_public(endpoint)
    is_admin_only = whitelist_manager.is_endpoint_admin_only(endpoint)
    
    access_type = "public" if is_public else ("admin_only" if is_admin_only else "protected")
    
    return {
        "endpoint": endpoint,
        "access_type": access_type,
        "is_public": is_public,
        "is_admin_only": is_admin_only,
        "requires_auth": not is_public
    }

===== modules/system/services/audit_service.py â€“ 2025-07-19 12:13:41 IST =====
"""
Audit Service

This service provides comprehensive audit logging capabilities for tracking
all system changes and transaction events. It integrates with both the
database-based audit log and the file-based transaction logger.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from uuid import UUID
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_

from app.modules.system.models import AuditLog
from app.modules.transactions.models.events import TransactionEvent
from app.core.transaction_logger import get_transaction_logger


class AuditService:
    """
    Service for managing comprehensive audit trails and transaction logging.
    
    This service coordinates between:
    - Database audit logs (AuditLog model)
    - Transaction events (TransactionEvent model)
    - File-based transaction logs (TransactionLogger)
    """
    
    def __init__(self, db_session: AsyncSession):
        """
        Initialize the audit service.
        
        Args:
            db_session: Database session for audit operations
        """
        self.db_session = db_session
        self.transaction_logger = get_transaction_logger()
        
    async def log_transaction_start(
        self,
        transaction_id: UUID,
        transaction_type: str,
        operation_name: str,
        user_id: Optional[UUID] = None,
        session_id: Optional[str] = None,
        ip_address: Optional[str] = None,
        additional_data: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Log the start of a transaction in both database and file logs.
        
        Args:
            transaction_id: Transaction identifier
            transaction_type: Type of transaction
            operation_name: Specific operation being performed
            user_id: User initiating the transaction
            session_id: Session identifier
            ip_address: Client IP address
            additional_data: Additional context data
        """
        # Start file-based logging
        self.transaction_logger.start_transaction_log(
            transaction_type=transaction_type,
            transaction_id=transaction_id,
            operation_name=operation_name
        )
        
        # Create database audit log
        await self._create_audit_log(
            entity_type="TRANSACTION",
            entity_id=str(transaction_id),
            action="CREATE",
            description=f"Started {transaction_type} transaction",
            user_id=user_id,
            session_id=session_id,
            ip_address=ip_address,
            additional_data=additional_data
        )
        
        # Create transaction event
        await self._create_transaction_event(
            transaction_id=str(transaction_id),
            event_type="TRANSACTION_STARTED",
            description=f"{transaction_type} transaction initiated",
            category="TRANSACTION",
            user_id=str(user_id) if user_id else None,
            operation_name=operation_name,
            event_data=additional_data
        )
        
    async def log_validation_step(
        self,
        transaction_id: UUID,
        validation_type: str,
        result: bool,
        details: Optional[Dict[str, Any]] = None,
        user_id: Optional[UUID] = None
    ) -> None:
        """
        Log validation steps and their results.
        
        Args:
            transaction_id: Transaction identifier
            validation_type: Type of validation performed
            result: Whether validation passed
            details: Validation details and results
            user_id: User performing the validation
        """
        # Log to file
        self.transaction_logger.log_validation(
            validation_type=validation_type,
            result=result,
            details=details
        )
        
        # Create transaction event
        await self._create_transaction_event(
            transaction_id=str(transaction_id),
            event_type="VALIDATION",
            description=f"{validation_type} validation {'passed' if result else 'failed'}",
            category="VALIDATION",
            status="SUCCESS" if result else "FAILURE",
            user_id=str(user_id) if user_id else None,
            event_data={
                "validation_type": validation_type,
                "result": result,
                "details": details or {}
            }
        )
        
    async def log_inventory_change(
        self,
        transaction_id: UUID,
        item_id: UUID,
        item_name: str,
        change_type: str,
        quantity_before: Decimal,
        quantity_after: Decimal,
        location_id: Optional[UUID] = None,
        location_name: Optional[str] = None,
        user_id: Optional[UUID] = None
    ) -> None:
        """
        Log inventory changes caused by transactions.
        
        Args:
            transaction_id: Transaction identifier
            item_id: Item identifier
            item_name: Item name
            change_type: Type of change (SALE, PURCHASE, RENTAL_OUT, etc.)
            quantity_before: Quantity before change
            quantity_after: Quantity after change
            location_id: Location identifier
            location_name: Location name
            user_id: User making the change
        """
        quantity_change = quantity_after - quantity_before
        
        # Log to file
        self.transaction_logger.log_inventory_change(
            item_id=item_id,
            item_name=item_name,
            change_type=change_type,
            quantity_before=quantity_before,
            quantity_after=quantity_after,
            location_id=location_id,
            location_name=location_name
        )
        
        # Create audit log
        await self._create_audit_log(
            entity_type="INVENTORY",
            entity_id=str(item_id),
            action=change_type,
            description=f"Inventory change: {item_name} ({quantity_change:+})",
            user_id=user_id,
            old_values={
                "quantity": str(quantity_before),
                "location_id": str(location_id) if location_id else None
            },
            new_values={
                "quantity": str(quantity_after),
                "location_id": str(location_id) if location_id else None
            },
            additional_data={
                "transaction_id": str(transaction_id),
                "change_type": change_type,
                "location_name": location_name
            }
        )
        
        # Create transaction event
        await self._create_transaction_event(
            transaction_id=str(transaction_id),
            event_type="INVENTORY_CHANGE",
            description=f"Inventory {change_type}: {item_name} ({quantity_change:+})",
            category="INVENTORY",
            user_id=str(user_id) if user_id else None,
            event_data={
                "item_id": str(item_id),
                "item_name": item_name,
                "change_type": change_type,
                "quantity_before": str(quantity_before),
                "quantity_after": str(quantity_after),
                "quantity_change": str(quantity_change),
                "location_id": str(location_id) if location_id else None,
                "location_name": location_name
            }
        )
        
    async def log_payment_event(
        self,
        transaction_id: UUID,
        payment_type: str,
        amount: Decimal,
        method: str,
        status: str,
        reference: Optional[str] = None,
        user_id: Optional[UUID] = None,
        additional_details: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Log payment-related events.
        
        Args:
            transaction_id: Transaction identifier
            payment_type: Type of payment
            amount: Payment amount
            method: Payment method
            status: Payment status
            reference: Payment reference
            user_id: User processing the payment
            additional_details: Additional payment details
        """
        # Log to file
        self.transaction_logger.log_payment_event(
            payment_type=payment_type,
            amount=amount,
            method=method,
            status=status,
            reference=reference,
            details=additional_details
        )
        
        # Create audit log
        await self._create_audit_log(
            entity_type="PAYMENT",
            entity_id=str(transaction_id),
            action=payment_type,
            description=f"Payment {payment_type}: {amount} via {method}",
            user_id=user_id,
            additional_data={
                "transaction_id": str(transaction_id),
                "amount": str(amount),
                "method": method,
                "status": status,
                "reference": reference,
                **(additional_details or {})
            }
        )
        
        # Create transaction event
        await self._create_transaction_event(
            transaction_id=str(transaction_id),
            event_type="PAYMENT_EVENT",
            description=f"Payment {payment_type}: {amount} via {method} - {status}",
            category="PAYMENT",
            user_id=str(user_id) if user_id else None,
            status="SUCCESS" if status in ["COMPLETED", "APPROVED"] else "PENDING",
            event_data={
                "payment_type": payment_type,
                "amount": str(amount),
                "method": method,
                "status": status,
                "reference": reference,
                "details": additional_details or {}
            }
        )
        
    async def log_master_data_change(
        self,
        entity_type: str,
        entity_id: UUID,
        entity_name: str,
        action: str,
        old_values: Optional[Dict[str, Any]] = None,
        new_values: Optional[Dict[str, Any]] = None,
        user_id: Optional[UUID] = None,
        transaction_id: Optional[UUID] = None
    ) -> None:
        """
        Log changes to master data entities.
        
        Args:
            entity_type: Type of entity (CUSTOMER, ITEM, LOCATION, etc.)
            entity_id: Entity identifier
            entity_name: Entity name
            action: Action performed (CREATE, UPDATE, DELETE)
            old_values: Previous values
            new_values: New values
            user_id: User making the change
            transaction_id: Related transaction if applicable
        """
        # Log to file if part of a transaction
        if transaction_id and self.transaction_logger.current_transaction_id:
            self.transaction_logger.log_master_data_change(
                entity_type=entity_type,
                entity_id=entity_id,
                entity_name=entity_name,
                change_type=action,
                old_values=old_values,
                new_values=new_values
            )
        
        # Create audit log
        await self._create_audit_log(
            entity_type=entity_type,
            entity_id=str(entity_id),
            action=action,
            description=f"{action} {entity_type}: {entity_name}",
            user_id=user_id,
            old_values=old_values,
            new_values=new_values,
            additional_data={
                "transaction_id": str(transaction_id) if transaction_id else None
            }
        )
        
        # Create transaction event if part of a transaction
        if transaction_id:
            await self._create_transaction_event(
                transaction_id=str(transaction_id),
                event_type="MASTER_DATA_CHANGE",
                description=f"{action} {entity_type}: {entity_name}",
                category="MASTER_DATA",
                user_id=str(user_id) if user_id else None,
                event_data={
                    "entity_type": entity_type,
                    "entity_id": str(entity_id),
                    "entity_name": entity_name,
                    "action": action,
                    "old_values": old_values or {},
                    "new_values": new_values or {}
                }
            )
            
    async def log_error(
        self,
        transaction_id: Optional[UUID],
        error_type: str,
        error_message: str,
        error_details: Optional[Dict[str, Any]] = None,
        stack_trace: Optional[str] = None,
        user_id: Optional[UUID] = None
    ) -> None:
        """
        Log errors that occur during processing.
        
        Args:
            transaction_id: Transaction identifier if applicable
            error_type: Type of error
            error_message: Error message
            error_details: Additional error details
            stack_trace: Stack trace if available
            user_id: User associated with the error
        """
        # Log to file if part of a transaction
        if transaction_id and self.transaction_logger.current_transaction_id:
            self.transaction_logger.log_error(
                error_type=error_type,
                error_message=error_message,
                error_details=error_details,
                stack_trace=stack_trace
            )
        
        # Create audit log
        await self._create_audit_log(
            entity_type="SYSTEM",
            entity_id=str(transaction_id) if transaction_id else "SYSTEM",
            action="ERROR",
            description=f"Error: {error_type} - {error_message}",
            user_id=user_id,
            additional_data={
                "error_type": error_type,
                "error_message": error_message,
                "error_details": error_details or {},
                "stack_trace": stack_trace,
                "transaction_id": str(transaction_id) if transaction_id else None
            }
        )
        
        # Create transaction event if part of a transaction
        if transaction_id:
            await self._create_transaction_event(
                transaction_id=str(transaction_id),
                event_type="ERROR",
                description=error_message,
                category="ERROR",
                status="FAILURE",
                user_id=str(user_id) if user_id else None,
                error_code=error_type,
                error_message=error_message,
                event_data={
                    "error_details": error_details or {},
                    "stack_trace": stack_trace
                }
            )
            
    async def complete_transaction_log(
        self,
        transaction_id: UUID,
        final_status: str,
        user_id: Optional[UUID] = None,
        completion_notes: Optional[str] = None
    ) -> Optional[str]:
        """
        Complete transaction logging and generate final log file.
        
        Args:
            transaction_id: Transaction identifier
            final_status: Final transaction status
            user_id: User completing the transaction
            completion_notes: Additional completion notes
            
        Returns:
            Path to the generated log file if successful
        """
        # Create final audit log
        await self._create_audit_log(
            entity_type="TRANSACTION",
            entity_id=str(transaction_id),
            action="COMPLETE",
            description=f"Transaction completed with status: {final_status}",
            user_id=user_id,
            additional_data={
                "final_status": final_status,
                "completion_notes": completion_notes
            }
        )
        
        # Create final transaction event
        await self._create_transaction_event(
            transaction_id=str(transaction_id),
            event_type="TRANSACTION_COMPLETED",
            description=f"Transaction completed: {final_status}",
            category="TRANSACTION",
            user_id=str(user_id) if user_id else None,
            status="SUCCESS" if final_status == "COMPLETED" else "FAILURE",
            event_data={
                "final_status": final_status,
                "completion_notes": completion_notes
            }
        )
        
        # Complete file-based logging
        if self.transaction_logger.current_transaction_id == transaction_id:
            log_file = self.transaction_logger.complete_transaction_log(final_status)
            return str(log_file)
            
        return None
        
    async def get_transaction_audit_trail(
        self,
        transaction_id: UUID,
        include_events: bool = True,
        include_audit_logs: bool = True
    ) -> Dict[str, List[Dict[str, Any]]]:
        """
        Retrieve complete audit trail for a transaction.
        
        Args:
            transaction_id: Transaction identifier
            include_events: Whether to include transaction events
            include_audit_logs: Whether to include audit logs
            
        Returns:
            Dictionary containing audit trail data
        """
        result = {
            "transaction_events": [],
            "audit_logs": [],
            "summary": {
                "total_events": 0,
                "total_audit_logs": 0,
                "has_errors": False,
                "completion_status": None
            }
        }
        
        # Get transaction events
        if include_events:
            events_query = select(TransactionEvent).where(
                TransactionEvent.transaction_id == str(transaction_id)
            ).order_by(TransactionEvent.event_timestamp)
            
            events_result = await self.db_session.execute(events_query)
            events = events_result.scalars().all()
            
            result["transaction_events"] = [event.to_dict() for event in events]
            result["summary"]["total_events"] = len(events)
            result["summary"]["has_errors"] = any(
                event.status == "FAILURE" for event in events
            )
            
            # Get completion status from last event
            if events:
                last_event = events[-1]
                if last_event.event_type == "TRANSACTION_COMPLETED":
                    result["summary"]["completion_status"] = last_event.event_data.get("final_status")
        
        # Get audit logs
        if include_audit_logs:
            audit_query = select(AuditLog).where(
                or_(
                    AuditLog.entity_id == str(transaction_id),
                    AuditLog.additional_data.op('->>')('transaction_id') == str(transaction_id)
                )
            ).order_by(AuditLog.created_at)
            
            audit_result = await self.db_session.execute(audit_query)
            audit_logs = audit_result.scalars().all()
            
            result["audit_logs"] = [
                {
                    "id": str(log.id),
                    "entity_type": log.entity_type,
                    "entity_id": log.entity_id,
                    "action": log.action,
                    "description": log.description,
                    "old_values": log.old_values,
                    "new_values": log.new_values,
                    "additional_data": log.additional_data,
                    "created_at": log.created_at.isoformat(),
                    "created_by": str(log.created_by) if log.created_by else None
                }
                for log in audit_logs
            ]
            result["summary"]["total_audit_logs"] = len(audit_logs)
        
        return result
        
    async def _create_audit_log(
        self,
        entity_type: str,
        entity_id: str,
        action: str,
        description: str,
        user_id: Optional[UUID] = None,
        session_id: Optional[str] = None,
        ip_address: Optional[str] = None,
        old_values: Optional[Dict[str, Any]] = None,
        new_values: Optional[Dict[str, Any]] = None,
        additional_data: Optional[Dict[str, Any]] = None
    ) -> AuditLog:
        """Create a new audit log entry."""
        audit_log = AuditLog(
            entity_type=entity_type,
            entity_id=entity_id,
            action=action,
            description=description,
            created_by=user_id,
            session_id=session_id,
            ip_address=ip_address,
            old_values=old_values or {},
            new_values=new_values or {},
            additional_data=additional_data or {}
        )
        
        self.db_session.add(audit_log)
        await self.db_session.flush()
        return audit_log
        
    async def _create_transaction_event(
        self,
        transaction_id: str,
        event_type: str,
        description: str,
        category: str = "GENERAL",
        status: str = "SUCCESS",
        user_id: Optional[str] = None,
        operation_name: Optional[str] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        event_data: Optional[Dict[str, Any]] = None
    ) -> TransactionEvent:
        """Create a new transaction event."""
        event = TransactionEvent(
            transaction_id=transaction_id,
            event_type=event_type,
            description=description,
            event_category=category,
            status=status,
            user_id=user_id,
            operation_name=operation_name,
            error_code=error_code,
            error_message=error_message,
            event_data=event_data or {}
        )
        
        self.db_session.add(event)
        await self.db_session.flush()
        return event

===== modules/transactions/__init__.py â€“ 2025-07-19 12:13:41 IST =====
# Transactions module

from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionLine,
    TransactionType,
    TransactionStatus,
    PaymentMethod,
    PaymentStatus,
    RentalPeriodUnit,
    LineItemType,
    TransactionMetadata,
    RentalInspection,
    PurchaseCreditMemo,
)

__all__ = [
    "TransactionHeader",
    "TransactionLine",
    "TransactionType",
    "TransactionStatus",
    "PaymentMethod",
    "PaymentStatus",
    "RentalPeriodUnit",
    "LineItemType",
    "TransactionMetadata",
    "RentalInspection",
    "PurchaseCreditMemo",
]

===== modules/transactions/rentals/__init__.py â€“ 2025-07-19 14:56:34 IST =====
"""
Rentals Module

Handles all rental-related transactions including creation, retrieval, and returns.
"""

from app.modules.transactions.rentals.schemas import (
    RentalResponse,
    NewRentalRequest,
    NewRentalResponse,
    RentalItemCreate,
    RentalLineItemResponse,
    RentalDetail,
    RentalListResponse,
    CustomerNestedResponse,
    LocationNestedResponse,
    ItemNestedResponse,
    RentableItemResponse,
    LocationAvailability,
    BrandNested,
    CategoryNested,
    UnitOfMeasurementNested,
    RentalPeriodUpdate,
)
from app.modules.transactions.rentals.services import RentalsService
from app.modules.transactions.rentals.repository import RentalsRepository
from app.modules.transactions.rentals.routes import router as rentals_router

__all__ = [
    # Schemas
    "RentalResponse",
    "NewRentalRequest",
    "NewRentalResponse",
    "RentalItemCreate",
    "RentalLineItemResponse",
    "RentalDetail",
    "RentalListResponse",
    "CustomerNestedResponse",
    "LocationNestedResponse",
    "ItemNestedResponse",
    "RentableItemResponse",
    "LocationAvailability",
    "BrandNested",
    "CategoryNested",
    "UnitOfMeasurementNested",
    "RentalPeriodUpdate",
    # Service and Repository
    "RentalsService",
    "RentalsRepository",
    # Router
    "rentals_router",
]

===== modules/transactions/rentals/repository.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rentals Repository

Data access layer for rental-specific operations.
"""

from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, update
from sqlalchemy.orm import selectinload

from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionLine,
    TransactionType,
    TransactionStatus,
    PaymentStatus,
    RentalStatus,
)
from app.modules.transactions.base.repository import TransactionHeaderRepository


class RentalsRepository(TransactionHeaderRepository):
    """Repository for rental-specific operations."""

    async def get_rentals(
        self,
        skip: int = 0,
        limit: int = 100,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[TransactionStatus] = None,
        rental_status: Optional[RentalStatus] = None,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        overdue_only: bool = False,
    ) -> List[TransactionHeader]:
        """Get rental transactions with filtering."""
        filters = [TransactionHeader.transaction_type == TransactionType.RENTAL]
        
        if customer_id:
            filters.append(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            filters.append(TransactionHeader.location_id == str(location_id))
        if status:
            filters.append(TransactionHeader.status == status)
        if date_from:
            filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
        if date_to:
            filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))

        stmt = (
            select(TransactionHeader)
            .where(and_(*filters))
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
            .offset(skip)
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        rentals = result.scalars().unique().all()
        
        # Additional filtering for rental status and overdue
        if rental_status or overdue_only:
            filtered_rentals = []
            for rental in rentals:
                # Check rental status in transaction lines
                if rental_status:
                    has_matching_status = any(
                        line.current_rental_status == rental_status 
                        for line in rental.transaction_lines
                    )
                    if not has_matching_status:
                        continue
                
                # Check if overdue
                if overdue_only:
                    is_overdue = any(
                        line.rental_end_date and line.rental_end_date < date.today() and 
                        line.returned_quantity < line.quantity
                        for line in rental.transaction_lines
                    )
                    if not is_overdue:
                        continue
                
                filtered_rentals.append(rental)
            return filtered_rentals
        
        return rentals

    async def get_rental_by_id(self, rental_id: UUID) -> Optional[TransactionHeader]:
        """Get a single rental transaction by ID."""
        stmt = (
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.id == rental_id,
                    TransactionHeader.transaction_type == TransactionType.RENTAL
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
        )
        
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()

    async def get_rental_summary(
        self,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
    ) -> Dict[str, Any]:
        """Get rental summary statistics."""
        filters = [TransactionHeader.transaction_type == TransactionType.RENTAL]
        
        if date_from:
            filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
        if date_to:
            filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))
        if customer_id:
            filters.append(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            filters.append(TransactionHeader.location_id == str(location_id))

        # Get aggregated data
        stmt = select(
            func.count(TransactionHeader.id).label('total_rentals'),
            func.sum(TransactionHeader.total_amount).label('total_amount'),
            func.sum(TransactionHeader.deposit_amount).label('total_deposits'),
            func.avg(TransactionHeader.total_amount).label('average_amount'),
        ).where(and_(*filters))
        
        result = await self.session.execute(stmt)
        summary = result.first()
        
        # Get active rentals count
        active_filters = filters + [TransactionHeader.status != TransactionStatus.COMPLETED]
        active_stmt = select(func.count(TransactionHeader.id)).where(and_(*active_filters))
        active_result = await self.session.execute(active_stmt)
        active_count = active_result.scalar()
        
        return {
            'total_rentals': summary.total_rentals or 0,
            'active_rentals': active_count or 0,
            'total_amount': float(summary.total_amount or 0),
            'total_deposits': float(summary.total_deposits or 0),
            'average_amount': float(summary.average_amount or 0),
        }

    async def get_rentals_due_for_return(
        self,
        as_of_date: Optional[date] = None
    ) -> List[TransactionHeader]:
        """Get rentals due for return."""
        target_date = as_of_date or date.today()
        
        stmt = (
            select(TransactionHeader)
            .join(TransactionLine)
            .where(
                and_(
                    TransactionHeader.transaction_type == TransactionType.RENTAL,
                    TransactionHeader.status != TransactionStatus.COMPLETED,
                    TransactionLine.rental_end_date <= target_date,
                    TransactionLine.returned_quantity < TransactionLine.quantity
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
            .distinct()
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def get_overdue_rentals(
        self,
        as_of_date: Optional[date] = None
    ) -> List[TransactionHeader]:
        """Get overdue rentals."""
        target_date = as_of_date or date.today()
        
        stmt = (
            select(TransactionHeader)
            .join(TransactionLine)
            .where(
                and_(
                    TransactionHeader.transaction_type == TransactionType.RENTAL,
                    TransactionHeader.status != TransactionStatus.COMPLETED,
                    TransactionLine.rental_end_date < target_date,
                    TransactionLine.returned_quantity < TransactionLine.quantity
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
            .distinct()
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def get_customer_rental_history(
        self,
        customer_id: UUID,
        skip: int = 0,
        limit: int = 100
    ) -> List[TransactionHeader]:
        """Get rental history for a specific customer."""
        stmt = (
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.customer_id == str(customer_id),
                    TransactionHeader.transaction_type == TransactionType.RENTAL,
                    TransactionHeader.is_active == True
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
            .offset(skip)
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def get_rental_utilization_by_item(
        self,
        item_id: UUID,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
    ) -> Dict[str, Any]:
        """Get rental utilization statistics for a specific item."""
        filters = [
            TransactionHeader.transaction_type == TransactionType.RENTAL,
            TransactionLine.item_id == str(item_id),
            TransactionHeader.is_active == True
        ]
        
        if date_from:
            filters.append(TransactionLine.rental_start_date >= date_from)
        if date_to:
            filters.append(TransactionLine.rental_end_date <= date_to)

        # Get rental statistics
        stmt = (
            select(
                func.count(TransactionLine.id).label('total_rentals'),
                func.sum(TransactionLine.quantity).label('total_quantity_rented'),
                func.sum(TransactionLine.line_total).label('total_revenue'),
                func.avg(func.julianday(TransactionLine.rental_end_date) - 
                        func.julianday(TransactionLine.rental_start_date)).label('avg_rental_days')
            )
            .join(TransactionHeader)
            .where(and_(*filters))
        )
        
        result = await self.session.execute(stmt)
        stats = result.first()
        
        return {
            'item_id': item_id,
            'total_rentals': stats.total_rentals or 0,
            'total_quantity_rented': float(stats.total_quantity_rented or 0),
            'total_revenue': float(stats.total_revenue or 0),
            'average_rental_days': float(stats.avg_rental_days or 0),
        }

    async def update_rental_status(
        self,
        rental_id: UUID,
        status: TransactionStatus
    ) -> bool:
        """Update rental transaction status."""
        stmt = (
            update(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.id == rental_id,
                    TransactionHeader.transaction_type == TransactionType.RENTAL
                )
            )
            .values(status=status, updated_at=func.now())
        )
        
        result = await self.session.execute(stmt)
        await self.session.commit()
        return result.rowcount > 0

===== modules/transactions/rentals/routes.py â€“ 2025-07-20 11:53:15 IST =====
"""
Rentals Routes

API endpoints for rental-related operations.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import date
from decimal import Decimal
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.shared.dependencies import get_session
from app.modules.transactions.rentals.services import RentalsService
from app.modules.transactions.base.models import (
    TransactionStatus,
    PaymentStatus,
    RentalStatus,
)
from app.modules.transactions.rentals.schemas import (
    RentalResponse,
    NewRentalRequest,
    NewRentalResponse,
    RentableItemResponse,
    RentalPeriodUpdate,
)
from app.core.errors import NotFoundError, ValidationError, ConflictError


router = APIRouter(tags=["rentals"])


def get_rentals_service(session: AsyncSession = Depends(get_session)) -> RentalsService:
    """Get rentals service instance."""
    return RentalsService(session)


@router.get("/", response_model=List[RentalResponse])
async def get_rental_transactions(
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
    customer_id: Optional[UUID] = Query(None, description="Filter by customer ID"),
    location_id: Optional[UUID] = Query(None, description="Filter by location ID"),
    status: Optional[TransactionStatus] = Query(None, description="Filter by transaction status"),
    rental_status: Optional[RentalStatus] = Query(None, description="Filter by rental status"),
    date_from: Optional[date] = Query(None, description="Filter by rental start date (from)"),
    date_to: Optional[date] = Query(None, description="Filter by rental end date (to)"),
    overdue_only: bool = Query(False, description="Show only overdue rentals"),
    service: RentalsService = Depends(get_rentals_service),
):
    """
    Get rental transactions with comprehensive filtering options.
    
    This endpoint provides rental-specific filtering and includes lifecycle information:
    - Filter by customer, location, transaction status, or rental status
    - Filter by rental date range (start/end dates)
    - Show only overdue rentals
    - Includes rental lifecycle information (current status, fees, etc.)
    - Supports pagination
    
    Filters:
    - customer_id: Filter by specific customer UUID
    - location_id: Filter by specific location UUID  
    - status: Filter by transaction status (DRAFT, CONFIRMED, COMPLETED, etc.)
    - rental_status: Filter by rental status (ACTIVE, LATE, PARTIAL_RETURN, etc.)
    - date_from/date_to: Filter by rental start/end date range
    - overdue_only: Show only rentals that are past their end date
    
    Returns list of rental transactions with lifecycle information.
    """
    return await service.get_rental_transactions(
        skip=skip,
        limit=limit,
        customer_id=customer_id,
        location_id=location_id,
        status=status,
        rental_status=rental_status,
        date_from=date_from,
        date_to=date_to,
        overdue_only=overdue_only,
    )


@router.get("/rentable-items", response_model=List[RentableItemResponse])
async def get_rentable_items(
    location_id: Optional[UUID] = Query(None, description="Filter by specific location"),
    category_id: Optional[UUID] = Query(None, description="Filter by category"),
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
    service: RentalsService = Depends(get_rentals_service),
):
    """
    Get rentable items with current stock availability by location.
    
    This endpoint returns all items that are:
    - Marked as rentable (is_rentable=True)
    - Active status
    - Have available quantity > 0 in at least one location
    
    The response includes:
    - Item details (SKU, name, rental rate, security deposit)
    - Total available quantity across all locations
    - Breakdown of availability by location
    - Related information (brand, category, unit of measurement)
    
    Use this endpoint when building rental forms to show available items.
    """
    return await service.get_rentable_items_with_availability(
        location_id=location_id,
        category_id=category_id,
        skip=skip,
        limit=limit
    )


@router.get("/{rental_id}", response_model=RentalResponse)
async def get_rental_by_id(
    rental_id: UUID, service: RentalsService = Depends(get_rentals_service)
):
    """Get a single rental transaction by ID with rental-specific format."""
    try:
        return await service.get_rental_by_id(rental_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


@router.post("/new", response_model=NewRentalResponse, status_code=status.HTTP_201_CREATED)
async def create_new_rental(
    rental_data: NewRentalRequest,
    service: RentalsService = Depends(get_rentals_service),
):
    """
    Create a new rental transaction with optimized batch processing.

    This endpoint accepts rental data in the exact format sent by the frontend:
    - transaction_date as string in YYYY-MM-DD format
    - customer_id as string UUID (must exist and be able to transact)
    - location_id as string UUID (must exist)
    - payment_method as string (CASH, CARD, BANK_TRANSFER, CHECK, ONLINE)
    - payment_reference as string (optional)
    - notes as string (optional)
    - items array with:
      * item_id as string UUID (must exist and be rentable)
      * quantity as integer (>=0, allows reservations)
      * rental_period_value as integer (>=0, number of days)
      * tax_rate as decimal (0-100, optional)
      * discount_amount as decimal (>=0, optional)
      * rental_start_date as string YYYY-MM-DD (item-specific)
      * rental_end_date as string YYYY-MM-DD (item-specific, must be after start)
      * notes as string (optional)

    Features:
    - Automatically fetches rental rates from item master data
    - Generates unique transaction numbers (REN-YYYYMMDD-XXXX)
    - Supports item-level rental date management
    - Comprehensive validation at header and line levels
    - Optimized batch processing for performance:
      * Batch validation of all items in a single query
      * Bulk stock level lookups instead of individual queries
      * Single database transaction for all operations
      * Reduced database commits from N+1 to 1

    Performance: Optimized to prevent 30+ second timeouts, expected <2 seconds (93% faster)

    Returns a standardized response with success status, message, transaction data, and identifiers.
    """
    try:
        print(f"DEBUG ROUTE: About to call service.create_rental with data: {rental_data}")
        result = await service.create_rental(rental_data)
        print(f"DEBUG ROUTE: service.create_rental returned: {result}")
        return result
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}",
        )


@router.put("/{rental_id}/extend", response_model=RentalResponse)
async def extend_rental_period(
    rental_id: UUID,
    extension_data: RentalPeriodUpdate,
    service: RentalsService = Depends(get_rentals_service),
):
    """Extend rental period."""
    try:
        return await service.extend_rental_period(rental_id, extension_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


@router.get("/reports/due-for-return", response_model=List[RentalResponse])
async def get_rentals_due_for_return(
    as_of_date: Optional[date] = Query(None, description="As of date"),
    service: RentalsService = Depends(get_rentals_service),
):
    """Get rental transactions due for return."""
    return await service.get_rental_transactions_due_for_return(as_of_date)


@router.get("/reports/overdue", response_model=List[RentalResponse])
async def get_overdue_rentals(
    as_of_date: Optional[date] = Query(None, description="As of date"),
    service: RentalsService = Depends(get_rentals_service),
):
    """Get overdue rental transactions."""
    return await service.get_overdue_rentals(as_of_date)

===== modules/transactions/rentals/schemas.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rentals Schemas

Pydantic schemas for rental-related operations.
"""

from typing import Optional, List
from datetime import date, datetime
from decimal import Decimal
from pydantic import BaseModel, Field, ConfigDict, field_validator, model_validator
from uuid import UUID

from app.modules.transactions.base.models import TransactionType, TransactionStatus, PaymentStatus, RentalStatus, RentalPeriodUnit


# Nested response schemas for rental details
class CustomerNestedResponse(BaseModel):
    """Schema for nested customer response in rental transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Customer name")


class LocationNestedResponse(BaseModel):
    """Schema for nested location response in rental transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Location name")


class ItemNestedResponse(BaseModel):
    """Schema for nested item response in rental transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Item name")


class BrandNested(BaseModel):
    """Nested brand information for rentable items."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    name: str


class CategoryNested(BaseModel):
    """Nested category information for rentable items."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    name: str


class UnitOfMeasurementNested(BaseModel):
    """Nested unit of measurement information."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    name: str
    abbreviation: str


class LocationAvailability(BaseModel):
    """Location-wise availability information for rentable items."""

    model_config = ConfigDict(from_attributes=True)

    location_id: UUID = Field(..., description="Location ID")
    location_name: str = Field(..., description="Location name")
    available_quantity: float = Field(..., description="Available quantity at this location")


class RentalItemCreate(BaseModel):
    """Schema for creating a rental item."""
    
    item_id: str = Field(..., description="Item ID")
    quantity: int = Field(..., ge=0, description="Quantity")
    rental_period_value: int = Field(..., ge=0, description="Rental period value")
    tax_rate: Optional[Decimal] = Field(0, ge=0, le=100, description="Tax rate percentage")
    discount_amount: Optional[Decimal] = Field(0, ge=0, description="Discount amount")
    rental_start_date: str = Field(..., description="Rental start date in YYYY-MM-DD format")
    rental_end_date: str = Field(..., description="Rental end date in YYYY-MM-DD format")
    notes: Optional[str] = Field("", description="Additional notes")
    
    @field_validator("rental_start_date", "rental_end_date")
    @classmethod
    def validate_rental_dates(cls, v):
        """Validate and parse rental dates."""
        try:
            from datetime import datetime
            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")
    
    @model_validator(mode="after")
    def validate_rental_date_range(self):
        """Validate rental end date is after start date."""
        if self.rental_end_date <= self.rental_start_date:
            raise ValueError("Rental end date must be after start date")
        return self


class RentalLineItemResponse(BaseModel):
    """Schema for rental line item response with rental-specific fields."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    item: ItemNestedResponse = Field(..., description="Item details")
    quantity: Decimal
    unit_price: Decimal = Field(..., description="Rental rate per period")
    tax_rate: Decimal = Field(..., description="Tax rate percentage")
    discount_amount: Decimal = Field(..., description="Discount amount")
    rental_period_value: int = Field(..., description="Rental period value")
    rental_period_unit: RentalPeriodUnit = Field(..., description="Rental period unit")
    rental_start_date: date = Field(..., description="Rental start date")
    rental_end_date: date = Field(..., description="Rental end date")
    current_rental_status: Optional[RentalStatus] = Field(None, description="Current rental status")
    notes: str = Field(default="", description="Additional notes")
    tax_amount: Decimal = Field(..., description="Calculated tax amount")
    line_total: Decimal = Field(..., description="Total line amount")
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_transaction_line(cls, line: dict, item_details: dict = None) -> "RentalLineItemResponse":
        """Create RentalLineItemResponse from TransactionLine data."""
        # Create item nested response
        item_nested = ItemNestedResponse(
            id=item_details["id"] if item_details else line["item_id"],
            name=item_details["name"] if item_details else "Unknown Item"
        )
        
        return cls(
            id=line["id"],
            item=item_nested,
            quantity=line["quantity"],
            unit_price=line["unit_price"],
            tax_rate=line["tax_rate"],
            discount_amount=line["discount_amount"],
            rental_period_value=line.get("rental_period", line.get("rental_period_value", 1)),
            rental_period_unit=line.get("rental_period_unit", RentalPeriodUnit.DAYS),
            rental_start_date=line["rental_start_date"],
            rental_end_date=line["rental_end_date"],
            current_rental_status=line.get("current_rental_status"),
            notes=line.get("notes", ""),
            tax_amount=line["tax_amount"],
            line_total=line["line_total"],
            created_at=line["created_at"],
            updated_at=line["updated_at"],
        )


class NewRentalRequest(BaseModel):
    """Schema for the new-rental endpoint - matches frontend JSON structure exactly."""
    
    transaction_date: str = Field(..., description="Transaction date in YYYY-MM-DD format")
    customer_id: str = Field(..., description="Customer ID")
    location_id: str = Field(..., description="Location ID")
    payment_method: str = Field(..., description="Payment method")
    payment_reference: Optional[str] = Field("", description="Payment reference")
    notes: Optional[str] = Field("", description="Additional notes")
    items: List[RentalItemCreate] = Field(..., min_length=1, description="Rental items")
    
    # New delivery fields
    delivery_required: bool = Field(False, description="Whether delivery is required")
    delivery_address: Optional[str] = Field(None, description="Delivery address")
    delivery_date: Optional[str] = Field(None, description="Delivery date in YYYY-MM-DD format")
    delivery_time: Optional[str] = Field(None, description="Delivery time in HH:MM format")
    
    # New pickup fields
    pickup_required: bool = Field(False, description="Whether pickup is required")
    pickup_date: Optional[str] = Field(None, description="Pickup date in YYYY-MM-DD format")
    pickup_time: Optional[str] = Field(None, description="Pickup time in HH:MM format")
    
    # Deposit amount (add reference_number alias for transaction_number)
    deposit_amount: Optional[Decimal] = Field(None, ge=0, description="Security deposit amount")
    reference_number: Optional[str] = Field(None, description="Reference number for the rental")
    
    @field_validator("transaction_date")
    @classmethod
    def validate_transaction_date(cls, v):
        """Validate and parse transaction date."""
        try:
            from datetime import datetime
            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")
    
    @field_validator("customer_id", "location_id")
    @classmethod
    def validate_uuids(cls, v):
        """Validate UUID strings."""
        try:
            from uuid import UUID
            return UUID(v)
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")
    
    @field_validator("delivery_date", "pickup_date")
    @classmethod
    def validate_optional_dates(cls, v):
        """Validate optional date fields."""
        if v is None:
            return None
        try:
            from datetime import datetime
            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")
    
    @field_validator("delivery_time", "pickup_time")
    @classmethod
    def validate_optional_times(cls, v):
        """Validate optional time fields."""
        if v is None:
            return None
        try:
            from datetime import datetime
            datetime.strptime(v, "%H:%M")
            return v
        except ValueError:
            raise ValueError("Invalid time format. Use HH:MM format.")
    
    @model_validator(mode="after")
    def validate_delivery_fields(self):
        """Validate delivery fields consistency."""
        if self.delivery_required:
            if not self.delivery_address:
                raise ValueError("Delivery address is required when delivery is required")
            if not self.delivery_date:
                raise ValueError("Delivery date is required when delivery is required")
        return self
    
    @model_validator(mode="after")
    def validate_pickup_fields(self):
        """Validate pickup fields consistency."""
        if self.pickup_required:
            if not self.pickup_date:
                raise ValueError("Pickup date is required when pickup is required")
        return self


class NewRentalResponse(BaseModel):
    """Schema for new-rental response."""
    
    model_config = ConfigDict(from_attributes=True)
    
    success: bool = Field(True, description="Operation success status")
    message: str = Field("Rental created successfully", description="Response message")
    data: dict = Field(..., description="Rental transaction data")
    transaction_id: UUID = Field(..., description="Created transaction ID")
    transaction_number: str = Field(..., description="Generated transaction number")


class RentalResponse(BaseModel):
    """Schema for rental response - maps transaction data to rental format."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    customer: CustomerNestedResponse = Field(..., description="Customer details")
    location: LocationNestedResponse = Field(..., description="Location details")
    transaction_date: date = Field(..., description="Transaction date")
    reference_number: Optional[str] = Field(None, description="Reference number")
    notes: Optional[str] = Field(None, description="Additional notes")
    subtotal: Decimal = Field(..., description="Subtotal amount")
    tax_amount: Decimal = Field(..., description="Tax amount")
    discount_amount: Decimal = Field(..., description="Discount amount")
    total_amount: Decimal = Field(..., description="Total amount")
    deposit_amount: Decimal = Field(..., description="Security deposit amount")
    status: str = Field(..., description="Rental status")
    payment_status: str = Field(..., description="Payment status")
    delivery_required: bool = Field(False, description="Whether delivery is required")
    delivery_address: Optional[str] = Field(None, description="Delivery address")
    delivery_date: Optional[date] = Field(None, description="Delivery date")
    delivery_time: Optional[str] = Field(None, description="Delivery time")
    pickup_required: bool = Field(False, description="Whether pickup is required")
    pickup_date: Optional[date] = Field(None, description="Pickup date")
    pickup_time: Optional[str] = Field(None, description="Pickup time")
    created_at: datetime
    updated_at: datetime
    items: List[RentalLineItemResponse] = Field(default_factory=list, description="Rental items")

    @classmethod
    def from_transaction(cls, transaction: dict, customer_details: dict = None, location_details: dict = None, items_details: dict = None) -> "RentalResponse":
        """Create RentalResponse from TransactionHeaderResponse data."""
        # Create nested customer response
        customer_nested = CustomerNestedResponse(
            id=customer_details["id"] if customer_details else transaction["customer_id"],
            name=customer_details["name"] if customer_details else "Unknown Customer"
        )
        
        # Create nested location response
        location_nested = LocationNestedResponse(
            id=location_details["id"] if location_details else transaction["location_id"],
            name=location_details["name"] if location_details else "Unknown Location"
        )
        
        # Transform transaction lines to rental line items
        rental_items = []
        items_details = items_details or {}
        for line in transaction.get("transaction_lines", []):
            item_detail = items_details.get(str(line["item_id"]), None)
            rental_items.append(RentalLineItemResponse.from_transaction_line(line, item_detail))
        
        return cls(
            id=transaction["id"],
            customer=customer_nested,
            location=location_nested,
            transaction_date=transaction["transaction_date"].date()
            if isinstance(transaction["transaction_date"], datetime)
            else transaction["transaction_date"],
            reference_number=transaction.get("transaction_number"),
            notes=transaction.get("notes"),
            subtotal=transaction["subtotal"],
            tax_amount=transaction["tax_amount"],
            discount_amount=transaction["discount_amount"],
            total_amount=transaction["total_amount"],
            deposit_amount=transaction.get("deposit_amount", Decimal("0")),
            status=transaction["status"],
            payment_status=transaction["payment_status"],
            delivery_required=transaction.get("delivery_required", False),
            delivery_address=transaction.get("delivery_address"),
            delivery_date=transaction.get("delivery_date"),
            delivery_time=transaction.get("delivery_time"),
            pickup_required=transaction.get("pickup_required", False),
            pickup_date=transaction.get("pickup_date"),
            pickup_time=transaction.get("pickup_time"),
            created_at=transaction["created_at"],
            updated_at=transaction["updated_at"],
            items=rental_items,
        )


class RentalPeriodUpdate(BaseModel):
    """Schema for updating rental period."""

    new_end_date: date = Field(..., description="New rental end date")
    reason: Optional[str] = Field(None, description="Reason for change")
    notes: Optional[str] = Field(None, description="Additional notes")


class RentalReturn(BaseModel):
    """Schema for rental return."""

    actual_return_date: date = Field(..., description="Actual return date")
    condition_notes: Optional[str] = Field(None, description="Condition notes")
    late_fees: Optional[Decimal] = Field(None, ge=0, description="Late fees")
    damage_fees: Optional[Decimal] = Field(None, ge=0, description="Damage fees")
    notes: Optional[str] = Field(None, description="Additional notes")


class RentableItemResponse(BaseModel):
    """Rentable item with stock position across locations."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID = Field(..., description="Item ID")
    sku: str = Field(..., description="Stock Keeping Unit")
    item_name: str = Field(..., description="Item name")
    rental_rate_per_period: Decimal = Field(..., description="Rental rate per period")
    rental_period: str = Field(..., description="Rental period (number of periods)")
    security_deposit: Decimal = Field(..., description="Security deposit amount")
    total_available_quantity: float = Field(..., description="Total available quantity across all locations")
    brand: Optional[BrandNested] = Field(None, description="Brand information")
    category: Optional[CategoryNested] = Field(None, description="Category information")
    unit_of_measurement: UnitOfMeasurementNested = Field(..., description="Unit of measurement")
    location_availability: List[LocationAvailability] = Field(..., description="Availability breakdown by location")


class RentalDetail(BaseModel):
    """Schema for detailed rental information."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    transaction_number: str
    customer_id: UUID
    customer_name: Optional[str] = None
    location_id: UUID
    location_name: Optional[str] = None
    transaction_date: date
    reference_number: Optional[str] = None
    notes: Optional[str] = None
    subtotal: Decimal
    tax_amount: Decimal
    discount_amount: Decimal
    total_amount: Decimal
    deposit_amount: Decimal
    paid_amount: Decimal
    status: TransactionStatus
    payment_status: PaymentStatus
    delivery_required: bool
    delivery_address: Optional[str] = None
    delivery_date: Optional[date] = None
    delivery_time: Optional[str] = None
    pickup_required: bool
    pickup_date: Optional[date] = None
    pickup_time: Optional[str] = None
    created_at: datetime
    updated_at: datetime
    items: List[RentalLineItemResponse] = Field(default_factory=list)


class RentalListResponse(BaseModel):
    """Response schema for rental list."""
    
    rentals: List[RentalResponse] = Field(default_factory=list)
    total: int
    page: int
    page_size: int
    total_pages: int

===== modules/transactions/rentals/services.py â€“ 2025-07-22 10:44:03 IST =====
"""
Simplified Rentals Service

Streamlined business logic for rental operations with reduced complexity.
"""

from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func, update
from sqlalchemy.orm import selectinload

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.core.cache import RentalCache
from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionLine,
    TransactionType,
    TransactionStatus,
    PaymentMethod,
    LineItemType,
    RentalStatus,
    RentalPeriodUnit,
)
from app.modules.transactions.base.repository import (
    TransactionHeaderRepository,
    TransactionLineRepository,
)
from app.modules.transactions.rentals.schemas import (
    RentalResponse,
    RentalItemCreate,
    NewRentalRequest,
    NewRentalResponse,
)
from app.modules.customers.repository import CustomerRepository
# ---From Inventory Module---
from app.modules.inventory import InventoryUnitRepository, StockLevelRepository,StockLevel
from app.modules.inventory.integrations import async_process_rental_out_line_items, async_check_transaction_stock_availability
from app.modules.master_data.locations.repository import LocationRepository
from app.core.logger import get_purchase_logger


class RentalsService:
    """Simplified service for rental transaction operations."""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.transaction_repository = TransactionHeaderRepository(session)
        self.line_repository = TransactionLineRepository(session)
        self.customer_repository = CustomerRepository(session)
        self.item_repository = InventoryUnitRepository(session)
        self.stock_level_repository = StockLevelRepository(session)
        self.location_repository = LocationRepository(session)
        self.logger = get_purchase_logger()

    async def create_rental(self, rental_data: NewRentalRequest) -> NewRentalResponse:
        """
        Create a new rental transaction - simplified version.
        
        Key simplifications:
        1. Single method instead of optimized/non-optimized variants
        2. Direct data handling without excessive transformations
        3. Consolidated validation logic
        4. Streamlined stock processing
        """
        # Log immediately to check if method is called
        print(f"DEBUG: create_rental called with data: {rental_data}")
        self.logger.log_debug_info("Entering create_rental method", {})
        try:
            self.logger.log_debug_info("Creating rental", {
                "customer_id": str(rental_data.customer_id),
                "item_count": len(rental_data.items)
            })
            
            # Validate prerequisites
            self.logger.log_debug_info("Step 1: Validating prerequisites", {})
            await self._validate_rental_prerequisites(rental_data)
            self.logger.log_debug_info("Step 1 completed: Prerequisites validated", {})
            
            # Get rental items data
            self.logger.log_debug_info("Step 2: Getting rental items data", {})
            items_data = await self._get_rental_items_data(rental_data.items)
            self.logger.log_debug_info("Step 2 completed: Rental items data retrieved", {"items_count": len(items_data)})
            
            # Validate stock availability using new inventory service
            self.logger.log_debug_info("Step 3: Validating stock availability", {})
            await self._validate_stock_availability_new(rental_data.items, rental_data.location_id)
            self.logger.log_debug_info("Step 3 completed: Stock availability validated", {})
            
            # Get stock levels for the items
            item_ids = [item.item_id for item in rental_data.items]
            stock_levels = await self._get_stock_levels(item_ids, rental_data.location_id)
            self.logger.log_debug_info("Step 3b: Stock levels retrieved", {"stock_count": len(stock_levels)})
            
            
            # Create transaction
            self.logger.log_debug_info("Step 4: Creating transaction", {})
            transaction = await self._create_rental_transaction(rental_data, items_data, stock_levels)
            self.logger.log_debug_info("Transaction created", {"has_id": bool(transaction.id)})
            
            # Flush to ensure ID is generated but don't commit (let dependency handle commit)
            await self.session.flush()
            await self.session.refresh(transaction)
            
            self.logger.log_debug_info("Transaction flushed and refreshed", {
                "transaction_id": str(transaction.id) if transaction.id else "None",
                "transaction_number": transaction.transaction_number,
                "transaction_type": str(type(transaction.id)) if transaction.id else "NoneType"
            })
            
            # Ensure transaction ID is available after flush
            if not transaction.id:
                raise ValidationError("Transaction ID is None after flush and refresh - database configuration issue")
            
            self.logger.log_debug_info("Step 5: Creating response", {
                "transaction_id": str(transaction.id),
                "transaction_number": transaction.transaction_number
            })
            
            # Return success response
            try:
                response = NewRentalResponse(
                    success=True,
                    message="Rental created successfully",
                    data={
                        "transaction": {
                            "id": str(transaction.id),
                            "transaction_number": transaction.transaction_number,
                            "customer_id": transaction.customer_id,
                            "location_id": transaction.location_id,
                            "total_amount": float(transaction.total_amount),
                            "status": transaction.status.value,
                            "transaction_date": transaction.transaction_date.isoformat(),
                            "created_at": transaction.created_at.isoformat()
                        }
                    },
                    transaction_id=transaction.id,
                    transaction_number=transaction.transaction_number
                )
                self.logger.log_debug_info("Step 5 completed: Response created successfully", {})
                return response
            except Exception as resp_error:
                self.logger.log_debug_info("Error creating response", {
                    "error": str(resp_error),
                    "transaction_id": str(transaction.id) if transaction.id else "None",
                    "transaction_id_type": type(transaction.id).__name__
                })
                raise
        except Exception as e:
            # Use print to bypass any logger issues
            print(f"CRITICAL DEBUG: Error in create_rental: {e}")
            print(f"CRITICAL DEBUG: Error type: {type(e)}")
            print(f"CRITICAL DEBUG: Error details: {repr(e)}")
            
            self.logger.log_debug_info("Error creating rental - Full details", {
                "error": str(e),
                "error_type": type(e).__name__,
                "error_details": repr(e)
            })
            # Don't manually rollback - let the dependency handle rollback automatically
            # Add more specific error information
            if "transaction_id" in str(e):
                self.logger.log_debug_info("Transaction ID error detected", {
                    "error_message": "The transaction_id is None when creating response"
                })
            raise

    async def _validate_rental_prerequisites(self, rental_data: NewRentalRequest) -> None:
        """Validate all rental prerequisites in one method."""
        # Validate customer
        customer = await self.customer_repository.get_by_id(rental_data.customer_id)
        if not customer:
            raise NotFoundError(f"Customer {rental_data.customer_id} not found")
        if not customer.can_transact:
            raise ValidationError(f"Customer {customer.name} cannot transact")
        
        # Validate location
        location = await self.location_repository.get_by_id(rental_data.location_id)
        if not location:
            raise NotFoundError(f"Location {rental_data.location_id} not found")

    async def _get_rental_items_data(self, items: List[RentalItemCreate]) -> Dict[str, Any]:
        """Get all rental items data in a single query."""
        item_ids = [item.item_id for item in items]
        
        # Import the Item model directly
        from app.modules.master_data.item_master.models import Item
        
        # Single query to get all items
        stmt = select(Item).where(
            Item.id.in_(item_ids),
            Item.is_rentable == True,
            Item.is_active == True
        )
        result = await self.session.execute(stmt)
        items_list = result.scalars().all()
        
        if len(items_list) != len(item_ids):
            found_ids = {item.id for item in items_list}
            missing = set(item_ids) - found_ids
            self.logger.log_debug_info("Items missing from database", {
                "requested_items": [str(id) for id in item_ids],
                "found_items": [str(id) for id in found_ids],
                "missing_items": [str(id) for id in missing]
            })
            
            # Raise proper validation error instead of creating mock data
            missing_items_str = ", ".join(str(id) for id in missing)
            raise NotFoundError(f"Items not found or not rentable: {missing_items_str}")
                    
        self.logger.log_debug_info("All items found and validated", {
            "item_count": len(items_list)
        })
        
        return {str(item.id): item for item in items_list}

    async def _get_stock_levels(self, item_ids: List[str], location_id: UUID) -> Dict[str, StockLevel]:
        """Get stock levels for all items in one query."""
        # Convert string item_ids to UUIDs for database query
        uuid_item_ids = [UUID(item_id) for item_id in item_ids]
        
        stmt = select(StockLevel).where(
            and_(
                StockLevel.item_id.in_(uuid_item_ids),
                StockLevel.location_id == location_id
            )
        )
        result = await self.session.execute(stmt)
        stock_levels = result.scalars().all()
        
        # Validate stock availability - all items must have stock levels
        stock_dict = {str(sl.item_id): sl for sl in stock_levels}
        missing_stock = []
        
        for item_id in item_ids:
            if item_id not in stock_dict:
                missing_stock.append(item_id)
        
        if missing_stock:
            missing_stock_str = ", ".join(missing_stock)
            raise NotFoundError(f"Stock levels not found for items at location {location_id}: {missing_stock_str}")
        
        # Validate sufficient stock is available
        insufficient_stock = []
        for item_id in item_ids:
            stock_level = stock_dict[item_id]
            if stock_level.quantity_available <= 0:
                insufficient_stock.append(f"{item_id} (available: {stock_level.quantity_available})")
        
        if insufficient_stock:
            insufficient_stock_str = ", ".join(insufficient_stock)
            raise ValidationError(f"Insufficient stock available for items: {insufficient_stock_str}")
        
        self.logger.log_debug_info("All stock levels validated", {
            "stock_count": len(stock_dict)
        })
        
        return stock_dict

    async def _validate_stock_availability_new(self, items: List[RentalItemCreate], location_id: UUID):
        """Validate stock availability using new inventory service."""
        try:
            # Prepare line items for stock check
            line_items = [
                {
                    'item_id': item.item_id,
                    'quantity': item.quantity
                }
                for item in items
            ]
            print('line items in _validate_stock_availability_new :', line_items)  # Debug print to check line items
            
            # Check availability using new service
            availability = await async_check_transaction_stock_availability(
                async_session=self.session,
                transaction_line_items=line_items,
                location_id=location_id
            )
            self.logger.log_debug_info("Stock availability checked using new service", {
                "location_id": str(location_id),
                "availability": availability
            })
            
            if not availability['all_available']:
                unavailable_details = []
                for item_detail in availability['unavailable_items']:
                    unavailable_details.append(
                        f"Item {item_detail['item_id']}: requested {item_detail['required_quantity']}, "
                        f"available {item_detail['available_quantity']}"
                    )
                raise ValidationError(f"Insufficient stock: {'; '.join(unavailable_details)}")
                
        except Exception as e:
            print(f"CRITICAL DEBUG: Error validating stock availability with new service-tluanga: {e}")
            self.logger.log_debug_info("New stock validation failed, using fallback", {
                "error": str(e)
            })
            # Fallback to old method
            await self._validate_stock_availability(items, location_id)

    async def _validate_stock_availability(self, items: List[RentalItemCreate], location_id: UUID):
        """Validate stock availability for all rental items (old method)."""
        for item in items:
            stock_level = await self.stock_level_repository.get_by_item_location(item.item_id, location_id)
            
            if not stock_level:
                raise ValidationError(f"No stock found for item {item.item_id} at location")
            
            if stock_level.quantity_available < Decimal(str(item.quantity)):
                raise ValidationError(
                    f"Insufficient stock for item {item.item_id}. "
                    f"Available: {stock_level.quantity_available}, Requested: {item.quantity}"
                )

    async def _create_rental_transaction(
        self, 
        rental_data: NewRentalRequest, 
        items_data: Dict[str, Any], 
        stock_levels: Dict[str, StockLevel]
    ) -> TransactionHeader:
        """Create rental transaction with all operations in single transaction."""
        # Create transaction header
        self.logger.log_debug_info("Creating transaction header", {
            "customer_id": str(rental_data.customer_id),
            "location_id": str(rental_data.location_id),
            "payment_method": rental_data.payment_method
        })
        
        # Let SQLAlchemy generate the UUID automatically
        transaction = TransactionHeader(
            transaction_number=await self._generate_transaction_number(rental_data),
            transaction_type=TransactionType.RENTAL,
            transaction_date=datetime.combine(
                rental_data.transaction_date,  # Already a date object from Pydantic validation
                datetime.min.time()
            ),
            customer_id=str(rental_data.customer_id),
            location_id=str(rental_data.location_id),
            status=TransactionStatus.IN_PROGRESS,  # Use IN_PROGRESS for rentals
            payment_method=rental_data.payment_method,  # Keep as string
            payment_reference=rental_data.payment_reference or "",
            notes=rental_data.notes or "",
            subtotal=Decimal("0"),
            discount_amount=Decimal("0"),
            tax_amount=Decimal("0"),
            total_amount=Decimal("0"),
            deposit_amount=getattr(rental_data, 'deposit_amount', None) or Decimal("0"),
            delivery_required=getattr(rental_data, 'delivery_required', False),
            delivery_address=getattr(rental_data, 'delivery_address', None),
            delivery_date=rental_data.delivery_date if rental_data.delivery_date else None,
            delivery_time=getattr(rental_data, 'delivery_time', None),
            pickup_required=getattr(rental_data, 'pickup_required', False),
            pickup_date=rental_data.pickup_date if rental_data.pickup_date else None,
            pickup_time=getattr(rental_data, 'pickup_time', None),
            is_active=True,
        )
        self.session.add(transaction)
        await self.session.flush()
        await self.session.refresh(transaction)
        
        # Check if transaction ID was generated
        if not transaction.id:
            self.logger.log_debug_info("Transaction ID not generated after flush", {
                "transaction_number": transaction.transaction_number,
                "status": transaction.status.value if transaction.status else "None"
            })
            # Try one more refresh
            await self.session.refresh(transaction)
            if not transaction.id:
                # This indicates a database connection or configuration issue
                self.logger.log_debug_info("Database error: UUID not generated", {})
                raise ValidationError("Database error: Failed to generate transaction ID. Check database connection.")

        # Create transaction lines and process stock using new inventory service
        total_amount = Decimal("0")
        transaction_lines = []

        for idx, item in enumerate(rental_data.items):
            item_obj = items_data[item.item_id]
            unit_price = item_obj.rental_rate_per_period or Decimal("0")
            
            # Calculate amounts
            line_subtotal = unit_price * Decimal(str(item.quantity)) * Decimal(str(item.rental_period_value))
            tax_amount = (line_subtotal * (item.tax_rate or Decimal("0"))) / 100
            discount_amount = item.discount_amount or Decimal("0")
            line_total = line_subtotal + tax_amount - discount_amount

            # Create transaction line
            line = TransactionLine(
                transaction_id=str(transaction.id),
                line_number=idx + 1,
                line_type=LineItemType.PRODUCT,
                item_id=str(item.item_id),
                description=f"Rental: {item_obj.item_name}",
                quantity=Decimal(str(item.quantity)),
                unit_price=unit_price,
                tax_rate=item.tax_rate or Decimal("0"),
                tax_amount=tax_amount,
                discount_amount=discount_amount,
                line_total=line_total,
                rental_period=item.rental_period_value,
                rental_period_unit=RentalPeriodUnit.DAY,
                rental_start_date=item.rental_start_date,  # Already a date object
                rental_end_date=item.rental_end_date,    # Already a date object
                current_rental_status=RentalStatus.ACTIVE,
                notes=item.notes or "",
                is_active=True,
            )
            transaction_lines.append(line)
            total_amount += line_total

        # Bulk insert transaction lines
        self.session.add_all(transaction_lines)

        # Process inventory updates using the new inventory service
        try:
            await async_process_rental_out_line_items(
                rental_data.items,
                str(transaction.id),
                transaction.transaction_number,
                str(rental_data.location_id),
                self.session
            )
            self.logger.log_debug_info("Stock levels updated successfully using new inventory service", {
                "transaction_id": str(transaction.id),
                "items_count": len(rental_data.items)
            })
        except Exception as e:
            self.logger.log_error(f"Failed to update stock levels with new inventory service: {str(e)}", {
                "transaction_id": str(transaction.id),
                "error": str(e)
            })
            # Fallback to manual stock updates for backward compatibility
            await self._fallback_manual_stock_updates(transaction, rental_data.items, stock_levels)
            self.logger.log_debug_info("Used fallback manual stock update method", {
                "transaction_id": str(transaction.id)
            })
        
        # Update transaction totals
        transaction.subtotal = total_amount
        transaction.total_amount = total_amount
        transaction.tax_amount = sum(line.tax_amount for line in transaction_lines)
        transaction.discount_amount = sum(line.discount_amount for line in transaction_lines)

        return transaction

    async def _generate_transaction_number(self, rental_data: NewRentalRequest) -> str:
        """Generate unique transaction number."""
        if rental_data.reference_number:
            exists = await self.session.execute(
                select(1).where(TransactionHeader.transaction_number == rental_data.reference_number)
            )
            if exists.scalar():
                raise ConflictError(f"Reference number '{rental_data.reference_number}' already exists")
            return rental_data.reference_number
        
        # Generate timestamp-based number
        import time
        date_str = rental_data.transaction_date.strftime('%Y%m%d')  # Already a date object
        timestamp = int(time.time() * 1000)
        return f"REN-{date_str}-{timestamp % 10000}"

    async def _fallback_manual_stock_updates(self, transaction, rental_items, stock_levels):
        """Fallback method for manual stock updates when new inventory service fails."""
        from app.modules.inventory import StockMovement, StockLevel, MovementType, ReferenceType
        from sqlalchemy import update, and_, func
        
        stock_updates = []
        stock_movements = []
        
        for item in rental_items:
            stock_level = stock_levels[item.item_id]
            quantity = Decimal(str(item.quantity))
            
            stock_updates.append({
                'id': stock_level.id,
                'item_id': item.item_id,
                'available': stock_level.quantity_available - quantity,
                'on_rent': stock_level.quantity_on_rent + quantity
            })
            
            stock_movements.append(StockMovement(
                stock_level_id=str(stock_level.id),
                item_id=str(item.item_id),
                location_id=str(transaction.location_id),
                movement_type=MovementType.RENTAL_OUT,
                reference_type=ReferenceType.TRANSACTION,
                reference_id=str(transaction.id),
                quantity_change=-quantity,
                quantity_before=stock_level.quantity_available,
                quantity_after=stock_level.quantity_available - quantity,
                reason=f"Rental transaction {transaction.transaction_number}"
            ))
        
        # Atomic stock level updates with optimistic locking
        if stock_updates:
            for stock_update in stock_updates:
                current_stock = stock_levels[stock_update['item_id']]
                
                stmt = (
                    update(StockLevel)
                    .where(
                        and_(
                            StockLevel.id == stock_update['id'],
                            StockLevel.updated_at == current_stock.updated_at
                        )
                    )
                    .values(
                        quantity_available=stock_update['available'],
                        quantity_on_rent=stock_update['on_rent'],
                        updated_at=func.now()
                    )
                )
                result = await self.session.execute(stmt)
                
                if result.rowcount == 0:
                    raise ConflictError(
                        f"Stock level for item {stock_update['item_id']} was modified by another "
                        "transaction. Please retry the rental creation."
                    )
        
        # Bulk insert stock movements
        self.session.add_all(stock_movements)

    def _format_transaction_response(self, transaction: TransactionHeader) -> Dict[str, Any]:
        """Format transaction for response."""
        return {
            "id": str(transaction.id),
            "transaction_number": transaction.transaction_number,
            "transaction_type": transaction.transaction_type.value,
            "transaction_date": transaction.transaction_date.isoformat(),
            "customer_id": transaction.customer_id,
            "location_id": transaction.location_id,
            "status": transaction.status.value,
            "payment_status": transaction.payment_status.value,
            "subtotal": float(transaction.subtotal),
            "tax_amount": float(transaction.tax_amount),
            "discount_amount": float(transaction.discount_amount),
            "total_amount": float(transaction.total_amount),
            "transaction_lines": [
                {
                    "id": str(line.id),
                    "line_number": line.line_number,
                    "item_id": line.item_id,
                    "quantity": float(line.quantity),
                    "unit_price": float(line.unit_price),
                    "line_total": float(line.line_total),
                    "description": line.description
                }
                for line in transaction.transaction_lines
            ]
        }

    # Additional methods required by routes but not yet implemented
    async def create_new_rental(self, rental_data: NewRentalRequest) -> NewRentalResponse:
        """Alias for create_rental to maintain compatibility with routes."""
        return await self.create_rental(rental_data)
    
    async def create_new_rental_optimized(self, rental_data: NewRentalRequest) -> NewRentalResponse:
        """Optimized version - for now just calls the regular create_rental."""
        return await self.create_rental(rental_data)
    
    async def get_rental_transactions(
        self,
        skip: int = 0,
        limit: int = 100,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status = None,
        rental_status = None,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        overdue_only: bool = False,
    ):
        """Get rental transactions with filtering."""
        stmt = (
            select(TransactionHeader)
            .where(TransactionHeader.transaction_type == TransactionType.RENTAL)
            .options(selectinload(TransactionHeader.transaction_lines))
        )
        
        # Add filters
        if customer_id:
            stmt = stmt.where(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            stmt = stmt.where(TransactionHeader.location_id == str(location_id))
        if status:
            stmt = stmt.where(TransactionHeader.status == status)
        if date_from:
            stmt = stmt.where(TransactionHeader.transaction_date >= date_from)
        if date_to:
            stmt = stmt.where(TransactionHeader.transaction_date <= date_to)
        
        # Add pagination
        stmt = stmt.offset(skip).limit(limit).order_by(TransactionHeader.created_at.desc())
        
        result = await self.session.execute(stmt)
        transactions = result.scalars().all()
        
        # Convert to response format
        return [
            RentalResponse(
                id=str(transaction.id),
                transaction_number=transaction.transaction_number,
                transaction_date=transaction.transaction_date.date(),
                customer_id=UUID(transaction.customer_id),
                location_id=UUID(transaction.location_id),
                status=transaction.status,
                payment_status=transaction.payment_status,
                subtotal=transaction.subtotal,
                tax_amount=transaction.tax_amount,
                discount_amount=transaction.discount_amount,
                total_amount=transaction.total_amount,
                notes=transaction.notes or "",
                created_at=transaction.created_at,
                updated_at=transaction.updated_at,
                items=[],  # TODO: Add line items
                rental_lifecycle=None  # TODO: Add rental lifecycle
            )
            for transaction in transactions
        ]
    
    async def get_rentable_items_with_availability(
        self,
        location_id: Optional[UUID] = None,
        category_id: Optional[UUID] = None,
        skip: int = 0,
        limit: int = 100,
    ):
        """Get rentable items with availability."""
        # Temporary implementation
        return []
    
    async def get_rental_by_id(self, rental_id: UUID):
        """Get rental by ID."""
        # Use the existing method
        return await self.get_rental(rental_id)
    
    async def extend_rental_period(self, rental_id: UUID, extension_data):
        """Extend rental period."""
        # Temporary implementation
        raise NotFoundError(f"Rental {rental_id} not found")
    
    async def get_rental_transactions_due_for_return(self, as_of_date: Optional[date] = None):
        """Get rental transactions due for return."""
        # Temporary implementation
        return []
    
    async def get_overdue_rentals(self, as_of_date: Optional[date] = None):
        """Get overdue rental transactions."""
        # Temporary implementation
        return []

    # Simplified getter methods
    async def get_rental(self, rental_id: UUID) -> RentalResponse:
        """Get single rental by ID."""
        transaction = await self.transaction_repository.get_with_lines(rental_id)
        if not transaction or transaction.transaction_type != TransactionType.RENTAL:
            raise NotFoundError(f"Rental {rental_id} not found")
        
        return await self._build_rental_response(transaction)

    async def get_rentals(
        self,
        skip: int = 0,
        limit: int = 100,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
    ) -> List[RentalResponse]:
        """Get rentals with basic filtering."""
        filters = [TransactionHeader.transaction_type == TransactionType.RENTAL]
        
        if customer_id:
            filters.append(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            filters.append(TransactionHeader.location_id == str(location_id))
        
        stmt = (
            select(TransactionHeader)
            .where(and_(*filters))
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
            .offset(skip)
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        transactions = result.scalars().unique().all()
        
        return [await self._build_rental_response(t) for t in transactions]

    async def _build_rental_response(self, transaction: TransactionHeader) -> RentalResponse:
        """Build rental response from transaction."""
        # Get customer and location
        customer = await self.customer_repository.get_by_id(UUID(transaction.customer_id)) if transaction.customer_id else None
        location = await self.location_repository.get_by_id(UUID(transaction.location_id)) if transaction.location_id else None
        
        # Build response
        return RentalResponse(
            id=transaction.id,
            customer={"id": customer.id, "name": customer.name} if customer else None,
            location={"id": location.id, "name": location.name} if location else None,
            transaction_date=transaction.transaction_date.date(),
            reference_number=transaction.transaction_number,
            notes=transaction.notes,
            subtotal=transaction.subtotal,
            tax_amount=transaction.tax_amount,
            discount_amount=transaction.discount_amount,
            total_amount=transaction.total_amount,
            deposit_amount=transaction.deposit_amount,
            status=transaction.status.value,
            payment_status=transaction.payment_status.value,
            delivery_required=transaction.delivery_required,
            delivery_address=transaction.delivery_address,
            delivery_date=transaction.delivery_date,
            delivery_time=transaction.delivery_time,
            pickup_required=transaction.pickup_required,
            pickup_date=transaction.pickup_date,
            pickup_time=transaction.pickup_time,
            created_at=transaction.created_at,
            updated_at=transaction.updated_at,
            items=[]
        )


===== modules/transactions/rental_returns/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental Returns Module

Handles all rental return operations including inspections, damage assessments, and deposit calculations.
"""

from app.modules.transactions.rental_returns.schemas import (
    RentalReturnLineItem,
    RentalReturnCreate,
    RentalReturnDetails,
    RentalInspectionCreate,
    RentalInspectionResponse,
    RentalReturnSummary,
    RentalDamageAssessment,
    RentalReturnFees,
    RentalReturn,
)
from app.modules.transactions.rental_returns.service import RentalReturnsService
from app.modules.transactions.rental_returns.routes import router as rental_returns_router
from app.modules.transactions.rental_returns.models import RentalInspection, RentalReturnEvent
from app.modules.transactions.rental_returns.repository import (
    RentalInspectionRepository,
    RentalReturnEventRepository,
    RentalReturnsRepository,
)

__all__ = [
    # Schemas
    "RentalReturnLineItem",
    "RentalReturnCreate",
    "RentalReturnDetails",
    "RentalInspectionCreate", 
    "RentalInspectionResponse",
    "RentalReturnSummary",
    "RentalDamageAssessment",
    "RentalReturnFees",
    "RentalReturn",
    # Service
    "RentalReturnsService",
    # Router
    "rental_returns_router",
    # Models
    "RentalInspection",
    "RentalReturnEvent",
    # Repositories
    "RentalInspectionRepository",
    "RentalReturnEventRepository", 
    "RentalReturnsRepository",
]

===== modules/transactions/rental_returns/models.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental Returns Models

Models specific to rental return operations, inspections, and lifecycle tracking.
"""

from sqlalchemy import Column, String, Text, Boolean, DateTime, Numeric, ForeignKey, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
from uuid import uuid4
from datetime import datetime

from app.db.base import BaseModel, UUIDType

# Import models from base models to avoid duplication
from app.modules.transactions.base.models import RentalInspection, RentalReturnEvent

===== modules/transactions/rental_returns/repository.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental Returns Repository

Data access layer for rental return operations.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime, date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, update, delete
from sqlalchemy.orm import selectinload

from app.modules.transactions.rental_returns.models import RentalInspection, RentalReturnEvent
from app.modules.transactions.base.models import TransactionHeader, TransactionType, TransactionStatus
from app.shared.repository import BaseRepository


class RentalInspectionRepository(BaseRepository[RentalInspection]):
    """Repository for rental inspection operations."""
    
    def __init__(self, session: AsyncSession):
        super().__init__(RentalInspection, session)
    
    async def get_by_return_id(self, return_id: UUID) -> Optional[RentalInspection]:
        """Get inspection by return transaction ID."""
        result = await self.session.execute(
            select(RentalInspection).where(
                RentalInspection.return_id == str(return_id)
            )
        )
        return result.scalar_one_or_none()
    
    async def get_by_inspector(self, inspector_id: UUID) -> List[RentalInspection]:
        """Get all inspections performed by a specific inspector."""
        result = await self.session.execute(
            select(RentalInspection).where(
                RentalInspection.inspector_id == str(inspector_id)
            ).order_by(RentalInspection.inspection_date.desc())
        )
        return result.scalars().all()
    
    async def get_pending_customer_disputes(self) -> List[RentalInspection]:
        """Get inspections with pending customer disputes."""
        result = await self.session.execute(
            select(RentalInspection).where(
                RentalInspection.customer_disputed == True
            ).order_by(RentalInspection.created_at.desc())
        )
        return result.scalars().all()
    
    async def get_by_condition(self, condition: str) -> List[RentalInspection]:
        """Get inspections by overall condition."""
        result = await self.session.execute(
            select(RentalInspection).where(
                RentalInspection.overall_condition == condition
            ).order_by(RentalInspection.inspection_date.desc())
        )
        return result.scalars().all()


class RentalReturnEventRepository(BaseRepository[RentalReturnEvent]):
    """Repository for rental return event operations."""
    
    def __init__(self, session: AsyncSession):
        super().__init__(RentalReturnEvent, session)
    
    async def get_by_rental_id(self, rental_id: UUID) -> List[RentalReturnEvent]:
        """Get all return events for a rental transaction."""
        result = await self.session.execute(
            select(RentalReturnEvent).where(
                RentalReturnEvent.rental_id == str(rental_id)
            ).order_by(RentalReturnEvent.return_date.asc())
        )
        return result.scalars().all()
    
    async def get_latest_by_rental_id(self, rental_id: UUID) -> Optional[RentalReturnEvent]:
        """Get the most recent return event for a rental."""
        result = await self.session.execute(
            select(RentalReturnEvent).where(
                RentalReturnEvent.rental_id == str(rental_id)
            ).order_by(RentalReturnEvent.return_date.desc()).limit(1)
        )
        return result.scalar_one_or_none()
    
    async def get_by_date_range(
        self, 
        date_from: Optional[date] = None, 
        date_to: Optional[date] = None
    ) -> List[RentalReturnEvent]:
        """Get return events within a date range."""
        filters = []
        
        if date_from:
            filters.append(RentalReturnEvent.return_date >= date_from)
        if date_to:
            filters.append(RentalReturnEvent.return_date <= date_to)
        
        stmt = select(RentalReturnEvent)
        if filters:
            stmt = stmt.where(and_(*filters))
        
        stmt = stmt.order_by(RentalReturnEvent.return_date.desc())
        
        result = await self.session.execute(stmt)
        return result.scalars().all()
    
    async def get_events_with_late_fees(self) -> List[RentalReturnEvent]:
        """Get return events that have late fees."""
        result = await self.session.execute(
            select(RentalReturnEvent).where(
                RentalReturnEvent.late_fee > 0
            ).order_by(RentalReturnEvent.return_date.desc())
        )
        return result.scalars().all()
    
    async def get_events_with_damage_fees(self) -> List[RentalReturnEvent]:
        """Get return events that have damage fees."""
        result = await self.session.execute(
            select(RentalReturnEvent).where(
                RentalReturnEvent.damage_fee > 0
            ).order_by(RentalReturnEvent.return_date.desc())
        )
        return result.scalars().all()
    
    async def get_events_requiring_inspection(self) -> List[RentalReturnEvent]:
        """Get return events that require inspection."""
        result = await self.session.execute(
            select(RentalReturnEvent).where(
                RentalReturnEvent.inspection_required == True
            ).order_by(RentalReturnEvent.return_date.desc())
        )
        return result.scalars().all()


class RentalReturnsRepository:
    """Main repository for rental returns operations combining inspection and event repositories."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.inspection_repo = RentalInspectionRepository(session)
        self.event_repo = RentalReturnEventRepository(session)
    
    async def get_returns_pending_inspection(self, days_old: int = 7) -> List[Dict[str, Any]]:
        """Get rental returns that are pending inspection."""
        cutoff_date = datetime.utcnow() - datetime.timedelta(days=days_old)
        
        # Query returns without inspections
        stmt = (
            select(TransactionHeader)
            .outerjoin(
                RentalInspection,
                RentalInspection.return_id == TransactionHeader.id
            )
            .where(
                and_(
                    TransactionHeader.transaction_type == TransactionType.RENTAL_RETURN,
                    TransactionHeader.transaction_date <= cutoff_date,
                    TransactionHeader.status != TransactionStatus.COMPLETED,
                    RentalInspection.id.is_(None)
                )
            )
        )
        
        result = await self.session.execute(stmt)
        returns = result.scalars().all()
        
        pending = []
        for return_txn in returns:
            metadata = return_txn.metadata or {}
            
            pending.append({
                "return_id": return_txn.id,
                "transaction_number": return_txn.transaction_number,
                "return_date": return_txn.transaction_date,
                "days_pending": (datetime.utcnow() - return_txn.transaction_date).days,
                "customer_id": return_txn.customer_id,
                "inspection_required": metadata.get("inspection_required", True),
                "total_fees": float(return_txn.total_amount or 0)
            })
        
        return pending
    
    async def get_inspection_statistics(
        self, 
        date_from: Optional[date] = None, 
        date_to: Optional[date] = None
    ) -> Dict[str, Any]:
        """Get inspection statistics for a date range."""
        filters = []
        
        if date_from:
            filters.append(RentalInspection.inspection_date >= date_from)
        if date_to:
            filters.append(RentalInspection.inspection_date <= date_to)
        
        # Base query
        base_query = select(RentalInspection)
        if filters:
            base_query = base_query.where(and_(*filters))
        
        # Total inspections
        total_result = await self.session.execute(
            select(func.count()).select_from(
                base_query.subquery()
            )
        )
        total_inspections = total_result.scalar()
        
        # Condition breakdown
        condition_result = await self.session.execute(
            select(
                RentalInspection.overall_condition,
                func.count().label('count')
            ).select_from(
                base_query.subquery()
            ).group_by(RentalInspection.overall_condition)
        )
        condition_breakdown = {row.overall_condition: row.count for row in condition_result}
        
        # Customer disputes
        disputes_result = await self.session.execute(
            select(func.count()).where(
                and_(
                    RentalInspection.customer_disputed == True,
                    *filters
                )
            )
        )
        customer_disputes = disputes_result.scalar()
        
        # Average costs
        cost_result = await self.session.execute(
            select(
                func.avg(RentalInspection.estimated_repair_cost).label('avg_repair'),
                func.avg(RentalInspection.estimated_cleaning_cost).label('avg_cleaning'),
                func.avg(RentalInspection.recommended_deposit_deduction).label('avg_deduction')
            ).select_from(
                base_query.subquery()
            )
        )
        cost_row = cost_result.first()
        
        return {
            "total_inspections": total_inspections,
            "condition_breakdown": condition_breakdown,
            "customer_disputes": customer_disputes,
            "dispute_rate": (customer_disputes / total_inspections * 100) if total_inspections > 0 else 0,
            "average_costs": {
                "repair_cost": float(cost_row.avg_repair or 0),
                "cleaning_cost": float(cost_row.avg_cleaning or 0),
                "deposit_deduction": float(cost_row.avg_deduction or 0)
            }
        }

===== modules/transactions/rental_returns/routes.py â€“ 2025-07-19 13:16:21 IST =====
"""
Rental Returns Routes

API endpoints for rental return operations.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import date
from decimal import Decimal
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.shared.dependencies import get_session
from app.modules.transactions.rental_returns.service import RentalReturnsService
from app.modules.transactions.rental_returns.schemas import (
    RentalReturn,
    RentalReturnCreate,
    RentalReturnDetails,
    RentalInspectionCreate,
    RentalInspectionResponse,
    RentalReturnSummary,
    RentalDamageAssessment,
    RentalReturnFees,
)
from app.modules.transactions.schemas import TransactionWithLinesResponse
from app.core.errors import NotFoundError, ValidationError, ConflictError


router = APIRouter(tags=["rental-returns"])


def get_rental_returns_service(session: AsyncSession = Depends(get_session)) -> RentalReturnsService:
    """Get rental returns service instance."""
    return RentalReturnsService(session)


@router.post("/", response_model=TransactionWithLinesResponse, status_code=status.HTTP_201_CREATED)
async def create_rental_return(
    return_data: RentalReturnCreate,
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """
    Create a rental return transaction.
    
    This endpoint processes rental returns, including:
    - Late fee calculations
    - Damage assessments
    - Cleaning fees
    - Deposit calculations and refunds
    - Inspection requirements
    """
    try:
        return await service.create_rental_return(return_data)
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating rental return: {str(e)}"
        )


@router.post("/{rental_id}/quick-return", response_model=Dict[str, Any])
async def quick_rental_return(
    rental_id: UUID,
    return_data: RentalReturn,
    service: RentalReturnsService = Depends(get_rental_returns_service),
):
    """
    Quick rental return for simple cases.
    
    Use this endpoint for straightforward returns without detailed inspection.
    """
    try:
        return await service.quick_rental_return(rental_id, return_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


@router.get("/{return_id}", response_model=RentalReturnDetails)
async def get_rental_return_details(
    return_id: UUID,
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """
    Get comprehensive rental return details.
    
    Returns all information about a rental return transaction,
    including fees, damages, and inspection results.
    """
    try:
        return await service.get_rental_return_details(return_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/{return_id}/summary", response_model=RentalReturnSummary)
async def get_rental_return_summary(
    return_id: UUID,
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """
    Get financial summary of rental return.
    
    Provides a breakdown of all fees, deductions, and refunds.
    """
    try:
        return await service.get_rental_return_summary(return_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.post("/{return_id}/inspection", response_model=RentalInspectionResponse)
async def create_rental_inspection(
    return_id: UUID,
    inspection_data: RentalInspectionCreate,
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """
    Submit inspection results for a rental return.
    
    This endpoint allows recording inspection findings for rental returns,
    including damage assessments and repair cost estimates.
    """
    try:
        # Ensure return_id matches
        inspection_data.return_id = return_id
        return await service.create_rental_inspection(inspection_data)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/{return_id}/inspection", response_model=RentalInspectionResponse)
async def get_rental_inspection(
    return_id: UUID,
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """
    Get inspection results for a rental return.
    
    This endpoint retrieves existing inspection data for a rental return.
    """
    try:
        inspection = await service.get_rental_inspection(return_id)
        if not inspection:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="No inspection found for this return"
            )
        return inspection
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting rental inspection: {str(e)}"
        )


@router.put("/{return_id}/inspection", response_model=RentalInspectionResponse)
async def update_rental_inspection(
    return_id: UUID,
    inspection_data: RentalInspectionCreate,
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """Update existing rental inspection."""
    try:
        inspection_data.return_id = return_id
        return await service.update_rental_inspection(inspection_data)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/{return_id}/damages", response_model=List[RentalDamageAssessment])
async def get_damage_assessments(
    return_id: UUID,
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """Get all damage assessments for a rental return."""
    try:
        return await service.get_damage_assessments(return_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/{return_id}/fees", response_model=RentalReturnFees)
async def get_rental_return_fees(
    return_id: UUID,
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """Get detailed fee breakdown for a rental return."""
    try:
        return await service.calculate_rental_return_fees(return_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.post("/{return_id}/approve-deposit-refund", response_model=Dict[str, Any])
async def approve_deposit_refund(
    return_id: UUID,
    approved_by: UUID = Query(..., description="User approving the refund"),
    refund_amount: Optional[Decimal] = Query(None, description="Override refund amount"),
    notes: Optional[str] = Query(None, description="Approval notes"),
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """
    Approve deposit refund for rental return.
    
    This finalizes the deposit refund amount and updates the return status.
    """
    try:
        return await service.approve_deposit_refund(
            return_id=return_id,
            approved_by=approved_by,
            refund_amount=refund_amount,
            notes=notes
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/reports/pending-inspections", response_model=List[Dict[str, Any]])
async def get_pending_inspections(
    days_old: int = Query(7, description="Returns older than X days"),
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """Get rental returns pending inspection."""
    return await service.get_pending_inspections(days_old)


@router.get("/reports/deposit-summary")
async def get_deposit_summary(
    date_from: Optional[date] = Query(None, description="Start date"),
    date_to: Optional[date] = Query(None, description="End date"),
    service: RentalReturnsService = Depends(get_rental_returns_service)
):
    """Get summary of deposit refunds and deductions."""
    return await service.get_deposit_summary(date_from, date_to)

===== modules/transactions/rental_returns/schemas.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental Returns Schemas

Schemas for rental return transactions, inspections, and damage assessments.
"""

from typing import Literal, Optional, List, Dict, Any
from datetime import datetime, date
from decimal import Decimal
from pydantic import BaseModel, Field, field_validator, model_validator
from uuid import UUID


# Rental return specific line item
class RentalReturnLineItem(BaseModel):
    """Rental return specific line item properties."""
    
    original_line_id: UUID = Field(..., description="Original transaction line ID")
    return_quantity: Decimal = Field(..., gt=0, description="Quantity to return")
    return_reason: Optional[str] = Field(None, description="Item-specific return reason")
    condition_on_return: Literal["EXCELLENT", "GOOD", "FAIR", "POOR", "DAMAGED"] = Field(...)
    damage_description: Optional[str] = Field(None, description="Damage description")
    damage_photos: Optional[List[str]] = Field(default_factory=list, description="Damage photo URLs")
    cleaning_condition: Literal["CLEAN", "MINOR_CLEANING", "MAJOR_CLEANING"] = Field(...)
    functionality_check: Literal["WORKING", "PARTIAL", "NOT_WORKING"] = Field(...)
    missing_accessories: Optional[List[str]] = Field(default_factory=list)
    estimated_repair_cost: Optional[Decimal] = Field(None, ge=0)
    beyond_normal_wear: bool = Field(default=False)


# Rental return create schema
class RentalReturnCreate(BaseModel):
    """Rental return creation schema."""
    
    # Core return information
    original_transaction_id: UUID = Field(..., description="Original rental transaction to return against")
    return_date: datetime = Field(default_factory=datetime.utcnow)
    return_reason_code: str = Field(..., max_length=50, description="Standardized return reason code")
    return_reason_notes: Optional[str] = Field(None, max_length=1000, description="Additional return notes")
    processed_by: Optional[UUID] = Field(None, description="User processing the return")
    
    # Rental-specific properties
    scheduled_return_date: date = Field(..., description="When it was supposed to be returned")
    actual_return_date: date = Field(..., description="When it was actually returned")
    late_fee_applicable: bool = Field(default=False)
    late_fee_amount: Optional[Decimal] = Field(None, ge=0)
    damage_assessment_required: bool = Field(default=True)
    cleaning_required: bool = Field(default=False)
    cleaning_fee: Optional[Decimal] = Field(None, ge=0)
    deposit_amount: Decimal = Field(..., ge=0, description="Original deposit")
    deposit_deductions: Optional[Decimal] = Field(default=Decimal("0"), ge=0)
    deposit_refund_amount: Optional[Decimal] = Field(None, ge=0)
    inspection_checklist: Optional[Dict[str, Any]] = Field(None)
    photos_required: bool = Field(default=True)
    photo_urls: Optional[List[str]] = Field(default_factory=list)
    
    # Line items
    return_items: List[RentalReturnLineItem] = Field(..., min_length=1, description="Items to return")
    
    @field_validator('actual_return_date')
    @classmethod
    def validate_return_date(cls, v, info):
        """Validate actual return date is not in future."""
        if v > date.today():
            raise ValueError("Actual return date cannot be in the future")
        return v
    
    @model_validator(mode='after')
    def validate_late_fee(self):
        """Validate late fee consistency."""
        if self.actual_return_date > self.scheduled_return_date:
            self.late_fee_applicable = True
            if not self.late_fee_amount or self.late_fee_amount == 0:
                # Calculate default late fee if not provided
                days_late = (self.actual_return_date - self.scheduled_return_date).days
                self.late_fee_amount = Decimal(str(days_late * 10))  # $10 per day default
        return self
    
    @model_validator(mode='after')
    def validate_photos(self):
        """Validate photos are provided when required."""
        if self.photos_required and self.damage_assessment_required:
            has_damage = any(
                item.condition_on_return in ["POOR", "DAMAGED"] 
                for item in self.return_items
            )
            if has_damage and not self.photo_urls:
                raise ValueError("Photos required for damaged items")
        return self


# Simple rental return schema (for basic returns)
class RentalReturn(BaseModel):
    """Simple rental return schema for basic return operations."""
    
    actual_return_date: date = Field(..., description="Actual return date")
    late_fees: Optional[Decimal] = Field(None, ge=0, description="Late fees if applicable")
    damage_fees: Optional[Decimal] = Field(None, ge=0, description="Damage fees if applicable")
    notes: Optional[str] = Field(None, description="Return notes")


# Rental inspection schemas
class RentalInspectionCreate(BaseModel):
    """Create a rental inspection record."""
    
    return_id: UUID = Field(..., description="Return transaction ID")
    inspector_id: UUID = Field(..., description="Inspector user ID")
    inspection_date: datetime = Field(default_factory=datetime.utcnow)
    overall_condition: Literal["EXCELLENT", "GOOD", "FAIR", "POOR", "DAMAGED"] = Field(...)
    cleanliness_rating: int = Field(..., ge=1, le=5, description="Cleanliness rating 1-5")
    functionality_rating: int = Field(..., ge=1, le=5, description="Functionality rating 1-5")
    
    # Detailed findings
    damage_findings: Optional[List[Dict[str, Any]]] = Field(default_factory=list)
    missing_items: Optional[List[Dict[str, Any]]] = Field(default_factory=list)
    repair_recommendations: Optional[List[Dict[str, Any]]] = Field(default_factory=list)
    
    # Financial assessments
    estimated_repair_cost: Decimal = Field(default=Decimal("0"), ge=0)
    estimated_cleaning_cost: Decimal = Field(default=Decimal("0"), ge=0)
    recommended_deposit_deduction: Decimal = Field(default=Decimal("0"), ge=0)
    
    # Documentation
    inspection_photos: Optional[List[str]] = Field(default_factory=list)
    inspection_notes: Optional[str] = Field(None, max_length=2000)
    customer_signature: Optional[str] = Field(None, description="Digital signature or acknowledgment")
    customer_disputed: bool = Field(default=False)
    dispute_notes: Optional[str] = Field(None)


class RentalInspectionResponse(BaseModel):
    """Rental inspection response."""
    
    id: UUID
    return_id: UUID
    inspector_id: UUID
    inspection_date: datetime
    overall_condition: str
    cleanliness_rating: int
    functionality_rating: int
    damage_findings: List[Dict[str, Any]]
    missing_items: List[Dict[str, Any]]
    repair_recommendations: List[Dict[str, Any]]
    estimated_repair_cost: Decimal
    estimated_cleaning_cost: Decimal
    recommended_deposit_deduction: Decimal
    inspection_photos: List[str]
    inspection_notes: Optional[str]
    customer_signature: Optional[str]
    customer_disputed: bool
    dispute_notes: Optional[str]
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


# Rental return response schemas
class RentalReturnDetails(BaseModel):
    """Rental return specific details for response."""
    
    scheduled_return_date: date
    actual_return_date: date
    days_late: int
    late_fee_applicable: bool
    late_fee_amount: Decimal
    damage_assessment_required: bool
    cleaning_required: bool
    cleaning_fee: Decimal
    deposit_amount: Decimal
    deposit_deductions: Decimal
    deposit_refund_amount: Decimal
    total_fees: Decimal
    inspection_completed: bool
    inspection_id: Optional[UUID]
    photos_urls: List[str]


class RentalReturnSummary(BaseModel):
    """Summary of rental return financial calculations."""
    
    original_rental_amount: Decimal
    deposit_amount: Decimal
    late_fees: Decimal
    damage_fees: Decimal
    cleaning_fees: Decimal
    other_fees: Decimal
    total_deductions: Decimal
    deposit_refund: Decimal
    amount_due: Decimal
    payment_status: str


class RentalDamageAssessment(BaseModel):
    """Damage assessment details."""
    
    item_id: UUID
    item_name: str
    damage_type: str
    severity: Literal["MINOR", "MODERATE", "SEVERE"]
    repair_cost: Decimal
    replacement_cost: Decimal
    recommended_action: Literal["REPAIR", "REPLACE", "WRITE_OFF"]
    photos: List[str]
    notes: Optional[str]


class RentalReturnFees(BaseModel):
    """Breakdown of all rental return fees."""
    
    late_fee: Decimal = Field(default=Decimal("0"))
    damage_fee: Decimal = Field(default=Decimal("0"))
    cleaning_fee: Decimal = Field(default=Decimal("0"))
    missing_item_fee: Decimal = Field(default=Decimal("0"))
    administrative_fee: Decimal = Field(default=Decimal("0"))
    total_fees: Decimal = Field(default=Decimal("0"))
    
    @model_validator(mode='after')
    def calculate_total(self):
        """Calculate total fees."""
        self.total_fees = (
            self.late_fee + 
            self.damage_fee + 
            self.cleaning_fee + 
            self.missing_item_fee + 
            self.administrative_fee
        )
        return self

===== modules/transactions/rental_returns/service.py â€“ 2025-07-21 18:30:47 IST =====
"""
Rental Returns Service

Business logic for rental return operations.
"""

from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, update
from sqlalchemy.orm import selectinload

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionLine,
    TransactionType,
    TransactionStatus,
    PaymentStatus,
    RentalStatus,
)
from app.modules.transactions.rental_returns.models import RentalInspection, RentalReturnEvent
from app.modules.transactions.base.repository import TransactionHeaderRepository, TransactionLineRepository
from app.modules.transactions.rental_returns.schemas import (
    RentalReturn,
    RentalReturnCreate,
    RentalReturnDetails,
    RentalInspectionCreate,
    RentalInspectionResponse,
    RentalReturnSummary,
    RentalDamageAssessment,
    RentalReturnFees,
)
from app.modules.transactions.rentals.services import RentalsService
from app.modules.customers.repository import CustomerRepository
from app.modules.inventory import InventoryUnitRepository, StockLevelRepository
from app.modules.inventory import StockLevel, StockMovement, MovementType, ReferenceType
from app.modules.master_data.locations.repository import LocationRepository
from app.core.logger import get_purchase_logger


class RentalReturnsService:
    """Service for rental return operations."""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.transaction_repository = TransactionHeaderRepository(session)
        self.line_repository = TransactionLineRepository(session)
        self.customer_repository = CustomerRepository(session)
        self.item_repository = InventoryUnitRepository(session)
        self.stock_level_repository = StockLevelRepository(session)
        self.location_repository = LocationRepository(session)
        self.rentals_service = RentalsService(session)
        self.logger = get_purchase_logger()

    async def create_rental_return(self, return_data: RentalReturnCreate) -> TransactionHeader:
        """
        Create a comprehensive rental return transaction.
        
        This handles:
        - Creating return transaction
        - Calculating all fees
        - Processing deposit deductions
        - Updating inventory
        - Recording return events
        """
        try:
            # Get original rental transaction
            original_transaction = await self.transaction_repository.get_with_lines(
                return_data.original_transaction_id
            )
            
            if not original_transaction:
                raise NotFoundError(f"Original transaction {return_data.original_transaction_id} not found")
            
            if original_transaction.transaction_type != TransactionType.RENTAL:
                raise ValidationError("Original transaction is not a rental")
            
            # Calculate fees
            fees = self._calculate_return_fees(return_data, original_transaction)
            
            # Create return transaction
            async with self.session.begin():
                # Generate return transaction number
                return_number = await self._generate_return_number("RET")
                
                # Create return transaction header
                return_transaction = TransactionHeader(
                    transaction_number=return_number,
                    transaction_type=TransactionType.RENTAL_RETURN,
                    transaction_date=return_data.return_date,
                    customer_id=original_transaction.customer_id,
                    location_id=original_transaction.location_id,
                    status=TransactionStatus.PENDING,
                    reference_transaction_id=str(original_transaction.id),
                    notes=return_data.return_reason_notes or "",
                    
                    # Financial details
                    subtotal=Decimal("0"),
                    discount_amount=Decimal("0"),
                    tax_amount=Decimal("0"),
                    total_amount=fees.total_fees,
                    deposit_amount=return_data.deposit_amount,
                    deposit_refund_amount=return_data.deposit_refund_amount,
                    
                    # Metadata for rental return specifics
                    metadata={
                        "return_type": "RENTAL_RETURN",
                        "scheduled_return_date": str(return_data.scheduled_return_date),
                        "actual_return_date": str(return_data.actual_return_date),
                        "days_late": (return_data.actual_return_date - return_data.scheduled_return_date).days,
                        "late_fee_amount": str(fees.late_fee),
                        "damage_fee_amount": str(fees.damage_fee),
                        "cleaning_fee_amount": str(fees.cleaning_fee),
                        "deposit_deductions": str(return_data.deposit_deductions),
                        "inspection_required": return_data.damage_assessment_required,
                        "photos_urls": return_data.photo_urls,
                    },
                    
                    is_active=True,
                )
                self.session.add(return_transaction)
                await self.session.flush()
                
                # Process return items
                for idx, item in enumerate(return_data.return_items):
                    # Get original line
                    original_line = next(
                        (line for line in original_transaction.transaction_lines 
                         if str(line.id) == str(item.original_line_id)),
                        None
                    )
                    
                    if not original_line:
                        raise NotFoundError(f"Original line {item.original_line_id} not found")
                    
                    # Create return line
                    return_line = TransactionLine(
                        transaction_id=str(return_transaction.id),
                        line_number=idx + 1,
                        line_type=original_line.line_type,
                        item_id=original_line.item_id,
                        description=f"Return: {original_line.description}",
                        quantity=item.return_quantity,
                        unit_price=original_line.unit_price,
                        line_total=Decimal("0"),  # Returns typically have negative or zero line totals
                        
                        # Return specific fields
                        returned_quantity=item.return_quantity,
                        return_date=return_data.actual_return_date,
                        return_condition=item.condition_on_return[0],  # First letter for code
                        current_rental_status=RentalStatus.COMPLETED,
                        
                        # Metadata for item-specific return details
                        metadata={
                            "condition_on_return": item.condition_on_return,
                            "damage_description": item.damage_description,
                            "damage_photos": item.damage_photos,
                            "cleaning_condition": item.cleaning_condition,
                            "functionality_check": item.functionality_check,
                            "missing_accessories": item.missing_accessories,
                            "estimated_repair_cost": str(item.estimated_repair_cost) if item.estimated_repair_cost else None,
                            "beyond_normal_wear": item.beyond_normal_wear,
                        },
                        
                        is_active=True,
                    )
                    self.session.add(return_line)
                    
                    # Update original line
                    original_line.returned_quantity = (original_line.returned_quantity or Decimal("0")) + item.return_quantity
                    original_line.return_date = return_data.actual_return_date
                    original_line.current_rental_status = RentalStatus.COMPLETED
                    
                    # Update inventory
                    await self._update_inventory_for_return(
                        item_id=UUID(original_line.item_id),
                        location_id=UUID(original_transaction.location_id),
                        quantity=item.return_quantity,
                        condition=item.condition_on_return,
                        transaction_id=return_transaction.id
                    )
                
                # Create return event
                return_event = RentalReturnEvent(
                    rental_id=str(original_transaction.id),
                    return_date=return_data.actual_return_date,
                    days_late=(return_data.actual_return_date - return_data.scheduled_return_date).days,
                    late_fee=fees.late_fee,
                    damage_fee=fees.damage_fee,
                    cleaning_fee=fees.cleaning_fee,
                    total_deductions=fees.total_fees,
                    deposit_refund=return_data.deposit_refund_amount or Decimal("0"),
                    inspection_required=return_data.damage_assessment_required,
                    processed_by=str(return_data.processed_by) if return_data.processed_by else None,
                )
                self.session.add(return_event)
                
                # Update original transaction status
                all_returned = all(
                    line.returned_quantity >= line.quantity 
                    for line in original_transaction.transaction_lines
                )
                
                if all_returned:
                    original_transaction.status = TransactionStatus.COMPLETED
                else:
                    original_transaction.status = TransactionStatus.PARTIAL
            
            # Return the complete transaction
            return await self.transaction_repository.get_with_lines(return_transaction.id)
            
        except Exception as e:
            self.logger.log_debug_info("Error creating rental return", {"error": str(e)})
            await self.session.rollback()
            raise

    async def quick_rental_return(self, rental_id: UUID, return_data: RentalReturn) -> Dict[str, Any]:
        """
        Quick rental return for simple cases.
        
        This is a simplified version that doesn't create a full return transaction.
        """
        try:
            # Get the rental transaction
            transaction = await self.transaction_repository.get_with_lines(rental_id)
            
            if not transaction:
                raise NotFoundError(f"Rental transaction {rental_id} not found")
            
            # Verify it's a rental transaction
            if transaction.transaction_type != TransactionType.RENTAL:
                raise ValidationError(f"Transaction {rental_id} is not a rental")
            
            # Process return for each line
            async with self.session.begin():
                for line in transaction.transaction_lines:
                    if line.returned_quantity < line.quantity:
                        # Update returned quantity
                        line.returned_quantity = line.quantity
                        line.return_date = return_data.actual_return_date
                        line.return_condition = "A"  # Default to good condition
                        line.current_rental_status = RentalStatus.COMPLETED
                        
                        # Update stock levels
                        stock_level = await self.stock_level_repository.get_by_item_location(
                            UUID(line.item_id), UUID(transaction.location_id)
                        )
                        
                        if stock_level:
                            stock_level.available_quantity += line.quantity
                            stock_level.on_rent_quantity -= line.quantity
                            
                            # Create stock movement
                            movement = StockMovement(
                                stock_level_id=stock_level.id,
                                item_id=line.item_id,
                                location_id=transaction.location_id,
                                movement_type=MovementType.RENTAL_RETURN.value,
                                reference_type=ReferenceType.TRANSACTION.value,
                                reference_id=str(transaction.id),
                                quantity_change=line.quantity,
                                quantity_before=stock_level.available_quantity - line.quantity,
                                quantity_after=stock_level.available_quantity,
                                reason=f"Rental return - Transaction {transaction.transaction_number}",
                                notes=return_data.notes or ""
                            )
                            self.session.add(movement)
                
                # Update transaction status
                transaction.status = TransactionStatus.COMPLETED
                
                # Apply any fees
                if return_data.late_fees:
                    transaction.total_amount += return_data.late_fees
                if return_data.damage_fees:
                    transaction.total_amount += return_data.damage_fees
            
            return {
                "success": True,
                "message": "Rental return completed successfully",
                "transaction_id": transaction.id,
                "late_fees": float(return_data.late_fees or 0),
                "damage_fees": float(return_data.damage_fees or 0)
            }
            
        except Exception as e:
            self.logger.log_debug_info("Error completing rental return", {"error": str(e)})
            await self.session.rollback()
            raise

    async def get_rental_return_details(self, return_id: UUID) -> RentalReturnDetails:
        """Get comprehensive rental return details."""
        try:
            # Get return transaction
            return_txn = await self.transaction_repository.get_with_lines(return_id)
            
            if not return_txn or return_txn.transaction_type != TransactionType.RENTAL_RETURN:
                raise NotFoundError(f"Rental return {return_id} not found")
            
            # Get metadata
            metadata = return_txn.metadata or {}
            
            # Check if inspection exists
            inspection = await self.session.execute(
                select(RentalInspection).where(
                    RentalInspection.return_id == str(return_id)
                )
            )
            inspection_result = inspection.scalar_one_or_none()
            
            return RentalReturnDetails(
                scheduled_return_date=date.fromisoformat(metadata.get("scheduled_return_date", str(date.today()))),
                actual_return_date=date.fromisoformat(metadata.get("actual_return_date", str(date.today()))),
                days_late=metadata.get("days_late", 0),
                late_fee_applicable=metadata.get("days_late", 0) > 0,
                late_fee_amount=Decimal(metadata.get("late_fee_amount", "0")),
                damage_assessment_required=metadata.get("inspection_required", False),
                cleaning_required=Decimal(metadata.get("cleaning_fee_amount", "0")) > 0,
                cleaning_fee=Decimal(metadata.get("cleaning_fee_amount", "0")),
                deposit_amount=return_txn.deposit_amount or Decimal("0"),
                deposit_deductions=Decimal(metadata.get("deposit_deductions", "0")),
                deposit_refund_amount=return_txn.deposit_refund_amount or Decimal("0"),
                total_fees=return_txn.total_amount or Decimal("0"),
                inspection_completed=inspection_result is not None,
                inspection_id=UUID(inspection_result.id) if inspection_result else None,
                photos_urls=metadata.get("photos_urls", [])
            )
            
        except Exception as e:
            self.logger.log_debug_info("Error getting rental return details", {"error": str(e)})
            raise

    async def get_rental_return_summary(self, return_id: UUID) -> RentalReturnSummary:
        """Get financial summary of rental return."""
        try:
            # Get return transaction
            return_txn = await self.transaction_repository.get_with_lines(return_id)
            
            if not return_txn or return_txn.transaction_type != TransactionType.RENTAL_RETURN:
                raise NotFoundError(f"Rental return {return_id} not found")
            
            # Get original rental transaction
            original_txn = None
            if return_txn.reference_transaction_id:
                original_txn = await self.transaction_repository.get_by_id(
                    UUID(return_txn.reference_transaction_id)
                )
            
            # Get metadata
            metadata = return_txn.metadata or {}
            
            # Calculate amounts
            late_fees = Decimal(metadata.get("late_fee_amount", "0"))
            damage_fees = Decimal(metadata.get("damage_fee_amount", "0"))
            cleaning_fees = Decimal(metadata.get("cleaning_fee_amount", "0"))
            other_fees = Decimal("0")  # Could include administrative fees, etc.
            
            total_deductions = late_fees + damage_fees + cleaning_fees + other_fees
            deposit_refund = (return_txn.deposit_amount or Decimal("0")) - total_deductions
            
            # Amount due calculation
            amount_due = total_deductions - (return_txn.deposit_amount or Decimal("0"))
            if amount_due < 0:
                amount_due = Decimal("0")
            
            return RentalReturnSummary(
                original_rental_amount=original_txn.total_amount if original_txn else Decimal("0"),
                deposit_amount=return_txn.deposit_amount or Decimal("0"),
                late_fees=late_fees,
                damage_fees=damage_fees,
                cleaning_fees=cleaning_fees,
                other_fees=other_fees,
                total_deductions=total_deductions,
                deposit_refund=max(deposit_refund, Decimal("0")),
                amount_due=amount_due,
                payment_status=return_txn.payment_status.value if return_txn.payment_status else "PENDING"
            )
            
        except Exception as e:
            self.logger.log_debug_info("Error getting rental return summary", {"error": str(e)})
            raise

    async def create_rental_inspection(self, inspection_data: RentalInspectionCreate) -> RentalInspectionResponse:
        """Create rental inspection record."""
        try:
            # Verify return exists
            return_txn = await self.transaction_repository.get_by_id(inspection_data.return_id)
            
            if not return_txn or return_txn.transaction_type != TransactionType.RENTAL_RETURN:
                raise NotFoundError(f"Rental return {inspection_data.return_id} not found")
            
            async with self.session.begin():
                # Create inspection
                inspection = RentalInspection(
                    return_id=str(inspection_data.return_id),
                    inspector_id=str(inspection_data.inspector_id),
                    inspection_date=inspection_data.inspection_date,
                    overall_condition=inspection_data.overall_condition,
                    cleanliness_rating=inspection_data.cleanliness_rating,
                    functionality_rating=inspection_data.functionality_rating,
                    damage_findings=inspection_data.damage_findings,
                    missing_items=inspection_data.missing_items,
                    repair_recommendations=inspection_data.repair_recommendations,
                    estimated_repair_cost=inspection_data.estimated_repair_cost,
                    estimated_cleaning_cost=inspection_data.estimated_cleaning_cost,
                    recommended_deposit_deduction=inspection_data.recommended_deposit_deduction,
                    inspection_photos=inspection_data.inspection_photos,
                    inspection_notes=inspection_data.inspection_notes,
                    customer_signature=inspection_data.customer_signature,
                    customer_disputed=inspection_data.customer_disputed,
                    dispute_notes=inspection_data.dispute_notes,
                )
                self.session.add(inspection)
                await self.session.flush()
                
                # Update return transaction status
                return_txn.status = TransactionStatus.PROCESSING
                
                # Update deposit deductions if recommended
                if inspection_data.recommended_deposit_deduction > 0:
                    deposit_refund = (return_txn.deposit_amount or Decimal("0")) - inspection_data.recommended_deposit_deduction
                    return_txn.deposit_refund_amount = max(deposit_refund, Decimal("0"))
            
            return RentalInspectionResponse.model_validate(inspection)
            
        except Exception as e:
            self.logger.log_debug_info("Error creating rental inspection", {"error": str(e)})
            await self.session.rollback()
            raise

    async def get_rental_inspection(self, return_id: UUID) -> Optional[RentalInspectionResponse]:
        """Get rental inspection for a return."""
        try:
            result = await self.session.execute(
                select(RentalInspection).where(
                    RentalInspection.return_id == str(return_id)
                )
            )
            inspection = result.scalar_one_or_none()
            
            if inspection:
                return RentalInspectionResponse.model_validate(inspection)
            return None
            
        except Exception as e:
            self.logger.log_debug_info("Error getting rental inspection", {"error": str(e)})
            raise

    async def update_rental_inspection(self, inspection_data: RentalInspectionCreate) -> RentalInspectionResponse:
        """Update existing rental inspection."""
        try:
            # Get existing inspection
            result = await self.session.execute(
                select(RentalInspection).where(
                    RentalInspection.return_id == str(inspection_data.return_id)
                )
            )
            inspection = result.scalar_one_or_none()
            
            if not inspection:
                # Create new if doesn't exist
                return await self.create_rental_inspection(inspection_data)
            
            # Update existing
            async with self.session.begin():
                for key, value in inspection_data.model_dump(exclude={'return_id'}).items():
                    setattr(inspection, key, value)
                
                inspection.updated_at = datetime.utcnow()
            
            return RentalInspectionResponse.model_validate(inspection)
            
        except Exception as e:
            self.logger.log_debug_info("Error updating rental inspection", {"error": str(e)})
            await self.session.rollback()
            raise

    async def get_damage_assessments(self, return_id: UUID) -> List[RentalDamageAssessment]:
        """Get damage assessments from return lines."""
        try:
            # Get return transaction with lines
            return_txn = await self.transaction_repository.get_with_lines(return_id)
            
            if not return_txn or return_txn.transaction_type != TransactionType.RENTAL_RETURN:
                raise NotFoundError(f"Rental return {return_id} not found")
            
            assessments = []
            
            for line in return_txn.transaction_lines:
                metadata = line.metadata or {}
                
                # Check if item has damage
                if metadata.get("condition_on_return") in ["POOR", "DAMAGED"]:
                    # Get item details
                    item = await self.item_repository.get_by_id(UUID(line.item_id))
                    
                    if item:
                        # Determine severity
                        severity = "MINOR"
                        if metadata.get("beyond_normal_wear"):
                            severity = "SEVERE"
                        elif metadata.get("functionality_check") == "NOT_WORKING":
                            severity = "MODERATE"
                        
                        # Determine action
                        repair_cost = Decimal(metadata.get("estimated_repair_cost", "0"))
                        replacement_cost = item.unit_cost or Decimal("0")
                        
                        recommended_action = "REPAIR"
                        if repair_cost > replacement_cost * Decimal("0.7"):
                            recommended_action = "REPLACE"
                        elif metadata.get("functionality_check") == "NOT_WORKING" and repair_cost > replacement_cost * Decimal("0.5"):
                            recommended_action = "WRITE_OFF"
                        
                        assessment = RentalDamageAssessment(
                            item_id=UUID(line.item_id),
                            item_name=item.item_name,
                            damage_type=metadata.get("damage_description", "General damage"),
                            severity=severity,
                            repair_cost=repair_cost,
                            replacement_cost=replacement_cost,
                            recommended_action=recommended_action,
                            photos=metadata.get("damage_photos", []),
                            notes=metadata.get("damage_description")
                        )
                        assessments.append(assessment)
            
            return assessments
            
        except Exception as e:
            self.logger.log_debug_info("Error getting damage assessments", {"error": str(e)})
            raise

    async def calculate_rental_return_fees(self, return_id: UUID) -> RentalReturnFees:
        """Calculate detailed fee breakdown for a rental return."""
        try:
            # Get return transaction
            return_txn = await self.transaction_repository.get_with_lines(return_id)
            
            if not return_txn or return_txn.transaction_type != TransactionType.RENTAL_RETURN:
                raise NotFoundError(f"Rental return {return_id} not found")
            
            # Get metadata
            metadata = return_txn.metadata or {}
            
            # Get inspection if exists
            inspection = await self.get_rental_inspection(return_id)
            
            # Calculate fees
            late_fee = Decimal(metadata.get("late_fee_amount", "0"))
            damage_fee = Decimal(metadata.get("damage_fee_amount", "0"))
            cleaning_fee = Decimal(metadata.get("cleaning_fee_amount", "0"))
            
            # Calculate missing item fees
            missing_item_fee = Decimal("0")
            for line in return_txn.transaction_lines:
                line_metadata = line.metadata or {}
                missing_accessories = line_metadata.get("missing_accessories", [])
                if missing_accessories:
                    # Estimate $10 per missing accessory (could be item-specific)
                    missing_item_fee += Decimal(str(len(missing_accessories) * 10))
            
            # Administrative fee (if applicable)
            administrative_fee = Decimal("0")
            if metadata.get("days_late", 0) > 7:
                administrative_fee = Decimal("25")  # Late processing fee
            
            return RentalReturnFees(
                late_fee=late_fee,
                damage_fee=damage_fee,
                cleaning_fee=cleaning_fee,
                missing_item_fee=missing_item_fee,
                administrative_fee=administrative_fee
            )
            
        except Exception as e:
            self.logger.log_debug_info("Error calculating rental return fees", {"error": str(e)})
            raise

    async def approve_deposit_refund(
        self,
        return_id: UUID,
        approved_by: UUID,
        refund_amount: Optional[Decimal] = None,
        notes: Optional[str] = None
    ) -> Dict[str, Any]:
        """Approve deposit refund for rental return."""
        try:
            # Get return transaction
            return_txn = await self.transaction_repository.get_by_id(return_id)
            
            if not return_txn or return_txn.transaction_type != TransactionType.RENTAL_RETURN:
                raise NotFoundError(f"Rental return {return_id} not found")
            
            async with self.session.begin():
                # Update refund amount if provided
                if refund_amount is not None:
                    return_txn.deposit_refund_amount = refund_amount
                
                # Update status
                return_txn.status = TransactionStatus.COMPLETED
                
                # Add approval to metadata
                metadata = return_txn.metadata or {}
                metadata["deposit_approved"] = True
                metadata["deposit_approved_by"] = str(approved_by)
                metadata["deposit_approved_at"] = datetime.utcnow().isoformat()
                if notes:
                    metadata["deposit_approval_notes"] = notes
                return_txn.metadata = metadata
            
            return {
                "success": True,
                "message": "Deposit refund approved",
                "return_id": return_id,
                "refund_amount": float(return_txn.deposit_refund_amount or 0),
                "approved_by": approved_by,
                "approved_at": datetime.utcnow()
            }
            
        except Exception as e:
            self.logger.log_debug_info("Error approving deposit refund", {"error": str(e)})
            await self.session.rollback()
            raise

    async def get_pending_inspections(self, days_old: int = 7) -> List[Dict[str, Any]]:
        """Get rental returns pending inspection."""
        try:
            cutoff_date = datetime.utcnow() - timedelta(days=days_old)
            
            # Query returns without inspections
            stmt = (
                select(TransactionHeader)
                .outerjoin(
                    RentalInspection,
                    RentalInspection.return_id == TransactionHeader.id
                )
                .where(
                    and_(
                        TransactionHeader.transaction_type == TransactionType.RENTAL_RETURN,
                        TransactionHeader.transaction_date <= cutoff_date,
                        TransactionHeader.status != TransactionStatus.COMPLETED,
                        RentalInspection.id.is_(None)
                    )
                )
            )
            
            result = await self.session.execute(stmt)
            returns = result.scalars().all()
            
            pending = []
            for return_txn in returns:
                metadata = return_txn.metadata or {}
                
                pending.append({
                    "return_id": return_txn.id,
                    "transaction_number": return_txn.transaction_number,
                    "return_date": return_txn.transaction_date,
                    "days_pending": (datetime.utcnow() - return_txn.transaction_date).days,
                    "customer_id": return_txn.customer_id,
                    "inspection_required": metadata.get("inspection_required", True),
                    "total_fees": float(return_txn.total_amount or 0)
                })
            
            return pending
            
        except Exception as e:
            self.logger.log_debug_info("Error getting pending inspections", {"error": str(e)})
            raise

    async def get_deposit_summary(
        self,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None
    ) -> Dict[str, Any]:
        """Get summary of deposit refunds and deductions."""
        try:
            # Build query
            filters = [TransactionHeader.transaction_type == TransactionType.RENTAL_RETURN]
            
            if date_from:
                filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
            if date_to:
                filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))
            
            stmt = select(TransactionHeader).where(and_(*filters))
            result = await self.session.execute(stmt)
            returns = result.scalars().all()
            
            # Calculate summary
            total_deposits = Decimal("0")
            total_refunds = Decimal("0")
            total_deductions = Decimal("0")
            return_count = len(returns)
            
            deduction_breakdown = {
                "late_fees": Decimal("0"),
                "damage_fees": Decimal("0"),
                "cleaning_fees": Decimal("0"),
                "other_fees": Decimal("0")
            }
            
            for return_txn in returns:
                metadata = return_txn.metadata or {}
                
                deposit = return_txn.deposit_amount or Decimal("0")
                refund = return_txn.deposit_refund_amount or Decimal("0")
                deduction = deposit - refund
                
                total_deposits += deposit
                total_refunds += refund
                total_deductions += deduction
                
                # Breakdown by type
                deduction_breakdown["late_fees"] += Decimal(metadata.get("late_fee_amount", "0"))
                deduction_breakdown["damage_fees"] += Decimal(metadata.get("damage_fee_amount", "0"))
                deduction_breakdown["cleaning_fees"] += Decimal(metadata.get("cleaning_fee_amount", "0"))
            
            deduction_breakdown["other_fees"] = total_deductions - sum(deduction_breakdown.values())
            
            return {
                "period": {
                    "from": date_from,
                    "to": date_to
                },
                "summary": {
                    "total_returns": return_count,
                    "total_deposits_held": float(total_deposits),
                    "total_deposits_refunded": float(total_refunds),
                    "total_deductions": float(total_deductions),
                    "average_deduction": float(total_deductions / return_count) if return_count > 0 else 0,
                    "refund_percentage": float((total_refunds / total_deposits) * 100) if total_deposits > 0 else 0
                },
                "deduction_breakdown": {
                    k: float(v) for k, v in deduction_breakdown.items()
                }
            }
            
        except Exception as e:
            self.logger.log_debug_info("Error getting deposit summary", {"error": str(e)})
            raise

    # Helper methods
    def _calculate_return_fees(self, return_data: RentalReturnCreate, original_transaction: TransactionHeader) -> RentalReturnFees:
        """Calculate all fees for rental return."""
        late_fee = return_data.late_fee_amount or Decimal("0")
        damage_fee = Decimal("0")
        cleaning_fee = return_data.cleaning_fee or Decimal("0")
        missing_item_fee = Decimal("0")
        administrative_fee = Decimal("0")
        
        # Calculate damage fees from items
        for item in return_data.return_items:
            if item.estimated_repair_cost:
                damage_fee += item.estimated_repair_cost
            
            if item.missing_accessories:
                # Estimate fee for missing accessories
                missing_item_fee += Decimal(str(len(item.missing_accessories) * 10))
        
        # Administrative fee for very late returns
        if return_data.late_fee_applicable and (return_data.actual_return_date - return_data.scheduled_return_date).days > 7:
            administrative_fee = Decimal("25")
        
        return RentalReturnFees(
            late_fee=late_fee,
            damage_fee=damage_fee,
            cleaning_fee=cleaning_fee,
            missing_item_fee=missing_item_fee,
            administrative_fee=administrative_fee
        )

    async def _generate_return_number(self, prefix: str) -> str:
        """Generate unique return transaction number."""
        import time
        
        timestamp = int(time.time() * 1000)
        date_str = datetime.utcnow().strftime('%Y%m%d')
        
        # Try timestamp-based number first
        transaction_number = f"{prefix}-{date_str}-{timestamp % 1000000}"
        
        # Check if it exists
        exists = await self.session.execute(
            select(1).where(
                TransactionHeader.transaction_number == transaction_number
            ).limit(1)
        )
        
        if not exists.scalar():
            return transaction_number
        
        # Fallback with counter
        for i in range(1, 100):
            transaction_number = f"{prefix}-{date_str}-{timestamp % 1000000}-{i}"
            exists = await self.session.execute(
                select(1).where(
                    TransactionHeader.transaction_number == transaction_number
                ).limit(1)
            )
            if not exists.scalar():
                return transaction_number
        
        raise ConflictError("Unable to generate unique transaction number")

    async def _update_inventory_for_return(
        self,
        item_id: UUID,
        location_id: UUID,
        quantity: Decimal,
        condition: str,
        transaction_id: UUID
    ):
        """Update inventory when items are returned."""
        # Get stock level
        stock_level = await self.stock_level_repository.get_by_item_location(item_id, location_id)
        
        if not stock_level:
            raise ValidationError(f"No stock level found for item {item_id} at location {location_id}")
        
        # Update quantities based on condition
        if condition in ["EXCELLENT", "GOOD", "FAIR"]:
            # Return to available stock
            stock_level.available_quantity += quantity
            stock_level.on_rent_quantity -= quantity
        else:
            # Damaged items go to damaged quantity
            stock_level.damaged_quantity = (stock_level.damaged_quantity or Decimal("0")) + quantity
            stock_level.on_rent_quantity -= quantity
        
        # Create stock movement
        movement = StockMovement(
            stock_level_id=stock_level.id,
            item_id=str(item_id),
            location_id=str(location_id),
            movement_type=MovementType.RENTAL_RETURN.value,
            reference_type=ReferenceType.TRANSACTION.value,
            reference_id=str(transaction_id),
            quantity_change=quantity,
            quantity_before=stock_level.available_quantity - quantity,
            quantity_after=stock_level.available_quantity,
            reason=f"Rental return - Condition: {condition}",
            notes=f"Return transaction {transaction_id}"
        )
        self.session.add(movement)

===== modules/transactions/sales/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""
Sales Module

Handles all sales-related transactions including creation, retrieval, and returns.
"""

from app.modules.transactions.sales.schemas import (
    SaleResponse,
    NewSaleRequest,
    NewSaleResponse,
    SaleItemCreate,
    SaleLineItemResponse,
    SaleDetail,
    SaleListResponse,
    CustomerNestedResponse,
    LocationNestedResponse,
    ItemNestedResponse,
)
from app.modules.transactions.sales.service import SalesService
from app.modules.transactions.sales.repository import SalesRepository
from app.modules.transactions.sales.routes import router as sales_router

__all__ = [
    # Schemas
    "SaleResponse",
    "NewSaleRequest",
    "NewSaleResponse",
    "SaleItemCreate",
    "SaleLineItemResponse",
    "SaleDetail",
    "SaleListResponse",
    "CustomerNestedResponse",
    "LocationNestedResponse",
    "ItemNestedResponse",
    # Service and Repository
    "SalesService",
    "SalesRepository",
    # Router
    "sales_router",
]

===== modules/transactions/sales/repository.py â€“ 2025-07-19 12:13:41 IST =====
"""
Sales Repository

Data access layer for sales-specific operations.
"""

from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, update
from sqlalchemy.orm import selectinload

from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionLine,
    TransactionType,
    TransactionStatus,
    PaymentStatus,
)
from app.modules.transactions.base.repository import TransactionHeaderRepository


class SalesRepository(TransactionHeaderRepository):
    """Repository for sales-specific operations."""

    async def get_sales(
        self,
        skip: int = 0,
        limit: int = 100,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        amount_from: Optional[Decimal] = None,
        amount_to: Optional[Decimal] = None,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[TransactionStatus] = None,
        payment_status: Optional[PaymentStatus] = None,
    ) -> List[TransactionHeader]:
        """Get sale transactions with filtering."""
        filters = [TransactionHeader.transaction_type == TransactionType.SALE]
        
        if date_from:
            filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
        if date_to:
            filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))
        if amount_from:
            filters.append(TransactionHeader.total_amount >= amount_from)
        if amount_to:
            filters.append(TransactionHeader.total_amount <= amount_to)
        if customer_id:
            filters.append(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            filters.append(TransactionHeader.location_id == str(location_id))
        if status:
            filters.append(TransactionHeader.status == status)
        if payment_status:
            filters.append(TransactionHeader.payment_status == payment_status)

        stmt = (
            select(TransactionHeader)
            .where(and_(*filters))
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
            .offset(skip)
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def get_sale_by_id(self, sale_id: UUID) -> Optional[TransactionHeader]:
        """Get a single sale transaction by ID."""
        stmt = (
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.id == sale_id,
                    TransactionHeader.transaction_type == TransactionType.SALE
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
        )
        
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()

    async def get_sale_summary(
        self,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
    ) -> Dict[str, Any]:
        """Get sale summary statistics."""
        filters = [TransactionHeader.transaction_type == TransactionType.SALE]
        
        if date_from:
            filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
        if date_to:
            filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))
        if customer_id:
            filters.append(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            filters.append(TransactionHeader.location_id == str(location_id))

        # Get aggregated data
        stmt = select(
            func.count(TransactionHeader.id).label('total_sales'),
            func.sum(TransactionHeader.total_amount).label('total_amount'),
            func.sum(TransactionHeader.tax_amount).label('total_tax'),
            func.sum(TransactionHeader.discount_amount).label('total_discount'),
            func.avg(TransactionHeader.total_amount).label('average_amount'),
        ).where(and_(*filters))
        
        result = await self.session.execute(stmt)
        summary = result.first()
        
        return {
            'total_sales': summary.total_sales or 0,
            'total_amount': float(summary.total_amount or 0),
            'total_tax': float(summary.total_tax or 0),
            'total_discount': float(summary.total_discount or 0),
            'average_amount': float(summary.average_amount or 0),
        }

    async def get_sale_returns(self, sale_id: UUID) -> List[TransactionHeader]:
        """Get all return transactions for a sale."""
        stmt = (
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.reference_transaction_id == str(sale_id),
                    TransactionHeader.transaction_type == TransactionType.RETURN,
                    TransactionHeader.is_active == True
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def get_customer_sale_history(
        self,
        customer_id: UUID,
        skip: int = 0,
        limit: int = 100
    ) -> List[TransactionHeader]:
        """Get sale history for a specific customer."""
        stmt = (
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.customer_id == str(customer_id),
                    TransactionHeader.transaction_type == TransactionType.SALE,
                    TransactionHeader.is_active == True
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
            .offset(skip)
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def get_top_selling_items(
        self,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get top selling items by quantity or revenue."""
        filters = [
            TransactionHeader.transaction_type == TransactionType.SALE,
            TransactionHeader.is_active == True
        ]
        
        if date_from:
            filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
        if date_to:
            filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))

        # Join with transaction lines and aggregate
        stmt = (
            select(
                TransactionLine.item_id,
                func.sum(TransactionLine.quantity).label('total_quantity'),
                func.sum(TransactionLine.line_total).label('total_revenue'),
                func.count(TransactionLine.id).label('transaction_count')
            )
            .join(TransactionHeader)
            .where(and_(*filters))
            .group_by(TransactionLine.item_id)
            .order_by(func.sum(TransactionLine.quantity).desc())
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        items = result.all()
        
        return [
            {
                'item_id': item.item_id,
                'total_quantity': float(item.total_quantity),
                'total_revenue': float(item.total_revenue),
                'transaction_count': item.transaction_count
            }
            for item in items
        ]

    async def update_sale_payment_status(
        self,
        sale_id: UUID,
        payment_status: PaymentStatus,
        paid_amount: Optional[Decimal] = None
    ) -> bool:
        """Update payment status for a sale."""
        values = {'payment_status': payment_status}
        if paid_amount is not None:
            values['paid_amount'] = paid_amount
            
        stmt = (
            update(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.id == sale_id,
                    TransactionHeader.transaction_type == TransactionType.SALE
                )
            )
            .values(**values)
        )
        
        result = await self.session.execute(stmt)
        await self.session.commit()
        return result.rowcount > 0

===== modules/transactions/sales/routes.py â€“ 2025-07-19 13:16:12 IST =====
"""
Sales Routes

API endpoints for sales-related operations.
"""

from typing import List, Optional
from uuid import UUID
from datetime import date
from decimal import Decimal
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.shared.dependencies import get_session
from app.modules.transactions.sales.service import SalesService
from app.modules.transactions.base.models import (
    TransactionStatus,
    PaymentStatus,
)
from app.modules.transactions.sales.schemas import (
    SaleResponse,
    NewSaleRequest,
    NewSaleResponse,
)
from app.core.errors import NotFoundError, ValidationError, ConflictError


router = APIRouter(tags=["sales"])


def get_sales_service(session: AsyncSession = Depends(get_session)) -> SalesService:
    """Get sales service instance."""
    return SalesService(session)


@router.get("/", response_model=List[SaleResponse])
async def get_sale_transactions(
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
    date_from: Optional[date] = Query(None, description="Sale date from (inclusive)"),
    date_to: Optional[date] = Query(None, description="Sale date to (inclusive)"),
    amount_from: Optional[Decimal] = Query(None, ge=0, description="Minimum total amount"),
    amount_to: Optional[Decimal] = Query(None, ge=0, description="Maximum total amount"),
    customer_id: Optional[UUID] = Query(None, description="Filter by customer ID"),
    location_id: Optional[UUID] = Query(None, description="Filter by location ID"),
    status: Optional[TransactionStatus] = Query(None, description="Transaction status"),
    payment_status: Optional[PaymentStatus] = Query(None, description="Payment status"),
    service: SalesService = Depends(get_sales_service),
):
    """
    Get sale transactions with filtering options.
    
    Filters:
    - date_from/date_to: Filter by sale date range
    - amount_from/amount_to: Filter by total amount range
    - customer_id: Filter by specific customer
    - location_id: Filter by specific location
    - status: Filter by transaction status
    - payment_status: Filter by payment status
    
    Returns list of sale transactions with sale-specific line item format.
    """
    return await service.get_sale_transactions(
        skip=skip,
        limit=limit,
        date_from=date_from,
        date_to=date_to,
        amount_from=amount_from,
        amount_to=amount_to,
        customer_id=customer_id,
        location_id=location_id,
        status=status,
        payment_status=payment_status,
    )


@router.get("/{sale_id}", response_model=SaleResponse)
async def get_sale_by_id(
    sale_id: UUID, service: SalesService = Depends(get_sales_service)
):
    """Get a single sale transaction by ID with sale-specific format."""
    try:
        return await service.get_sale_by_id(sale_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


@router.post("/new", response_model=NewSaleResponse, status_code=status.HTTP_201_CREATED)
async def create_new_sale(
    sale_data: NewSaleRequest,
    service: SalesService = Depends(get_sales_service),
):
    """
    Create a new sale transaction with the simplified format.

    This endpoint accepts sale data in the exact format sent by the frontend:
    - customer_id as string UUID (must exist and be able to transact)
    - transaction_date as string in YYYY-MM-DD format
    - notes as string (optional)
    - reference_number as string (optional, max 50 chars)
    - items array with:
      * item_id as string UUID (must exist and be saleable)
      * quantity as integer (>=1, required)
      * unit_cost as decimal (>=0, price per unit)
      * tax_rate as decimal (0-100, optional, defaults to 0)
      * discount_amount as decimal (>=0, optional, defaults to 0)
      * notes as string (optional)

    Features:
    - Automatically validates customer can transact
    - Generates unique transaction numbers (SAL-YYYYMMDD-XXXX)
    - Updates inventory stock levels and marks units as sold
    - Creates stock movement records for audit trail
    - Supports item-level discounts and taxes
    - Comprehensive validation at header and line levels

    Returns a standardized response with success status, message, transaction data, and identifiers.
    """
    try:
        return await service.create_new_sale(sale_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}",
        )


@router.get("/returns/{sale_id}")
async def get_sale_returns(
    sale_id: UUID,
    service: SalesService = Depends(get_sales_service),
):
    """
    Get all return transactions for a specific sale.
    
    This endpoint retrieves all return transactions that reference
    the given sale transaction ID.
    """
    try:
        return await service.get_sale_returns(sale_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting sale returns: {str(e)}"
        )

===== modules/transactions/sales/schemas.py â€“ 2025-07-19 12:13:41 IST =====
"""
Sales Schemas

Pydantic schemas for sales-related operations.
"""

from typing import Optional, List
from datetime import date, datetime
from decimal import Decimal
from pydantic import BaseModel, Field, ConfigDict, field_validator
from uuid import UUID

from app.modules.transactions.base.models import TransactionType, TransactionStatus, PaymentStatus


# Nested response schemas for sales details
class CustomerNestedResponse(BaseModel):
    """Schema for nested customer response in sale transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Customer name")


class LocationNestedResponse(BaseModel):
    """Schema for nested location response in sale transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Location name")


class ItemNestedResponse(BaseModel):
    """Schema for nested item response in sale transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Item name")


class SaleItemCreate(BaseModel):
    """Schema for creating a sale item."""

    item_id: str = Field(..., description="Item ID")
    quantity: int = Field(..., ge=1, description="Quantity")
    unit_cost: Decimal = Field(..., ge=0, description="Unit cost")
    tax_rate: Optional[Decimal] = Field(0, ge=0, le=100, description="Tax rate percentage")
    discount_amount: Optional[Decimal] = Field(0, ge=0, description="Discount amount")
    notes: Optional[str] = Field("", description="Additional notes")

    @field_validator("item_id")
    @classmethod
    def validate_item_id(cls, v):
        """Validate item ID as UUID."""
        try:
            from uuid import UUID
            return UUID(v)
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")


class SaleLineItemResponse(BaseModel):
    """Schema for sale line item response with sale-specific fields."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    item: ItemNestedResponse = Field(..., description="Item details")
    quantity: Decimal
    unit_cost: Decimal = Field(..., description="Unit cost per item")
    tax_rate: Decimal = Field(..., description="Tax rate percentage")
    discount_amount: Decimal = Field(..., description="Discount amount")
    notes: str = Field(default="", description="Additional notes")
    tax_amount: Decimal = Field(..., description="Calculated tax amount")
    line_total: Decimal = Field(..., description="Total line amount")
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_transaction_line(cls, line: dict, item_details: dict = None) -> "SaleLineItemResponse":
        """Create SaleLineItemResponse from TransactionLine data."""
        # Create item nested response
        item_nested = ItemNestedResponse(
            id=item_details["id"] if item_details else line["item_id"],
            name=item_details["name"] if item_details else "Unknown Item"
        )
        
        return cls(
            id=line["id"],
            item=item_nested,
            quantity=line["quantity"],
            unit_cost=line["unit_price"],  # Map unit_price to unit_cost
            tax_rate=line["tax_rate"],
            discount_amount=line["discount_amount"],
            notes=line.get("notes", ""),
            tax_amount=line["tax_amount"],
            line_total=line["line_total"],
            created_at=line["created_at"],
            updated_at=line["updated_at"],
        )


class SaleCreate(BaseModel):
    """Schema for creating a sale transaction."""

    customer_id: UUID = Field(..., description="Customer ID")
    location_id: UUID = Field(..., description="Location ID")
    transaction_date: date = Field(..., description="Sale date")
    notes: Optional[str] = Field("", description="Additional notes")
    reference_number: Optional[str] = Field("", max_length=50, description="Reference number")
    items: List[SaleItemCreate] = Field(..., min_length=1, description="Sale items")


class NewSaleRequest(BaseModel):
    """Schema for the new-sale endpoint - matches frontend JSON structure exactly."""

    customer_id: str = Field(..., description="Customer ID")
    transaction_date: str = Field(..., description="Transaction date in YYYY-MM-DD format")
    notes: Optional[str] = Field("", description="Additional notes")
    reference_number: Optional[str] = Field("", max_length=50, description="Reference number")
    items: List[SaleItemCreate] = Field(..., min_length=1, description="Sale items")

    @field_validator("transaction_date")
    @classmethod
    def validate_transaction_date(cls, v):
        """Validate and parse transaction date."""
        try:
            from datetime import datetime
            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")

    @field_validator("customer_id")
    @classmethod
    def validate_customer_id(cls, v):
        """Validate customer ID as UUID."""
        try:
            from uuid import UUID
            return UUID(v)
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")


class NewSaleResponse(BaseModel):
    """Schema for new-sale response."""

    model_config = ConfigDict(from_attributes=True)

    success: bool = Field(True, description="Operation success status")
    message: str = Field("Sale created successfully", description="Response message")
    data: dict = Field(..., description="Sale transaction data")
    transaction_id: UUID = Field(..., description="Created transaction ID")
    transaction_number: str = Field(..., description="Generated transaction number")


class SaleResponse(BaseModel):
    """Schema for sale response - maps transaction data to sale format."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    customer: CustomerNestedResponse = Field(..., description="Customer details")
    location: LocationNestedResponse = Field(..., description="Location details")
    transaction_date: date = Field(..., description="Transaction date")
    reference_number: Optional[str] = Field(None, description="Reference number")
    notes: Optional[str] = Field(None, description="Additional notes")
    subtotal: Decimal = Field(..., description="Subtotal amount")
    tax_amount: Decimal = Field(..., description="Tax amount")
    discount_amount: Decimal = Field(..., description="Discount amount")
    total_amount: Decimal = Field(..., description="Total amount")
    status: str = Field(..., description="Sale status")
    payment_status: str = Field(..., description="Payment status")
    created_at: datetime
    updated_at: datetime
    items: List[SaleLineItemResponse] = Field(default_factory=list, description="Sale items")

    @classmethod
    def from_transaction(cls, transaction: dict, customer_details: dict = None, location_details: dict = None, items_details: dict = None) -> "SaleResponse":
        """Create SaleResponse from TransactionHeaderResponse data."""
        # Create nested customer response
        customer_nested = CustomerNestedResponse(
            id=customer_details["id"] if customer_details else transaction["customer_id"],
            name=customer_details["name"] if customer_details else "Unknown Customer"
        )
        
        # Create nested location response
        location_nested = LocationNestedResponse(
            id=location_details["id"] if location_details else transaction["location_id"],
            name=location_details["name"] if location_details else "Unknown Location"
        )
        
        # Transform transaction lines to sale line items
        sale_items = []
        items_details = items_details or {}
        for line in transaction.get("transaction_lines", []):
            item_detail = items_details.get(str(line["item_id"]), None)
            sale_items.append(SaleLineItemResponse.from_transaction_line(line, item_detail))
        
        return cls(
            id=transaction["id"],
            customer=customer_nested,
            location=location_nested,
            transaction_date=transaction["transaction_date"].date()
            if isinstance(transaction["transaction_date"], datetime)
            else transaction["transaction_date"],
            reference_number=transaction.get("transaction_number"),
            notes=transaction.get("notes"),
            subtotal=transaction["subtotal"],
            tax_amount=transaction["tax_amount"],
            discount_amount=transaction["discount_amount"],
            total_amount=transaction["total_amount"],
            status=transaction["status"],
            payment_status=transaction["payment_status"],
            created_at=transaction["created_at"],
            updated_at=transaction["updated_at"],
            items=sale_items,
        )


class SaleDetail(BaseModel):
    """Schema for detailed sale information."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    transaction_number: str
    customer_id: UUID
    customer_name: Optional[str] = None
    location_id: UUID
    location_name: Optional[str] = None
    transaction_date: date
    reference_number: Optional[str] = None
    notes: Optional[str] = None
    subtotal: Decimal
    tax_amount: Decimal
    discount_amount: Decimal
    total_amount: Decimal
    paid_amount: Decimal
    status: TransactionStatus
    payment_status: PaymentStatus
    created_at: datetime
    updated_at: datetime
    items: List[SaleLineItemResponse] = Field(default_factory=list)


class SaleListResponse(BaseModel):
    """Response schema for sale list."""
    
    sales: List[SaleResponse] = Field(default_factory=list)
    total: int
    page: int
    page_size: int
    total_pages: int

===== modules/transactions/sales/service.py â€“ 2025-07-21 18:27:09 IST =====
"""
Sales Service

Business logic for sales-related operations.
"""

from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func
from sqlalchemy.orm import selectinload

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionLine,
    TransactionType,
    TransactionStatus,
    PaymentMethod,
    PaymentStatus,
    LineItemType,
)
from app.modules.transactions.base.repository import (
    TransactionHeaderRepository,
    TransactionLineRepository,
)
from app.modules.transactions.sales.schemas import (
    SaleResponse,
    SaleItemCreate,
    NewSaleRequest,
    NewSaleResponse,
    CustomerNestedResponse,
    LocationNestedResponse,
    SaleLineItemResponse,
)
from app.modules.customers.repository import CustomerRepository
from app.modules.inventory import InventoryUnit, StockLevelRepository, InventoryUnitRepository
from app.modules.inventory import StockLevel, StockMovement, MovementType, ReferenceType, InventoryUnit
from app.modules.inventory.integrations import async_process_sale_line_items, async_check_transaction_stock_availability, process_sale_line_items, check_transaction_stock_availability
from app.modules.master_data.locations.repository import LocationRepository
from app.core.logger import get_purchase_logger


class SalesService:
    """Service for sales transaction operations."""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.transaction_repository = TransactionHeaderRepository(session)
        self.line_repository = TransactionLineRepository(session)
        self.customer_repository = CustomerRepository(session)
        self.item_repository = ItemRepository(session)
        self.stock_level_repository = StockLevelRepository(session)
        self.inventory_unit_repository = InventoryUnitRepository(session)
        self.location_repository = LocationRepository(session)
        self.logger = get_purchase_logger()

    async def get_sale_transactions(
        self,
        skip: int = 0,
        limit: int = 100,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        amount_from: Optional[Decimal] = None,
        amount_to: Optional[Decimal] = None,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[TransactionStatus] = None,
        payment_status: Optional[PaymentStatus] = None,
    ) -> List[SaleResponse]:
        """Get sale transactions with filtering options."""
        try:
            # Build filter conditions
            filters = [TransactionHeader.transaction_type == TransactionType.SALE]
            
            if date_from:
                filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
            if date_to:
                filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))
            if amount_from:
                filters.append(TransactionHeader.total_amount >= amount_from)
            if amount_to:
                filters.append(TransactionHeader.total_amount <= amount_to)
            if customer_id:
                filters.append(TransactionHeader.customer_id == str(customer_id))
            if location_id:
                filters.append(TransactionHeader.location_id == str(location_id))
            if status:
                filters.append(TransactionHeader.status == status)
            if payment_status:
                filters.append(TransactionHeader.payment_status == payment_status)

            # Query transactions with lines
            stmt = (
                select(TransactionHeader)
                .where(and_(*filters))
                .options(selectinload(TransactionHeader.transaction_lines))
                .order_by(TransactionHeader.transaction_date.desc())
                .offset(skip)
                .limit(limit)
            )
            
            result = await self.session.execute(stmt)
            transactions = result.scalars().unique().all()

            # Get all unique customer and location IDs
            customer_ids = list({UUID(t.customer_id) for t in transactions if t.customer_id})
            location_ids = list({UUID(t.location_id) for t in transactions if t.location_id})
            
            # Batch fetch customers and locations
            customers = {}
            locations = {}
            
            if customer_ids:
                customers = {}
                for customer_id in customer_ids:
                    customer = await self.customer_repository.get_by_id(customer_id)
                    if customer:
                        customers[customer.id] = customer
            
            if location_ids:
                for location_id in location_ids:
                    location = await self.location_repository.get_by_id(location_id)
                    if location:
                        locations[location.id] = location

            # Get all unique item IDs from transaction lines
            item_ids = []
            for transaction in transactions:
                for line in transaction.transaction_lines:
                    if line.item_id:
                        item_ids.append(UUID(line.item_id))
            
            # Batch fetch items
            items = {}
            if item_ids:
                for item_id in list(set(item_ids)):
                    item = await self.item_repository.get_by_id(item_id)
                    if item:
                        items[str(item.id)] = {"id": item.id, "name": item.item_name}

            # Transform to sale response format
            sale_responses = []
            for transaction in transactions:
                customer = customers.get(UUID(transaction.customer_id)) if transaction.customer_id else None
                location = locations.get(UUID(transaction.location_id)) if transaction.location_id else None
                
                sale_response = SaleResponse.from_transaction(
                    transaction.to_dict(),
                    customer_details={"id": customer.id, "name": customer.name} if customer else None,
                    location_details={"id": location.id, "name": location.name} if location else None,
                    items_details=items
                )
                sale_responses.append(sale_response)

            return sale_responses

        except Exception as e:
            self.logger.log_debug_info("Error getting sale transactions", {"error": str(e)})
            raise

    async def get_sale_by_id(self, sale_id: UUID) -> SaleResponse:
        """Get a single sale transaction by ID."""
        try:
            # Get transaction with lines
            transaction = await self.transaction_repository.get_with_lines(sale_id)
            
            if not transaction:
                raise NotFoundError(f"Sale transaction {sale_id} not found")
            
            # Verify it's a sale transaction
            if transaction.transaction_type != TransactionType.SALE:
                raise ValidationError(f"Transaction {sale_id} is not a sale")

            # Get customer and location details
            customer = None
            location = None
            
            if transaction.customer_id:
                customer = await self.customer_repository.get_by_id(UUID(transaction.customer_id))
            
            if transaction.location_id:
                location = await self.location_repository.get_by_id(UUID(transaction.location_id))

            # Get item details for all lines
            item_ids = [UUID(line.item_id) for line in transaction.transaction_lines if line.item_id]
            items = {}
            
            if item_ids:
                for item_id in list(set(item_ids)):
                    item = await self.item_repository.get_by_id(item_id)
                    if item:
                        items[str(item.id)] = {"id": item.id, "name": item.item_name}

            # Transform to sale response
            return SaleResponse.from_transaction(
                transaction.to_dict(),
                customer_details={"id": customer.id, "name": customer.name} if customer else None,
                location_details={"id": location.id, "name": location.name} if location else None,
                items_details=items
            )

        except Exception as e:
            self.logger.log_debug_info("Error getting sale by ID", {"error": str(e)})
            raise

    async def create_new_sale(self, sale_data: NewSaleRequest) -> NewSaleResponse:
        """Create a new sale transaction."""
        try:
            self.logger.log_debug_info("Creating new sale", {"customer_id": str(sale_data.customer_id)})

            # Validate customer exists and can transact
            customer = await self.customer_repository.get_by_id(sale_data.customer_id)
            if not customer:
                raise NotFoundError(f"Customer {sale_data.customer_id} not found")
            
            if not customer.can_transact:
                raise ValidationError(f"Customer {customer.name} is not allowed to transact")

            # Validate all items exist and are saleable
            item_ids = [item.item_id for item in sale_data.items]
            items_dict = {}
            for item_id in item_ids:
                item = await self.item_repository.get_by_id(item_id)
                if item:
                    items_dict[str(item.id)] = item
            
            missing_items = set(str(item_id) for item_id in item_ids) - set(items_dict.keys())
            if missing_items:
                raise NotFoundError(f"Items not found: {list(missing_items)}")
            
            # Validate items are saleable
            non_saleable = [item.item_name for item in items_dict.values() if not item.is_saleable]
            if non_saleable:
                raise ValidationError(f"Items are not saleable: {non_saleable}")

            # Get default location if not provided
            location_id = None
            if hasattr(sale_data, 'location_id') and sale_data.location_id:
                location_id = sale_data.location_id
            else:
                # Get default location from settings or first available
                default_location = await self._get_default_location()
                location_id = default_location.id

            # Validate stock availability using new inventory service
            await self._validate_stock_availability_new(sale_data.items, location_id)

            # Generate transaction number
            transaction_number = await self._generate_sale_transaction_number(sale_data)

            # Begin transaction
            async with self.session.begin():
                # Create transaction header
                transaction = TransactionHeader(
                    transaction_number=transaction_number,
                    transaction_type=TransactionType.SALE,
                    transaction_date=datetime.combine(sale_data.transaction_date, datetime.min.time()),
                    customer_id=str(sale_data.customer_id),
                    location_id=str(location_id),
                    status=TransactionStatus.CONFIRMED,
                    payment_status=PaymentStatus.PENDING,
                    notes=sale_data.notes or "",
                    subtotal=Decimal("0"),
                    discount_amount=Decimal("0"),
                    tax_amount=Decimal("0"),
                    total_amount=Decimal("0"),
                    paid_amount=Decimal("0"),
                    is_active=True,
                )
                self.session.add(transaction)
                await self.session.flush()

                # Create transaction lines and calculate totals
                total_amount = Decimal("0")
                tax_total = Decimal("0")
                discount_total = Decimal("0")
                sale_line_items = []  # Collect line items for inventory update
                
                for idx, item_data in enumerate(sale_data.items):
                    item = items_dict[str(item_data.item_id)]
                    
                    # Calculate line totals
                    line_subtotal = item_data.unit_cost * Decimal(str(item_data.quantity))
                    tax_amount = (line_subtotal * (item_data.tax_rate or Decimal("0"))) / 100
                    discount_amount = item_data.discount_amount or Decimal("0")
                    line_total = line_subtotal + tax_amount - discount_amount

                    # Create transaction line
                    line = TransactionLine(
                        transaction_id=str(transaction.id),
                        line_number=idx + 1,
                        line_type=LineItemType.PRODUCT,
                        item_id=str(item.id),
                        description=item.item_name,
                        quantity=Decimal(str(item_data.quantity)),
                        unit_price=item_data.unit_cost,
                        tax_rate=item_data.tax_rate or Decimal("0"),
                        tax_amount=tax_amount,
                        discount_amount=discount_amount,
                        line_total=line_total,
                        notes=item_data.notes or "",
                        is_active=True,
                    )
                    self.session.add(line)
                    await self.session.flush()  # Get the line ID
                    
                    total_amount += line_total
                    tax_total += tax_amount
                    discount_total += discount_amount
                    
                    # Collect line item for inventory update
                    sale_line_items.append({
                        'id': line.id,
                        'item_id': item.id,
                        'quantity': item_data.quantity
                    })
                
                # Update stock levels using ONLY sync inventory service (temporary fix)
                try:
                    print(f"DEBUG: Using sync inventory service for sales")
                    # Convert async session to sync for testing using correct method
                    from sqlalchemy.orm import sessionmaker
                    sync_engine = self.session.bind.sync_engine
                    sync_session_maker = sessionmaker(bind=sync_engine)
                    sync_session = sync_session_maker()
                    
                    inventory_responses = process_sale_line_items(
                        db=sync_session,
                        transaction_line_items=sale_line_items,
                        location_id=location_id,
                        remarks=f"Sale Transaction {transaction.transaction_number}",
                        created_by=None  # TODO: Get from auth context
                    )
                    sync_session.close()
                    print(f"DEBUG: Sync inventory service worked! Updated {len(inventory_responses)} items")
                    
                    self.logger.log_debug_info("Inventory updated using sync service", {
                        "updated_items": len(inventory_responses)
                    })
                    
                except Exception as inventory_error:
                    print(f"DEBUG: Sync inventory service failed: {inventory_error}")
                    print(f"DEBUG: Error type: {type(inventory_error)}")
                    self.logger.log_debug_info("Sync inventory service failed, using old fallback", {
                        "error": str(inventory_error)
                    })
                    # Fallback to old method
                    for idx, item_data in enumerate(sale_data.items):
                        item = items_dict[str(item_data.item_id)]
                        try:
                            await self._update_stock_for_sale(
                                item_id=item.id,
                                location_id=location_id,
                                quantity=item_data.quantity,
                                transaction_id=transaction.id,
                                customer_id=sale_data.customer_id
                            )
                        except Exception as e:
                            self.logger.log_error(f"Stock update error: {str(e)}", {"error_type": type(e).__name__})
                            raise

                # Update transaction totals
                transaction.subtotal = total_amount - tax_total + discount_total
                transaction.tax_amount = tax_total
                transaction.discount_amount = discount_total
                transaction.total_amount = total_amount

            # Get complete transaction for response
            result = await self.transaction_repository.get_with_lines(transaction.id)

            return NewSaleResponse(
                success=True,
                message="Sale transaction created successfully",
                data=result.to_dict(),
                transaction_id=transaction.id,
                transaction_number=transaction.transaction_number,
            )

        except Exception as e:
            self.logger.log_debug_info("Error creating sale", {"error": str(e)})
            await self.session.rollback()
            raise

    async def _get_default_location(self) -> Any:
        """Get default location for sales."""
        # Try to get the first active location
        stmt = select(self.location_repository.model).where(
            self.location_repository.model.is_active == True
        ).limit(1)
        result = await self.session.execute(stmt)
        location = result.scalar_one_or_none()
        
        if not location:
            raise ValidationError("No active locations found")
        
        return location

    async def _validate_stock_availability(self, items: List[SaleItemCreate], location_id: UUID):
        """Validate stock availability for all sale items (old method)."""
        for item in items:
            stock_level = await self.stock_level_repository.get_by_item_location(item.item_id, location_id)
            
            if not stock_level:
                raise ValidationError(f"No stock found for item {item.item_id} at location")
            
            if stock_level.quantity_available < Decimal(str(item.quantity)):
                raise ValidationError(
                    f"Insufficient stock for item {item.item_id}. "
                    f"Available: {stock_level.quantity_available}, Requested: {item.quantity}"
                )
    
    async def _validate_stock_availability_new(self, items: List[SaleItemCreate], location_id: UUID):
        """Validate stock availability using new inventory service."""
        try:
            # Prepare line items for stock check
            line_items = [
                {
                    'item_id': item.item_id,
                    'quantity': item.quantity
                }
                for item in items
            ]
            
            # Check availability using new service
            availability = await async_check_transaction_stock_availability(
                async_session=self.session,
                transaction_line_items=line_items,
                location_id=location_id
            )
            
            if not availability['all_available']:
                unavailable_details = []
                for item_detail in availability['unavailable_items']:
                    unavailable_details.append(
                        f"Item {item_detail['item_id']}: requested {item_detail['required_quantity']}, "
                        f"available {item_detail['available_quantity']}"
                    )
                raise ValidationError(f"Insufficient stock: {'; '.join(unavailable_details)}")
                
        except Exception as e:
            self.logger.log_debug_info("New stock validation failed, using fallback", {
                "error": str(e)
            })
            # Fallback to old method
            await self._validate_stock_availability(items, location_id)

    async def _generate_sale_transaction_number(self, sale_data: NewSaleRequest) -> str:
        """Generate unique sale transaction number."""
        if sale_data.reference_number:
            # Check if reference number already exists
            exists = await self.session.execute(
                select(1).where(
                    TransactionHeader.transaction_number == sale_data.reference_number
                ).limit(1)
            )
            if exists.scalar():
                raise ConflictError(f"Reference number '{sale_data.reference_number}' already exists")
            return sale_data.reference_number
        
        # Generate automatic number
        date_str = sale_data.transaction_date.strftime('%Y%m%d')
        
        # Get count of sales for the date
        count_result = await self.session.execute(
            select(func.count(TransactionHeader.id)).where(
                and_(
                    TransactionHeader.transaction_type == TransactionType.SALE,
                    func.date(TransactionHeader.transaction_date) == sale_data.transaction_date
                )
            )
        )
        count = count_result.scalar() or 0
        
        # Generate number with retry logic
        for i in range(100):
            transaction_number = f"SAL-{date_str}-{count + i + 1:04d}"
            exists = await self.session.execute(
                select(1).where(
                    TransactionHeader.transaction_number == transaction_number
                ).limit(1)
            )
            if not exists.scalar():
                return transaction_number
        
        raise ConflictError("Unable to generate unique transaction number")

    async def _update_stock_for_sale(
        self, 
        item_id: UUID, 
        location_id: UUID, 
        quantity: int,
        transaction_id: UUID,
        customer_id: UUID
    ):
        """Update stock levels and inventory units for a sale."""
        # Get stock level
        stock_level = await self.stock_level_repository.get_by_item_location(item_id, location_id)
        
        if not stock_level:
            raise ValidationError(f"Stock level not found for item {item_id} at location {location_id}")

        # Update stock level
        old_quantity = stock_level.quantity_on_hand
        old_available = stock_level.quantity_available
        
        stock_level.quantity_on_hand -= Decimal(str(quantity))
        stock_level.quantity_available -= Decimal(str(quantity))

        # Create stock movement record
        movement = StockMovement(
            stock_level_id=stock_level.id,
            item_id=str(item_id),
            location_id=str(location_id),
            movement_type=MovementType.SALE.value,
            reference_type=ReferenceType.TRANSACTION.value,
            reference_id=str(transaction_id),
            quantity_change=-Decimal(str(quantity)),
            quantity_before=old_quantity,
            quantity_after=stock_level.quantity_on_hand,
            reason=f"Sale transaction {transaction_id}",
            notes=f"Sale of {quantity} units to customer {customer_id}",
        )
        self.session.add(movement)

        # Mark inventory units as sold
        stmt = (
            select(InventoryUnit)
            .where(
                and_(
                    InventoryUnit.item_id == str(item_id),
                    InventoryUnit.location_id == str(location_id),
                    InventoryUnit.status == "AVAILABLE"
                )
            )
            .limit(quantity)
        )
        result = await self.session.execute(stmt)
        units = result.scalars().all()

        for unit in units:
            unit.status = "SOLD"
            unit.assigned_to_customer_id = str(customer_id)
            unit.transaction_id = str(transaction_id)

    async def get_sale_returns(self, sale_id: UUID) -> Dict[str, Any]:
        """Get all return transactions for a specific sale."""
        try:
            # Get the original sale transaction
            sale_txn = await self.transaction_repository.get(sale_id)
            
            if not sale_txn:
                raise NotFoundError(f"Sale transaction {sale_id} not found")
            
            # Verify it's a sale transaction
            if sale_txn.transaction_type != TransactionType.SALE:
                raise ValidationError(f"Transaction {sale_id} is not a sale transaction")
            
            # Get all return transactions that reference this sale
            returns = await self.transaction_repository.get_all_with_lines(
                reference_transaction_id=sale_id,
                transaction_type=TransactionType.RETURN,
                active_only=True
            )
            
            # Transform to response format
            return_list = []
            for return_txn in returns:
                return_list.append({
                    "id": return_txn.id,
                    "transaction_number": return_txn.transaction_number,
                    "transaction_date": return_txn.transaction_date,
                    "status": return_txn.status,
                    "total_amount": float(return_txn.total_amount),
                    "items_returned": len(return_txn.transaction_lines),
                    "created_at": return_txn.created_at
                })
            
            return {
                "sale_id": sale_id,
                "sale_number": sale_txn.transaction_number,
                "returns": return_list,
                "total_returns": len(return_list)
            }
            
        except Exception as e:
            self.logger.log_debug_info("Error getting sale returns", {"error": str(e)})
            raise

===== modules/transactions/schemas/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""
Transaction schemas package.
"""

# Import all schemas from main and returns modules for backward compatibility
from .main import *
from .returns import *

# Explicitly define what should be available when importing from this package
__all__ = [
    # From main schemas
    "TransactionHeaderCreate",
    "TransactionHeaderUpdate", 
    "TransactionHeaderResponse",
    "TransactionLineCreate",
    "TransactionLineUpdate", 
    "TransactionLineResponse",
    "TransactionWithLinesResponse",
    "TransactionSummaryResponse",
    
    # Purchase and rental schemas
    "NewPurchaseRequest",
    "NewPurchaseResponse",
    "NewRentalRequest", 
    "NewRentalResponse",
    "NewSaleRequest",
    "NewSaleResponse",
    "SaleItemCreate",
    
    # Rentable items schemas
    "RentableItemResponse",
    "LocationAvailability",
    
    # From returns schemas  
    "SaleReturnCreate",
    "PurchaseReturnCreate",
    "RentalReturnCreate",
    "ReturnTransactionCreate",
    "ReturnValidationResponse", 
    "ReturnDetailsResponse",
    "ReturnStatusUpdate",
    "ReturnWorkflowState", 
    "PurchaseCreditMemoCreate", 
    "PurchaseCreditMemoResponse"
]

===== modules/transactions/schemas/main.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Any
from datetime import datetime, date, time
from decimal import Decimal
from pydantic import BaseModel, Field, ConfigDict, field_validator, computed_field, model_validator
from uuid import UUID

from app.modules.transactions.base.models import (
    TransactionType,
    TransactionStatus,
    PaymentMethod,
    PaymentStatus,
    RentalPeriodUnit,
    RentalStatus,
    LineItemType,
)


class TransactionHeaderCreate(BaseModel):
    """Schema for creating a new transaction header."""

    transaction_number: str = Field(..., max_length=50, description="Unique transaction number")
    transaction_type: TransactionType = Field(..., description="Transaction type")
    transaction_date: datetime = Field(..., description="Transaction date")
    customer_id: UUID = Field(..., description="Customer ID")
    location_id: UUID = Field(..., description="Location ID")
    sales_person_id: Optional[UUID] = Field(None, description="Sales person ID")
    status: TransactionStatus = Field(
        default=TransactionStatus.PENDING, description="Transaction status"
    )
    reference_transaction_id: Optional[UUID] = Field(None, description="Reference transaction ID")
    notes: Optional[str] = Field(None, description="Additional notes")


class TransactionHeaderUpdate(BaseModel):
    """Schema for updating a transaction header."""

    transaction_type: Optional[TransactionType] = Field(None, description="Transaction type")
    transaction_date: Optional[datetime] = Field(None, description="Transaction date")
    customer_id: Optional[UUID] = Field(None, description="Customer ID")
    location_id: Optional[UUID] = Field(None, description="Location ID")
    sales_person_id: Optional[UUID] = Field(None, description="Sales person ID")
    status: Optional[TransactionStatus] = Field(None, description="Transaction status")
    payment_status: Optional[PaymentStatus] = Field(None, description="Payment status")
    reference_transaction_id: Optional[UUID] = Field(None, description="Reference transaction ID")
    notes: Optional[str] = Field(None, description="Additional notes")


class TransactionHeaderResponse(BaseModel):
    """Schema for transaction header response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    transaction_number: str
    transaction_type: TransactionType
    transaction_date: datetime
    customer_id: UUID
    location_id: UUID
    sales_person_id: Optional[UUID]
    status: TransactionStatus
    payment_status: PaymentStatus
    subtotal: Decimal
    discount_amount: Decimal
    tax_amount: Decimal
    total_amount: Decimal
    paid_amount: Decimal
    deposit_amount: Decimal
    reference_transaction_id: Optional[UUID]
    customer_advance_balance: Decimal
    due_date: Optional[date]
    notes: Optional[str]
    payment_method: Optional[PaymentMethod]
    payment_reference: Optional[str]
    
    # New delivery fields
    delivery_required: bool
    delivery_address: Optional[str]
    delivery_date: Optional[date]
    delivery_time: Optional[time]
    
    # New pickup fields
    pickup_required: bool
    pickup_date: Optional[date]
    pickup_time: Optional[time]
    
    is_active: bool
    created_at: datetime
    updated_at: datetime

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.transaction_number} - {self.transaction_type.value}"

    @computed_field
    @property
    def balance_due(self) -> Decimal:
        return max(self.total_amount - self.paid_amount, Decimal("0.00"))

    @computed_field
    @property
    def is_paid_in_full(self) -> bool:
        return self.paid_amount >= self.total_amount

    @computed_field
    @property
    def is_rental(self) -> bool:
        return self.transaction_type == TransactionType.RENTAL

    @computed_field
    @property
    def is_sale(self) -> bool:
        return self.transaction_type == TransactionType.SALE
    
    @computed_field
    @property
    def reference_number(self) -> str:
        """Alias for transaction_number to match frontend expectations."""
        return self.transaction_number



class TransactionHeaderListResponse(BaseModel):
    """Schema for transaction header list response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    transaction_number: str
    transaction_type: TransactionType
    transaction_date: datetime
    customer_id: UUID
    location_id: UUID
    status: TransactionStatus
    payment_status: PaymentStatus
    total_amount: Decimal
    paid_amount: Decimal
    is_active: bool
    created_at: datetime
    updated_at: datetime

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.transaction_number} - {self.transaction_type.value}"

    @computed_field
    @property
    def balance_due(self) -> Decimal:
        return max(self.total_amount - self.paid_amount, Decimal("0.00"))


class TransactionLineCreate(BaseModel):
    """Schema for creating a new transaction line."""

    line_number: int = Field(..., ge=1, description="Line number")
    line_type: LineItemType = Field(..., description="Line item type")
    description: str = Field(..., max_length=500, description="Line description")
    quantity: Decimal = Field(default=Decimal("1"), ge=0, description="Quantity")
    unit_price: Decimal = Field(default=Decimal("0.00"), description="Unit price")
    item_id: Optional[UUID] = Field(None, description="Item ID")
    inventory_unit_id: Optional[UUID] = Field(None, description="Inventory unit ID")
    discount_percentage: Decimal = Field(
        default=Decimal("0.00"), ge=0, le=100, description="Discount percentage"
    )
    discount_amount: Decimal = Field(default=Decimal("0.00"), ge=0, description="Discount amount")
    tax_rate: Decimal = Field(default=Decimal("0.00"), ge=0, description="Tax rate")
    rental_period_value: Optional[int] = Field(None, ge=1, description="Rental period value")
    rental_period_unit: Optional[RentalPeriodUnit] = Field(None, description="Rental period unit")
    rental_start_date: Optional[date] = Field(None, description="Rental start date")
    rental_end_date: Optional[date] = Field(None, description="Rental end date")
    current_rental_status: Optional[RentalStatus] = Field(None, description="Current rental status")
    notes: Optional[str] = Field(None, description="Additional notes")

    @field_validator("item_id")
    @classmethod
    def validate_item_id_for_product_service(cls, v, info):
        line_type = info.data.get("line_type")
        if line_type in [LineItemType.PRODUCT, LineItemType.SERVICE]:
            if not v:
                raise ValueError(f"Item ID is required for {line_type.value} lines")
        return v

    @field_validator("rental_period_unit")
    @classmethod
    def validate_rental_period_unit(cls, v, info):
        rental_period_value = info.data.get("rental_period_value")
        if rental_period_value is not None and not v:
            raise ValueError("Rental period unit is required when period value is specified")
        return v

    @field_validator("rental_end_date")
    @classmethod
    def validate_rental_end_date(cls, v, info):
        if v is not None and info.data.get("rental_start_date") is not None:
            if v < info.data.get("rental_start_date"):
                raise ValueError("Rental end date must be after start date")
        return v

    @field_validator("unit_price")
    @classmethod
    def validate_unit_price(cls, v, info):
        line_type = info.data.get("line_type")
        if v < 0 and line_type != LineItemType.DISCOUNT:
            raise ValueError("Unit price cannot be negative except for discount lines")
        return v


class TransactionLineUpdate(BaseModel):
    """Schema for updating a transaction line."""

    line_type: Optional[LineItemType] = Field(None, description="Line item type")
    description: Optional[str] = Field(None, max_length=500, description="Line description")
    quantity: Optional[Decimal] = Field(None, ge=0, description="Quantity")
    unit_price: Optional[Decimal] = Field(None, description="Unit price")
    item_id: Optional[UUID] = Field(None, description="Item ID")
    inventory_unit_id: Optional[UUID] = Field(None, description="Inventory unit ID")
    discount_percentage: Optional[Decimal] = Field(
        None, ge=0, le=100, description="Discount percentage"
    )
    discount_amount: Optional[Decimal] = Field(None, ge=0, description="Discount amount")
    tax_rate: Optional[Decimal] = Field(None, ge=0, description="Tax rate")
    rental_period_value: Optional[int] = Field(None, ge=1, description="Rental period value")
    rental_period_unit: Optional[RentalPeriodUnit] = Field(None, description="Rental period unit")
    rental_start_date: Optional[date] = Field(None, description="Rental start date")
    rental_end_date: Optional[date] = Field(None, description="Rental end date")
    current_rental_status: Optional[RentalStatus] = Field(None, description="Current rental status")
    notes: Optional[str] = Field(None, description="Additional notes")

    @field_validator("rental_end_date")
    @classmethod
    def validate_rental_end_date(cls, v, info):
        if v is not None and info.data.get("rental_start_date") is not None:
            if v < info.data.get("rental_start_date"):
                raise ValueError("Rental end date must be after start date")
        return v


class TransactionLineResponse(BaseModel):
    """Schema for transaction line response."""

    model_config = ConfigDict(from_attributes=True, populate_by_name=True)

    id: UUID
    transaction_id: UUID
    line_number: int
    line_type: LineItemType
    item_id: Optional[UUID]
    inventory_unit_id: Optional[UUID]
    description: str
    quantity: Decimal
    unit_price: Decimal
    discount_percentage: Optional[Decimal] = Field(None, alias="discount_percent")
    discount_amount: Decimal
    tax_rate: Decimal
    tax_amount: Decimal
    line_total: Decimal
    rental_period_value: Optional[int] = Field(None, alias="rental_period")
    rental_period_unit: Optional[RentalPeriodUnit]
    rental_start_date: Optional[date]
    rental_end_date: Optional[date]
    current_rental_status: Optional[RentalStatus]
    returned_quantity: Decimal
    return_date: Optional[date]
    notes: Optional[str]
    is_active: bool
    created_at: datetime
    updated_at: datetime

    @computed_field
    @property
    def display_name(self) -> str:
        return f"Line {self.line_number}: {self.description}"

    @computed_field
    @property
    def remaining_quantity(self) -> Decimal:
        return self.quantity - self.returned_quantity

    @computed_field
    @property
    def is_fully_returned(self) -> bool:
        return self.returned_quantity >= self.quantity

    @computed_field
    @property
    def is_partially_returned(self) -> bool:
        return 0 < self.returned_quantity < self.quantity

    @computed_field
    @property
    def rental_days(self) -> int:
        if not self.rental_start_date or not self.rental_end_date:
            return 0
        return (self.rental_end_date - self.rental_start_date).days + 1

    @computed_field
    @property
    def effective_unit_price(self) -> Decimal:
        if self.quantity == 0:
            return Decimal("0.00")

        subtotal = self.quantity * self.unit_price
        discounted_amount = subtotal - self.discount_amount

        return discounted_amount / self.quantity


class TransactionLineListResponse(BaseModel):
    """Schema for transaction line list response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    transaction_id: UUID
    line_number: int
    line_type: LineItemType
    item_id: Optional[UUID]
    inventory_unit_id: Optional[UUID]
    description: str
    quantity: Decimal
    unit_price: Decimal
    line_total: Decimal
    is_active: bool
    created_at: datetime
    updated_at: datetime

    @computed_field
    @property
    def display_name(self) -> str:
        return f"Line {self.line_number}: {self.description}"


class PaymentCreate(BaseModel):
    """Schema for creating a payment."""

    amount: Decimal = Field(..., gt=0, description="Payment amount")
    payment_method: PaymentMethod = Field(..., description="Payment method")
    payment_reference: Optional[str] = Field(None, max_length=100, description="Payment reference")
    notes: Optional[str] = Field(None, description="Payment notes")


class RefundCreate(BaseModel):
    """Schema for creating a refund."""

    refund_amount: Decimal = Field(..., gt=0, description="Refund amount")
    reason: str = Field(..., max_length=500, description="Refund reason")
    notes: Optional[str] = Field(None, description="Additional notes")


class StatusUpdate(BaseModel):
    """Schema for updating transaction status."""

    status: TransactionStatus = Field(..., description="New status")
    notes: Optional[str] = Field(None, description="Status update notes")


class DiscountApplication(BaseModel):
    """Schema for applying discount to transaction line."""

    discount_percentage: Optional[Decimal] = Field(
        None, ge=0, le=100, description="Discount percentage"
    )
    discount_amount: Optional[Decimal] = Field(None, ge=0, description="Discount amount")
    reason: Optional[str] = Field(None, description="Discount reason")

    @field_validator("discount_percentage")
    @classmethod
    def validate_discount_exclusivity(cls, v, info):
        if v is not None and info.data.get("discount_amount") is not None:
            raise ValueError("Cannot apply both percentage and amount discount")
        return v


class ReturnProcessing(BaseModel):
    """Schema for processing returns."""

    return_quantity: Decimal = Field(..., gt=0, description="Return quantity")
    return_date: date = Field(..., description="Return date")
    return_reason: Optional[str] = Field(None, description="Return reason")
    notes: Optional[str] = Field(None, description="Additional notes")


class RentalPeriodUpdate(BaseModel):
    """Schema for updating rental period."""

    new_end_date: date = Field(..., description="New rental end date")
    reason: Optional[str] = Field(None, description="Reason for change")
    notes: Optional[str] = Field(None, description="Additional notes")


class RentalReturn(BaseModel):
    """Schema for rental return."""

    actual_return_date: date = Field(..., description="Actual return date")
    condition_notes: Optional[str] = Field(None, description="Condition notes")
    late_fees: Optional[Decimal] = Field(None, ge=0, description="Late fees")
    damage_fees: Optional[Decimal] = Field(None, ge=0, description="Damage fees")
    notes: Optional[str] = Field(None, description="Additional notes")


class TransactionWithLinesResponse(BaseModel):
    """Schema for transaction with lines response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    transaction_number: str
    transaction_type: TransactionType
    transaction_date: datetime
    customer_id: UUID
    location_id: UUID
    sales_person_id: Optional[UUID]
    status: TransactionStatus
    payment_status: PaymentStatus
    subtotal: Decimal
    discount_amount: Decimal
    tax_amount: Decimal
    total_amount: Decimal
    paid_amount: Decimal
    deposit_amount: Decimal
    reference_transaction_id: Optional[UUID]
    customer_advance_balance: Decimal
    notes: Optional[str]
    payment_method: Optional[PaymentMethod]
    payment_reference: Optional[str]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    transaction_lines: List[TransactionLineResponse] = []

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.transaction_number} - {self.transaction_type.value}"

    @computed_field
    @property
    def balance_due(self) -> Decimal:
        return max(self.total_amount - self.paid_amount, Decimal("0.00"))

    @computed_field
    @property
    def is_paid_in_full(self) -> bool:
        return self.paid_amount >= self.total_amount

    @computed_field
    @property
    def line_count(self) -> int:
        return len(self.transaction_lines)


class TransactionHeaderWithLinesListResponse(BaseModel):
    """Schema for transaction header list response with nested line items."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    transaction_number: str
    transaction_type: TransactionType
    transaction_date: datetime
    customer_id: UUID
    location_id: UUID
    sales_person_id: Optional[UUID]
    status: TransactionStatus
    payment_status: PaymentStatus
    subtotal: Decimal
    discount_amount: Decimal
    tax_amount: Decimal
    total_amount: Decimal
    paid_amount: Decimal
    deposit_amount: Decimal
    reference_transaction_id: Optional[UUID]
    customer_advance_balance: Decimal
    due_date: Optional[date]
    notes: Optional[str]
    payment_method: Optional[PaymentMethod]
    payment_reference: Optional[str]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    transaction_lines: List[TransactionLineResponse] = []

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.transaction_number} - {self.transaction_type.value}"

    @computed_field
    @property
    def balance_due(self) -> Decimal:
        return max(self.total_amount - self.paid_amount, Decimal("0.00"))

    @computed_field
    @property
    def is_paid_in_full(self) -> bool:
        return self.paid_amount >= self.total_amount

    @computed_field
    @property
    def line_count(self) -> int:
        return len(self.transaction_lines)


class TransactionSummary(BaseModel):
    """Schema for transaction summary."""

    total_transactions: int
    total_amount: Decimal
    total_paid: Decimal
    total_outstanding: Decimal
    transactions_by_status: dict[str, int]
    transactions_by_type: dict[str, int]
    transactions_by_payment_status: dict[str, int]


class TransactionReport(BaseModel):
    """Schema for transaction report."""

    transactions: List[TransactionHeaderListResponse]
    summary: TransactionSummary
    date_range: dict[str, date]


class TransactionSearch(BaseModel):
    """Schema for transaction search."""

    transaction_number: Optional[str] = Field(None, description="Transaction number")
    transaction_type: Optional[TransactionType] = Field(None, description="Transaction type")
    customer_id: Optional[UUID] = Field(None, description="Customer ID")
    location_id: Optional[UUID] = Field(None, description="Location ID")
    sales_person_id: Optional[UUID] = Field(None, description="Sales person ID")
    status: Optional[TransactionStatus] = Field(None, description="Transaction status")
    payment_status: Optional[PaymentStatus] = Field(None, description="Payment status")
    date_from: Optional[date] = Field(None, description="Date from")
    date_to: Optional[date] = Field(None, description="Date to")
    amount_from: Optional[Decimal] = Field(None, ge=0, description="Amount from")
    amount_to: Optional[Decimal] = Field(None, ge=0, description="Amount to")

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v, info):
        if v is not None and info.data.get("date_from") is not None:
            if v < info.data.get("date_from"):
                raise ValueError("Date to must be after date from")
        return v

    @field_validator("amount_to")
    @classmethod
    def validate_amount_range(cls, v, info):
        if v is not None and info.data.get("amount_from") is not None:
            if v < info.data.get("amount_from"):
                raise ValueError("Amount to must be greater than amount from")
        return v


# Purchase-specific schemas

# Nested response schemas for purchase details
class SupplierNestedResponse(BaseModel):
    """Schema for nested supplier response in purchase transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Supplier name")


class LocationNestedResponse(BaseModel):
    """Schema for nested location response in purchase transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Location name")


class ItemNestedResponse(BaseModel):
    """Schema for nested item response in purchase transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Item name")


class PurchaseItemCreate(BaseModel):
    """Schema for creating a purchase item."""

    item_id: str = Field(..., description="Item ID")
    quantity: int = Field(..., ge=1, description="Quantity")
    unit_cost: Decimal = Field(..., ge=0, description="Unit cost")
    tax_rate: Optional[Decimal] = Field(0, ge=0, le=100, description="Tax rate percentage")
    discount_amount: Optional[Decimal] = Field(0, ge=0, description="Discount amount")
    condition: str = Field(..., pattern="^[A-D]$", description="Item condition (A, B, C, or D)")
    notes: Optional[str] = Field("", description="Additional notes")


class PurchaseLineItemResponse(BaseModel):
    """Schema for purchase line item response with purchase-specific fields."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    item: ItemNestedResponse = Field(..., description="Item details")
    quantity: Decimal
    unit_cost: Decimal = Field(..., description="Unit cost per item")
    tax_rate: Decimal = Field(..., description="Tax rate percentage")
    discount_amount: Decimal = Field(..., description="Discount amount")
    condition: str = Field(..., description="Item condition (A, B, C, or D)")
    notes: str = Field(default="", description="Additional notes")
    tax_amount: Decimal = Field(..., description="Calculated tax amount")
    line_total: Decimal = Field(..., description="Total line amount")
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_transaction_line(cls, line: dict, item_details: dict = None) -> "PurchaseLineItemResponse":
        """Create PurchaseLineItemResponse from TransactionLine data."""
        # Extract condition from description if available
        condition = "A"  # Default condition
        description = line.get("description", "")
        if "(Condition: " in description and ")" in description:
            condition_start = description.find("(Condition: ") + len("(Condition: ")
            condition_end = description.find(")", condition_start)
            condition = description[condition_start:condition_end].strip()
        
        # Create item nested response
        item_nested = ItemNestedResponse(
            id=item_details["id"] if item_details else line["item_id"],
            name=item_details["name"] if item_details else "Unknown Item"
        )
        
        return cls(
            id=line["id"],
            item=item_nested,
            quantity=line["quantity"],
            unit_cost=line["unit_price"],  # Map unit_price to unit_cost
            tax_rate=line["tax_rate"],
            discount_amount=line["discount_amount"],
            condition=condition,
            notes=line.get("notes", ""),
            tax_amount=line["tax_amount"],
            line_total=line["line_total"],
            created_at=line["created_at"],
            updated_at=line["updated_at"],
        )


class PurchaseCreate(BaseModel):
    """Schema for creating a purchase transaction."""

    supplier_id: UUID = Field(..., description="Supplier ID")
    location_id: UUID = Field(..., description="Location ID")
    purchase_date: date = Field(..., description="Purchase date")
    notes: Optional[str] = Field("", description="Additional notes")
    reference_number: Optional[str] = Field("", max_length=50, description="Reference number")
    items: List[PurchaseItemCreate] = Field(..., min_length=1, description="Purchase items")


class NewPurchaseRequest(BaseModel):
    """Schema for the new-purchase endpoint - matches frontend JSON structure exactly."""

    supplier_id: str = Field(..., description="Supplier ID")
    location_id: str = Field(..., description="Location ID")
    purchase_date: str = Field(..., description="Purchase date in YYYY-MM-DD format")
    notes: str = Field("", description="Additional notes")
    reference_number: str = Field("", description="Reference number")
    items: List[PurchaseItemCreate] = Field(..., min_length=1, description="Purchase items")

    @field_validator("purchase_date")
    @classmethod
    def validate_purchase_date(cls, v):
        """Validate and parse the purchase date."""
        try:
            from datetime import datetime

            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")

    @field_validator("supplier_id", "location_id")
    @classmethod
    def validate_uuids(cls, v):
        """Validate UUID strings."""
        try:
            from uuid import UUID

            return UUID(v)
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")


class NewPurchaseResponse(BaseModel):
    """Schema for new-purchase response."""

    model_config = ConfigDict(from_attributes=True)

    success: bool = Field(True, description="Operation success status")
    message: str = Field("Purchase created successfully", description="Response message")
    data: dict = Field(..., description="Purchase transaction data")
    transaction_id: UUID = Field(..., description="Created transaction ID")
    transaction_number: str = Field(..., description="Generated transaction number")


class PurchaseResponse(BaseModel):
    """Schema for purchase response - maps transaction data to purchase format."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    supplier: SupplierNestedResponse = Field(..., description="Supplier details")
    location: LocationNestedResponse = Field(..., description="Location details")
    purchase_date: date = Field(..., description="Purchase date (mapped from transaction_date)")
    reference_number: Optional[str] = Field(
        None, description="Reference number (mapped from transaction_number)"
    )
    notes: Optional[str] = Field(None, description="Additional notes")
    subtotal: Decimal = Field(..., description="Subtotal amount")
    tax_amount: Decimal = Field(..., description="Tax amount")
    discount_amount: Decimal = Field(..., description="Discount amount")
    total_amount: Decimal = Field(..., description="Total amount")
    status: str = Field(..., description="Purchase status")
    payment_status: str = Field(..., description="Payment status")
    created_at: datetime
    updated_at: datetime
    items: List[PurchaseLineItemResponse] = Field(default_factory=list, description="Purchase items")

    @classmethod
    def from_transaction(cls, transaction: dict, supplier_details: dict = None, location_details: dict = None, items_details: dict = None) -> "PurchaseResponse":
        """Create PurchaseResponse from TransactionHeaderResponse data."""
        # Create nested supplier response
        supplier_nested = SupplierNestedResponse(
            id=supplier_details["id"] if supplier_details else transaction["customer_id"],
            name=supplier_details["name"] if supplier_details else "Unknown Supplier"
        )
        
        # Create nested location response
        location_nested = LocationNestedResponse(
            id=location_details["id"] if location_details else transaction["location_id"],
            name=location_details["name"] if location_details else "Unknown Location"
        )
        
        # Transform transaction lines to purchase line items
        purchase_items = []
        items_details = items_details or {}
        for line in transaction.get("transaction_lines", []):
            item_detail = items_details.get(str(line["item_id"]), None)
            purchase_items.append(PurchaseLineItemResponse.from_transaction_line(line, item_detail))
        
        return cls(
            id=transaction["id"],
            supplier=supplier_nested,
            location=location_nested,
            purchase_date=transaction["transaction_date"].date()
            if isinstance(transaction["transaction_date"], datetime)
            else transaction["transaction_date"],
            reference_number=transaction.get("transaction_number"),
            notes=transaction.get("notes"),
            subtotal=transaction["subtotal"],
            tax_amount=transaction["tax_amount"],
            discount_amount=transaction["discount_amount"],
            total_amount=transaction["total_amount"],
            status=transaction["status"],
            payment_status=transaction["payment_status"],
            created_at=transaction["created_at"],
            updated_at=transaction["updated_at"],
            items=purchase_items,
        )


# Rental-specific schemas

class RentalItemCreate(BaseModel):
    """Schema for creating a rental item."""
    
    item_id: str = Field(..., description="Item ID")
    quantity: int = Field(..., ge=0, description="Quantity")
    rental_period_value: int = Field(..., ge=0, description="Rental period value")
    tax_rate: Optional[Decimal] = Field(0, ge=0, le=100, description="Tax rate percentage")
    discount_amount: Optional[Decimal] = Field(0, ge=0, description="Discount amount")
    rental_start_date: str = Field(..., description="Rental start date in YYYY-MM-DD format")
    rental_end_date: str = Field(..., description="Rental end date in YYYY-MM-DD format")
    notes: Optional[str] = Field("", description="Additional notes")
    
    @field_validator("rental_start_date", "rental_end_date")
    @classmethod
    def validate_rental_dates(cls, v):
        """Validate and parse rental dates."""
        try:
            from datetime import datetime
            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")
    
    @model_validator(mode="after")
    def validate_rental_date_range(self):
        """Validate rental end date is after start date."""
        if self.rental_end_date <= self.rental_start_date:
            raise ValueError("Rental end date must be after start date")
        return self


class NewRentalRequest(BaseModel):
    """Schema for the new-rental endpoint - matches frontend JSON structure exactly."""
    
    transaction_date: str = Field(..., description="Transaction date in YYYY-MM-DD format")
    customer_id: str = Field(..., description="Customer ID")
    location_id: str = Field(..., description="Location ID")
    payment_method: str = Field(..., description="Payment method")
    payment_reference: Optional[str] = Field("", description="Payment reference")
    notes: Optional[str] = Field("", description="Additional notes")
    items: List[RentalItemCreate] = Field(..., min_length=1, description="Rental items")
    
    # New delivery fields
    delivery_required: bool = Field(False, description="Whether delivery is required")
    delivery_address: Optional[str] = Field(None, description="Delivery address")
    delivery_date: Optional[str] = Field(None, description="Delivery date in YYYY-MM-DD format")
    delivery_time: Optional[str] = Field(None, description="Delivery time in HH:MM format")
    
    # New pickup fields
    pickup_required: bool = Field(False, description="Whether pickup is required")
    pickup_date: Optional[str] = Field(None, description="Pickup date in YYYY-MM-DD format")
    pickup_time: Optional[str] = Field(None, description="Pickup time in HH:MM format")
    
    # Deposit amount (add reference_number alias for transaction_number)
    deposit_amount: Optional[Decimal] = Field(None, ge=0, description="Security deposit amount")
    reference_number: Optional[str] = Field(None, description="Reference number for the rental")
    
    @field_validator("transaction_date")
    @classmethod
    def validate_transaction_date(cls, v):
        """Validate and parse transaction date."""
        try:
            from datetime import datetime
            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")
    
    @field_validator("customer_id", "location_id")
    @classmethod
    def validate_uuids(cls, v):
        """Validate UUID strings."""
        try:
            from uuid import UUID
            return UUID(v)
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")
    
    @field_validator("payment_method")
    @classmethod
    def validate_payment_method(cls, v):
        """Validate payment method."""
        valid_methods = ["CASH", "CARD", "BANK_TRANSFER", "CHECK", "ONLINE"]
        if v not in valid_methods:
            raise ValueError(f"Invalid payment method. Must be one of: {', '.join(valid_methods)}")
        return v
    
    @field_validator("delivery_date", "pickup_date")
    @classmethod
    def validate_delivery_pickup_dates(cls, v):
        """Validate delivery and pickup dates."""
        if v is not None:
            try:
                from datetime import datetime
                return datetime.strptime(v, "%Y-%m-%d").date()
            except ValueError:
                raise ValueError("Invalid date format. Use YYYY-MM-DD format.")
        return v
    
    @field_validator("delivery_time", "pickup_time")
    @classmethod
    def validate_delivery_pickup_times(cls, v):
        """Validate delivery and pickup times."""
        if v is not None:
            try:
                from datetime import datetime
                return datetime.strptime(v, "%H:%M").time()
            except ValueError:
                raise ValueError("Invalid time format. Use HH:MM format.")
        return v
    
    @model_validator(mode="after")
    def validate_delivery_pickup_requirements(self):
        """Validate delivery and pickup requirements."""
        if self.delivery_required and not self.delivery_address:
            raise ValueError("Delivery address is required when delivery is enabled")
        if self.delivery_required and not self.delivery_date:
            raise ValueError("Delivery date is required when delivery is enabled")
        if self.pickup_required and not self.pickup_date:
            raise ValueError("Pickup date is required when pickup is enabled")
        return self


class NewRentalResponse(BaseModel):
    """Schema for new-rental response."""
    
    model_config = ConfigDict(from_attributes=True)
    
    success: bool = Field(True, description="Operation success status")
    message: str = Field("Rental created successfully", description="Response message")
    data: dict = Field(..., description="Rental transaction data")
    transaction_id: UUID = Field(..., description="Created transaction ID")
    transaction_number: str = Field(..., description="Generated transaction number")


# Sale-specific schemas

class SaleItemCreate(BaseModel):
    """Schema for creating a sale item."""

    item_id: str = Field(..., description="Item ID")
    quantity: int = Field(..., ge=1, description="Quantity")
    unit_cost: Decimal = Field(..., ge=0, description="Unit cost")
    tax_rate: Optional[Decimal] = Field(0, ge=0, le=100, description="Tax rate percentage")
    discount_amount: Optional[Decimal] = Field(0, ge=0, description="Discount amount")
    notes: Optional[str] = Field("", description="Additional notes")

    @field_validator("item_id")
    @classmethod
    def validate_item_id(cls, v):
        """Validate item ID as UUID."""
        try:
            from uuid import UUID
            return UUID(v)
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")


class NewSaleRequest(BaseModel):
    """Schema for the new-sale endpoint - matches frontend JSON structure exactly."""

    customer_id: str = Field(..., description="Customer ID")
    transaction_date: str = Field(..., description="Transaction date in YYYY-MM-DD format")
    notes: Optional[str] = Field("", description="Additional notes")
    reference_number: Optional[str] = Field("", max_length=50, description="Reference number")
    items: List[SaleItemCreate] = Field(..., min_length=1, description="Sale items")

    @field_validator("transaction_date")
    @classmethod
    def validate_transaction_date(cls, v):
        """Validate and parse transaction date."""
        try:
            from datetime import datetime
            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")

    @field_validator("customer_id")
    @classmethod
    def validate_customer_id(cls, v):
        """Validate customer ID as UUID."""
        try:
            from uuid import UUID
            return UUID(v)
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")


class SaleLineItemResponse(BaseModel):
    """Schema for sale line item response with sale-specific fields."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    item: ItemNestedResponse = Field(..., description="Item details")
    quantity: Decimal
    unit_cost: Decimal = Field(..., description="Unit cost per item")
    tax_rate: Decimal = Field(..., description="Tax rate percentage")
    discount_amount: Decimal = Field(..., description="Discount amount")
    notes: str = Field(default="", description="Additional notes")
    tax_amount: Decimal = Field(..., description="Calculated tax amount")
    line_total: Decimal = Field(..., description="Total line amount")
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_transaction_line(cls, line: dict, item_details: dict = None) -> "SaleLineItemResponse":
        """Create SaleLineItemResponse from TransactionLine data."""
        # Create item nested response
        item_nested = ItemNestedResponse(
            id=item_details["id"] if item_details else line["item_id"],
            name=item_details["name"] if item_details else "Unknown Item"
        )
        
        return cls(
            id=line["id"],
            item=item_nested,
            quantity=line["quantity"],
            unit_cost=line["unit_price"],  # Map unit_price to unit_cost
            tax_rate=line["tax_rate"],
            discount_amount=line["discount_amount"],
            notes=line.get("notes", ""),
            tax_amount=line["tax_amount"],
            line_total=line["line_total"],
            created_at=line["created_at"],
            updated_at=line["updated_at"],
        )


class CustomerNestedResponse(BaseModel):
    """Schema for nested customer response in sale transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Customer name")


class SaleResponse(BaseModel):
    """Schema for sale response - maps transaction data to sale format."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    customer: CustomerNestedResponse = Field(..., description="Customer details")
    location: LocationNestedResponse = Field(..., description="Location details")
    transaction_date: date = Field(..., description="Transaction date")
    reference_number: Optional[str] = Field(None, description="Reference number")
    notes: Optional[str] = Field(None, description="Additional notes")
    subtotal: Decimal = Field(..., description="Subtotal amount")
    tax_amount: Decimal = Field(..., description="Tax amount")
    discount_amount: Decimal = Field(..., description="Discount amount")
    total_amount: Decimal = Field(..., description="Total amount")
    status: str = Field(..., description="Sale status")
    payment_status: str = Field(..., description="Payment status")
    created_at: datetime
    updated_at: datetime
    items: List[SaleLineItemResponse] = Field(default_factory=list, description="Sale items")

    @classmethod
    def from_transaction(cls, transaction: dict, customer_details: dict = None, location_details: dict = None, items_details: dict = None) -> "SaleResponse":
        """Create SaleResponse from TransactionHeaderResponse data."""
        # Create nested customer response
        customer_nested = CustomerNestedResponse(
            id=customer_details["id"] if customer_details else transaction["customer_id"],
            name=customer_details["name"] if customer_details else "Unknown Customer"
        )
        
        # Create nested location response
        location_nested = LocationNestedResponse(
            id=location_details["id"] if location_details else transaction["location_id"],
            name=location_details["name"] if location_details else "Unknown Location"
        )
        
        # Transform transaction lines to sale line items
        sale_items = []
        items_details = items_details or {}
        for line in transaction.get("transaction_lines", []):
            item_detail = items_details.get(str(line["item_id"]), None)
            sale_items.append(SaleLineItemResponse.from_transaction_line(line, item_detail))
        
        return cls(
            id=transaction["id"],
            customer=customer_nested,
            location=location_nested,
            transaction_date=transaction["transaction_date"].date()
            if isinstance(transaction["transaction_date"], datetime)
            else transaction["transaction_date"],
            reference_number=transaction.get("transaction_number"),
            notes=transaction.get("notes"),
            subtotal=transaction["subtotal"],
            tax_amount=transaction["tax_amount"],
            discount_amount=transaction["discount_amount"],
            total_amount=transaction["total_amount"],
            status=transaction["status"],
            payment_status=transaction["payment_status"],
            created_at=transaction["created_at"],
            updated_at=transaction["updated_at"],
            items=sale_items,
        )


class NewSaleResponse(BaseModel):
    """Schema for new-sale response."""

    model_config = ConfigDict(from_attributes=True)

    success: bool = Field(True, description="Operation success status")
    message: str = Field("Sale created successfully", description="Response message")
    data: dict = Field(..., description="Sale transaction data")
    transaction_id: UUID = Field(..., description="Created transaction ID")
    transaction_number: str = Field(..., description="Generated transaction number")


class LocationAvailability(BaseModel):
    """Location-wise availability information for rentable items."""

    model_config = ConfigDict(from_attributes=True)

    location_id: UUID = Field(..., description="Location ID")
    location_name: str = Field(..., description="Location name")
    available_quantity: float = Field(..., description="Available quantity at this location")


class BrandNested(BaseModel):
    """Nested brand information for rentable items."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    name: str


class CategoryNested(BaseModel):
    """Nested category information for rentable items."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    name: str


class UnitOfMeasurementNested(BaseModel):
    """Nested unit of measurement information for rentable items."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    name: str
    code: Optional[str] = Field(None, description="Unit abbreviation/code")


class RentableItemResponse(BaseModel):
    """Rentable item with stock position across locations."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID = Field(..., description="Item ID")
    sku: str = Field(..., description="Stock Keeping Unit")
    item_name: str = Field(..., description="Item name")
    rental_rate_per_period: Decimal = Field(..., description="Rental rate per period")
    rental_period: str = Field(..., description="Rental period (number of periods)")
    security_deposit: Decimal = Field(..., description="Security deposit amount")
    total_available_quantity: float = Field(..., description="Total available quantity across all locations")
    brand: Optional[BrandNested] = Field(None, description="Brand information")
    category: Optional[CategoryNested] = Field(None, description="Category information")
    unit_of_measurement: UnitOfMeasurementNested = Field(..., description="Unit of measurement")
    location_availability: List[LocationAvailability] = Field(..., description="Availability breakdown by location")


===== modules/transactions/schemas/rentals.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental-specific Pydantic schemas for API requests and responses.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime, date, time
from decimal import Decimal
from pydantic import BaseModel, Field, ConfigDict

from app.modules.transactions.base.models import RentalStatus, ReturnEventType, InspectionCondition


# Base schemas
class RentalItemBase(BaseModel):
    """Base schema for rental items."""
    transaction_line_id: UUID = Field(..., description="Transaction line ID")
    quantity: Decimal = Field(..., gt=0, description="Quantity to return")


class InspectionDetailsBase(BaseModel):
    """Base schema for inspection details."""
    condition: InspectionCondition = Field(..., description="Item condition")
    has_damage: bool = Field(default=False, description="Whether item has damage")
    damage_description: Optional[str] = Field(None, description="Description of damage")
    damage_photos: Optional[List[str]] = Field(None, description="URLs of damage photos")
    damage_fee: Optional[Decimal] = Field(None, ge=0, description="Damage fee assessed")
    cleaning_fee: Optional[Decimal] = Field(None, ge=0, description="Cleaning fee assessed")
    replacement_required: bool = Field(default=False, description="Whether replacement is required")
    replacement_cost: Optional[Decimal] = Field(None, ge=0, description="Cost of replacement")
    return_to_stock: bool = Field(default=True, description="Whether item can be returned to stock")
    notes: Optional[str] = Field(None, description="Inspection notes")


# Request schemas
class RentalReturnInitiateRequest(BaseModel):
    """Schema for initiating a rental return."""
    return_date: date = Field(..., description="Date of return")
    items_to_return: List[RentalItemBase] = Field(..., min_length=1, description="Items being returned")
    notes: Optional[str] = Field(None, description="Return notes")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "return_date": "2025-07-14",
                "items_to_return": [
                    {
                        "transaction_line_id": "550e8400-e29b-41d4-a716-446655440000",
                        "quantity": 2
                    }
                ],
                "notes": "Customer returning early"
            }
        }
    )


class RentalItemInspectionRequest(BaseModel):
    """Schema for recording item inspection."""
    transaction_line_id: UUID = Field(..., description="Transaction line ID")
    quantity_inspected: Decimal = Field(..., gt=0, description="Quantity inspected")
    inspection_details: InspectionDetailsBase = Field(..., description="Inspection details")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "transaction_line_id": "550e8400-e29b-41d4-a716-446655440000",
                "quantity_inspected": 2,
                "inspection_details": {
                    "condition": "GOOD",
                    "has_damage": False,
                    "return_to_stock": True,
                    "notes": "Items in good condition"
                }
            }
        }
    )


class RentalReturnCompleteRequest(BaseModel):
    """Schema for completing a rental return."""
    payment_collected: Decimal = Field(default=0, ge=0, description="Payment collected")
    refund_issued: Decimal = Field(default=0, ge=0, description="Refund issued")
    receipt_number: Optional[str] = Field(None, description="Receipt number")
    notes: Optional[str] = Field(None, description="Completion notes")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "payment_collected": 25.00,
                "refund_issued": 0,
                "receipt_number": "RCP-20250714-001",
                "notes": "Late fees collected"
            }
        }
    )


class RentalExtensionRequest(BaseModel):
    """Schema for extending rental period."""
    new_end_date: date = Field(..., description="New rental end date")
    reason: str = Field(..., min_length=1, max_length=200, description="Reason for extension")
    notes: Optional[str] = Field(None, description="Additional notes")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "new_end_date": "2025-07-21",
                "reason": "Customer requested additional time",
                "notes": "Approved by manager"
            }
        }
    )


class RentalStatusUpdateRequest(BaseModel):
    """Schema for updating rental status."""
    new_status: RentalStatus = Field(..., description="New rental status")
    notes: Optional[str] = Field(None, description="Status change notes")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "new_status": "LATE",
                "notes": "Automatically updated - overdue"
            }
        }
    )


# Response schemas
class RentalLifecycleResponse(BaseModel):
    """Schema for rental lifecycle response."""
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    transaction_id: UUID
    current_status: str
    last_status_change: datetime
    status_changed_by: Optional[UUID]
    total_returned_quantity: Decimal
    expected_return_date: Optional[date]
    total_late_fees: Decimal
    total_damage_fees: Decimal
    total_other_fees: Decimal
    notes: Optional[str]
    created_at: datetime
    updated_at: datetime

    @property
    def total_fees(self) -> Decimal:
        """Calculate total fees."""
        return self.total_late_fees + self.total_damage_fees + self.total_other_fees


class RentalReturnEventResponse(BaseModel):
    """Schema for rental return event response."""
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    rental_lifecycle_id: UUID
    event_type: str
    event_date: date
    processed_by: Optional[UUID]
    processed_at: datetime
    items_returned: Optional[List[Dict[str, Any]]]
    total_quantity_returned: Decimal
    late_fees_charged: Decimal
    damage_fees_charged: Decimal
    other_fees_charged: Decimal
    payment_collected: Decimal
    refund_issued: Decimal
    new_return_date: Optional[date]
    extension_reason: Optional[str]
    notes: Optional[str]
    receipt_number: Optional[str]

    @property
    def total_fees_charged(self) -> Decimal:
        """Calculate total fees charged."""
        return self.late_fees_charged + self.damage_fees_charged + self.other_fees_charged

    @property
    def net_amount(self) -> Decimal:
        """Calculate net payment amount."""
        return self.payment_collected - self.refund_issued


class RentalItemInspectionResponse(BaseModel):
    """Schema for rental item inspection response."""
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    return_event_id: UUID
    transaction_line_id: UUID
    quantity_inspected: Decimal
    condition: str
    inspected_by: Optional[UUID]
    inspected_at: datetime
    has_damage: bool
    damage_description: Optional[str]
    damage_photos: Optional[List[str]]
    damage_fee_assessed: Decimal
    cleaning_fee_assessed: Decimal
    replacement_required: bool
    replacement_cost: Optional[Decimal]
    return_to_stock: bool
    stock_location: Optional[str]
    inspection_notes: Optional[str]

    @property
    def total_fees_assessed(self) -> Decimal:
        """Calculate total fees assessed."""
        return (
            self.damage_fee_assessed + 
            self.cleaning_fee_assessed + 
            (self.replacement_cost or Decimal('0'))
        )


class RentalTransactionResponse(BaseModel):
    """Schema for rental transaction response with lifecycle info."""
    model_config = ConfigDict(from_attributes=True)

    # Transaction fields
    id: UUID
    transaction_number: str
    transaction_date: datetime
    customer_id: Optional[str]
    location_id: Optional[str]
    status: str
    rental_start_date: Optional[date]
    rental_end_date: Optional[date]
    rental_period: Optional[int]
    rental_period_unit: Optional[str]
    total_amount: Decimal
    paid_amount: Decimal
    deposit_amount: Optional[Decimal]
    deposit_paid: bool
    current_rental_status: Optional[str]
    customer_advance_balance: Decimal
    
    # New delivery fields
    delivery_required: bool
    delivery_address: Optional[str]
    delivery_date: Optional[date]
    delivery_time: Optional[time]
    
    # New pickup fields
    pickup_required: bool
    pickup_date: Optional[date]
    pickup_time: Optional[time]

    # Lifecycle info
    lifecycle: Optional[RentalLifecycleResponse] = None
    
    @property
    def is_overdue(self) -> bool:
        """Check if rental is overdue."""
        if not self.rental_end_date:
            return False
        return self.rental_end_date < date.today()

    @property
    def days_overdue(self) -> int:
        """Calculate days overdue."""
        if not self.is_overdue:
            return 0
        return (date.today() - self.rental_end_date).days
    
    @property
    def reference_number(self) -> str:
        """Alias for transaction_number to match frontend expectations."""
        return self.transaction_number


class RentalDetailsResponse(BaseModel):
    """Comprehensive rental details response."""
    model_config = ConfigDict(from_attributes=True)

    transaction: RentalTransactionResponse
    lifecycle: RentalLifecycleResponse
    return_events: List[RentalReturnEventResponse]
    inspections: List[RentalItemInspectionResponse]
    total_fees: Decimal
    is_overdue: bool
    days_overdue: int


class RentalListResponse(BaseModel):
    """Schema for rental list response."""
    rentals: List[RentalTransactionResponse]
    total_count: int
    page: int
    page_size: int
    total_pages: int


class RentalDashboardResponse(BaseModel):
    """Schema for rental dashboard statistics."""
    active_rentals: int
    overdue_rentals: int
    partial_returns: int
    completed_today: int
    total_fees_pending: Decimal
    total_fees_collected_today: Decimal

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "active_rentals": 45,
                "overdue_rentals": 8,
                "partial_returns": 3,
                "completed_today": 12,
                "total_fees_pending": 1250.00,
                "total_fees_collected_today": 350.00
            }
        }
    )


# Query parameters schemas
class RentalQueryParams(BaseModel):
    """Query parameters for rental listing."""
    customer_id: Optional[UUID] = Field(None, description="Filter by customer")
    location_id: Optional[UUID] = Field(None, description="Filter by location")
    status: Optional[RentalStatus] = Field(None, description="Filter by status")
    overdue_only: bool = Field(False, description="Show only overdue rentals")
    date_from: Optional[date] = Field(None, description="Filter by rental start date")
    date_to: Optional[date] = Field(None, description="Filter by rental end date")
    page: int = Field(1, ge=1, description="Page number")
    page_size: int = Field(20, ge=1, le=100, description="Items per page")


class ReturnEventQueryParams(BaseModel):
    """Query parameters for return events."""
    event_type: Optional[ReturnEventType] = Field(None, description="Filter by event type")
    date_from: Optional[date] = Field(None, description="Filter by event date")
    date_to: Optional[date] = Field(None, description="Filter by event date")
    processed_by: Optional[UUID] = Field(None, description="Filter by processor")


# Utility schemas
class RentalFeeCalculation(BaseModel):
    """Schema for rental fee calculations."""
    base_amount: Decimal
    late_fee_days: int
    late_fee_rate: Decimal
    late_fee_amount: Decimal
    damage_fees: Decimal
    other_fees: Decimal
    total_fees: Decimal
    deposit_credit: Decimal
    advance_payment_credit: Decimal
    amount_due: Decimal

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "base_amount": 100.00,
                "late_fee_days": 3,
                "late_fee_rate": 0.05,
                "late_fee_amount": 15.00,
                "damage_fees": 25.00,
                "other_fees": 0.00,
                "total_fees": 40.00,
                "deposit_credit": 50.00,
                "advance_payment_credit": 0.00,
                "amount_due": 90.00
            }
        }
    )


class BatchStatusUpdateRequest(BaseModel):
    """Schema for batch status updates."""
    transaction_ids: List[UUID] = Field(..., min_length=1, description="Transaction IDs to update")
    new_status: RentalStatus = Field(..., description="New status for all transactions")
    notes: Optional[str] = Field(None, description="Batch update notes")


class BatchStatusUpdateResponse(BaseModel):
    """Schema for batch status update response."""
    updated_count: int
    failed_count: int
    failed_transactions: List[Dict[str, Any]]
    updated_transactions: List[UUID]

===== modules/transactions/schemas/returns.py â€“ 2025-07-19 12:13:41 IST =====
"""
Return transaction schemas with polymorphic design for type-specific properties.
"""
from typing import Union, Literal, Optional, List, Dict, Any
from datetime import datetime, date
from decimal import Decimal
from pydantic import BaseModel, Field, field_validator, model_validator
from uuid import UUID


# Base return line item schema
class ReturnLineItemBase(BaseModel):
    """Base schema for return line items."""
    
    original_line_id: UUID = Field(..., description="Original transaction line ID")
    return_quantity: Decimal = Field(..., gt=0, description="Quantity to return")
    return_reason: Optional[str] = Field(None, description="Item-specific return reason")


# Sale return specific line item
class SaleReturnLineItem(ReturnLineItemBase):
    """Sale return specific line item properties."""
    
    condition: Literal["NEW", "OPENED", "USED", "DAMAGED"] = Field(..., description="Item condition")
    return_to_stock: bool = Field(default=True, description="Whether to return to stock")
    original_packaging: bool = Field(default=True, description="Has original packaging")
    all_accessories_included: bool = Field(default=True, description="All accessories included")
    testing_required: bool = Field(default=False, description="Requires testing")
    testing_notes: Optional[str] = Field(None, description="Testing notes")


# Purchase return specific line item
class PurchaseReturnLineItem(ReturnLineItemBase):
    """Purchase return specific line item properties."""
    
    defect_code: Optional[str] = Field(None, description="Supplier defect code")
    batch_number: Optional[str] = Field(None, description="Batch number for tracking")
    expiry_date: Optional[date] = Field(None, description="For perishables")
    supplier_fault: bool = Field(default=False, description="Is supplier at fault")
    replacement_requested: bool = Field(default=False, description="Request replacement")


# Rental return specific line item
class RentalReturnLineItem(ReturnLineItemBase):
    """Rental return specific line item properties."""
    
    condition_on_return: Literal["EXCELLENT", "GOOD", "FAIR", "POOR", "DAMAGED"] = Field(...)
    damage_description: Optional[str] = Field(None, description="Damage description")
    damage_photos: Optional[List[str]] = Field(default_factory=list, description="Damage photo URLs")
    cleaning_condition: Literal["CLEAN", "MINOR_CLEANING", "MAJOR_CLEANING"] = Field(...)
    functionality_check: Literal["WORKING", "PARTIAL", "NOT_WORKING"] = Field(...)
    missing_accessories: Optional[List[str]] = Field(default_factory=list)
    estimated_repair_cost: Optional[Decimal] = Field(None, ge=0)
    beyond_normal_wear: bool = Field(default=False)




# Base return transaction schema
class ReturnTransactionBase(BaseModel):
    """Base schema for all return transactions."""
    
    # Shared properties
    original_transaction_id: UUID = Field(..., description="Original transaction to return against")
    return_date: datetime = Field(default_factory=datetime.utcnow)
    return_reason_code: str = Field(..., max_length=50, description="Standardized return reason code")
    return_reason_notes: Optional[str] = Field(None, max_length=1000, description="Additional return notes")
    processed_by: Optional[UUID] = Field(None, description="User processing the return")
    
    # Financial adjustments (shared but calculated differently)
    refund_amount: Optional[Decimal] = Field(None, ge=0, description="Amount to refund")
    restocking_fee: Optional[Decimal] = Field(default=Decimal("0"), ge=0)


# Sale return specific schema
class SaleReturnCreate(ReturnTransactionBase):
    """Sale return specific properties."""
    
    return_type: Literal["SALE_RETURN"] = Field(default="SALE_RETURN")
    
    # Sale-specific properties
    customer_return_method: Literal["IN_STORE", "SHIPPED", "PICKUP"] = Field(..., description="How customer is returning")
    refund_method: Literal["ORIGINAL_PAYMENT", "STORE_CREDIT", "EXCHANGE"] = Field(..., description="Refund method")
    exchange_transaction_id: Optional[UUID] = Field(None, description="New transaction if exchange")
    return_shipping_cost: Optional[Decimal] = Field(None, ge=0, description="Cost of return shipping")
    customer_pays_shipping: bool = Field(default=False)
    quality_check_required: bool = Field(default=True)
    restock_location_id: Optional[UUID] = Field(None, description="Where to restock items")
    
    # Line items
    return_items: List[SaleReturnLineItem] = Field(..., min_length=1, description="Items to return")
    
    @model_validator(mode='after')
    def validate_exchange_transaction(self):
        """Validate exchange transaction ID is provided when refund method is exchange."""
        if self.refund_method == "EXCHANGE" and not self.exchange_transaction_id:
            raise ValueError("Exchange transaction ID required when refund method is EXCHANGE")
        return self


# Purchase return specific schema
class PurchaseReturnCreate(ReturnTransactionBase):
    """Purchase return specific properties."""
    
    return_type: Literal["PURCHASE_RETURN"] = Field(default="PURCHASE_RETURN")
    
    # Purchase-specific properties
    supplier_rma_number: Optional[str] = Field(None, max_length=100, description="Supplier's RMA number")
    return_authorization_date: Optional[date] = Field(None)
    supplier_credit_expected: bool = Field(default=True)
    credit_memo_number: Optional[str] = Field(None, max_length=100)
    return_shipping_method: Optional[str] = Field(None, max_length=100)
    return_tracking_number: Optional[str] = Field(None, max_length=100)
    supplier_restocking_fee_percent: Optional[Decimal] = Field(None, ge=0, le=100)
    quality_claim: bool = Field(default=False, description="Is this a quality issue claim?")
    expected_credit_date: Optional[date] = Field(None)
    
    # Line items
    return_items: List[PurchaseReturnLineItem] = Field(..., min_length=1, description="Items to return")
    
    @model_validator(mode='after')
    def validate_quality_claim(self):
        """Validate quality claim has supplier fault items."""
        if self.quality_claim:
            has_supplier_fault = any(item.supplier_fault for item in self.return_items)
            if not has_supplier_fault:
                raise ValueError("Quality claim requires at least one item marked as supplier fault")
        return self




# Rental return specific schema
class RentalReturnCreate(ReturnTransactionBase):
    """Rental return specific properties."""
    
    return_type: Literal["RENTAL_RETURN"] = Field(default="RENTAL_RETURN")
    
    # Rental-specific properties
    scheduled_return_date: date = Field(..., description="When it was supposed to be returned")
    actual_return_date: date = Field(..., description="When it was actually returned")
    late_fee_applicable: bool = Field(default=False)
    late_fee_amount: Optional[Decimal] = Field(None, ge=0)
    damage_assessment_required: bool = Field(default=True)
    cleaning_required: bool = Field(default=False)
    cleaning_fee: Optional[Decimal] = Field(None, ge=0)
    deposit_amount: Decimal = Field(..., ge=0, description="Original deposit")
    deposit_deductions: Optional[Decimal] = Field(default=Decimal("0"), ge=0)
    deposit_refund_amount: Optional[Decimal] = Field(None, ge=0)
    inspection_checklist: Optional[Dict[str, Any]] = Field(None)
    photos_required: bool = Field(default=True)
    photo_urls: Optional[List[str]] = Field(default_factory=list)
    
    # Line items
    return_items: List[RentalReturnLineItem] = Field(..., min_length=1, description="Items to return")
    
    @field_validator('actual_return_date')
    @classmethod
    def validate_return_date(cls, v, info):
        """Validate actual return date is not in future."""
        if v > date.today():
            raise ValueError("Actual return date cannot be in the future")
        return v
    
    @model_validator(mode='after')
    def validate_late_fee(self):
        """Validate late fee consistency."""
        if self.actual_return_date > self.scheduled_return_date:
            self.late_fee_applicable = True
            if not self.late_fee_amount or self.late_fee_amount == 0:
                # Calculate default late fee if not provided
                days_late = (self.actual_return_date - self.scheduled_return_date).days
                self.late_fee_amount = Decimal(str(days_late * 10))  # $10 per day default
        return self
    
    @model_validator(mode='after')
    def validate_photos(self):
        """Validate photos are provided when required."""
        if self.photos_required and self.damage_assessment_required:
            has_damage = any(
                item.condition_on_return in ["POOR", "DAMAGED"] 
                for item in self.return_items
            )
            if has_damage and not self.photo_urls:
                raise ValueError("Photos required for damaged items")
        return self


# Union type for all return creates
ReturnTransactionCreate = Union[
    SaleReturnCreate,
    PurchaseReturnCreate,
    RentalReturnCreate
]


# Response schemas for returns
class ReturnTransactionResponse(BaseModel):
    """Base response for return transactions."""
    
    id: UUID
    transaction_number: str
    return_type: str
    original_transaction_id: UUID
    reference_transaction_number: str
    return_date: datetime
    return_reason_code: str
    return_reason_notes: Optional[str]
    status: str
    financial_summary: Dict[str, Decimal]
    created_at: datetime
    updated_at: datetime


class SaleReturnDetails(BaseModel):
    """Sale return specific details for response."""
    
    customer_return_method: str
    refund_method: str
    exchange_transaction_id: Optional[UUID]
    return_shipping_cost: Optional[Decimal]
    customer_pays_shipping: bool
    quality_check_required: bool
    quality_check_status: Optional[str]
    restock_location_id: Optional[UUID]


class PurchaseReturnDetails(BaseModel):
    """Purchase return specific details for response."""
    
    supplier_rma_number: Optional[str]
    return_authorization_date: Optional[date]
    supplier_credit_expected: bool
    credit_memo_number: Optional[str]
    return_shipping_method: Optional[str]
    return_tracking_number: Optional[str]
    supplier_restocking_fee_percent: Optional[Decimal]
    quality_claim: bool
    expected_credit_date: Optional[date]
    credit_received: bool = False
    credit_received_date: Optional[date]


class RentalReturnDetails(BaseModel):
    """Rental return specific details for response."""
    
    scheduled_return_date: date
    actual_return_date: date
    days_late: int
    late_fee_applicable: bool
    late_fee_amount: Decimal
    damage_assessment_required: bool
    damage_assessment_status: Optional[str]
    cleaning_required: bool
    cleaning_fee: Decimal
    deposit_amount: Decimal
    deposit_deductions: Decimal
    deposit_refund_amount: Decimal
    inspection_checklist: Optional[Dict[str, Any]]
    photo_urls: List[str]


class ReturnDetailsResponse(BaseModel):
    """Comprehensive return details response."""
    
    # Common fields
    id: UUID
    transaction_number: str
    return_type: str
    original_transaction_id: UUID
    return_date: datetime
    status: str
    
    # Financial summary
    financial_summary: Dict[str, Decimal]
    
    # Type-specific details
    specific_details: Union[
        SaleReturnDetails,
        PurchaseReturnDetails,
        RentalReturnDetails
    ]
    
    # Line items
    return_lines: List[Dict[str, Any]]
    
    created_at: datetime
    updated_at: datetime


# Validation and status update schemas
class ReturnValidationRequest(BaseModel):
    """Request for return validation."""
    
    return_data: ReturnTransactionCreate


class ReturnValidationResponse(BaseModel):
    """Response from return validation."""
    
    is_valid: bool
    errors: List[str] = Field(default_factory=list)
    warnings: List[str] = Field(default_factory=list)
    estimated_refund: Optional[Decimal]
    estimated_fees: Optional[Dict[str, Decimal]]


class ReturnStatusUpdate(BaseModel):
    """Update return status."""
    
    new_status: str
    notes: Optional[str]
    updated_by: UUID


class ReturnWorkflowState(str):
    """Return workflow states."""
    
    INITIATED = "INITIATED"
    VALIDATED = "VALIDATED"
    ITEMS_RECEIVED = "ITEMS_RECEIVED"
    INSPECTION_PENDING = "INSPECTION_PENDING"
    INSPECTION_COMPLETE = "INSPECTION_COMPLETE"
    REFUND_APPROVED = "REFUND_APPROVED"
    REFUND_PROCESSED = "REFUND_PROCESSED"
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"




# Purchase return credit memo schemas
class PurchaseCreditMemoCreate(BaseModel):
    """Record supplier credit memo for purchase return."""
    
    return_id: UUID = Field(..., description="Purchase return ID")
    credit_memo_number: str = Field(..., max_length=100, description="Supplier's credit memo number")
    credit_date: date = Field(..., description="Date credit was issued")
    credit_amount: Decimal = Field(..., gt=0, description="Credit amount")
    
    # Credit details
    credit_type: Literal["FULL_REFUND", "PARTIAL_REFUND", "STORE_CREDIT", "REPLACEMENT"] = Field(...)
    currency: str = Field(default="USD", max_length=3)
    exchange_rate: Optional[Decimal] = Field(default=Decimal("1.0"), gt=0)
    
    # Line item credits (optional breakdown)
    line_credits: Optional[List[Dict[str, Any]]] = Field(None)
    
    # Additional information
    credit_terms: Optional[str] = Field(None, max_length=500)
    supplier_notes: Optional[str] = Field(None, max_length=1000)
    received_by: UUID = Field(..., description="User recording the credit")
    
    @model_validator(mode='after')
    def validate_credit_amount(self):
        """Validate credit amount is reasonable."""
        if self.credit_amount <= 0:
            raise ValueError("Credit amount must be positive")
        return self


class PurchaseCreditMemoResponse(BaseModel):
    """Purchase credit memo response."""
    
    id: UUID
    return_id: UUID
    credit_memo_number: str
    credit_date: date
    credit_amount: Decimal
    credit_type: str
    currency: str
    exchange_rate: Decimal
    line_credits: Optional[List[Dict[str, Any]]]
    credit_terms: Optional[str]
    supplier_notes: Optional[str]
    received_by: UUID
    created_at: datetime
    updated_at: datetime

===== modules/transactions/purchase/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""
Purchase Module

Handles all purchase-related transactions including creation, retrieval, and returns.
"""

from app.modules.transactions.purchase.schemas import (
    PurchaseResponse,
    NewPurchaseRequest,
    NewPurchaseResponse,
    PurchaseItemCreate,
    PurchaseLineItemResponse,
    PurchaseDetail,
    PurchaseListResponse,
    SupplierNestedResponse,
    LocationNestedResponse,
    ItemNestedResponse,
)
from app.modules.transactions.purchase.service import PurchaseService
from app.modules.transactions.purchase.repository import PurchaseRepository
from app.modules.transactions.purchase.routes import router as purchase_router

__all__ = [
    # Schemas
    "PurchaseResponse",
    "NewPurchaseRequest",
    "NewPurchaseResponse",
    "PurchaseItemCreate",
    "PurchaseLineItemResponse",
    "PurchaseDetail",
    "PurchaseListResponse",
    "SupplierNestedResponse",
    "LocationNestedResponse",
    "ItemNestedResponse",
    # Service and Repository
    "PurchaseService",
    "PurchaseRepository",
    # Router
    "purchase_router",
]

===== modules/transactions/purchase/repository.py â€“ 2025-07-19 12:13:41 IST =====
"""
Purchase Repository

Data access layer for purchase-specific operations.
"""

from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, update
from sqlalchemy.orm import selectinload

from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionLine,
    TransactionType,
    TransactionStatus,
    PaymentStatus,
)
from app.modules.transactions.base.repository import TransactionHeaderRepository


class PurchaseRepository(TransactionHeaderRepository):
    """Repository for purchase-specific operations."""

    async def get_purchases(
        self,
        skip: int = 0,
        limit: int = 100,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        amount_from: Optional[Decimal] = None,
        amount_to: Optional[Decimal] = None,
        supplier_id: Optional[UUID] = None,
        status: Optional[TransactionStatus] = None,
        payment_status: Optional[PaymentStatus] = None,
    ) -> List[TransactionHeader]:
        """Get purchase transactions with filtering."""
        filters = [TransactionHeader.transaction_type == TransactionType.PURCHASE]
        
        if date_from:
            filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
        if date_to:
            filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))
        if amount_from:
            filters.append(TransactionHeader.total_amount >= amount_from)
        if amount_to:
            filters.append(TransactionHeader.total_amount <= amount_to)
        if supplier_id:
            filters.append(TransactionHeader.customer_id == str(supplier_id))
        if status:
            filters.append(TransactionHeader.status == status)
        if payment_status:
            filters.append(TransactionHeader.payment_status == payment_status)

        stmt = (
            select(TransactionHeader)
            .where(and_(*filters))
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
            .offset(skip)
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def get_purchase_by_id(self, purchase_id: UUID) -> Optional[TransactionHeader]:
        """Get a single purchase transaction by ID."""
        stmt = (
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.id == purchase_id,
                    TransactionHeader.transaction_type == TransactionType.PURCHASE
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
        )
        
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()

    async def get_purchase_summary(
        self,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        supplier_id: Optional[UUID] = None,
    ) -> Dict[str, Any]:
        """Get purchase summary statistics."""
        filters = [TransactionHeader.transaction_type == TransactionType.PURCHASE]
        
        if date_from:
            filters.append(TransactionHeader.transaction_date >= datetime.combine(date_from, datetime.min.time()))
        if date_to:
            filters.append(TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time()))
        if supplier_id:
            filters.append(TransactionHeader.customer_id == str(supplier_id))

        # Get aggregated data
        stmt = select(
            func.count(TransactionHeader.id).label('total_purchases'),
            func.sum(TransactionHeader.total_amount).label('total_amount'),
            func.sum(TransactionHeader.tax_amount).label('total_tax'),
            func.sum(TransactionHeader.discount_amount).label('total_discount'),
            func.avg(TransactionHeader.total_amount).label('average_amount'),
        ).where(and_(*filters))
        
        result = await self.session.execute(stmt)
        summary = result.first()
        
        return {
            'total_purchases': summary.total_purchases or 0,
            'total_amount': float(summary.total_amount or 0),
            'total_tax': float(summary.total_tax or 0),
            'total_discount': float(summary.total_discount or 0),
            'average_amount': float(summary.average_amount or 0),
        }

    async def get_purchase_returns(self, purchase_id: UUID) -> List[TransactionHeader]:
        """Get all return transactions for a purchase."""
        stmt = (
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.reference_transaction_id == str(purchase_id),
                    TransactionHeader.transaction_type == TransactionType.RETURN,
                    TransactionHeader.is_active == True
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def get_supplier_purchase_history(
        self,
        supplier_id: UUID,
        skip: int = 0,
        limit: int = 100
    ) -> List[TransactionHeader]:
        """Get purchase history for a specific supplier."""
        stmt = (
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.customer_id == str(supplier_id),
                    TransactionHeader.transaction_type == TransactionType.PURCHASE,
                    TransactionHeader.is_active == True
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
            .order_by(TransactionHeader.transaction_date.desc())
            .offset(skip)
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().unique().all()

    async def update_purchase_payment_status(
        self,
        purchase_id: UUID,
        payment_status: PaymentStatus,
        paid_amount: Optional[Decimal] = None
    ) -> bool:
        """Update payment status for a purchase."""
        values = {'payment_status': payment_status}
        if paid_amount is not None:
            values['paid_amount'] = paid_amount
            
        stmt = (
            update(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.id == purchase_id,
                    TransactionHeader.transaction_type == TransactionType.PURCHASE
                )
            )
            .values(**values)
        )
        
        result = await self.session.execute(stmt)
        await self.session.commit()
        return result.rowcount > 0

===== modules/transactions/purchase/routes.py â€“ 2025-07-19 16:22:34 IST =====
"""
Purchase Routes

API endpoints for purchase-related operations.
"""

from typing import List, Optional
from uuid import UUID
from datetime import date
from decimal import Decimal
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.shared.dependencies import get_session
from app.modules.transactions.purchase.service import PurchaseService
from app.modules.transactions.base.models import (
    TransactionStatus,
    PaymentStatus,
)
from app.modules.transactions.purchase.schemas import (
    PurchaseResponse,
    NewPurchaseRequest,
    NewPurchaseResponse,
)
from app.core.errors import NotFoundError, ValidationError, ConflictError


router = APIRouter(tags=["purchases"])


def get_purchase_service(session: AsyncSession = Depends(get_session)) -> PurchaseService:
    """Get purchase service instance."""
    return PurchaseService(session)


@router.get("/", response_model=List[PurchaseResponse])
async def get_purchase_transactions(
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
    date_from: Optional[date] = Query(None, description="Purchase date from (inclusive)"),
    date_to: Optional[date] = Query(None, description="Purchase date to (inclusive)"),
    amount_from: Optional[Decimal] = Query(None, ge=0, description="Minimum total amount"),
    amount_to: Optional[Decimal] = Query(None, ge=0, description="Maximum total amount"),
    supplier_id: Optional[UUID] = Query(None, description="Filter by supplier ID"),
    status: Optional[TransactionStatus] = Query(None, description="Transaction status"),
    payment_status: Optional[PaymentStatus] = Query(None, description="Payment status"),
    service: PurchaseService = Depends(get_purchase_service),
):
    """
    Get purchase transactions with filtering options.
    
    Filters:
    - date_from/date_to: Filter by purchase date range
    - amount_from/amount_to: Filter by total amount range
    - supplier_id: Filter by specific supplier
    - status: Filter by transaction status
    - payment_status: Filter by payment status
    
    Returns list of purchase transactions with purchase-specific line item format.
    """
    return await service.get_purchase_transactions(
        skip=skip,
        limit=limit,
        date_from=date_from,
        date_to=date_to,
        amount_from=amount_from,
        amount_to=amount_to,
        supplier_id=supplier_id,
        status=status,
        payment_status=payment_status,
    )


@router.get("/{purchase_id}", response_model=PurchaseResponse)
async def get_purchase_by_id(
    purchase_id: UUID, service: PurchaseService = Depends(get_purchase_service)
):
    """Get a single purchase transaction by ID with purchase-specific format."""
    try:
        return await service.get_purchase_by_id(purchase_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


@router.post("/new", response_model=NewPurchaseResponse, status_code=status.HTTP_201_CREATED)
async def create_new_purchase(
    purchase_data: NewPurchaseRequest,
    service: PurchaseService = Depends(get_purchase_service),
):
    """
    Create a new purchase transaction with the simplified format.

    This endpoint accepts purchase data in the exact format sent by the frontend:
    - supplier_id as string UUID
    - location_id as string UUID
    - purchase_date as string in YYYY-MM-DD format
    - notes as string (can be empty)
    - reference_number as string (can be empty)
    - items array with item_id as string, quantity, unit_cost, tax_rate, discount_amount, condition, notes

    Returns a standardized response with success status, message, transaction data, and identifiers.
    """
    try:
        print("Creating new purchase with data:", purchase_data)
        return await service.create_new_purchase(purchase_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except Exception as e:
        import traceback
        print(f"ERROR: Full exception details: {e}")
        print(f"ERROR: Exception type: {type(e)}")
        print(f"ERROR: Traceback: {traceback.format_exc()}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}",
        )


@router.get("/returns/{purchase_id}")
async def get_purchase_returns(
    purchase_id: UUID,
    service: PurchaseService = Depends(get_purchase_service),
):
    """
    Get all return transactions for a specific purchase.
    
    This endpoint retrieves all return transactions that reference
    the given purchase transaction ID.
    """
    try:
        return await service.get_purchase_returns(purchase_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting purchase returns: {str(e)}"
        )

===== modules/transactions/purchase/schemas.py â€“ 2025-07-20 08:46:14 IST =====
"""
Purchase Schemas

Pydantic schemas for purchase-related operations.
"""

from typing import Optional, List
from datetime import date, datetime
from decimal import Decimal
from pydantic import BaseModel, Field, ConfigDict, field_validator
from uuid import UUID

from app.modules.transactions.base.models import TransactionType, TransactionStatus, PaymentStatus


# Nested response schemas for purchase details
class SupplierNestedResponse(BaseModel):
    """Schema for nested supplier response in purchase transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Supplier name")


class LocationNestedResponse(BaseModel):
    """Schema for nested location response in purchase transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Location name")


class ItemNestedResponse(BaseModel):
    """Schema for nested item response in purchase transactions."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str = Field(..., description="Item name")


class PurchaseItemCreate(BaseModel):
    """Schema for creating a purchase item."""

    item_id: str = Field(..., description="Item ID")
    quantity: int = Field(..., ge=1, description="Quantity")
    unit_cost: Decimal = Field(..., ge=0, description="Unit cost")
    tax_rate: Optional[Decimal] = Field(0, ge=0, le=100, description="Tax rate percentage")
    discount_amount: Optional[Decimal] = Field(0, ge=0, description="Discount amount")
    condition: str = Field(..., pattern="^[A-D]$", description="Item condition (A, B, C, or D)")
    notes: Optional[str] = Field("", description="Additional notes")


class PurchaseLineItemResponse(BaseModel):
    """Schema for purchase line item response with purchase-specific fields."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    item: ItemNestedResponse = Field(..., description="Item details")
    quantity: Decimal
    unit_cost: Decimal = Field(..., description="Unit cost per item")
    tax_rate: Decimal = Field(..., description="Tax rate percentage")
    discount_amount: Decimal = Field(..., description="Discount amount")
    condition: str = Field(..., description="Item condition (A, B, C, or D)")
    notes: str = Field(default="", description="Additional notes")
    tax_amount: Decimal = Field(..., description="Calculated tax amount")
    line_total: Decimal = Field(..., description="Total line amount")
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_transaction_line(cls, line: dict, item_details: dict = None) -> "PurchaseLineItemResponse":
        """Create PurchaseLineItemResponse from TransactionLine data."""
        # Extract condition from description if available
        condition = "A"  # Default condition
        description = line.get("description", "")
        if "(Condition: " in description and ")" in description:
            condition_start = description.find("(Condition: ") + len("(Condition: ")
            condition_end = description.find(")", condition_start)
            condition = description[condition_start:condition_end].strip()
        
        # Create item nested response
        item_nested = ItemNestedResponse(
            id=item_details["id"] if item_details else line["item_id"],
            name=item_details["name"] if item_details else "Unknown Item"
        )
        
        return cls(
            id=line["id"],
            item=item_nested,
            quantity=line["quantity"],
            unit_cost=line["unit_price"],  # Map unit_price to unit_cost
            tax_rate=line["tax_rate"],
            discount_amount=line["discount_amount"],
            condition=condition,
            notes=line.get("notes", ""),
            tax_amount=line["tax_amount"],
            line_total=line["line_total"],
            created_at=line["created_at"],
            updated_at=line["updated_at"],
        )


class PurchaseCreate(BaseModel):
    """Schema for creating a purchase transaction."""

    supplier_id: UUID = Field(..., description="Supplier ID")
    location_id: UUID = Field(..., description="Location ID")
    purchase_date: date = Field(..., description="Purchase date")
    notes: Optional[str] = Field("", description="Additional notes")
    reference_number: Optional[str] = Field("", max_length=50, description="Reference number")
    items: List[PurchaseItemCreate] = Field(..., min_length=1, description="Purchase items")


class PurchaseLineRequest(BaseModel):
    """Schema for purchase line item request."""
    
    item_id: UUID = Field(..., description="Item ID")
    quantity: Decimal = Field(..., gt=0, description="Quantity")
    unit_cost: Decimal = Field(..., ge=0, description="Unit cost")
    tax_rate: Optional[Decimal] = Field(0, ge=0, le=100, description="Tax rate percentage")
    discount_amount: Optional[Decimal] = Field(0, ge=0, description="Discount amount")
    condition: str = Field("A", pattern="^[A-D]$", description="Item condition (A, B, C, or D)")
    notes: Optional[str] = Field("", description="Additional notes")


class NewPurchaseRequest(BaseModel):
    """Schema for the new-purchase endpoint - matches frontend JSON structure exactly."""

    supplier_id: str = Field(..., description="Supplier ID")
    location_id: str = Field(..., description="Location ID")
    purchase_date: str = Field(..., description="Purchase date in YYYY-MM-DD format")
    notes: str = Field("", description="Additional notes")
    reference_number: str = Field("", description="Reference number")
    items: List[PurchaseItemCreate] = Field(..., min_length=1, description="Purchase items")

    @field_validator("purchase_date")
    @classmethod
    def validate_purchase_date(cls, v):
        """Validate and parse the purchase date."""
        try:
            from datetime import datetime

            return datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD format.")

    @field_validator("supplier_id", "location_id")
    @classmethod
    def validate_uuids(cls, v):
        """Validate UUID strings."""
        try:
            from uuid import UUID

            return UUID(v)
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")


class NewPurchaseResponse(BaseModel):
    """Schema for new-purchase response."""

    model_config = ConfigDict(from_attributes=True)

    success: bool = Field(True, description="Operation success status")
    message: str = Field("Purchase created successfully", description="Response message")
    data: dict = Field(..., description="Purchase transaction data")
    transaction_id: UUID = Field(..., description="Created transaction ID")
    transaction_number: str = Field(..., description="Generated transaction number")


class PurchaseResponse(BaseModel):
    """Schema for purchase response - maps transaction data to purchase format."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    supplier: SupplierNestedResponse = Field(..., description="Supplier details")
    location: LocationNestedResponse = Field(..., description="Location details")
    purchase_date: date = Field(..., description="Purchase date (mapped from transaction_date)")
    reference_number: Optional[str] = Field(
        None, description="Reference number (mapped from transaction_number)"
    )
    notes: Optional[str] = Field(None, description="Additional notes")
    subtotal: Decimal = Field(..., description="Subtotal amount")
    tax_amount: Decimal = Field(..., description="Tax amount")
    discount_amount: Decimal = Field(..., description="Discount amount")
    total_amount: Decimal = Field(..., description="Total amount")
    status: str = Field(..., description="Purchase status")
    payment_status: str = Field(..., description="Payment status")
    created_at: datetime
    updated_at: datetime
    items: List[PurchaseLineItemResponse] = Field(default_factory=list, description="Purchase items")

    @classmethod
    def from_transaction(cls, transaction: dict, supplier_details: dict = None, location_details: dict = None, items_details: dict = None) -> "PurchaseResponse":
        """Create PurchaseResponse from TransactionHeaderResponse data."""
        # Create nested supplier response
        supplier_nested = SupplierNestedResponse(
            id=supplier_details["id"] if supplier_details else transaction["customer_id"],
            name=supplier_details["name"] if supplier_details else "Unknown Supplier"
        )
        
        # Create nested location response
        location_nested = LocationNestedResponse(
            id=location_details["id"] if location_details else transaction["location_id"],
            name=location_details["name"] if location_details else "Unknown Location"
        )
        
        # Transform transaction lines to purchase line items
        purchase_items = []
        items_details = items_details or {}
        for line in transaction.get("transaction_lines", []):
            item_detail = items_details.get(str(line["item_id"]), None)
            purchase_items.append(PurchaseLineItemResponse.from_transaction_line(line, item_detail))
        
        return cls(
            id=transaction["id"],
            supplier=supplier_nested,
            location=location_nested,
            purchase_date=transaction["transaction_date"].date()
            if isinstance(transaction["transaction_date"], datetime)
            else transaction["transaction_date"],
            reference_number=transaction.get("transaction_number"),
            notes=transaction.get("notes"),
            subtotal=transaction["subtotal"],
            tax_amount=transaction["tax_amount"],
            discount_amount=transaction["discount_amount"],
            total_amount=transaction["total_amount"],
            status=transaction["status"],
            payment_status=transaction["payment_status"] or "PENDING",
            created_at=transaction["created_at"],
            updated_at=transaction["updated_at"],
            items=purchase_items,
        )


class PurchaseDetail(BaseModel):
    """Schema for detailed purchase information."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    transaction_number: str
    supplier_id: UUID
    supplier_name: Optional[str] = None
    location_id: UUID
    location_name: Optional[str] = None
    purchase_date: date
    reference_number: Optional[str] = None
    notes: Optional[str] = None
    subtotal: Decimal
    tax_amount: Decimal
    discount_amount: Decimal
    total_amount: Decimal
    paid_amount: Decimal
    status: TransactionStatus
    payment_status: PaymentStatus
    created_at: datetime
    updated_at: datetime
    items: List[PurchaseLineItemResponse] = Field(default_factory=list)


class PurchaseListResponse(BaseModel):
    """Response schema for purchase list."""
    
    purchases: List[PurchaseResponse] = Field(default_factory=list)
    total: int
    page: int
    page_size: int
    total_pages: int

===== modules/transactions/purchase/service.py â€“ 2025-07-21 18:08:52 IST =====
"""
Purchase Service

Business logic for purchase transaction operations.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime, date
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from sqlalchemy import select, and_, or_, func

from app.core.errors import NotFoundError, ValidationError
from app.modules.transactions.base.models import (
    TransactionHeader, 
    TransactionType, 
    TransactionLine,
    TransactionStatus,
    PaymentStatus
)
from app.modules.transactions.purchase.schemas import (
    PurchaseResponse,
    PurchaseDetail,
    NewPurchaseRequest,
    NewPurchaseResponse
)
from app.modules.transactions.base.repository import TransactionHeaderRepository, TransactionLineRepository
from app.modules.suppliers.repository import SupplierRepository
from app.modules.master_data.locations.repository import LocationRepository
from app.modules.master_data.item_master.repository import ItemMasterRepository
from app.modules.inventory import StockLevelRepository, StockMovementRepository,MovementType, ReferenceType
from app.modules.inventory.schemas import StockLevelCreate
from app.modules.inventory.integrations import async_process_purchase_line_items


class PurchaseService:
    """Service for handling purchase transaction operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.transaction_repository = TransactionHeaderRepository(session)
        self.transaction_line_repository = TransactionLineRepository(session)
        self.supplier_repository = SupplierRepository(session)
        self.location_repository = LocationRepository(session)
        self.item_repository = ItemMasterRepository(session)
        self.stock_level_repository = StockLevelRepository(session)
        self.stock_movement_repository = StockMovementRepository(session)
    
    async def get_purchase_transactions(
        self,
        skip: int = 0,
        limit: int = 100,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        amount_from: Optional[Decimal] = None,
        amount_to: Optional[Decimal] = None,
        supplier_id: Optional[UUID] = None,
        status: Optional[TransactionStatus] = None,
        payment_status: Optional[PaymentStatus] = None,
    ) -> List[PurchaseResponse]:
        """
        Get purchase transactions with filtering options.
        """
        # Build query
        query = select(TransactionHeader).where(
            TransactionHeader.transaction_type == TransactionType.PURCHASE
        )
        
        # Apply filters
        if date_from:
            query = query.where(TransactionHeader.transaction_date >= date_from)
        if date_to:
            query = query.where(TransactionHeader.transaction_date <= date_to)
        if amount_from:
            query = query.where(TransactionHeader.total_amount >= amount_from)
        if amount_to:
            query = query.where(TransactionHeader.total_amount <= amount_to)
        if supplier_id:
            query = query.where(TransactionHeader.customer_id == str(supplier_id))
        if status:
            query = query.where(TransactionHeader.status == status)
        if payment_status:
            query = query.where(TransactionHeader.payment_status == payment_status)
            
        # Add ordering and pagination
        query = query.order_by(TransactionHeader.transaction_date.desc())
        query = query.offset(skip).limit(limit)
        
        # Execute query with eager loading
        query = query.options(selectinload(TransactionHeader.transaction_lines))
        result = await self.session.execute(query)
        transactions = result.scalars().all()
        
        # Batch load all related data to avoid N+1 queries
        # Collect all unique IDs
        supplier_ids = set()
        location_ids = set()
        item_ids = set()
        
        for transaction in transactions:
            if transaction.customer_id:
                supplier_ids.add(UUID(transaction.customer_id))
            if transaction.location_id:
                location_ids.add(UUID(transaction.location_id))
            for line in transaction.transaction_lines:
                if line.item_id:
                    item_ids.add(UUID(line.item_id))
        
        # Batch load suppliers
        suppliers_map = {}
        if supplier_ids:
            suppliers = await self.supplier_repository.get_by_ids(list(supplier_ids))
            suppliers_map = {supplier.id: supplier for supplier in suppliers}
        
        # Batch load locations
        locations_map = {}
        if location_ids:
            locations = await self.location_repository.get_by_ids(list(location_ids))
            locations_map = {location.id: location for location in locations}
        
        # Batch load items
        items_map = {}
        if item_ids:
            items = await self.item_repository.get_by_ids(list(item_ids))
            items_map = {item.id: item for item in items}
        
        # Transform to purchase response format
        purchase_responses = []
        for transaction in transactions:
            # Get supplier details from map
            supplier = None
            if transaction.customer_id:
                supplier = suppliers_map.get(UUID(transaction.customer_id))
            
            # Get location details from map
            location = None
            if transaction.location_id:
                location = locations_map.get(UUID(transaction.location_id))
                
            # Get item details for each line from map
            items_details = {}
            for line in transaction.transaction_lines:
                if line.item_id:
                    item = items_map.get(UUID(line.item_id))
                    if item:
                        items_details[str(line.item_id)] = {
                            "id": item.id,
                            "name": item.item_name
                        }
            
            # Convert transaction to dict with proper line serialization
            transaction_dict = {
                "id": transaction.id,
                "transaction_number": transaction.transaction_number,
                "transaction_type": transaction.transaction_type,
                "transaction_date": transaction.transaction_date,
                "customer_id": transaction.customer_id,
                "location_id": transaction.location_id,
                "status": transaction.status.value if transaction.status else "PENDING",
                "payment_status": transaction.payment_status or "PENDING",
                "subtotal": transaction.subtotal,
                "tax_amount": transaction.tax_amount,
                "discount_amount": transaction.discount_amount,
                "total_amount": transaction.total_amount,
                "notes": transaction.notes,
                "created_at": transaction.created_at,
                "updated_at": transaction.updated_at,
                "transaction_lines": [
                    {
                        "id": line.id,
                        "item_id": line.item_id,
                        "quantity": line.quantity,
                        "unit_price": line.unit_price,
                        "tax_rate": line.tax_rate,
                        "tax_amount": line.tax_amount,
                        "discount_amount": line.discount_amount,
                        "line_total": line.line_total,
                        "description": line.description,
                        "notes": line.notes,
                        "created_at": line.created_at,
                        "updated_at": line.updated_at,
                    }
                    for line in transaction.transaction_lines
                ]
            }
            
            purchase_response = PurchaseResponse.from_transaction(
                transaction_dict,
                supplier_details={"id": supplier.id, "name": supplier.company_name} if supplier else None,
                location_details={"id": location.id, "name": location.location_name} if location else None,
                items_details=items_details
            )
            purchase_responses.append(purchase_response)
            
        return purchase_responses
    
    async def get_purchase_by_id(self, purchase_id: UUID) -> PurchaseResponse:
        """Get a single purchase transaction by ID."""
        transaction = await self.transaction_repository.get_with_lines(purchase_id)
        
        if not transaction:
            raise NotFoundError(f"Purchase transaction {purchase_id} not found")
            
        if transaction.transaction_type != TransactionType.PURCHASE:
            raise ValidationError(f"Transaction {purchase_id} is not a purchase transaction")
        
        # Get supplier details
        supplier = None
        if transaction.customer_id:
            supplier = await self.supplier_repository.get_by_id(UUID(transaction.customer_id))
        
        # Get location details
        location = None
        if transaction.location_id:
            location = await self.location_repository.get_by_id(UUID(transaction.location_id))
            
        # Get item details for each line
        items_details = {}
        for line in transaction.transaction_lines:
            if line.item_id:
                item = await self.item_repository.get_by_id(UUID(line.item_id))
                if item:
                    items_details[str(line.item_id)] = {
                        "id": item.id,
                        "name": item.item_name
                    }
        
        # Convert transaction to dict with proper line serialization
        transaction_dict = {
            "id": transaction.id,
            "transaction_number": transaction.transaction_number,
            "transaction_type": transaction.transaction_type,
            "transaction_date": transaction.transaction_date,
            "customer_id": transaction.customer_id,
            "location_id": transaction.location_id,
            "status": transaction.status,
            "payment_status": transaction.payment_status or "PENDING",
            "subtotal": transaction.subtotal,
            "tax_amount": transaction.tax_amount,
            "discount_amount": transaction.discount_amount,
            "total_amount": transaction.total_amount,
            "notes": transaction.notes,
            "created_at": transaction.created_at,
            "updated_at": transaction.updated_at,
            "transaction_lines": [
                {
                    "id": line.id,
                    "item_id": line.item_id,
                    "quantity": line.quantity,
                    "unit_price": line.unit_price,
                    "tax_rate": line.tax_rate,
                    "tax_amount": line.tax_amount,
                    "discount_amount": line.discount_amount,
                    "line_total": line.line_total,
                    "description": line.description,
                    "notes": line.notes,
                    "created_at": line.created_at,
                    "updated_at": line.updated_at,
                }
                for line in transaction.transaction_lines
            ]
        }
        
        return PurchaseResponse.from_transaction(
            transaction_dict,
            supplier_details={"id": supplier.id, "name": supplier.company_name} if supplier else None,
            location_details={"id": location.id, "name": location.location_name} if location else None,
            items_details=items_details
        )
    
    async def create_new_purchase(self, purchase_data: NewPurchaseRequest) -> NewPurchaseResponse:
        """Create a new purchase transaction."""
        print("DEBUG: Service method called")
        print(f"DEBUG: purchase_data type: {type(purchase_data)}")
        print(f"DEBUG: purchase_data: {purchase_data}")
        # Validate supplier exists
        print("Creating new purchase with data: inside the service", purchase_data)
        supplier = await self.supplier_repository.get_by_id(purchase_data.supplier_id)
        if not supplier:
            raise NotFoundError(f"Supplier with ID {purchase_data.supplier_id} not found")
        
        # Validate location exists
        location = await self.location_repository.get_by_id(purchase_data.location_id)
        if not location:
            raise NotFoundError(f"Location with ID {purchase_data.location_id} not found")
        
        # Validate all items exist
        for item_data in purchase_data.items:
            item = await self.item_repository.get_by_id(UUID(item_data.item_id))
            if not item:
                raise NotFoundError(f"Item with ID {item_data.item_id} not found")
        
        # Generate transaction number
        transaction_number = await self._generate_transaction_number()
        
        # Create transaction header
        transaction = TransactionHeader(
            transaction_number=transaction_number,
            transaction_type=TransactionType.PURCHASE,
            transaction_date=purchase_data.purchase_date,
            customer_id=str(purchase_data.supplier_id),  # supplier_id maps to customer_id
            location_id=str(purchase_data.location_id),
            status=TransactionStatus.COMPLETED,
            payment_status=PaymentStatus.PENDING.value,
            notes=purchase_data.notes,
            reference_number=purchase_data.reference_number,
            subtotal=Decimal("0"),
            tax_amount=Decimal("0"),
            discount_amount=Decimal("0"),
            total_amount=Decimal("0"),
            paid_amount=Decimal("0"),
            created_by="00000000-0000-0000-0000-000000000000",  # System user
            updated_by="00000000-0000-0000-0000-000000000000"
        )
        
        self.session.add(transaction)
        await self.session.flush()
        
        # Create transaction lines and calculate totals
        line_number = 1
        subtotal = Decimal("0")
        total_tax = Decimal("0")
        total_discount = Decimal("0")
        transaction_lines_data = []  # Collect line data for response
        purchase_line_items = []  # Collect line items for inventory update
        
        for item_data in purchase_data.items:
            print(f"DEBUG: Processing item {item_data.item_id}")
            # Get item details for description
            item = await self.item_repository.get_by_id(UUID(item_data.item_id))
            print(f"DEBUG: Retrieved item: {item}")
            
            # Calculate line amounts
            line_subtotal = Decimal(str(item_data.quantity)) * Decimal(str(item_data.unit_cost))
            tax_amount = (line_subtotal * Decimal(str(item_data.tax_rate or 0))) / 100
            discount_amount = Decimal(str(item_data.discount_amount or 0))
            line_total = line_subtotal + tax_amount - discount_amount
            print(f"DEBUG: Line calculations done")
            
            # Create transaction line
            line = TransactionLine(
                transaction_id=transaction.id,
                line_number=line_number,
                item_id=str(item_data.item_id),
                quantity=Decimal(str(item_data.quantity)),
                unit_price=Decimal(str(item_data.unit_cost)),
                tax_rate=Decimal(str(item_data.tax_rate or 0)),
                tax_amount=tax_amount,
                discount_amount=discount_amount,
                line_total=line_total,
                description=f"{item.item_name} (Condition: {item_data.condition})",
                notes=item_data.notes
            )
            
            self.session.add(line)
            await self.session.flush()  # Flush to get the line ID
            
            # Add line data to response list
            transaction_lines_data.append({
                "id": str(line.id),
                "line_number": line.line_number,
                "item_id": line.item_id,
                "quantity": float(line.quantity),
                "unit_price": float(line.unit_price),
                "tax_rate": float(line.tax_rate),
                "tax_amount": float(line.tax_amount),
                "discount_amount": float(line.discount_amount),
                "line_total": float(line.line_total),
                "description": line.description
            })
            
            # Collect line item for inventory update
            purchase_line_items.append({
                'id': line.id,
                'item_id': UUID(item_data.item_id),
                'quantity': item_data.quantity
            })
            
            # Update totals
            subtotal += line_subtotal
            total_tax += tax_amount
            total_discount += discount_amount
            line_number += 1
        
        # Update stock levels using the new inventory service
        try:
            inventory_responses = await async_process_purchase_line_items(
                async_session=self.session,
                transaction_line_items=purchase_line_items,
                location_id=purchase_data.location_id,
                remarks=f"Purchase Order {transaction_number} - {purchase_data.notes or ''}",
                created_by=None  # TODO: Get from auth context
            )
            print(f"DEBUG: Inventory updated for {len(inventory_responses)} line items")
            
        except Exception as inventory_error:
            print(f"DEBUG: Inventory update failed, falling back to old method: {inventory_error}")
            # Fallback to old method if new service fails
            for item_data in purchase_data.items:
                await self._update_stock_for_purchase(
                    item_id=UUID(item_data.item_id),
                    location_id=purchase_data.location_id,
                    quantity=Decimal(str(item_data.quantity)),
                    transaction_id=transaction.id,
                    condition=item_data.condition
                )
        
        # Update transaction totals
        transaction.subtotal = subtotal
        transaction.tax_amount = total_tax
        transaction.discount_amount = total_discount
        transaction.total_amount = subtotal + total_tax - total_discount
        
        # Store all transaction data before commit
        transaction_id = transaction.id
        transaction_number = transaction.transaction_number
        
        # Prepare response data before commit (to avoid lazy loading issues)
        response_data = {
            "id": str(transaction_id),
            "transaction_number": transaction_number,
            "transaction_type": transaction.transaction_type.value,
            "transaction_date": transaction.transaction_date.isoformat(),
            "supplier_id": transaction.customer_id,
            "location_id": transaction.location_id,
            "status": transaction.status.value,
            "payment_status": transaction.payment_status or "PENDING",
            "subtotal": float(transaction.subtotal),
            "tax_amount": float(transaction.tax_amount),
            "discount_amount": float(transaction.discount_amount),
            "total_amount": float(transaction.total_amount),
            "transaction_lines": transaction_lines_data  # Use the data we already collected
        }
        
        print(f"DEBUG: About to commit transaction")
        try:
            await self.session.commit()
            print(f"DEBUG: Commit successful")
        except Exception as e:
            print(f"DEBUG: Commit failed: {e}")
            print(f"DEBUG: Exception type: {type(e)}")
            import traceback
            print(f"DEBUG: Traceback: {traceback.format_exc()}")
            raise
        
        # Return response
        return NewPurchaseResponse(
            success=True,
            message="Purchase created successfully",
            transaction_id=transaction_id,
            transaction_number=transaction_number,
            data=response_data
        )
    
    async def _generate_transaction_number(self) -> str:
        """Generate unique transaction number."""
        date_str = datetime.now().strftime("%Y%m%d")
        
        # Get count of purchases today
        start_of_day = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        query = select(func.count(TransactionHeader.id)).where(
            and_(
                TransactionHeader.transaction_type == TransactionType.PURCHASE,
                TransactionHeader.created_at >= start_of_day
            )
        )
        result = await self.session.execute(query)
        count = result.scalar() or 0
        
        return f"PUR-{date_str}-{count + 1:04d}"
    
    async def _update_stock_for_purchase(
        self,
        item_id: UUID,
        location_id: UUID,
        quantity: Decimal,
        transaction_id: UUID,
        condition: str
    ):
        """Update stock levels for a purchase."""
        # Get or create stock level
        stock_level = await self.stock_level_repository.get_by_item_location(
            item_id, location_id
        )
        
        if stock_level is None:
            # Create new stock level
            stock_data = StockLevelCreate(
                item_id=item_id,
                location_id=location_id,
                quantity_on_hand=quantity,
                quantity_available=quantity
            )
            stock_level = await self.stock_level_repository.create(stock_data)
        else:
            # Update existing stock level
            stock_level.quantity_on_hand += quantity
            stock_level.quantity_available += quantity
        
        # Create stock movement record
        movement_data = {
            "stock_level_id": stock_level.id,
            "item_id": str(item_id),
            "location_id": str(location_id),
            "movement_type": MovementType.PURCHASE.value,
            "quantity_change": quantity,
            "reference_type": ReferenceType.TRANSACTION.value,
            "reference_id": str(transaction_id),
            "reason": f"Purchase transaction - Condition: {condition}",
            "notes": f"Purchase transaction - Condition: {condition}",
            "quantity_before": stock_level.quantity_on_hand - quantity,
            "quantity_after": stock_level.quantity_on_hand
        }
        await self.stock_movement_repository.create(movement_data)
    
    async def get_purchase_returns(self, purchase_id: UUID) -> List[Dict[str, Any]]:
        """Get all return transactions for a specific purchase."""
        # For now, return empty list as returns functionality is not implemented
        # This method prevents the endpoint from failing
        return []

===== modules/transactions/routes/__init__.py â€“ 2025-07-19 12:58:15 IST =====
"""
Transaction routes package - Base router that combines all transaction sub-modules.
"""

from fastapi import APIRouter

# Import sub-module routers
from app.modules.transactions.purchase.routes import router as purchase_router
from app.modules.transactions.sales.routes import router as sales_router
from app.modules.transactions.rentals.routes import router as rentals_router
from app.modules.transactions.rental_returns.routes import router as rental_returns_router

# Import the cross-module query router
from .main import router as query_router

# Create base transaction router
router = APIRouter()

# Include sub-module routers with their prefixes
router.include_router(purchase_router, prefix="/purchases", tags=["Purchases"])
router.include_router(sales_router, prefix="/sales", tags=["Sales"])
router.include_router(rentals_router, prefix="/rentals", tags=["Rentals"])
router.include_router(rental_returns_router, prefix="/rental-returns", tags=["Rental Returns"])

# Include cross-module query endpoints (no prefix needed)
router.include_router(query_router, tags=["Transaction Queries"])

__all__ = ["router"]

===== modules/transactions/routes/main.py â€“ 2025-07-19 15:15:51 IST =====
"""
Simplified transaction routes for cross-module queries.

This module provides basic read-only endpoints for querying transactions
across all types (purchase, sales, rentals). Each transaction type has its
own specific routes for creation and management.
"""

from typing import List, Optional
from uuid import UUID
from datetime import date
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func

from app.shared.dependencies import get_session
from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionType,
    TransactionStatus,
    PaymentStatus,
)
from app.modules.transactions.base.repository import TransactionHeaderRepository
from app.core.errors import NotFoundError


router = APIRouter(tags=["transactions"])


def get_transaction_repository(session: AsyncSession = Depends(get_session)) -> TransactionHeaderRepository:
    """Get transaction repository instance."""
    return TransactionHeaderRepository(session)


# Read-only endpoints for cross-module transaction queries

@router.get("/{transaction_id}")
async def get_transaction(
    transaction_id: UUID, 
    repository: TransactionHeaderRepository = Depends(get_transaction_repository)
):
    """Get transaction by ID (any type)."""
    try:
        transaction = await repository.get_by_id(transaction_id)
        if not transaction:
            raise NotFoundError(f"Transaction {transaction_id} not found")
        return transaction
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get("/number/{transaction_number}")
async def get_transaction_by_number(
    transaction_number: str, 
    repository: TransactionHeaderRepository = Depends(get_transaction_repository)
):
    """Get transaction by number."""
    try:
        transaction = await repository.get_by_number(transaction_number)
        if not transaction:
            raise NotFoundError(f"Transaction {transaction_number} not found")
        return transaction
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get("/")
async def get_transactions(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    transaction_type: Optional[TransactionType] = None,
    status: Optional[TransactionStatus] = None,
    payment_status: Optional[PaymentStatus] = None,
    customer_id: Optional[UUID] = None,
    location_id: Optional[UUID] = None,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    repository: TransactionHeaderRepository = Depends(get_transaction_repository)
):
    """
    Get all transactions with optional filtering.
    
    This endpoint provides read-only access to transactions across all types.
    For type-specific operations, use the dedicated endpoints:
    - /api/purchases for purchase transactions
    - /api/sales for sales transactions  
    - /api/rentals for rental transactions
    """
    return await repository.get_all(
        skip=skip,
        limit=limit,
        transaction_type=transaction_type,
        status=status,
        payment_status=payment_status,
        customer_id=customer_id,
        location_id=location_id,
        date_from=date_from,
        date_to=date_to
    )


@router.get("/reports/summary")
async def get_transaction_summary(
    date_from: Optional[date] = Query(None, description="Start date"),
    date_to: Optional[date] = Query(None, description="End date"),
    transaction_type: Optional[TransactionType] = None,
    session: AsyncSession = Depends(get_session)
):
    """Get transaction summary across all types."""
    query = select(
        TransactionHeader.transaction_type,
        func.count(TransactionHeader.id).label('count'),
        func.sum(TransactionHeader.total_amount).label('total_amount')
    ).where(
        TransactionHeader.is_active == True
    )
    
    if date_from:
        query = query.where(TransactionHeader.transaction_date >= date_from)
    if date_to:
        query = query.where(TransactionHeader.transaction_date <= date_to)
    if transaction_type:
        query = query.where(TransactionHeader.transaction_type == transaction_type)
    
    query = query.group_by(TransactionHeader.transaction_type)
    
    result = await session.execute(query)
    summary = result.all()
    
    return {
        "summary": [
            {
                "transaction_type": row.transaction_type,
                "count": row.count,
                "total_amount": float(row.total_amount or 0)
            }
            for row in summary
        ],
        "date_from": date_from,
        "date_to": date_to
    }

===== modules/transactions/base/repository.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy import and_, or_, func, select, update, delete, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload, joinedload

from app.modules.transactions.base.models import (
    TransactionHeader,
    TransactionLine,
    TransactionType,
    TransactionStatus,
    PaymentMethod,
    PaymentStatus,
    RentalPeriodUnit,
    LineItemType,
    RentalStatus,
    RentalLifecycle,
)
from app.modules.transactions.schemas import (
    TransactionHeaderCreate,
    TransactionHeaderUpdate,
    TransactionLineCreate,
    TransactionLineUpdate,
    TransactionSearch,
)


class TransactionHeaderRepository:
    """Repository for TransactionHeader operations."""

    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, transaction_data: TransactionHeaderCreate) -> TransactionHeader:
        """Create a new transaction header."""
        transaction = TransactionHeader(
            transaction_number=transaction_data.transaction_number,
            transaction_type=transaction_data.transaction_type,
            transaction_date=transaction_data.transaction_date,
            customer_id=str(transaction_data.customer_id),
            location_id=str(transaction_data.location_id),
            sales_person_id=str(transaction_data.sales_person_id)
            if transaction_data.sales_person_id
            else None,
            status=transaction_data.status,
            reference_transaction_id=str(transaction_data.reference_transaction_id)
            if transaction_data.reference_transaction_id
            else None,
            rental_start_date=transaction_data.rental_start_date,
            rental_end_date=transaction_data.rental_end_date,
            notes=transaction_data.notes,
        )

        self.session.add(transaction)
        await self.session.commit()
        await self.session.refresh(transaction)
        return transaction

    async def get_by_id(self, transaction_id: UUID) -> Optional[TransactionHeader]:
        """Get transaction header by ID."""
        query = select(TransactionHeader).where(TransactionHeader.id == transaction_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_by_number(self, transaction_number: str) -> Optional[TransactionHeader]:
        """Get transaction header by number."""
        query = select(TransactionHeader).where(
            TransactionHeader.transaction_number == transaction_number
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_with_lines(self, transaction_id: UUID) -> Optional[TransactionHeader]:
        """Get transaction header with lines."""
        query = (
            select(TransactionHeader)
            .options(selectinload(TransactionHeader.transaction_lines))
            .where(TransactionHeader.id == transaction_id)
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        transaction_type: Optional[TransactionType] = None,
        status: Optional[TransactionStatus] = None,
        payment_status: Optional[PaymentStatus] = None,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        sales_person_id: Optional[UUID] = None,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        active_only: bool = True,
    ) -> List[TransactionHeader]:
        """Get all transaction headers with optional filtering."""
        query = select(TransactionHeader)

        # Apply filters
        conditions = []
        if active_only:
            conditions.append(TransactionHeader.is_active == True)
        if transaction_type:
            conditions.append(TransactionHeader.transaction_type == transaction_type.value)
        if status:
            conditions.append(TransactionHeader.status == status.value)
        if payment_status:
            conditions.append(TransactionHeader.payment_status == payment_status.value)
        if customer_id:
            conditions.append(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            conditions.append(TransactionHeader.location_id == str(location_id))
        if sales_person_id:
            conditions.append(TransactionHeader.sales_person_id == str(sales_person_id))
        if date_from:
            conditions.append(
                TransactionHeader.transaction_date
                >= datetime.combine(date_from, datetime.min.time())
            )
        if date_to:
            conditions.append(
                TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time())
            )

        if conditions:
            query = query.where(and_(*conditions))

        query = query.order_by(desc(TransactionHeader.transaction_date)).offset(skip).limit(limit)

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_all_with_lines(
        self,
        skip: int = 0,
        limit: int = 100,
        transaction_type: Optional[TransactionType] = None,
        status: Optional[TransactionStatus] = None,
        payment_status: Optional[PaymentStatus] = None,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        sales_person_id: Optional[UUID] = None,
        reference_transaction_id: Optional[UUID] = None,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        active_only: bool = True,
    ) -> List[TransactionHeader]:
        """Get all transaction headers with lines using optional filtering."""
        query = select(TransactionHeader).options(selectinload(TransactionHeader.transaction_lines))

        # Apply filters (same as get_all method)
        conditions = []
        if active_only:
            conditions.append(TransactionHeader.is_active == True)
        if transaction_type:
            conditions.append(TransactionHeader.transaction_type == transaction_type.value)
        if status:
            conditions.append(TransactionHeader.status == status.value)
        if payment_status:
            conditions.append(TransactionHeader.payment_status == payment_status.value)
        if customer_id:
            conditions.append(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            conditions.append(TransactionHeader.location_id == str(location_id))
        if sales_person_id:
            conditions.append(TransactionHeader.sales_person_id == str(sales_person_id))
        if reference_transaction_id:
            conditions.append(TransactionHeader.reference_transaction_id == str(reference_transaction_id))
        if date_from:
            conditions.append(
                TransactionHeader.transaction_date
                >= datetime.combine(date_from, datetime.min.time())
            )
        if date_to:
            conditions.append(
                TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time())
            )

        if conditions:
            query = query.where(and_(*conditions))

        query = query.order_by(desc(TransactionHeader.transaction_date)).offset(skip).limit(limit)

        result = await self.session.execute(query)
        return result.scalars().all()

    async def count_all(
        self,
        transaction_type: Optional[TransactionType] = None,
        status: Optional[TransactionStatus] = None,
        payment_status: Optional[PaymentStatus] = None,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        sales_person_id: Optional[UUID] = None,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        active_only: bool = True,
    ) -> int:
        """Count all transaction headers with optional filtering."""
        query = select(func.count(TransactionHeader.id))

        # Apply filters
        conditions = []
        if active_only:
            conditions.append(TransactionHeader.is_active == True)
        if transaction_type:
            conditions.append(TransactionHeader.transaction_type == transaction_type.value)
        if status:
            conditions.append(TransactionHeader.status == status.value)
        if payment_status:
            conditions.append(TransactionHeader.payment_status == payment_status.value)
        if customer_id:
            conditions.append(TransactionHeader.customer_id == str(customer_id))
        if location_id:
            conditions.append(TransactionHeader.location_id == str(location_id))
        if sales_person_id:
            conditions.append(TransactionHeader.sales_person_id == str(sales_person_id))
        if date_from:
            conditions.append(
                TransactionHeader.transaction_date
                >= datetime.combine(date_from, datetime.min.time())
            )
        if date_to:
            conditions.append(
                TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time())
            )

        if conditions:
            query = query.where(and_(*conditions))

        result = await self.session.execute(query)
        return result.scalar()

    async def search(
        self,
        search_params: TransactionSearch,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True,
    ) -> List[TransactionHeader]:
        """Search transaction headers."""
        query = select(TransactionHeader)

        conditions = []
        if active_only:
            conditions.append(TransactionHeader.is_active == True)

        if search_params.transaction_number:
            conditions.append(
                TransactionHeader.transaction_number.ilike(f"%{search_params.transaction_number}%")
            )
        if search_params.transaction_type:
            conditions.append(
                TransactionHeader.transaction_type == search_params.transaction_type.value
            )
        if search_params.customer_id:
            conditions.append(TransactionHeader.customer_id == str(search_params.customer_id))
        if search_params.location_id:
            conditions.append(TransactionHeader.location_id == str(search_params.location_id))
        if search_params.sales_person_id:
            conditions.append(
                TransactionHeader.sales_person_id == str(search_params.sales_person_id)
            )
        if search_params.status:
            conditions.append(TransactionHeader.status == search_params.status.value)
        if search_params.payment_status:
            conditions.append(
                TransactionHeader.payment_status == search_params.payment_status.value
            )
        if search_params.date_from:
            conditions.append(
                TransactionHeader.transaction_date
                >= datetime.combine(search_params.date_from, datetime.min.time())
            )
        if search_params.date_to:
            conditions.append(
                TransactionHeader.transaction_date
                <= datetime.combine(search_params.date_to, datetime.max.time())
            )
        if search_params.amount_from:
            conditions.append(TransactionHeader.total_amount >= search_params.amount_from)
        if search_params.amount_to:
            conditions.append(TransactionHeader.total_amount <= search_params.amount_to)

        if conditions:
            query = query.where(and_(*conditions))

        query = query.order_by(desc(TransactionHeader.transaction_date)).offset(skip).limit(limit)

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_by_customer(
        self, customer_id: UUID, active_only: bool = True
    ) -> List[TransactionHeader]:
        """Get transactions by customer."""
        query = select(TransactionHeader).where(TransactionHeader.customer_id == str(customer_id))

        if active_only:
            query = query.where(TransactionHeader.is_active == True)

        query = query.order_by(desc(TransactionHeader.transaction_date))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_by_location(
        self, location_id: UUID, active_only: bool = True
    ) -> List[TransactionHeader]:
        """Get transactions by location."""
        query = select(TransactionHeader).where(TransactionHeader.location_id == str(location_id))

        if active_only:
            query = query.where(TransactionHeader.is_active == True)

        query = query.order_by(desc(TransactionHeader.transaction_date))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_by_sales_person(
        self, sales_person_id: UUID, active_only: bool = True
    ) -> List[TransactionHeader]:
        """Get transactions by sales person."""
        query = select(TransactionHeader).where(
            TransactionHeader.sales_person_id == str(sales_person_id)
        )

        if active_only:
            query = query.where(TransactionHeader.is_active == True)

        query = query.order_by(desc(TransactionHeader.transaction_date))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_overdue_transactions(self, as_of_date: date = None) -> List[TransactionHeader]:
        """Get overdue transactions."""
        if as_of_date is None:
            as_of_date = date.today()

        query = select(TransactionHeader).where(
            and_(
                TransactionHeader.payment_status == PaymentStatus.OVERDUE.value,
                TransactionHeader.status.not_in(
                    [TransactionStatus.CANCELLED.value, TransactionStatus.REFUNDED.value]
                ),
                TransactionHeader.is_active == True,
            )
        )

        query = query.order_by(desc(TransactionHeader.transaction_date))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_outstanding_transactions(self) -> List[TransactionHeader]:
        """Get transactions with outstanding balance."""
        query = select(TransactionHeader).where(
            and_(
                TransactionHeader.paid_amount < TransactionHeader.total_amount,
                TransactionHeader.payment_status != PaymentStatus.CANCELLED.value,
                TransactionHeader.status.not_in(
                    [TransactionStatus.CANCELLED.value, TransactionStatus.REFUNDED.value]
                ),
                TransactionHeader.is_active == True,
            )
        )

        query = query.order_by(desc(TransactionHeader.transaction_date))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_rental_transactions_due_for_return(
        self, as_of_date: date = None
    ) -> List[TransactionHeader]:
        """Get rental transactions due for return."""
        if as_of_date is None:
            as_of_date = date.today()

        query = select(TransactionHeader).where(
            and_(
                TransactionHeader.transaction_type == TransactionType.RENTAL.value,
                TransactionHeader.status == TransactionStatus.IN_PROGRESS.value,
                TransactionHeader.rental_end_date <= as_of_date,
                TransactionHeader.actual_return_date.is_(None),
                TransactionHeader.is_active == True,
            )
        )

        query = query.order_by(asc(TransactionHeader.rental_end_date))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def update(
        self, transaction_id: UUID, transaction_data: TransactionHeaderUpdate
    ) -> Optional[TransactionHeader]:
        """Update a transaction header."""
        query = select(TransactionHeader).where(TransactionHeader.id == transaction_id)
        result = await self.session.execute(query)
        transaction = result.scalar_one_or_none()

        if not transaction:
            return None

        # Update fields
        update_data = transaction_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            if field in [
                "customer_id",
                "location_id",
                "sales_person_id",
                "reference_transaction_id",
            ]:
                setattr(transaction, field, str(value) if value else None)
            else:
                setattr(transaction, field, value)

        await self.session.commit()
        await self.session.refresh(transaction)
        return transaction

    async def delete(self, transaction_id: UUID) -> bool:
        """Soft delete a transaction header."""
        query = select(TransactionHeader).where(TransactionHeader.id == transaction_id)
        result = await self.session.execute(query)
        transaction = result.scalar_one_or_none()

        if not transaction:
            return False

        transaction.is_active = False
        await self.session.commit()
        return True

    async def get_transaction_summary(
        self,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        active_only: bool = True,
    ) -> Dict[str, Any]:
        """Get transaction summary statistics."""
        query = select(TransactionHeader)

        conditions = []
        if active_only:
            conditions.append(TransactionHeader.is_active == True)
        if date_from:
            conditions.append(
                TransactionHeader.transaction_date
                >= datetime.combine(date_from, datetime.min.time())
            )
        if date_to:
            conditions.append(
                TransactionHeader.transaction_date <= datetime.combine(date_to, datetime.max.time())
            )

        if conditions:
            query = query.where(and_(*conditions))

        result = await self.session.execute(query)
        transactions = result.scalars().all()

        total_transactions = len(transactions)
        total_amount = sum(t.total_amount for t in transactions)
        total_paid = sum(t.paid_amount for t in transactions)
        total_outstanding = total_amount - total_paid

        # Count by status
        status_counts = {}
        for status in TransactionStatus:
            status_counts[status.value] = len([t for t in transactions if t.status == status.value])

        # Count by type
        type_counts = {}
        for transaction_type in TransactionType:
            type_counts[transaction_type.value] = len(
                [t for t in transactions if t.transaction_type == transaction_type.value]
            )

        # Count by payment status
        payment_status_counts = {}
        for payment_status in PaymentStatus:
            payment_status_counts[payment_status.value] = len(
                [t for t in transactions if t.payment_status == payment_status.value]
            )

        return {
            "total_transactions": total_transactions,
            "total_amount": total_amount,
            "total_paid": total_paid,
            "total_outstanding": total_outstanding,
            "transactions_by_status": status_counts,
            "transactions_by_type": type_counts,
            "transactions_by_payment_status": payment_status_counts,
        }

    async def get_rentals_with_lifecycle(
        self,
        skip: int = 0,
        limit: int = 100,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[TransactionStatus] = None,
        rental_status: Optional[RentalStatus] = None,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        overdue_only: bool = False,
        active_only: bool = True,
    ) -> List[TransactionHeader]:
        """Get rental transactions with lifecycle information and filtering."""
        
        # Start with base query joining rental lifecycle
        query = (
            select(TransactionHeader)
            .options(
                joinedload(TransactionHeader.rental_lifecycle),
                selectinload(TransactionHeader.transaction_lines)
            )
            .join(RentalLifecycle, TransactionHeader.id == RentalLifecycle.transaction_id, isouter=True)
        )

        # Apply filters
        conditions = []
        
        # Always filter for RENTAL transactions
        conditions.append(TransactionHeader.transaction_type == TransactionType.RENTAL.value)
        
        if active_only:
            conditions.append(TransactionHeader.is_active == True)
            
        if customer_id:
            conditions.append(TransactionHeader.customer_id == str(customer_id))
            
        if location_id:
            conditions.append(TransactionHeader.location_id == str(location_id))
            
        if status:
            conditions.append(TransactionHeader.status == status.value)
            
        if rental_status:
            conditions.append(TransactionHeader.current_rental_status == rental_status.value)
            
        if date_from:
            conditions.append(
                TransactionHeader.rental_start_date >= date_from
            )
            
        if date_to:
            conditions.append(
                TransactionHeader.rental_end_date <= date_to
            )
            
        if overdue_only:
            conditions.append(
                and_(
                    TransactionHeader.rental_end_date.is_not(None),
                    TransactionHeader.rental_end_date < func.current_date(),
                    TransactionHeader.current_rental_status.in_([
                        RentalStatus.ACTIVE.value,
                        RentalStatus.LATE.value,
                        RentalStatus.PARTIAL_RETURN.value,
                        RentalStatus.LATE_PARTIAL_RETURN.value
                    ])
                )
            )

        if conditions:
            query = query.where(and_(*conditions))

        # Order by transaction date (newest first)
        query = query.order_by(desc(TransactionHeader.transaction_date))
        
        # Apply pagination
        query = query.offset(skip).limit(limit)

        result = await self.session.execute(query)
        return result.unique().scalars().all()

    async def count_rentals_with_lifecycle(
        self,
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[TransactionStatus] = None,
        rental_status: Optional[RentalStatus] = None,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
        overdue_only: bool = False,
        active_only: bool = True,
    ) -> int:
        """Count rental transactions with the same filters."""
        
        query = (
            select(func.count(TransactionHeader.id))
            .join(RentalLifecycle, TransactionHeader.id == RentalLifecycle.transaction_id, isouter=True)
        )

        # Apply same filters as get_rentals_with_lifecycle
        conditions = []
        
        conditions.append(TransactionHeader.transaction_type == TransactionType.RENTAL.value)
        
        if active_only:
            conditions.append(TransactionHeader.is_active == True)
            
        if customer_id:
            conditions.append(TransactionHeader.customer_id == str(customer_id))
            
        if location_id:
            conditions.append(TransactionHeader.location_id == str(location_id))
            
        if status:
            conditions.append(TransactionHeader.status == status.value)
            
        if rental_status:
            conditions.append(TransactionHeader.current_rental_status == rental_status.value)
            
        if date_from:
            conditions.append(
                TransactionHeader.rental_start_date >= date_from
            )
            
        if date_to:
            conditions.append(
                TransactionHeader.rental_end_date <= date_to
            )
            
        if overdue_only:
            conditions.append(
                and_(
                    TransactionHeader.rental_end_date.is_not(None),
                    TransactionHeader.rental_end_date < func.current_date(),
                    TransactionHeader.current_rental_status.in_([
                        RentalStatus.ACTIVE.value,
                        RentalStatus.LATE.value,
                        RentalStatus.PARTIAL_RETURN.value,
                        RentalStatus.LATE_PARTIAL_RETURN.value
                    ])
                )
            )

        if conditions:
            query = query.where(and_(*conditions))

        result = await self.session.execute(query)
        return result.scalar() or 0


class TransactionLineRepository:
    """Repository for TransactionLine operations."""

    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(
        self, transaction_id: UUID, line_data: TransactionLineCreate
    ) -> TransactionLine:
        """Create a new transaction line."""
        line = TransactionLine(
            transaction_id=str(transaction_id),
            line_number=line_data.line_number,
            line_type=line_data.line_type,
            description=line_data.description,
            quantity=line_data.quantity,
            unit_price=line_data.unit_price,
            item_id=str(line_data.item_id) if line_data.item_id else None,
            inventory_unit_id=str(line_data.inventory_unit_id)
            if line_data.inventory_unit_id
            else None,
            discount_percentage=line_data.discount_percentage,
            discount_amount=line_data.discount_amount,
            tax_rate=line_data.tax_rate,
            rental_period_value=line_data.rental_period_value,
            rental_period_unit=line_data.rental_period_unit,
            rental_start_date=line_data.rental_start_date,
            rental_end_date=line_data.rental_end_date,
            notes=line_data.notes,
        )

        # Calculate line total
        line.calculate_line_total()

        self.session.add(line)
        await self.session.commit()
        await self.session.refresh(line)
        return line

    async def get_by_id(self, line_id: UUID) -> Optional[TransactionLine]:
        """Get transaction line by ID."""
        query = select(TransactionLine).where(TransactionLine.id == line_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_by_transaction(
        self, transaction_id: UUID, active_only: bool = True
    ) -> List[TransactionLine]:
        """Get transaction lines by transaction."""
        query = select(TransactionLine).where(TransactionLine.transaction_id == str(transaction_id))

        if active_only:
            query = query.where(TransactionLine.is_active == True)

        query = query.order_by(asc(TransactionLine.line_number))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_by_item(self, item_id: UUID, active_only: bool = True) -> List[TransactionLine]:
        """Get transaction lines by item."""
        query = select(TransactionLine).where(TransactionLine.item_id == str(item_id))

        if active_only:
            query = query.where(TransactionLine.is_active == True)

        query = query.order_by(desc(TransactionLine.created_at))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_by_inventory_unit(
        self, inventory_unit_id: UUID, active_only: bool = True
    ) -> List[TransactionLine]:
        """Get transaction lines by inventory unit."""
        query = select(TransactionLine).where(
            TransactionLine.inventory_unit_id == str(inventory_unit_id)
        )

        if active_only:
            query = query.where(TransactionLine.is_active == True)

        query = query.order_by(desc(TransactionLine.created_at))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_rental_lines_due_for_return(
        self, as_of_date: date = None
    ) -> List[TransactionLine]:
        """Get rental lines due for return."""
        if as_of_date is None:
            as_of_date = date.today()

        query = select(TransactionLine).where(
            and_(
                TransactionLine.line_type == LineItemType.PRODUCT.value,
                TransactionLine.rental_end_date <= as_of_date,
                TransactionLine.return_date.is_(None),
                TransactionLine.returned_quantity < TransactionLine.quantity,
                TransactionLine.is_active == True,
            )
        )

        query = query.order_by(asc(TransactionLine.rental_end_date))

        result = await self.session.execute(query)
        return result.scalars().all()

    async def update(
        self, line_id: UUID, line_data: TransactionLineUpdate
    ) -> Optional[TransactionLine]:
        """Update a transaction line."""
        query = select(TransactionLine).where(TransactionLine.id == line_id)
        result = await self.session.execute(query)
        line = result.scalar_one_or_none()

        if not line:
            return None

        # Update fields
        update_data = line_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            if field in ["item_id", "inventory_unit_id"]:
                setattr(line, field, str(value) if value else None)
            else:
                setattr(line, field, value)

        # Recalculate line total
        line.calculate_line_total()

        await self.session.commit()
        await self.session.refresh(line)
        return line

    async def delete(self, line_id: UUID) -> bool:
        """Soft delete a transaction line."""
        query = select(TransactionLine).where(TransactionLine.id == line_id)
        result = await self.session.execute(query)
        line = result.scalar_one_or_none()

        if not line:
            return False

        line.is_active = False
        await self.session.commit()
        return True

    async def get_next_line_number(self, transaction_id: UUID) -> int:
        """Get the next line number for a transaction."""
        query = select(func.coalesce(func.max(TransactionLine.line_number), 0) + 1).where(
            TransactionLine.transaction_id == str(transaction_id)
        )
        result = await self.session.execute(query)
        return result.scalar()

    async def resequence_lines(self, transaction_id: UUID) -> bool:
        """Resequence line numbers for a transaction."""
        query = (
            select(TransactionLine)
            .where(
                and_(
                    TransactionLine.transaction_id == str(transaction_id),
                    TransactionLine.is_active == True,
                )
            )
            .order_by(TransactionLine.line_number)
        )

        result = await self.session.execute(query)
        lines = result.scalars().all()

        for i, line in enumerate(lines, 1):
            line.line_number = i

        await self.session.commit()
        return True


===== modules/transactions/base/models/README.md â€“ 2025-07-18 16:38:42 IST =====
# Transaction Models Organization

This directory contains the transaction models organized into meaningful, maintainable files.

## File Structure

```
models/
â”œâ”€â”€ __init__.py              # Public API - imports all models
â”œâ”€â”€ transaction_headers.py   # TransactionHeader model and related enums
â”œâ”€â”€ transaction_lines.py     # TransactionLine model and related enums
â”œâ”€â”€ rental_lifecycle.py      # Rental operational models
â”œâ”€â”€ metadata.py              # Transaction metadata models
â”œâ”€â”€ inspections.py           # Inspection and credit memo models
â””â”€â”€ README.md               # This file
```

## Core Models

### ðŸ“„ transaction_headers.py
**Primary Model:** `TransactionHeader`

The main financial record for all transactions (sales, purchases, rentals).

**Key Features:**
- Financial tracking (amounts, payments, deposits)
- Rental-specific fields (dates, status, advance payments)
- Status management and payment tracking
- Helpful properties for rental operations

**Enums Included:**
- `TransactionType` - SALE, PURCHASE, RENTAL, RETURN, ADJUSTMENT
- `TransactionStatus` - PENDING, PROCESSING, COMPLETED, etc.
- `PaymentMethod` - CASH, CREDIT_CARD, BANK_TRANSFER, etc.
- `PaymentStatus` - PENDING, PAID, PARTIAL, FAILED, REFUNDED
- `RentalPeriodUnit` - HOUR, DAY, WEEK, MONTH
- `RentalStatus` - ACTIVE, LATE, EXTENDED, PARTIAL_RETURN, etc.

### ðŸ“„ transaction_lines.py
**Primary Model:** `TransactionLine`

Individual line items within transactions - products, services, fees, etc.

**Key Features:**
- Item identification and pricing
- Rental-specific tracking per line
- Return quantity tracking
- Inventory and fulfillment status
- Helpful properties for rental calculations

**Enums Included:**
- `LineItemType` - PRODUCT, SERVICE, DISCOUNT, TAX, SHIPPING, FEE

### ðŸ“„ rental_lifecycle.py
**Primary Models:** `RentalLifecycle`, `RentalReturnEvent`, `RentalItemInspection`

Operational tracking for rental workflows - separate from financial data.

**Key Features:**
- Rental status management
- Return event tracking (multiple returns per rental)
- Per-item inspection with damage assessment
- Fee accumulation and payment tracking

## Design Principles

### 1. **Separation of Concerns**
- **Financial Data** â†’ `transaction_headers.py` & `transaction_lines.py`
- **Operational Data** â†’ `rental_lifecycle.py`
- **Metadata** â†’ `metadata.py` & `inspections.py`

### 2. **Backward Compatibility**
The `__init__.py` file re-exports all models, so existing imports continue to work:

```python
# Still works
from app.modules.transactions.models import TransactionHeader, TransactionLine

# New explicit imports also work
from app.modules.transactions.models.transaction_headers import TransactionHeader
from app.modules.transactions.models.transaction_lines import TransactionLine
```

### 3. **Clear Relationships**
```
TransactionHeader (1) â†â†’ (Many) TransactionLine
      â†“
RentalLifecycle (1) â†â†’ (Many) RentalReturnEvent
      â†“
RentalItemInspection (per line item)
```

## Enhanced Features

### TransactionHeader Properties
- `is_rental` - Check if transaction is a rental
- `is_overdue` - Check if rental is past due
- `days_overdue` - Calculate days past due
- `rental_duration_days` - Total rental period in days

### TransactionLine Properties
- `remaining_quantity` - Quantity not yet returned
- `is_fully_returned` - All quantity returned
- `is_partially_returned` - Some but not all returned
- `return_percentage` - Percentage of quantity returned
- `is_rental_overdue` - Line-specific overdue check

### Rental Lifecycle Features
- Multi-stage return process
- Per-item inspection tracking
- Fee calculation and accumulation
- Payment and refund processing
- Status transition management

## Usage Examples

### Creating a Rental Transaction
```python
from app.modules.transactions.models import TransactionHeader, TransactionType, RentalStatus

transaction = TransactionHeader(
    transaction_number="R-2025-001",
    transaction_type=TransactionType.RENTAL,
    rental_start_date=date.today(),
    rental_end_date=date.today() + timedelta(days=7),
    current_rental_status=RentalStatus.ACTIVE,
    deposit_amount=100.00,
    deposit_paid=True
)
```

### Managing Rental Returns
```python
from app.modules.transactions.models import RentalLifecycle, RentalReturnEvent, ReturnEventType

# Create lifecycle tracking
lifecycle = RentalLifecycle(
    transaction_id=transaction.id,
    current_status=RentalStatus.ACTIVE.value
)

# Record return event
return_event = RentalReturnEvent(
    rental_lifecycle_id=lifecycle.id,
    event_type=ReturnEventType.PARTIAL_RETURN.value,
    event_date=date.today(),
    total_quantity_returned=2
)
```

## Migration Notes

- Database schema remains unchanged - only code organization improved
- All existing functionality preserved
- New helpful properties and methods added
- Enhanced rental status tracking capabilities
- Better separation for future maintenance

This reorganization makes the codebase more maintainable while preserving all existing functionality and adding powerful new rental management capabilities.

===== modules/transactions/base/models/__init__.py â€“ 2025-07-19 13:14:50 IST =====
"""
Transaction models package - organized for better maintainability.
"""

# Import core models from their respective files
from .transaction_headers import (
    TransactionHeader,
    TransactionType,
    TransactionStatus,
    PaymentMethod,
    PaymentStatus,
    RentalPeriodUnit,
    RentalStatus,
)

from .transaction_lines import (
    TransactionLine,
    LineItemType,
)


# Import additional models
from .metadata import TransactionMetadata
from .inspections import RentalInspection, PurchaseCreditMemo
from .events import TransactionEvent
from .rental_lifecycle import (
    RentalLifecycle, 
    RentalReturnEvent, 
    RentalItemInspection,
    RentalStatusLog,
    ReturnEventType,
    InspectionCondition,
    RentalStatusChangeReason
)

# Export all models for backward compatibility
__all__ = [
    # Core enums
    "TransactionType",
    "TransactionStatus", 
    "PaymentMethod",
    "PaymentStatus",
    "RentalPeriodUnit",
    "RentalStatus",
    "LineItemType",
    
    # Core models
    "TransactionHeader",
    "TransactionLine",
    
    # Additional models
    "TransactionMetadata",
    "TransactionEvent",
    "RentalInspection",
    "PurchaseCreditMemo",
    
    # Rental lifecycle models
    "RentalLifecycle",
    "RentalReturnEvent", 
    "RentalItemInspection",
    "RentalStatusLog",
    "ReturnEventType",
    "InspectionCondition",
    "RentalStatusChangeReason"
]

===== modules/transactions/base/models/events.py â€“ 2025-07-19 12:13:41 IST =====
"""
Transaction Event Models

This module defines models for tracking detailed transaction lifecycle events
and maintaining a comprehensive audit trail in the database.
"""

from datetime import datetime
from typing import Optional, Dict, Any
from sqlalchemy import Column, String, Text, DateTime, JSON, ForeignKey, Index, Integer
from sqlalchemy.orm import relationship

from app.db.base import BaseModel, UUIDType


class TransactionEvent(BaseModel):
    """
    Model for tracking detailed transaction events and lifecycle changes.
    
    This model stores granular events that occur during transaction processing,
    providing a comprehensive audit trail for compliance and debugging.
    """
    
    __tablename__ = "transaction_events"
    
    # Core event information
    transaction_id = Column(
        UUIDType(), 
        ForeignKey("transaction_headers.id", ondelete="CASCADE"),
        nullable=False,
        comment="Transaction this event belongs to"
    )
    event_type = Column(
        String(50), 
        nullable=False, 
        comment="Type of event (CREATED, VALIDATED, PROCESSED, etc.)"
    )
    event_category = Column(
        String(30),
        nullable=False,
        default="GENERAL",
        comment="Event category (TRANSACTION, INVENTORY, PAYMENT, ERROR, etc.)"
    )
    
    # Event details
    description = Column(
        Text,
        nullable=False,
        comment="Human-readable description of the event"
    )
    event_data = Column(
        JSON,
        nullable=True,
        comment="Additional structured data related to the event"
    )
    
    # Context information
    user_id = Column(
        Integer,
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        comment="User who triggered this event"
    )
    session_id = Column(
        String(100),
        nullable=True,
        comment="Session identifier for tracking user sessions"
    )
    ip_address = Column(
        String(45),
        nullable=True,
        comment="IP address of the client (supports IPv6)"
    )
    user_agent = Column(
        String(500),
        nullable=True,
        comment="User agent string from the request"
    )
    
    # System context
    service_name = Column(
        String(50),
        nullable=True,
        comment="Name of the service that generated this event"
    )
    operation_name = Column(
        String(100),
        nullable=True,
        comment="Specific operation being performed"
    )
    correlation_id = Column(
        String(100),
        nullable=True,
        comment="Correlation ID for tracking across services"
    )
    
    # Timing information
    event_timestamp = Column(
        DateTime,
        nullable=False,
        default=datetime.utcnow,
        comment="When this event occurred"
    )
    processing_duration_ms = Column(
        String(20),
        nullable=True,
        comment="How long the operation took in milliseconds"
    )
    
    # Status and outcome
    status = Column(
        String(20),
        nullable=False,
        default="SUCCESS",
        comment="Event status (SUCCESS, FAILURE, WARNING, INFO)"
    )
    error_code = Column(
        String(50),
        nullable=True,
        comment="Error code if the event represents an error"
    )
    error_message = Column(
        Text,
        nullable=True,
        comment="Error message if the event represents an error"
    )
    
    # Related entities
    affected_entities = Column(
        JSON,
        nullable=True,
        comment="List of entities affected by this event"
    )
    
    # Relationships
    transaction = relationship("TransactionHeader", back_populates="events")
    user = relationship("User", lazy="select")
    
    # Indexes for efficient querying
    __table_args__ = (
        Index('idx_transaction_events_transaction_id', 'transaction_id'),
        Index('idx_transaction_events_event_type', 'event_type'),
        Index('idx_transaction_events_category', 'event_category'),
        Index('idx_transaction_events_timestamp', 'event_timestamp'),
        Index('idx_transaction_events_user_id', 'user_id'),
        Index('idx_transaction_events_status', 'status'),
        Index('idx_transaction_events_operation', 'operation_name'),
        Index('idx_transaction_events_correlation', 'correlation_id'),
        # Composite indexes for common query patterns
        Index('idx_transaction_events_tx_type_time', 'transaction_id', 'event_type', 'event_timestamp'),
        Index('idx_transaction_events_category_status', 'event_category', 'status', 'event_timestamp'),
    )
    
    def __init__(
        self,
        transaction_id: str,
        event_type: str,
        description: str,
        event_category: str = "GENERAL",
        event_data: Optional[Dict[str, Any]] = None,
        user_id: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a transaction event.
        
        Args:
            transaction_id: ID of the related transaction
            event_type: Type of event being logged
            description: Human-readable description
            event_category: Category of the event
            event_data: Additional structured data
            user_id: ID of the user who triggered the event
            **kwargs: Additional fields
        """
        super().__init__(**kwargs)
        self.transaction_id = transaction_id
        self.event_type = event_type
        self.event_category = event_category
        self.description = description
        self.event_data = event_data or {}
        self.user_id = user_id
        
    @classmethod
    def create_transaction_event(
        cls,
        transaction_id: str,
        event_type: str,
        description: str,
        category: str = "TRANSACTION",
        data: Optional[Dict[str, Any]] = None,
        user_id: Optional[str] = None,
        operation: Optional[str] = None,
        status: str = "SUCCESS",
        duration_ms: Optional[int] = None
    ) -> "TransactionEvent":
        """
        Factory method to create a transaction event with standard fields.
        
        Args:
            transaction_id: Transaction identifier
            event_type: Type of event
            description: Event description
            category: Event category
            data: Additional event data
            user_id: User who triggered the event
            operation: Operation being performed
            status: Event status
            duration_ms: Processing duration in milliseconds
            
        Returns:
            New TransactionEvent instance
        """
        return cls(
            transaction_id=transaction_id,
            event_type=event_type,
            description=description,
            event_category=category,
            event_data=data,
            user_id=user_id,
            operation_name=operation,
            status=status,
            processing_duration_ms=str(duration_ms) if duration_ms else None
        )
    
    @classmethod
    def create_inventory_event(
        cls,
        transaction_id: str,
        event_type: str,
        item_id: str,
        item_name: str,
        quantity_change: str,
        location_id: Optional[str] = None,
        user_id: Optional[str] = None
    ) -> "TransactionEvent":
        """
        Factory method to create an inventory-related event.
        
        Args:
            transaction_id: Transaction identifier
            event_type: Type of inventory event
            item_id: Item identifier
            item_name: Item name
            quantity_change: Quantity change (+/-)
            location_id: Location identifier
            user_id: User who triggered the event
            
        Returns:
            New TransactionEvent instance
        """
        data = {
            "item_id": item_id,
            "item_name": item_name,
            "quantity_change": quantity_change,
            "location_id": location_id
        }
        
        return cls(
            transaction_id=transaction_id,
            event_type=event_type,
            description=f"Inventory change: {item_name} ({quantity_change})",
            event_category="INVENTORY",
            event_data=data,
            user_id=user_id
        )
    
    @classmethod
    def create_payment_event(
        cls,
        transaction_id: str,
        event_type: str,
        amount: str,
        payment_method: str,
        payment_status: str,
        reference: Optional[str] = None,
        user_id: Optional[str] = None
    ) -> "TransactionEvent":
        """
        Factory method to create a payment-related event.
        
        Args:
            transaction_id: Transaction identifier
            event_type: Type of payment event
            amount: Payment amount
            payment_method: Payment method used
            payment_status: Payment status
            reference: Payment reference
            user_id: User who triggered the event
            
        Returns:
            New TransactionEvent instance
        """
        data = {
            "amount": amount,
            "payment_method": payment_method,
            "payment_status": payment_status,
            "reference": reference
        }
        
        return cls(
            transaction_id=transaction_id,
            event_type=event_type,
            description=f"Payment event: {payment_method} {amount} - {payment_status}",
            event_category="PAYMENT",
            event_data=data,
            user_id=user_id
        )
    
    @classmethod
    def create_error_event(
        cls,
        transaction_id: str,
        error_type: str,
        error_message: str,
        error_code: Optional[str] = None,
        error_data: Optional[Dict[str, Any]] = None,
        user_id: Optional[str] = None
    ) -> "TransactionEvent":
        """
        Factory method to create an error event.
        
        Args:
            transaction_id: Transaction identifier
            error_type: Type of error
            error_message: Error message
            error_code: Error code
            error_data: Additional error data
            user_id: User who triggered the event
            
        Returns:
            New TransactionEvent instance
        """
        return cls(
            transaction_id=transaction_id,
            event_type=error_type,
            description=error_message,
            event_category="ERROR",
            event_data=error_data,
            user_id=user_id,
            status="FAILURE",
            error_code=error_code,
            error_message=error_message
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the event to a dictionary representation.
        
        Returns:
            Dictionary representation of the event
        """
        return {
            "id": str(self.id),
            "transaction_id": str(self.transaction_id),
            "event_type": self.event_type,
            "event_category": self.event_category,
            "description": self.description,
            "event_data": self.event_data,
            "user_id": str(self.user_id) if self.user_id else None,
            "event_timestamp": self.event_timestamp.isoformat(),
            "status": self.status,
            "operation_name": self.operation_name,
            "processing_duration_ms": self.processing_duration_ms,
            "error_code": self.error_code,
            "error_message": self.error_message,
            "affected_entities": self.affected_entities
        }
    
    def __repr__(self) -> str:
        """String representation of the event."""
        return f"<TransactionEvent(id={self.id}, tx={self.transaction_id}, type={self.event_type})>"


===== modules/transactions/base/models/inspections.py â€“ 2025-07-19 12:13:41 IST =====
"""
Models for rental return inspections and purchase credit memos.
"""
from sqlalchemy import Column, String, Text, Boolean, DateTime, Numeric, ForeignKey, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from uuid import uuid4
from datetime import datetime

from app.db.base import BaseModel, UUIDType


class RentalInspection(BaseModel):
    """Rental return inspection results."""
    
    __tablename__ = "rental_inspections"
    
    id = Column(UUIDType(), primary_key=True, default=uuid4)
    return_id = Column(UUIDType(), ForeignKey("transaction_headers.id"), nullable=False)
    inspector_id = Column(UUIDType(), nullable=False)  # Removed FK constraint temporarily
    inspection_date = Column(DateTime, nullable=False, default=datetime.utcnow)
    
    # Overall assessment
    overall_condition = Column(String(20), nullable=False)  # EXCELLENT, GOOD, FAIR, POOR
    inspection_passed = Column(Boolean, nullable=False)
    
    # Financial calculations
    total_repair_cost = Column(Numeric(10, 2), nullable=False, default=0)
    total_cleaning_cost = Column(Numeric(10, 2), nullable=False, default=0)
    total_deductions = Column(Numeric(10, 2), nullable=False, default=0)
    deposit_refund_amount = Column(Numeric(10, 2), nullable=False, default=0)
    
    # Additional information
    general_notes = Column(Text)
    customer_notification_required = Column(Boolean, nullable=False, default=False)
    follow_up_actions = Column(JSON)  # List of follow-up actions
    
    # Line item inspections stored as JSON for flexibility
    line_inspections = Column(JSON, nullable=False)
    
    # Relationships
    return_transaction = relationship("TransactionHeader", foreign_keys=[return_id])
    # inspector = relationship("User", foreign_keys=[inspector_id])  # Disabled temporarily


class PurchaseCreditMemo(BaseModel):
    """Purchase return credit memo tracking."""
    
    __tablename__ = "purchase_credit_memos"
    
    id = Column(UUIDType(), primary_key=True, default=uuid4)
    return_id = Column(UUIDType(), ForeignKey("transaction_headers.id"), nullable=False)
    credit_memo_number = Column(String(100), nullable=False, unique=True)
    credit_date = Column(DateTime, nullable=False)
    credit_amount = Column(Numeric(10, 2), nullable=False)
    
    # Credit details
    credit_type = Column(String(20), nullable=False)  # FULL_REFUND, PARTIAL_REFUND, etc.
    currency = Column(String(3), nullable=False, default="USD")
    exchange_rate = Column(Numeric(10, 6), nullable=False, default=1.0)
    
    # Line item breakdown (optional)
    line_credits = Column(JSON)
    
    # Additional information
    credit_terms = Column(String(500))
    supplier_notes = Column(Text)
    received_by = Column(UUIDType(), nullable=False)  # Removed FK constraint temporarily
    
    # Relationships
    return_transaction = relationship("TransactionHeader", foreign_keys=[return_id])
    # received_by_user = relationship("User", foreign_keys=[received_by])  # Disabled temporarily

===== modules/transactions/base/models/metadata.py â€“ 2025-07-19 12:13:41 IST =====
"""
Transaction metadata model for storing type-specific return data.
"""
from typing import Dict, Any, Optional
from datetime import datetime
from sqlalchemy import Column, String, ForeignKey, JSON, Index
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import JSONB

from app.db.base import BaseModel, UUIDType


class TransactionMetadata(BaseModel):
    """
    Transaction metadata model for storing flexible type-specific data.
    
    This model allows storing type-specific properties for returns and other
    transaction types without modifying the core transaction schema.
    """
    
    __tablename__ = "transaction_metadata"
    
    # Core fields
    transaction_id = Column(
        UUIDType(), 
        ForeignKey("transaction_headers.id"), 
        nullable=False,
        comment="Transaction ID this metadata belongs to"
    )
    metadata_type = Column(
        String(50), 
        nullable=False, 
        comment="Type of metadata (e.g., RETURN_SALE_RETURN)"
    )
    metadata_content = Column(
        JSONB, 
        nullable=False, 
        comment="JSON content with type-specific data"
    )
    
    # Relationships
    transaction = relationship(
        "TransactionHeader", 
        back_populates="metadata_entries",
        lazy="select"
    )
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_transaction_metadata_txn_id', 'transaction_id'),
        Index('idx_transaction_metadata_type', 'metadata_type'),
        Index('idx_transaction_metadata_content', 'metadata_content', postgresql_using='gin'),
    )
    
    def __init__(
        self,
        transaction_id: str,
        metadata_type: str,
        metadata_content: Dict[str, Any],
        **kwargs
    ):
        """
        Initialize transaction metadata.
        
        Args:
            transaction_id: Transaction this metadata belongs to
            metadata_type: Type identifier for the metadata
            metadata_content: Dictionary of type-specific data
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.transaction_id = transaction_id
        self.metadata_type = metadata_type
        self.metadata_content = metadata_content
        self._validate()
    
    def _validate(self):
        """Validate metadata."""
        if not self.transaction_id:
            raise ValueError("Transaction ID is required")
        
        if not self.metadata_type:
            raise ValueError("Metadata type is required")
        
        if not isinstance(self.metadata_content, dict):
            raise ValueError("Metadata content must be a dictionary")
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """
        Get a value from metadata content.
        
        Args:
            key: Key to retrieve
            default: Default value if key not found
            
        Returns:
            Value from metadata or default
        """
        return self.metadata_content.get(key, default)
    
    def set_value(self, key: str, value: Any) -> None:
        """
        Set a value in metadata content.
        
        Args:
            key: Key to set
            value: Value to store
        """
        if self.metadata_content is None:
            self.metadata_content = {}
        self.metadata_content[key] = value
    
    def update_values(self, updates: Dict[str, Any]) -> None:
        """
        Update multiple values in metadata content.
        
        Args:
            updates: Dictionary of updates to apply
        """
        if self.metadata_content is None:
            self.metadata_content = {}
        self.metadata_content.update(updates)
    
    @property
    def is_return_metadata(self) -> bool:
        """Check if this is return-related metadata."""
        return self.metadata_type.startswith("RETURN_")
    
    @property
    def return_type(self) -> Optional[str]:
        """Get return type if this is return metadata."""
        if self.is_return_metadata:
            return self.metadata_type.replace("RETURN_", "")
        return None
    
    def __str__(self) -> str:
        """String representation."""
        return f"TransactionMetadata({self.id}: {self.metadata_type})"
    
    def __repr__(self) -> str:
        """Developer representation."""
        return (
            f"TransactionMetadata(id={self.id}, "
            f"transaction_id={self.transaction_id}, "
            f"type='{self.metadata_type}', "
            f"content_keys={list(self.metadata_content.keys()) if self.metadata_content else []})"
        )

===== modules/transactions/base/models/rental_lifecycle.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental lifecycle models for tracking rental operations and returns.
"""

from enum import Enum as PyEnum
from typing import Optional, List, TYPE_CHECKING
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy import Column, String, Numeric, Boolean, Text, DateTime, Date, ForeignKey, Integer, Index, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
from uuid import uuid4

from app.db.base import BaseModel, UUIDType

if TYPE_CHECKING:
    from .transaction_headers import TransactionHeader
    from .transaction_lines import TransactionLine


class ReturnEventType(PyEnum):
    """Types of return events."""
    PARTIAL_RETURN = "PARTIAL_RETURN"
    FULL_RETURN = "FULL_RETURN"
    EXTENSION = "EXTENSION"
    STATUS_CHANGE = "STATUS_CHANGE"


class InspectionCondition(PyEnum):
    """Item condition after inspection."""
    EXCELLENT = "EXCELLENT"
    GOOD = "GOOD"
    FAIR = "FAIR"
    POOR = "POOR"
    DAMAGED = "DAMAGED"


class RentalLifecycle(BaseModel):
    """
    Tracks the operational lifecycle of a rental transaction.
    
    This model separates rental operations from financial records,
    allowing for complex rental workflows while keeping transaction
    data clean and focused on financial aspects.
    """
    
    __tablename__ = "rental_lifecycles"
    
    # Primary identification
    id = Column(UUIDType(), primary_key=True, default=uuid4, comment="Unique lifecycle identifier")
    transaction_id = Column(UUIDType(), ForeignKey("transaction_headers.id"), nullable=False, unique=True, comment="Associated transaction")
    
    # Status tracking
    current_status = Column(String(30), nullable=False, comment="Current rental status")
    last_status_change = Column(DateTime, nullable=False, default=datetime.utcnow, comment="Last status change timestamp")
    status_changed_by = Column(UUIDType(), nullable=True, comment="User who changed status")
    
    # Return tracking
    total_returned_quantity = Column(Numeric(10, 2), nullable=False, default=0, comment="Total quantity returned across all events")
    expected_return_date = Column(Date, nullable=True, comment="Expected return date (may change with extensions)")
    
    # Fee accumulation
    total_late_fees = Column(Numeric(15, 2), nullable=False, default=0, comment="Accumulated late fees")
    total_damage_fees = Column(Numeric(15, 2), nullable=False, default=0, comment="Accumulated damage fees")
    total_other_fees = Column(Numeric(15, 2), nullable=False, default=0, comment="Other fees (cleaning, restocking, etc.)")
    
    # Notes and metadata
    notes = Column(Text, nullable=True, comment="General notes about the rental")
    
    # Relationships
    transaction = relationship("TransactionHeader", back_populates="rental_lifecycle", lazy="select")
    return_events = relationship("RentalReturnEvent", back_populates="rental_lifecycle", lazy="select", cascade="all, delete-orphan")
    
    # Indexes
    __table_args__ = (
        Index("idx_lifecycle_transaction", "transaction_id"),
        Index("idx_lifecycle_status", "current_status"),
        Index("idx_lifecycle_expected_return", "expected_return_date"),
    )
    
    def __repr__(self):
        return f"<RentalLifecycle(id={self.id}, transaction_id={self.transaction_id}, status={self.current_status})>"
    
    @property
    def total_fees(self):
        """Calculate total accumulated fees."""
        return self.total_late_fees + self.total_damage_fees + self.total_other_fees


class RentalReturnEvent(BaseModel):
    """
    Records individual return events during the rental lifecycle.
    
    A rental may have multiple return events:
    - Partial returns (some items returned)
    - Extensions (changing return date)
    - Final return (completing the rental)
    """
    
    __tablename__ = "rental_return_events"
    
    # Primary identification
    id = Column(UUIDType(), primary_key=True, default=uuid4, comment="Unique event identifier")
    rental_lifecycle_id = Column(UUIDType(), ForeignKey("rental_lifecycles.id"), nullable=False, comment="Associated rental lifecycle")
    
    # Event details
    event_type = Column(String(20), nullable=False, comment="Type of return event")
    event_date = Column(Date, nullable=False, comment="Date of the event")
    processed_by = Column(UUIDType(), nullable=True, comment="User who processed this event")
    processed_at = Column(DateTime, nullable=False, default=datetime.utcnow, comment="When the event was processed")
    
    # Return details (for return events)
    items_returned = Column(JSON, nullable=True, comment="JSON array of returned items with quantities and conditions")
    total_quantity_returned = Column(Numeric(10, 2), nullable=False, default=0, comment="Total quantity returned in this event")
    
    # Financial details
    late_fees_charged = Column(Numeric(15, 2), nullable=False, default=0, comment="Late fees charged in this event")
    damage_fees_charged = Column(Numeric(15, 2), nullable=False, default=0, comment="Damage fees charged in this event")
    other_fees_charged = Column(Numeric(15, 2), nullable=False, default=0, comment="Other fees charged in this event")
    payment_collected = Column(Numeric(15, 2), nullable=False, default=0, comment="Payment collected during this event")
    refund_issued = Column(Numeric(15, 2), nullable=False, default=0, comment="Refund issued during this event")
    
    # Extension details (for extension events)
    new_return_date = Column(Date, nullable=True, comment="New return date for extensions")
    extension_reason = Column(String(200), nullable=True, comment="Reason for extension")
    
    # Notes and documentation
    notes = Column(Text, nullable=True, comment="Notes about this event")
    receipt_number = Column(String(50), nullable=True, comment="Receipt number for payments/refunds")
    
    # Relationships
    rental_lifecycle = relationship("RentalLifecycle", back_populates="return_events", lazy="select")
    
    # Indexes
    __table_args__ = (
        Index("idx_return_event_lifecycle", "rental_lifecycle_id"),
        Index("idx_return_event_date", "event_date"),
        Index("idx_return_event_type", "event_type"),
        Index("idx_return_event_processed", "processed_at"),
    )
    
    def __repr__(self):
        return f"<RentalReturnEvent(id={self.id}, type={self.event_type}, date={self.event_date})>"
    
    @property
    def total_fees_charged(self):
        """Calculate total fees charged in this event."""
        return self.late_fees_charged + self.damage_fees_charged + self.other_fees_charged
    
    @property
    def net_amount(self):
        """Calculate net amount (payment collected minus refund issued)."""
        return self.payment_collected - self.refund_issued


class RentalItemInspection(BaseModel):
    """
    Records inspection details for individual items during returns.
    
    Each item returned gets inspected and its condition recorded.
    This enables per-item damage tracking and fee calculation.
    """
    
    __tablename__ = "rental_item_inspections"
    
    # Primary identification
    id = Column(UUIDType(), primary_key=True, default=uuid4, comment="Unique inspection identifier")
    return_event_id = Column(UUIDType(), ForeignKey("rental_return_events.id"), nullable=False, comment="Associated return event")
    transaction_line_id = Column(UUIDType(), ForeignKey("transaction_lines.id"), nullable=False, comment="Transaction line being inspected")
    
    # Inspection details
    quantity_inspected = Column(Numeric(10, 2), nullable=False, comment="Quantity of this item inspected")
    condition = Column(String(20), nullable=False, comment="Overall condition assessment")
    inspected_by = Column(UUIDType(), nullable=True, comment="User who performed inspection")
    inspected_at = Column(DateTime, nullable=False, default=datetime.utcnow, comment="Inspection timestamp")
    
    # Condition details
    has_damage = Column(Boolean, nullable=False, default=False, comment="Whether item has damage")
    damage_description = Column(Text, nullable=True, comment="Description of any damage")
    damage_photos = Column(JSON, nullable=True, comment="JSON array of damage photo URLs")
    
    # Financial impact
    damage_fee_assessed = Column(Numeric(15, 2), nullable=False, default=0, comment="Damage fee assessed for this item")
    cleaning_fee_assessed = Column(Numeric(15, 2), nullable=False, default=0, comment="Cleaning fee assessed for this item")
    replacement_required = Column(Boolean, nullable=False, default=False, comment="Whether item needs replacement")
    replacement_cost = Column(Numeric(15, 2), nullable=True, comment="Cost of replacement if required")
    
    # Stock handling
    return_to_stock = Column(Boolean, nullable=False, default=True, comment="Whether item can be returned to stock")
    stock_location = Column(String(100), nullable=True, comment="Where item was returned to stock")
    
    # Notes
    inspection_notes = Column(Text, nullable=True, comment="Detailed inspection notes")
    
    # Relationships
    return_event = relationship("RentalReturnEvent", lazy="select")
    transaction_line = relationship("TransactionLine", lazy="select")
    
    # Indexes
    __table_args__ = (
        Index("idx_inspection_return_event", "return_event_id"),
        Index("idx_inspection_transaction_line", "transaction_line_id"),
        Index("idx_inspection_condition", "condition"),
        Index("idx_inspection_damage", "has_damage"),
    )
    
    def __repr__(self):
        return f"<RentalItemInspection(id={self.id}, condition={self.condition}, quantity={self.quantity_inspected})>"
    
    @property
    def total_fees_assessed(self):
        """Calculate total fees assessed for this inspection."""
        return self.damage_fee_assessed + self.cleaning_fee_assessed + (self.replacement_cost or 0)


class RentalStatusChangeReason(PyEnum):
    """Reasons for rental status changes."""
    SCHEDULED_UPDATE = "SCHEDULED_UPDATE"
    RETURN_EVENT = "RETURN_EVENT"
    MANUAL_UPDATE = "MANUAL_UPDATE"
    EXTENSION = "EXTENSION"
    LATE_FEE_APPLIED = "LATE_FEE_APPLIED"
    DAMAGE_ASSESSMENT = "DAMAGE_ASSESSMENT"


class RentalStatusLog(BaseModel):
    """
    Historical log of rental status changes for both headers and line items.
    
    Tracks all status transitions with context about why they occurred,
    enabling comprehensive audit trails and status history reporting.
    """
    
    __tablename__ = "rental_status_logs"
    
    # Primary identification
    id = Column(UUIDType(), primary_key=True, default=uuid4, comment="Unique log entry identifier")
    
    # Entity identification
    transaction_id = Column(UUIDType(), ForeignKey("transaction_headers.id"), nullable=False, comment="Transaction being tracked")
    transaction_line_id = Column(UUIDType(), ForeignKey("transaction_lines.id"), nullable=True, comment="Specific line item (null for header-level changes)")
    rental_lifecycle_id = Column(UUIDType(), ForeignKey("rental_lifecycles.id"), nullable=True, comment="Associated rental lifecycle")
    
    # Status change details
    old_status = Column(String(30), nullable=True, comment="Previous status (null for initial status)")
    new_status = Column(String(30), nullable=False, comment="New status after change")
    change_reason = Column(String(30), nullable=False, comment="Reason for the status change")
    change_trigger = Column(String(50), nullable=True, comment="What triggered the change (scheduled_job, return_event_id, etc.)")
    
    # Change context
    changed_by = Column(UUIDType(), nullable=True, comment="User who initiated the change (null for system changes)")
    changed_at = Column(DateTime, nullable=False, default=datetime.utcnow, comment="When the change occurred")
    
    # Additional context
    notes = Column(Text, nullable=True, comment="Additional notes about the status change")
    status_metadata = Column(JSON, nullable=True, comment="Additional context data (overdue days, return quantities, etc.)")
    
    # System tracking
    system_generated = Column(Boolean, nullable=False, default=False, comment="Whether this change was system-generated")
    batch_id = Column(String(50), nullable=True, comment="Batch ID for scheduled updates")
    
    # Relationships
    transaction = relationship("TransactionHeader", lazy="select")
    transaction_line = relationship("TransactionLine", lazy="select")
    rental_lifecycle = relationship("RentalLifecycle", lazy="select")
    
    # Indexes
    __table_args__ = (
        Index("idx_status_log_transaction", "transaction_id"),
        Index("idx_status_log_line", "transaction_line_id"),
        Index("idx_status_log_changed_at", "changed_at"),
        Index("idx_status_log_reason", "change_reason"),
        Index("idx_status_log_batch", "batch_id"),
        Index("idx_status_log_system", "system_generated"),
    )
    
    def __repr__(self):
        entity_type = "line" if self.transaction_line_id else "header"
        return f"<RentalStatusLog(id={self.id}, {entity_type}, {self.old_status}->{self.new_status})>"
    
    @property
    def is_header_change(self) -> bool:
        """Check if this is a header-level status change."""
        return self.transaction_line_id is None
    
    @property
    def is_line_change(self) -> bool:
        """Check if this is a line-level status change."""
        return self.transaction_line_id is not None

===== modules/transactions/base/models/transaction_headers.py â€“ 2025-07-19 16:32:30 IST =====
"""
Transaction Header model - main transaction records.
"""

from enum import Enum as PyEnum
from typing import Optional, TYPE_CHECKING
from decimal import Decimal
from datetime import datetime, date, time
from sqlalchemy import Column, String, Numeric, Boolean, Text, DateTime, Date, Time, ForeignKey, Integer, Index, Enum, CheckConstraint
from sqlalchemy.orm import relationship
from uuid import uuid4

from app.db.base import BaseModel, UUIDType

if TYPE_CHECKING:
    from .transaction_lines import TransactionLine
    from .rental_lifecycle import RentalLifecycle
    from .metadata import TransactionMetadata


# Transaction Type Enum
class TransactionType(PyEnum):
    SALE = "SALE"
    PURCHASE = "PURCHASE"
    RENTAL = "RENTAL"
    RETURN = "RETURN"
    ADJUSTMENT = "ADJUSTMENT"


# Transaction Status Enum
class TransactionStatus(PyEnum):
    PENDING = "PENDING"
    PROCESSING = "PROCESSING"
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"
    ON_HOLD = "ON_HOLD"
    IN_PROGRESS = "IN_PROGRESS"  # For rentals


# Payment Method Enum
class PaymentMethod(PyEnum):
    CASH = "CASH"
    CREDIT_CARD = "CREDIT_CARD"
    DEBIT_CARD = "DEBIT_CARD"
    BANK_TRANSFER = "BANK_TRANSFER"
    CHEQUE = "CHEQUE"
    ONLINE = "ONLINE"
    CREDIT_ACCOUNT = "CREDIT_ACCOUNT"


# Payment Status Enum
class PaymentStatus(PyEnum):
    PENDING = "PENDING"
    PAID = "PAID"
    PARTIAL = "PARTIAL"
    FAILED = "FAILED"
    REFUNDED = "REFUNDED"


# Rental Period Unit Enum
class RentalPeriodUnit(PyEnum):
    HOUR = "HOUR"
    DAY = "DAY"
    WEEK = "WEEK"
    MONTH = "MONTH"


# Rental Status Enum
class RentalStatus(PyEnum):
    ACTIVE = "ACTIVE"
    LATE = "LATE"
    EXTENDED = "EXTENDED"
    PARTIAL_RETURN = "PARTIAL_RETURN"
    LATE_PARTIAL_RETURN = "LATE_PARTIAL_RETURN"
    COMPLETED = "COMPLETED"


class TransactionHeader(BaseModel):
    """
    Transaction Header model for managing sales, purchases, and rentals.
    
    This is the main financial record that tracks all monetary aspects of transactions.
    For rentals, it works with RentalLifecycle for operational tracking.
    """
    
    __tablename__ = "transaction_headers"
    
    # Primary identification
    id = Column(UUIDType(), primary_key=True, default=uuid4, comment="Unique transaction identifier")
    transaction_number = Column(String(50), unique=True, nullable=False, comment="Human-readable transaction number")
    
    # Transaction categorization
    transaction_type = Column(Enum(TransactionType), nullable=False, comment="Type of transaction")
    status = Column(Enum(TransactionStatus), nullable=False, default=TransactionStatus.PENDING, comment="Current status")
    payment_status = Column(String(20), nullable=True, comment="Payment status")
    
    # Temporal information
    transaction_date = Column(DateTime, nullable=False, default=datetime.utcnow, comment="Transaction date and time")
    due_date = Column(Date, nullable=True, comment="Payment due date")
    
    # Parties involved
    customer_id = Column(String(36), nullable=True, comment="Customer/Supplier UUID as string")
    location_id = Column(String(36), nullable=True, comment="Location UUID as string")
    sales_person_id = Column(UUIDType(), nullable=True, comment="Sales person handling transaction")
    
    # Financial information
    currency = Column(String(3), nullable=False, default="USD", comment="Currency code")
    exchange_rate = Column(Numeric(10, 6), nullable=False, default=1.0, comment="Exchange rate to base currency")
    
    # Amount calculations
    subtotal = Column(Numeric(15, 2), nullable=False, default=0, comment="Subtotal before discounts and taxes")
    discount_amount = Column(Numeric(15, 2), nullable=False, default=0, comment="Total discount amount")
    tax_amount = Column(Numeric(15, 2), nullable=False, default=0, comment="Total tax amount")
    shipping_amount = Column(Numeric(15, 2), nullable=False, default=0, comment="Shipping charges")
    total_amount = Column(Numeric(15, 2), nullable=False, default=0, comment="Final total amount")
    paid_amount = Column(Numeric(15, 2), nullable=False, default=0, comment="Amount already paid")
    
    # Rental-specific fields (moved to TransactionLine level)
    deposit_amount = Column(Numeric(15, 2), nullable=True, comment="Security deposit for rentals")
    deposit_paid = Column(Boolean, nullable=False, default=False, comment="Whether deposit has been paid")
    customer_advance_balance = Column(Numeric(15, 2), nullable=False, default=0, comment="Customer advance payment balance")
    
    # Return handling
    reference_transaction_id = Column(UUIDType(), ForeignKey("transaction_headers.id"), nullable=True, comment="Reference to original transaction for returns")
    
    # Additional information
    notes = Column(Text, nullable=True, comment="Additional notes")
    reference_number = Column(String(50), nullable=True, comment="External reference number")
    payment_method = Column(String(20), nullable=True, comment="Payment method")
    payment_reference = Column(String(100), nullable=True, comment="Payment reference")
    return_workflow_state = Column(String(50), nullable=True, comment="Return workflow state")
    
    # Delivery fields
    delivery_required = Column(Boolean, nullable=False, default=False, comment="Whether delivery is required")
    delivery_address = Column(Text, nullable=True, comment="Delivery address if delivery is required")
    delivery_date = Column(Date, nullable=True, comment="Scheduled delivery date")
    delivery_time = Column(Time, nullable=True, comment="Scheduled delivery time")
    
    # Pickup fields
    pickup_required = Column(Boolean, nullable=False, default=False, comment="Whether pickup is required")
    pickup_date = Column(Date, nullable=True, comment="Scheduled pickup date")
    pickup_time = Column(Time, nullable=True, comment="Scheduled pickup time")
    
    # Relationships
    # customer = relationship("Customer", back_populates="transactions", lazy="select")  # Temporarily disabled
    # location = relationship("Location", back_populates="transactions", lazy="select")  # Temporarily disabled
    # sales_person = relationship("User", back_populates="transactions", lazy="select")  # Temporarily disabled
    reference_transaction = relationship("TransactionHeader", remote_side="TransactionHeader.id", lazy="select")
    transaction_lines = relationship("TransactionLine", back_populates="transaction", lazy="select", cascade="all, delete-orphan")
    metadata_entries = relationship("TransactionMetadata", back_populates="transaction", lazy="select", cascade="all, delete-orphan")
    rental_lifecycle = relationship("RentalLifecycle", back_populates="transaction", uselist=False, lazy="select")
    events = relationship("TransactionEvent", back_populates="transaction", lazy="select", cascade="all, delete-orphan")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index("idx_transaction_number", "transaction_number"),
        Index("idx_transaction_type", "transaction_type"),
        Index("idx_transaction_status", "status"),
        Index("idx_transaction_date", "transaction_date"),
        Index("idx_customer_id", "customer_id"),
        Index("idx_location_id", "location_id"),
        Index("idx_reference_transaction", "reference_transaction_id"),
        Index("idx_delivery_required", "delivery_required"),
        Index("idx_pickup_required", "pickup_required"),
        Index("idx_delivery_date", "delivery_date"),
        Index("idx_pickup_date", "pickup_date"),
        CheckConstraint("total_amount >= 0", name="check_positive_total"),
        CheckConstraint("paid_amount >= 0", name="check_positive_paid"),
        CheckConstraint("paid_amount <= total_amount", name="check_paid_not_exceed_total"),
    )
    
    def __repr__(self):
        return f"<TransactionHeader(id={self.id}, number={self.transaction_number}, type={self.transaction_type}, total={self.total_amount})>"
    
    @property
    def balance_due(self):
        """Calculate outstanding balance."""
        return self.total_amount - self.paid_amount
    
    @property
    def is_paid(self):
        """Check if transaction is fully paid."""
        return self.paid_amount >= self.total_amount
    
    def compute_payment_status(self):
        """Compute payment status based on amounts (for validation/comparison)."""
        if self.paid_amount == 0:
            return PaymentStatus.PENDING
        elif self.paid_amount >= self.total_amount:
            return PaymentStatus.PAID
        else:
            return PaymentStatus.PARTIAL
    
    @property
    def is_rental(self):
        """Check if this is a rental transaction."""
        return self.transaction_type == TransactionType.RENTAL
    
    @property
    def rental_duration_days(self):
        """Calculate rental duration in days from transaction lines."""
        if not self.is_rental or not self.transaction_lines:
            return 0
        
        # Get the maximum rental duration from all lines
        max_duration = 0
        for line in self.transaction_lines:
            if line.rental_start_date and line.rental_end_date:
                duration = (line.rental_end_date - line.rental_start_date).days
                max_duration = max(max_duration, duration)
        return max_duration
    
    @property
    def rental_start_date(self):
        """Get the earliest rental start date from transaction lines."""
        if not self.is_rental or not self.transaction_lines:
            return None
        
        start_dates = [line.rental_start_date for line in self.transaction_lines 
                      if line.rental_start_date]
        return min(start_dates) if start_dates else None
    
    @property
    def rental_end_date(self):
        """Get the latest rental end date from transaction lines."""
        if not self.is_rental or not self.transaction_lines:
            return None
        
        end_dates = [line.rental_end_date for line in self.transaction_lines 
                    if line.rental_end_date]
        return max(end_dates) if end_dates else None
    
    @property
    def current_rental_status(self):
        """Aggregate rental status from transaction lines."""
        if not self.is_rental or not self.transaction_lines:
            return None
        
        # Use RentalStatus enum directly
        
        # Get all line statuses
        line_statuses = [line.current_rental_status for line in self.transaction_lines 
                        if line.current_rental_status]
        
        if not line_statuses:
            return None
        
        # Status aggregation logic:
        # - If any line is LATE, transaction is LATE
        # - If any line has PARTIAL_RETURN, transaction has partial returns
        # - If all lines are COMPLETED, transaction is COMPLETED
        # - Otherwise, transaction is ACTIVE
        
        if RentalStatus.LATE in line_statuses or RentalStatus.LATE_PARTIAL_RETURN in line_statuses:
            if RentalStatus.PARTIAL_RETURN in line_statuses or RentalStatus.LATE_PARTIAL_RETURN in line_statuses:
                return RentalStatus.LATE_PARTIAL_RETURN
            return RentalStatus.LATE
        
        if RentalStatus.PARTIAL_RETURN in line_statuses:
            return RentalStatus.PARTIAL_RETURN
        
        if all(status == RentalStatus.COMPLETED for status in line_statuses):
            return RentalStatus.COMPLETED
        
        if RentalStatus.EXTENDED in line_statuses:
            return RentalStatus.EXTENDED
        
        return RentalStatus.ACTIVE
    
    @property
    def is_overdue(self):
        """Check if rental is overdue based on line items."""
        if not self.is_rental:
            return False
        
        rental_end = self.rental_end_date
        if not rental_end:
            return False
        
        return rental_end < date.today()
    
    @property
    def days_overdue(self):
        """Calculate days overdue for rental."""
        if not self.is_overdue:
            return 0
        return (date.today() - self.rental_end_date).days

===== modules/transactions/base/models/transaction_lines.py â€“ 2025-07-19 12:13:41 IST =====
"""
Transaction Line models - individual line items within transactions.
"""

from enum import Enum as PyEnum
from typing import Optional, TYPE_CHECKING
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy import Column, String, Text, Numeric, DateTime, Date, Boolean, Integer, ForeignKey, Enum, Index, UniqueConstraint, CheckConstraint
from sqlalchemy.orm import relationship
from uuid import uuid4

from app.db.base import BaseModel, UUIDType

if TYPE_CHECKING:
    from .transaction_headers import TransactionHeader

# Import enums directly to avoid circular imports
from .transaction_headers import RentalPeriodUnit, RentalStatus


# Line Item Type Enum
class LineItemType(PyEnum):
    PRODUCT = "PRODUCT"
    SERVICE = "SERVICE"
    DISCOUNT = "DISCOUNT"
    TAX = "TAX"
    SHIPPING = "SHIPPING"
    FEE = "FEE"


class TransactionLine(BaseModel):
    """
    Transaction Line Item model for detailed transaction components.
    
    Each line represents a specific item, service, or fee within a transaction.
    For rentals, tracks item-specific rental periods and return status.
    """
    
    __tablename__ = "transaction_lines"
    
    # Primary identification
    id = Column(UUIDType(), primary_key=True, default=uuid4, comment="Unique line item identifier")
    transaction_id = Column(UUIDType(), ForeignKey("transaction_headers.id"), nullable=False, comment="Parent transaction ID")
    line_number = Column(Integer, nullable=False, comment="Line sequence number within transaction")
    
    # Item identification
    line_type = Column(Enum(LineItemType), nullable=False, default=LineItemType.PRODUCT, comment="Type of line item")
    item_id = Column(String(36), nullable=True, comment="Item/Product UUID as string")
    inventory_unit_id = Column(String(36), nullable=True, comment="Specific inventory unit for serialized items")
    sku = Column(String(100), nullable=True, comment="Stock Keeping Unit")
    
    # Description and categorization
    description = Column(Text, nullable=False, comment="Line item description")
    category = Column(String(100), nullable=True, comment="Item category")
    
    # Quantity and measurements
    quantity = Column(Numeric(10, 2), nullable=False, default=1, comment="Quantity ordered/sold")
    unit_of_measure = Column(String(20), nullable=True, comment="Unit of measurement")
    
    # Pricing information
    unit_price = Column(Numeric(10, 2), nullable=False, default=0, comment="Price per unit")
    discount_percent = Column(Numeric(5, 2), nullable=False, default=0, comment="Discount percentage")
    discount_amount = Column(Numeric(10, 2), nullable=False, default=0, comment="Discount amount")
    tax_rate = Column(Numeric(5, 2), nullable=False, default=0, comment="Tax rate percentage")
    tax_amount = Column(Numeric(10, 2), nullable=False, default=0, comment="Tax amount")
    line_total = Column(Numeric(10, 2), nullable=False, default=0, comment="Total for this line item")
    
    # Rental-specific fields
    rental_start_date = Column(Date, nullable=True, comment="Item rental start date")
    rental_end_date = Column(Date, nullable=True, comment="Item rental end date")
    rental_period = Column(Integer, nullable=True, comment="Rental period for this item")
    rental_period_unit = Column(Enum(RentalPeriodUnit), nullable=True, comment="Rental period unit")
    current_rental_status = Column(Enum(RentalStatus), nullable=True, comment="Current rental status for this item")
    daily_rate = Column(Numeric(10, 2), nullable=True, comment="Daily rental rate")
    
    # Inventory and fulfillment
    location_id = Column(String(36), nullable=True, comment="Fulfillment location UUID as string")
    warehouse_location = Column(String(100), nullable=True, comment="Specific warehouse location")
    
    # Status tracking
    status = Column(String(20), nullable=False, default="PENDING", comment="Line item status")
    fulfillment_status = Column(String(20), nullable=False, default="PENDING", comment="Fulfillment status")
    
    # Return handling
    returned_quantity = Column(Numeric(10, 2), nullable=False, default=0, comment="Returned quantity")
    return_date = Column(Date, nullable=True, comment="Return date")
    notes = Column(Text, nullable=True, comment="Additional notes")
    return_condition = Column(String(1), nullable=True, default="A", comment="Return condition (A-D)")
    return_to_stock = Column(Boolean, nullable=True, default=True, comment="Whether to return to stock")
    inspection_status = Column(String(20), nullable=True, comment="Inspection status for returns")
    
    # Relationships
    transaction = relationship("TransactionHeader", back_populates="transaction_lines", lazy="select")
    # item = relationship("Item", back_populates="transaction_lines", lazy="select")  # Temporarily disabled
    # inventory_unit = relationship("InventoryUnit", back_populates="transaction_lines", lazy="select")  # Temporarily disabled
    # location = relationship("Location", back_populates="transaction_lines", lazy="select")  # Temporarily disabled
    
    # Indexes and constraints
    __table_args__ = (
        Index("idx_transaction_id", "transaction_id"),
        Index("idx_line_number", "transaction_id", "line_number"),
        Index("idx_item_id", "item_id"),
        Index("idx_inventory_unit_id", "inventory_unit_id"),
        Index("idx_sku", "sku"),
        Index("idx_status", "status"),
        Index("idx_fulfillment_status", "fulfillment_status"),
        Index("idx_rental_dates", "rental_start_date", "rental_end_date"),
        Index("idx_rental_status", "current_rental_status"),
        UniqueConstraint("transaction_id", "line_number", name="uq_transaction_line_number"),
        CheckConstraint("quantity > 0", name="check_positive_quantity"),
        CheckConstraint("unit_price >= 0", name="check_non_negative_price"),
        CheckConstraint("discount_percent >= 0 AND discount_percent <= 100", name="check_valid_discount_percent"),
        CheckConstraint("tax_rate >= 0", name="check_non_negative_tax_rate"),
        CheckConstraint("returned_quantity >= 0", name="check_non_negative_returned"),
        CheckConstraint("returned_quantity <= quantity", name="check_returned_not_exceed_quantity"),
    )
    
    def __repr__(self):
        return f"<TransactionLine(id={self.id}, transaction_id={self.transaction_id}, line={self.line_number}, item={self.description})>"
    
    @property
    def extended_price(self):
        """Calculate extended price before discount."""
        return self.quantity * self.unit_price
    
    @property
    def net_amount(self):
        """Calculate net amount after discount but before tax."""
        return self.extended_price - self.discount_amount
    
    @property
    def remaining_quantity(self):
        """Calculate quantity not yet returned."""
        return self.quantity - self.returned_quantity
    
    @property
    def return_percentage(self):
        """Calculate percentage of quantity returned."""
        if self.quantity == 0:
            return Decimal('0')
        return (self.returned_quantity / self.quantity) * 100
    
    @property
    def is_fully_returned(self):
        """Check if all quantity has been returned."""
        return self.returned_quantity >= self.quantity
    
    @property
    def is_partially_returned(self):
        """Check if some but not all quantity has been returned."""
        return 0 < self.returned_quantity < self.quantity
    
    @property
    def rental_duration_days(self):
        """Calculate rental duration in days for this line."""
        if self.rental_start_date and self.rental_end_date:
            return (self.rental_end_date - self.rental_start_date).days
        return 0
    
    @property
    def is_rental_overdue(self):
        """Check if this rental line is overdue."""
        if not self.rental_end_date:
            return False
        return self.rental_end_date < date.today() and not self.is_fully_returned
    
    @property
    def days_overdue(self):
        """Calculate days overdue for this rental line."""
        if not self.is_rental_overdue:
            return 0
        return (date.today() - self.rental_end_date).days
    
    @property
    def is_active_rental(self):
        """Check if this line represents an active rental."""
        return (self.current_rental_status == RentalStatus.ACTIVE and 
                self.rental_start_date and self.rental_end_date)
    
    @property
    def is_completed_rental(self):
        """Check if this rental line is completed."""
        return self.current_rental_status == RentalStatus.COMPLETED
    
    @property
    def is_late_rental(self):
        """Check if this rental line is late."""
        return (self.current_rental_status == RentalStatus.LATE or 
                self.current_rental_status == RentalStatus.LATE_PARTIAL_RETURN)
    
    @property
    def has_partial_return(self):
        """Check if this rental line has partial returns."""
        return (self.current_rental_status == RentalStatus.PARTIAL_RETURN or 
                self.current_rental_status == RentalStatus.LATE_PARTIAL_RETURN)
    
    def calculate_line_total(self):
        """Calculate and update line total."""
        extended = self.quantity * self.unit_price
        after_discount = extended - self.discount_amount
        self.line_total = after_discount + self.tax_amount
        return self.line_total
    
    def can_return_quantity(self, quantity: Decimal) -> bool:
        """Check if specified quantity can be returned."""
        return quantity <= self.remaining_quantity
    
    def calculate_daily_rate(self) -> Decimal:
        """Calculate daily rental rate for this line."""
        if self.daily_rate:
            return self.daily_rate
        
        if self.rental_duration_days > 0:
            return self.line_total / self.rental_duration_days
        
        return Decimal('0')

===== modules/transactions/services/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""
Transaction services package.
"""

from .unified_returns import UnifiedReturnService
from .return_processors import (
    ReturnProcessor,
    SaleReturnProcessor,
    PurchaseReturnProcessor,
    RentalReturnProcessor
)
from .return_workflows import WorkflowManager

__all__ = [
    "UnifiedReturnService",
    "ReturnProcessor", 
    "SaleReturnProcessor",
    "PurchaseReturnProcessor",
    "RentalReturnProcessor",
    "WorkflowManager"
]

===== modules/transactions/services/fee_calculator.py â€“ 2025-07-19 12:13:41 IST =====
"""
Fee calculation utilities for rental transactions.
"""

from typing import Dict, Any, Optional
from uuid import UUID
from datetime import date, datetime
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.modules.transactions.base.models import (
    TransactionHeader, 
    TransactionLine,
    RentalLifecycle
)
from app.core.config import settings
import logging

logger = logging.getLogger(__name__)


class RentalFeeCalculator:
    """Calculator for rental-related fees."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        
        # Default fee configuration (should come from settings or database)
        self.default_late_fee_rate = Decimal('0.05')  # 5% per day
        self.max_late_fee_multiplier = Decimal('3.0')  # Max 3x daily rate
        self.default_damage_rate = Decimal('0.10')  # 10% of item value
        self.default_cleaning_fee = Decimal('25.00')  # $25 default cleaning
    
    async def calculate_late_fees(
        self, 
        transaction_id: UUID,
        as_of_date: Optional[date] = None
    ) -> Dict[str, Any]:
        """Calculate late fees for a rental transaction."""
        if not as_of_date:
            as_of_date = date.today()
        
        # Get transaction details
        result = await self.session.execute(
            select(TransactionHeader)
            .where(TransactionHeader.id == transaction_id)
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction or not transaction.rental_end_date:
            return {
                'late_fee_days': 0,
                'late_fee_amount': Decimal('0'),
                'is_overdue': False
            }
        
        # Calculate days overdue
        days_overdue = max(0, (as_of_date - transaction.rental_end_date).days)
        is_overdue = days_overdue > 0
        
        if not is_overdue:
            return {
                'late_fee_days': 0,
                'late_fee_amount': Decimal('0'),
                'is_overdue': False
            }
        
        # Calculate daily rental amount (base for late fee calculation)
        daily_rental_amount = self._calculate_daily_rental_amount(transaction)
        
        # Get late fee rate (could be customer-specific or item-specific)
        late_fee_rate = await self._get_late_fee_rate(transaction_id)
        
        # Calculate late fee
        daily_late_fee = daily_rental_amount * late_fee_rate
        max_late_fee = daily_rental_amount * self.max_late_fee_multiplier
        
        total_late_fee = min(daily_late_fee * days_overdue, max_late_fee)
        
        return {
            'late_fee_days': days_overdue,
            'late_fee_rate': late_fee_rate,
            'daily_rental_amount': daily_rental_amount,
            'daily_late_fee': daily_late_fee,
            'late_fee_amount': total_late_fee,
            'max_late_fee': max_late_fee,
            'is_overdue': True
        }
    
    async def calculate_damage_fees(
        self, 
        transaction_line_id: UUID,
        damage_level: str,
        custom_damage_amount: Optional[Decimal] = None
    ) -> Dict[str, Any]:
        """Calculate damage fees for a specific item."""
        # Get transaction line details
        result = await self.session.execute(
            select(TransactionLine)
            .where(TransactionLine.id == transaction_line_id)
        )
        line = result.scalar_one_or_none()
        
        if not line:
            return {
                'damage_fee': Decimal('0'),
                'cleaning_fee': Decimal('0'),
                'replacement_cost': Decimal('0'),
                'total_damage_cost': Decimal('0')
            }
        
        # If custom amount provided, use it
        if custom_damage_amount:
            return {
                'damage_fee': custom_damage_amount,
                'cleaning_fee': Decimal('0'),
                'replacement_cost': Decimal('0'),
                'total_damage_cost': custom_damage_amount
            }
        
        # Calculate based on damage level
        item_value = line.unit_price
        damage_fee = Decimal('0')
        cleaning_fee = Decimal('0')
        replacement_cost = Decimal('0')
        
        if damage_level == 'MINOR':
            cleaning_fee = self.default_cleaning_fee
        elif damage_level == 'MODERATE':
            damage_fee = item_value * Decimal('0.25')  # 25% of value
            cleaning_fee = self.default_cleaning_fee
        elif damage_level == 'MAJOR':
            damage_fee = item_value * Decimal('0.50')  # 50% of value
            cleaning_fee = self.default_cleaning_fee * 2
        elif damage_level == 'TOTAL_LOSS':
            replacement_cost = item_value
        
        total_damage_cost = damage_fee + cleaning_fee + replacement_cost
        
        return {
            'damage_level': damage_level,
            'item_value': item_value,
            'damage_fee': damage_fee,
            'cleaning_fee': cleaning_fee,
            'replacement_cost': replacement_cost,
            'total_damage_cost': total_damage_cost
        }
    
    async def calculate_total_rental_fees(
        self, 
        transaction_id: UUID,
        as_of_date: Optional[date] = None,
        include_pending_damage: bool = True
    ) -> Dict[str, Any]:
        """Calculate comprehensive fee breakdown for a rental."""
        if not as_of_date:
            as_of_date = date.today()
        
        # Get transaction and lifecycle
        transaction_result = await self.session.execute(
            select(TransactionHeader)
            .where(TransactionHeader.id == transaction_id)
        )
        transaction = transaction_result.scalar_one_or_none()
        
        lifecycle_result = await self.session.execute(
            select(RentalLifecycle)
            .where(RentalLifecycle.transaction_id == transaction_id)
        )
        lifecycle = lifecycle_result.scalar_one_or_none()
        
        if not transaction:
            raise ValueError(f"Transaction {transaction_id} not found")
        
        # Calculate late fees
        late_fee_info = await self.calculate_late_fees(transaction_id, as_of_date)
        
        # Get accumulated fees from lifecycle
        accumulated_late_fees = lifecycle.total_late_fees if lifecycle else Decimal('0')
        accumulated_damage_fees = lifecycle.total_damage_fees if lifecycle else Decimal('0')
        accumulated_other_fees = lifecycle.total_other_fees if lifecycle else Decimal('0')
        
        # Calculate new late fees (not yet charged)
        new_late_fees = max(Decimal('0'), late_fee_info['late_fee_amount'] - accumulated_late_fees)
        
        # Calculate totals
        total_fees = (
            accumulated_late_fees + 
            accumulated_damage_fees + 
            accumulated_other_fees + 
            new_late_fees
        )
        
        # Calculate amounts due considering deposits and advance payments
        deposit_credit = transaction.deposit_amount or Decimal('0') if transaction.deposit_paid else Decimal('0')
        advance_credit = transaction.customer_advance_balance or Decimal('0')
        
        amount_due = max(Decimal('0'), total_fees - deposit_credit - advance_credit)
        refund_due = max(Decimal('0'), deposit_credit + advance_credit - total_fees)
        
        return {
            'transaction_id': transaction_id,
            'calculation_date': as_of_date,
            'base_rental_amount': transaction.total_amount,
            
            # Late fee breakdown
            'late_fee_info': late_fee_info,
            'accumulated_late_fees': accumulated_late_fees,
            'new_late_fees': new_late_fees,
            'total_late_fees': accumulated_late_fees + new_late_fees,
            
            # Other fees
            'accumulated_damage_fees': accumulated_damage_fees,
            'accumulated_other_fees': accumulated_other_fees,
            'total_accumulated_fees': accumulated_late_fees + accumulated_damage_fees + accumulated_other_fees,
            
            # Totals
            'total_fees': total_fees,
            'deposit_credit': deposit_credit,
            'advance_payment_credit': advance_credit,
            'total_credits': deposit_credit + advance_credit,
            'amount_due': amount_due,
            'refund_due': refund_due,
            'net_amount': amount_due - refund_due
        }
    
    async def estimate_extension_cost(
        self,
        transaction_id: UUID,
        new_end_date: date,
        current_end_date: Optional[date] = None
    ) -> Dict[str, Any]:
        """Estimate cost for extending rental period."""
        # Get transaction
        result = await self.session.execute(
            select(TransactionHeader)
            .where(TransactionHeader.id == transaction_id)
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction:
            raise ValueError(f"Transaction {transaction_id} not found")
        
        original_end_date = current_end_date or transaction.rental_end_date
        if not original_end_date:
            raise ValueError("No end date available for extension calculation")
        
        if new_end_date <= original_end_date:
            raise ValueError("New end date must be after current end date")
        
        # Calculate extension period
        extension_days = (new_end_date - original_end_date).days
        
        # Calculate daily rate
        daily_rate = self._calculate_daily_rental_amount(transaction)
        
        # Calculate extension cost
        extension_cost = daily_rate * extension_days
        
        # Check for extension fees (could be a percentage or flat fee)
        extension_fee_rate = Decimal('0.10')  # 10% fee for extensions
        extension_fee = extension_cost * extension_fee_rate
        
        total_extension_cost = extension_cost + extension_fee
        
        return {
            'original_end_date': original_end_date,
            'new_end_date': new_end_date,
            'extension_days': extension_days,
            'daily_rate': daily_rate,
            'extension_cost': extension_cost,
            'extension_fee_rate': extension_fee_rate,
            'extension_fee': extension_fee,
            'total_extension_cost': total_extension_cost
        }
    
    def _calculate_daily_rental_amount(self, transaction: TransactionHeader) -> Decimal:
        """Calculate daily rental amount from transaction."""
        if not transaction.rental_period or not transaction.rental_period_unit:
            # Fallback: assume total amount is for the entire period
            if transaction.rental_start_date and transaction.rental_end_date:
                total_days = (transaction.rental_end_date - transaction.rental_start_date).days
                return transaction.total_amount / max(1, total_days)
            return transaction.total_amount
        
        # Calculate based on rental period unit
        total_amount = transaction.total_amount
        period = transaction.rental_period
        
        if transaction.rental_period_unit == 'DAY':
            return total_amount / period
        elif transaction.rental_period_unit == 'WEEK':
            return total_amount / (period * 7)
        elif transaction.rental_period_unit == 'MONTH':
            return total_amount / (period * 30)  # Approximate
        elif transaction.rental_period_unit == 'HOUR':
            return total_amount / (period / 24)  # Convert to days
        
        return total_amount
    
    async def _get_late_fee_rate(self, transaction_id: UUID) -> Decimal:
        """Get late fee rate for transaction (could be customer or item specific)."""
        # For now, return default rate
        # In future, could check customer preferences, item categories, etc.
        return self.default_late_fee_rate
    
    async def calculate_partial_return_adjustment(
        self,
        transaction_id: UUID,
        returned_items: list,
        as_of_date: Optional[date] = None
    ) -> Dict[str, Any]:
        """Calculate fee adjustments for partial returns."""
        if not as_of_date:
            as_of_date = date.today()
        
        # Get transaction lines
        result = await self.session.execute(
            select(TransactionLine)
            .where(TransactionLine.transaction_id == transaction_id)
        )
        lines = result.scalars().all()
        
        total_original_value = sum(line.quantity * line.unit_price for line in lines)
        total_returned_value = Decimal('0')
        
        # Calculate returned value
        for returned_item in returned_items:
            line_id = returned_item.get('transaction_line_id')
            quantity = Decimal(str(returned_item.get('quantity', 0)))
            
            line = next((l for l in lines if str(l.id) == str(line_id)), None)
            if line:
                returned_value = quantity * line.unit_price
                total_returned_value += returned_value
        
        # Calculate proportional adjustment
        if total_original_value > 0:
            return_percentage = total_returned_value / total_original_value
            remaining_percentage = Decimal('1') - return_percentage
        else:
            return_percentage = Decimal('0')
            remaining_percentage = Decimal('1')
        
        # Get current fee calculation
        fee_info = await self.calculate_total_rental_fees(transaction_id, as_of_date)
        
        # Adjust fees proportionally for remaining items
        adjusted_late_fees = fee_info['new_late_fees'] * remaining_percentage
        
        return {
            'total_original_value': total_original_value,
            'total_returned_value': total_returned_value,
            'return_percentage': return_percentage,
            'remaining_percentage': remaining_percentage,
            'original_late_fees': fee_info['new_late_fees'],
            'adjusted_late_fees': adjusted_late_fees,
            'late_fee_reduction': fee_info['new_late_fees'] - adjusted_late_fees
        }

===== modules/transactions/services/rental_service.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental service for managing rental lifecycle operations.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime, date
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, and_, or_
from sqlalchemy.orm import selectinload

from app.modules.transactions.base.models import (
    TransactionHeader, 
    TransactionLine,
    TransactionType,
    TransactionStatus,
    RentalStatus,
    RentalLifecycle,
    RentalReturnEvent,
    RentalItemInspection,
    ReturnEventType,
    InspectionCondition
)
from app.modules.transactions.services.rental_status_updater import RentalStatusUpdater
from app.core.errors import NotFoundError, ValidationError, ConflictError
import logging

logger = logging.getLogger(__name__)


class RentalStatusService:
    """Service for managing rental status transitions."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_rental_transaction(self, transaction_id: UUID) -> TransactionHeader:
        """Get rental transaction with validation."""
        result = await self.session.execute(
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.id == transaction_id,
                    TransactionHeader.transaction_type == TransactionType.RENTAL,
                    TransactionHeader.is_active == True
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction:
            raise NotFoundError(f"Rental transaction {transaction_id} not found")
        
        return transaction
    
    async def get_or_create_lifecycle(self, transaction_id: UUID) -> RentalLifecycle:
        """Get existing lifecycle or create new one."""
        # Try to get existing lifecycle
        result = await self.session.execute(
            select(RentalLifecycle)
            .where(RentalLifecycle.transaction_id == transaction_id)
        )
        lifecycle = result.scalar_one_or_none()
        
        if lifecycle:
            return lifecycle
        
        # Create new lifecycle for transaction
        transaction = await self.get_rental_transaction(transaction_id)
        
        lifecycle = RentalLifecycle(
            transaction_id=transaction_id,
            current_status=RentalStatus.ACTIVE.value,
            expected_return_date=transaction.rental_end_date,
            total_returned_quantity=0,
            total_late_fees=0,
            total_damage_fees=0,
            total_other_fees=0
        )
        
        self.session.add(lifecycle)
        await self.session.commit()
        await self.session.refresh(lifecycle)
        
        # Update transaction header status
        await self.session.execute(
            update(TransactionHeader)
            .where(TransactionHeader.id == transaction_id)
            .values(current_rental_status=RentalStatus.ACTIVE.value)
        )
        await self.session.commit()
        
        logger.info(f"Created rental lifecycle for transaction {transaction_id}")
        return lifecycle
    
    async def update_rental_status(
        self, 
        transaction_id: UUID, 
        new_status: RentalStatus, 
        changed_by: Optional[UUID] = None,
        notes: Optional[str] = None
    ) -> RentalLifecycle:
        """Update rental status with validation."""
        lifecycle = await self.get_or_create_lifecycle(transaction_id)
        old_status = lifecycle.current_status
        
        # Validate status transition
        if not self._is_valid_status_transition(old_status, new_status.value):
            raise ValidationError(f"Invalid status transition from {old_status} to {new_status.value}")
        
        # Update lifecycle
        lifecycle.current_status = new_status.value
        lifecycle.last_status_change = datetime.utcnow()
        lifecycle.status_changed_by = changed_by
        if notes:
            lifecycle.notes = notes
        
        # Update transaction header
        await self.session.execute(
            update(TransactionHeader)
            .where(TransactionHeader.id == transaction_id)
            .values(current_rental_status=new_status.value)
        )
        
        await self.session.commit()
        logger.info(f"Updated rental {transaction_id} status from {old_status} to {new_status.value}")
        
        return lifecycle
    
    def _is_valid_status_transition(self, from_status: str, to_status: str) -> bool:
        """Validate if status transition is allowed."""
        valid_transitions = {
            RentalStatus.ACTIVE.value: [
                RentalStatus.LATE.value,
                RentalStatus.EXTENDED.value,
                RentalStatus.PARTIAL_RETURN.value,
                RentalStatus.COMPLETED.value
            ],
            RentalStatus.LATE.value: [
                RentalStatus.EXTENDED.value,
                RentalStatus.LATE_PARTIAL_RETURN.value,
                RentalStatus.COMPLETED.value
            ],
            RentalStatus.EXTENDED.value: [
                RentalStatus.ACTIVE.value,
                RentalStatus.LATE.value,
                RentalStatus.PARTIAL_RETURN.value,
                RentalStatus.COMPLETED.value
            ],
            RentalStatus.PARTIAL_RETURN.value: [
                RentalStatus.LATE_PARTIAL_RETURN.value,
                RentalStatus.COMPLETED.value
            ],
            RentalStatus.LATE_PARTIAL_RETURN.value: [
                RentalStatus.COMPLETED.value
            ],
            RentalStatus.COMPLETED.value: []  # Terminal state
        }
        
        return to_status in valid_transitions.get(from_status, [])
    
    async def auto_update_late_status(self, as_of_date: Optional[date] = None) -> List[UUID]:
        """Automatically update rentals to LATE status based on due date."""
        if not as_of_date:
            as_of_date = date.today()
        
        # Find active rentals past due date
        result = await self.session.execute(
            select(TransactionHeader.id)
            .where(
                and_(
                    TransactionHeader.transaction_type == TransactionType.RENTAL,
                    TransactionHeader.current_rental_status.in_([
                        RentalStatus.ACTIVE.value,
                        RentalStatus.EXTENDED.value
                    ]),
                    TransactionHeader.rental_end_date < as_of_date,
                    TransactionHeader.is_active == True
                )
            )
        )
        
        overdue_ids = [row[0] for row in result.fetchall()]
        
        # Update to LATE status
        for transaction_id in overdue_ids:
            try:
                lifecycle = await self.get_or_create_lifecycle(transaction_id)
                current_status = RentalStatus(lifecycle.current_status)
                
                if current_status == RentalStatus.ACTIVE:
                    await self.update_rental_status(transaction_id, RentalStatus.LATE)
                elif current_status == RentalStatus.EXTENDED:
                    await self.update_rental_status(transaction_id, RentalStatus.LATE)
                elif current_status == RentalStatus.PARTIAL_RETURN:
                    await self.update_rental_status(transaction_id, RentalStatus.LATE_PARTIAL_RETURN)
                    
            except Exception as e:
                logger.error(f"Error updating rental {transaction_id} to late status: {e}")
        
        logger.info(f"Updated {len(overdue_ids)} rentals to late status")
        return overdue_ids


class RentalReturnService:
    """Service for managing rental return operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.status_service = RentalStatusService(session)
        self.status_updater = RentalStatusUpdater(session)
    
    async def initiate_return(
        self,
        transaction_id: UUID,
        return_date: date,
        items_to_return: List[Dict[str, Any]],
        processed_by: Optional[UUID] = None,
        notes: Optional[str] = None
    ) -> RentalReturnEvent:
        """Initiate a return event for rental items."""
        lifecycle = await self.status_service.get_or_create_lifecycle(transaction_id)
        transaction = await self.status_service.get_rental_transaction(transaction_id)
        
        # Validate items to return
        total_quantity = Decimal('0')
        validated_items = []
        
        for item in items_to_return:
            line_id = UUID(item['transaction_line_id'])
            quantity = Decimal(str(item['quantity']))
            
            # Find transaction line
            line = next((l for l in transaction.transaction_lines if l.id == line_id), None)
            if not line:
                raise ValidationError(f"Transaction line {line_id} not found")
            
            # Check available quantity
            available = line.quantity - line.returned_quantity
            if quantity > available:
                raise ValidationError(f"Cannot return {quantity} of item {line.description}, only {available} available")
            
            validated_items.append({
                'transaction_line_id': str(line_id),
                'quantity': float(quantity),
                'item_description': line.description,
                'unit_price': float(line.unit_price)
            })
            total_quantity += quantity
        
        # Create return event
        return_event = RentalReturnEvent(
            rental_lifecycle_id=lifecycle.id,
            event_type=ReturnEventType.PARTIAL_RETURN.value,
            event_date=return_date,
            processed_by=processed_by,
            items_returned=validated_items,
            total_quantity_returned=total_quantity,
            notes=notes
        )
        
        self.session.add(return_event)
        await self.session.commit()
        await self.session.refresh(return_event)
        
        logger.info(f"Initiated return event {return_event.id} for rental {transaction_id}")
        return return_event
    
    async def record_inspection(
        self,
        return_event_id: UUID,
        transaction_line_id: UUID,
        quantity_inspected: Decimal,
        condition: InspectionCondition,
        inspected_by: Optional[UUID] = None,
        damage_details: Optional[Dict[str, Any]] = None
    ) -> RentalItemInspection:
        """Record inspection results for returned items."""
        # Get return event
        result = await self.session.execute(
            select(RentalReturnEvent)
            .where(RentalReturnEvent.id == return_event_id)
            .options(selectinload(RentalReturnEvent.rental_lifecycle))
        )
        return_event = result.scalar_one_or_none()
        
        if not return_event:
            raise NotFoundError(f"Return event {return_event_id} not found")
        
        # Create inspection record
        inspection = RentalItemInspection(
            return_event_id=return_event_id,
            transaction_line_id=transaction_line_id,
            quantity_inspected=quantity_inspected,
            condition=condition.value,
            inspected_by=inspected_by,
            has_damage=damage_details is not None,
            damage_description=damage_details.get('description') if damage_details else None,
            damage_photos=damage_details.get('photos') if damage_details else None,
            damage_fee_assessed=Decimal(str(damage_details.get('damage_fee', 0))) if damage_details else Decimal('0'),
            cleaning_fee_assessed=Decimal(str(damage_details.get('cleaning_fee', 0))) if damage_details else Decimal('0'),
            replacement_required=damage_details.get('replacement_required', False) if damage_details else False,
            replacement_cost=Decimal(str(damage_details.get('replacement_cost', 0))) if damage_details and damage_details.get('replacement_cost') else None,
            return_to_stock=not (damage_details and damage_details.get('replacement_required', False)),
            inspection_notes=damage_details.get('notes') if damage_details else None
        )
        
        self.session.add(inspection)
        
        # Update return event with fees
        if damage_details:
            return_event.damage_fees_charged += inspection.damage_fee_assessed + inspection.cleaning_fee_assessed
            if inspection.replacement_cost:
                return_event.other_fees_charged += inspection.replacement_cost
        
        await self.session.commit()
        await self.session.refresh(inspection)
        
        logger.info(f"Recorded inspection for return event {return_event_id}, line {transaction_line_id}")
        return inspection
    
    async def complete_return(
        self,
        return_event_id: UUID,
        payment_collected: Decimal = Decimal('0'),
        refund_issued: Decimal = Decimal('0'),
        receipt_number: Optional[str] = None,
        notes: Optional[str] = None
    ) -> RentalReturnEvent:
        """Complete a return event with payment processing."""
        # Get return event with inspections
        result = await self.session.execute(
            select(RentalReturnEvent)
            .where(RentalReturnEvent.id == return_event_id)
            .options(
                selectinload(RentalReturnEvent.rental_lifecycle),
            )
        )
        return_event = result.scalar_one_or_none()
        
        if not return_event:
            raise NotFoundError(f"Return event {return_event_id} not found")
        
        lifecycle = return_event.rental_lifecycle
        
        # Get transaction with lines for total quantity calculation
        transaction = await self.status_service.get_rental_transaction(lifecycle.transaction_id)
        
        # Update return event with payment info
        return_event.payment_collected = payment_collected
        return_event.refund_issued = refund_issued
        return_event.receipt_number = receipt_number
        if notes:
            return_event.notes = notes
        
        # Update lifecycle totals
        lifecycle.total_returned_quantity += return_event.total_quantity_returned
        lifecycle.total_damage_fees += return_event.damage_fees_charged
        lifecycle.total_late_fees += return_event.late_fees_charged
        lifecycle.total_other_fees += return_event.other_fees_charged
        
        # Update transaction line returned quantities
        if return_event.items_returned:
            for item in return_event.items_returned:
                line_id = UUID(item['transaction_line_id'])
                quantity = Decimal(str(item['quantity']))
                
                await self.session.execute(
                    update(TransactionLine)
                    .where(TransactionLine.id == line_id)
                    .values(
                        returned_quantity=TransactionLine.returned_quantity + quantity,
                        return_date=return_event.event_date
                    )
                )
        
        # Update rental status based on return event
        total_quantity = sum(line.quantity for line in transaction.transaction_lines)
        
        if lifecycle.total_returned_quantity >= total_quantity:
            # All items returned - mark event as full return
            return_event.event_type = ReturnEventType.FULL_RETURN.value
        
        # Use the status updater to recalculate and update status
        await self.status_updater.update_status_from_return_event(
            transaction_id=lifecycle.transaction_id,
            return_event_id=return_event.id,
            changed_by=return_event.processed_by,
            notes=f"Status updated after processing return event"
        )
        
        await self.session.commit()
        logger.info(f"Completed return event {return_event_id}")
        
        return return_event
    
    async def extend_rental(
        self,
        transaction_id: UUID,
        new_end_date: date,
        reason: str,
        processed_by: Optional[UUID] = None,
        notes: Optional[str] = None
    ) -> RentalReturnEvent:
        """Extend rental period."""
        lifecycle = await self.status_service.get_or_create_lifecycle(transaction_id)
        
        # Create extension event
        extension_event = RentalReturnEvent(
            rental_lifecycle_id=lifecycle.id,
            event_type=ReturnEventType.EXTENSION.value,
            event_date=date.today(),
            processed_by=processed_by,
            new_return_date=new_end_date,
            extension_reason=reason,
            notes=notes
        )
        
        self.session.add(extension_event)
        
        # Update lifecycle and transaction
        lifecycle.expected_return_date = new_end_date
        
        await self.session.execute(
            update(TransactionHeader)
            .where(TransactionHeader.id == transaction_id)
            .values(rental_end_date=new_end_date)
        )
        
        # Update status to EXTENDED
        await self.status_service.update_rental_status(
            transaction_id, 
            RentalStatus.EXTENDED,
            changed_by=processed_by
        )
        
        await self.session.commit()
        logger.info(f"Extended rental {transaction_id} to {new_end_date}")
        
        return extension_event


class RentalService:
    """Main rental service combining all rental operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.status_service = RentalStatusService(session)
        self.return_service = RentalReturnService(session)
        self.status_updater = RentalStatusUpdater(session)
    
    async def get_active_rentals(
        self, 
        customer_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        overdue_only: bool = False
    ) -> List[TransactionHeader]:
        """Get list of active rentals with filters."""
        query = select(TransactionHeader).where(
            and_(
                TransactionHeader.transaction_type == TransactionType.RENTAL,
                TransactionHeader.current_rental_status.in_([
                    RentalStatus.ACTIVE.value,
                    RentalStatus.LATE.value,
                    RentalStatus.EXTENDED.value,
                    RentalStatus.PARTIAL_RETURN.value,
                    RentalStatus.LATE_PARTIAL_RETURN.value
                ]),
                TransactionHeader.is_active == True
            )
        ).options(selectinload(TransactionHeader.transaction_lines))
        
        if customer_id:
            query = query.where(TransactionHeader.customer_id == str(customer_id))
        
        if location_id:
            query = query.where(TransactionHeader.location_id == str(location_id))
        
        if overdue_only:
            query = query.where(TransactionHeader.rental_end_date < date.today())
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_rental_details(self, transaction_id: UUID) -> Dict[str, Any]:
        """Get comprehensive rental details."""
        transaction = await self.status_service.get_rental_transaction(transaction_id)
        lifecycle = await self.status_service.get_or_create_lifecycle(transaction_id)
        
        # Get return events
        result = await self.session.execute(
            select(RentalReturnEvent)
            .where(RentalReturnEvent.rental_lifecycle_id == lifecycle.id)
            .order_by(RentalReturnEvent.event_date.desc())
        )
        return_events = result.scalars().all()
        
        return {
            'transaction': transaction,
            'lifecycle': lifecycle,
            'return_events': return_events,
            'total_fees': lifecycle.total_fees,
            'is_overdue': transaction.rental_end_date < date.today() if transaction.rental_end_date else False
        }

===== modules/transactions/services/rental_status_calculator.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental Status Calculation Service

Implements the exact business rules defined in the PRD for calculating
rental transaction status at both header and line item levels.
"""

from typing import List, Dict, Any, Optional, Tuple
from uuid import UUID
from datetime import datetime, date
from decimal import Decimal
from enum import Enum as PyEnum
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_
from sqlalchemy.orm import selectinload

from app.modules.transactions.base.models import (
    TransactionHeader, 
    TransactionLine,
    TransactionType,
    RentalStatus,
    RentalLifecycle,
    RentalStatusLog,
    RentalStatusChangeReason
)
from app.core.errors import NotFoundError, ValidationError
import logging

logger = logging.getLogger(__name__)


class LineItemStatus(PyEnum):
    """Line item rental status as defined in PRD."""
    ACTIVE = "ACTIVE"
    LATE = "LATE"
    LATE_PARTIAL_RETURN = "LATE_PARTIAL_RETURN"
    PARTIAL_RETURN = "PARTIAL_RETURN"
    RETURNED = "RETURNED"


class HeaderStatus(PyEnum):
    """Header rental status as defined in PRD."""
    ACTIVE = "ACTIVE"
    LATE = "LATE"
    LATE_PARTIAL_RETURN = "LATE_PARTIAL_RETURN"
    PARTIAL_RETURN = "PARTIAL_RETURN"
    RETURNED = "RETURNED"


class RentalStatusCalculator:
    """
    Service for calculating rental status according to PRD business rules.
    
    This service implements the exact status calculation logic defined in the PRD:
    
    Line Item Status Rules:
    1. Active: Item with correct quantity is within return time frame AND no returns made yet
    2. Late: Item is past the return period
    3. Late - Partial Return: Some quantity returned AND item return time has passed
    4. Partial Return: Item is within return time frame AND item is not fully returned yet
    5. Returned: Item is returned within the return time frame
    
    Header Status Rules:
    1. Active: All items within return time frame AND no returns made yet
    2. Late: Some or all items are past the return period
    3. Late - Partial Return: Some items returned AND some or all items are late for return
    4. Partial Return: All items within return time frame AND some items returned
    5. Returned: All items are returned
    """
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def calculate_line_item_status(
        self, 
        line: TransactionLine, 
        as_of_date: Optional[date] = None
    ) -> LineItemStatus:
        """
        Calculate the status of a single rental line item according to PRD rules.
        
        Args:
            line: The transaction line to evaluate
            as_of_date: Date to calculate status as of (defaults to today)
            
        Returns:
            LineItemStatus enum value
        """
        if not as_of_date:
            as_of_date = date.today()
        
        # Get rental dates from the line
        rental_end_date = line.rental_end_date
        if not rental_end_date:
            # If no rental end date, treat as active
            return LineItemStatus.ACTIVE
        
        # Check if item is past return period
        is_past_return_period = rental_end_date < as_of_date
        
        # Check return status
        total_quantity = line.quantity
        returned_quantity = line.returned_quantity or Decimal('0')
        has_returns = returned_quantity > 0
        is_fully_returned = returned_quantity >= total_quantity
        
        # Apply PRD business rules
        if is_fully_returned:
            # Rule 5: Returned - Item is fully returned
            return LineItemStatus.RETURNED
        elif has_returns and is_past_return_period:
            # Rule 3: Late - Partial Return - Some quantity returned AND past return time
            return LineItemStatus.LATE_PARTIAL_RETURN
        elif has_returns and not is_past_return_period:
            # Rule 4: Partial Return - Item is within time frame AND not fully returned
            return LineItemStatus.PARTIAL_RETURN
        elif is_past_return_period:
            # Rule 2: Late - Item is past the return period
            return LineItemStatus.LATE
        else:
            # Rule 1: Active - Within time frame AND no returns made yet
            return LineItemStatus.ACTIVE
    
    async def calculate_header_status(
        self, 
        transaction: TransactionHeader, 
        as_of_date: Optional[date] = None
    ) -> HeaderStatus:
        """
        Calculate the status of a rental transaction header according to PRD rules.
        
        Args:
            transaction: The transaction header to evaluate
            as_of_date: Date to calculate status as of (defaults to today)
            
        Returns:
            HeaderStatus enum value
        """
        if not as_of_date:
            as_of_date = date.today()
        
        # Ensure we have transaction lines loaded
        if not transaction.transaction_lines:
            result = await self.session.execute(
                select(TransactionHeader)
                .where(TransactionHeader.id == transaction.id)
                .options(selectinload(TransactionHeader.transaction_lines))
            )
            transaction = result.scalar_one_or_none()
            if not transaction:
                raise NotFoundError(f"Transaction {transaction.id} not found")
        
        # Calculate status for each line item
        line_statuses = []
        for line in transaction.transaction_lines:
            line_status = await self.calculate_line_item_status(line, as_of_date)
            line_statuses.append(line_status)
        
        if not line_statuses:
            # No lines, default to active
            return HeaderStatus.ACTIVE
        
        # Count status types
        status_counts = {
            LineItemStatus.ACTIVE: 0,
            LineItemStatus.LATE: 0,
            LineItemStatus.LATE_PARTIAL_RETURN: 0,
            LineItemStatus.PARTIAL_RETURN: 0,
            LineItemStatus.RETURNED: 0
        }
        
        for status in line_statuses:
            status_counts[status] += 1
        
        total_lines = len(line_statuses)
        has_late_items = status_counts[LineItemStatus.LATE] > 0 or status_counts[LineItemStatus.LATE_PARTIAL_RETURN] > 0
        has_returned_items = status_counts[LineItemStatus.RETURNED] > 0 or status_counts[LineItemStatus.PARTIAL_RETURN] > 0 or status_counts[LineItemStatus.LATE_PARTIAL_RETURN] > 0
        all_returned = status_counts[LineItemStatus.RETURNED] == total_lines
        
        # Apply PRD business rules for header status
        if all_returned:
            # Rule 5: Returned - All items are returned
            return HeaderStatus.RETURNED
        elif has_late_items and has_returned_items:
            # Rule 3: Late - Partial Return - Some items returned AND some or all items are late
            return HeaderStatus.LATE_PARTIAL_RETURN
        elif has_late_items:
            # Rule 2: Late - Some or all items are past the return period
            return HeaderStatus.LATE
        elif has_returned_items:
            # Rule 4: Partial Return - All items within time frame AND some items returned
            return HeaderStatus.PARTIAL_RETURN
        else:
            # Rule 1: Active - All items within time frame AND no returns made yet
            return HeaderStatus.ACTIVE
    
    async def calculate_transaction_status(
        self, 
        transaction_id: UUID, 
        as_of_date: Optional[date] = None
    ) -> Dict[str, Any]:
        """
        Calculate comprehensive status for a rental transaction.
        
        Args:
            transaction_id: ID of the transaction to evaluate
            as_of_date: Date to calculate status as of (defaults to today)
            
        Returns:
            Dictionary containing header status, line statuses, and metadata
        """
        if not as_of_date:
            as_of_date = date.today()
        
        # Get transaction with lines
        result = await self.session.execute(
            select(TransactionHeader)
            .where(
                and_(
                    TransactionHeader.id == transaction_id,
                    TransactionHeader.transaction_type == TransactionType.RENTAL,
                    TransactionHeader.is_active == True
                )
            )
            .options(selectinload(TransactionHeader.transaction_lines))
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction:
            raise NotFoundError(f"Rental transaction {transaction_id} not found")
        
        # Calculate header status
        header_status = await self.calculate_header_status(transaction, as_of_date)
        
        # Calculate line statuses
        line_statuses = []
        for line in transaction.transaction_lines:
            line_status = await self.calculate_line_item_status(line, as_of_date)
            line_statuses.append({
                'line_id': line.id,
                'sku': line.sku,
                'description': line.description,
                'status': line_status.value,
                'quantity': float(line.quantity),
                'returned_quantity': float(line.returned_quantity or 0),
                'rental_start_date': line.rental_start_date.isoformat() if line.rental_start_date else None,
                'rental_end_date': line.rental_end_date.isoformat() if line.rental_end_date else None,
                'days_overdue': (as_of_date - line.rental_end_date).days if line.rental_end_date and line.rental_end_date < as_of_date else 0
            })
        
        # Calculate summary statistics
        total_quantity = sum(line.quantity for line in transaction.transaction_lines)
        total_returned = sum(line.returned_quantity or 0 for line in transaction.transaction_lines)
        return_percentage = (float(total_returned) / float(total_quantity) * 100) if total_quantity > 0 else 0
        
        overdue_lines = [ls for ls in line_statuses if ls['days_overdue'] > 0]
        max_overdue_days = max((ls['days_overdue'] for ls in overdue_lines), default=0)
        
        return {
            'transaction_id': transaction_id,
            'header_status': header_status.value,
            'line_statuses': line_statuses,
            'calculated_as_of': as_of_date.isoformat(),
            'summary': {
                'total_lines': len(line_statuses),
                'total_quantity': float(total_quantity),
                'total_returned_quantity': float(total_returned),
                'return_percentage': round(return_percentage, 2),
                'overdue_lines_count': len(overdue_lines),
                'max_overdue_days': max_overdue_days,
                'expected_return_date': transaction.rental_end_date.isoformat() if transaction.rental_end_date else None
            }
        }
    
    async def find_status_changes_needed(
        self, 
        transaction_ids: Optional[List[UUID]] = None,
        as_of_date: Optional[date] = None
    ) -> List[Dict[str, Any]]:
        """
        Find all rental transactions that need status updates.
        
        Args:
            transaction_ids: Specific transaction IDs to check (None = check all active rentals)
            as_of_date: Date to calculate status as of (defaults to today)
            
        Returns:
            List of transactions with current vs calculated status differences
        """
        if not as_of_date:
            as_of_date = date.today()
        
        # Build query for rental transactions
        query = select(TransactionHeader).where(
            and_(
                TransactionHeader.transaction_type == TransactionType.RENTAL,
                TransactionHeader.current_rental_status.in_([
                    RentalStatus.ACTIVE.value,
                    RentalStatus.LATE.value,
                    RentalStatus.EXTENDED.value,
                    RentalStatus.PARTIAL_RETURN.value,
                    RentalStatus.LATE_PARTIAL_RETURN.value
                ]),
                TransactionHeader.is_active == True
            )
        ).options(selectinload(TransactionHeader.transaction_lines))
        
        if transaction_ids:
            query = query.where(TransactionHeader.id.in_(transaction_ids))
        
        result = await self.session.execute(query)
        transactions = result.scalars().all()
        
        changes_needed = []
        
        for transaction in transactions:
            try:
                # Calculate what the status should be
                calculated_status = await self.calculate_header_status(transaction, as_of_date)
                current_status = transaction.current_rental_status
                
                # Check if status change is needed
                if current_status != calculated_status.value:
                    status_data = await self.calculate_transaction_status(transaction.id, as_of_date)
                    
                    changes_needed.append({
                        'transaction_id': transaction.id,
                        'current_status': current_status,
                        'calculated_status': calculated_status.value,
                        'status_data': status_data,
                        'priority': self._get_change_priority(current_status, calculated_status.value),
                        'reason': self._get_change_reason(current_status, calculated_status.value)
                    })
                    
            except Exception as e:
                logger.error(f"Error calculating status for transaction {transaction.id}: {e}")
                continue
        
        # Sort by priority (high priority changes first)
        changes_needed.sort(key=lambda x: x['priority'], reverse=True)
        
        logger.info(f"Found {len(changes_needed)} transactions needing status updates")
        return changes_needed
    
    def _get_change_priority(self, current_status: str, new_status: str) -> int:
        """Get priority for status change (higher number = higher priority)."""
        # High priority: becoming overdue
        if current_status in ['ACTIVE', 'PARTIAL_RETURN'] and new_status in ['LATE', 'LATE_PARTIAL_RETURN']:
            return 10
        
        # Medium priority: return-related changes
        if 'RETURN' in new_status:
            return 5
        
        # Low priority: other changes
        return 1
    
    def _get_change_reason(self, current_status: str, new_status: str) -> str:
        """Get human-readable reason for status change."""
        if current_status in ['ACTIVE', 'PARTIAL_RETURN'] and new_status in ['LATE', 'LATE_PARTIAL_RETURN']:
            return "Items are now past due date"
        elif 'PARTIAL_RETURN' in new_status and 'PARTIAL_RETURN' not in current_status:
            return "Some items have been returned"
        elif new_status == 'RETURNED':
            return "All items have been returned"
        else:
            return f"Status changed from {current_status} to {new_status}"

===== modules/transactions/services/rental_status_updater.py â€“ 2025-07-19 12:13:41 IST =====
"""
Rental Status Update Service

Centralized service for updating rental statuses with comprehensive logging
and audit trails. Integrates with the status calculator to apply changes.
"""

from typing import List, Dict, Any, Optional, Tuple
from uuid import UUID, uuid4
from datetime import datetime, date
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, and_, or_
from sqlalchemy.orm import selectinload

from app.modules.transactions.base.models import (
    TransactionHeader, 
    TransactionLine,
    TransactionType,
    RentalStatus,
    RentalLifecycle,
    RentalStatusLog,
    RentalStatusChangeReason
)
from app.modules.transactions.services.rental_status_calculator import (
    RentalStatusCalculator,
    HeaderStatus,
    LineItemStatus
)
from app.core.errors import NotFoundError, ValidationError
import logging

logger = logging.getLogger(__name__)


class RentalStatusUpdater:
    """
    Service for updating rental statuses with comprehensive logging.
    
    This service provides centralized status update functionality that:
    - Uses the status calculator to determine correct statuses
    - Updates both transaction headers and rental lifecycles
    - Creates detailed audit logs of all changes
    - Supports both individual and batch updates
    - Integrates with return events and scheduled tasks
    """
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.calculator = RentalStatusCalculator(session)
    
    async def update_transaction_status(
        self,
        transaction_id: UUID,
        changed_by: Optional[UUID] = None,
        change_reason: RentalStatusChangeReason = RentalStatusChangeReason.MANUAL_UPDATE,
        change_trigger: Optional[str] = None,
        notes: Optional[str] = None,
        as_of_date: Optional[date] = None,
        batch_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Update the status of a rental transaction and log the changes.
        
        Args:
            transaction_id: ID of the transaction to update
            changed_by: User ID making the change (None for system changes)
            change_reason: Reason for the status change
            change_trigger: What triggered the change (event ID, job name, etc.)
            notes: Additional notes about the change
            as_of_date: Date to calculate status as of (defaults to today)
            batch_id: Batch ID for scheduled updates
            
        Returns:
            Dictionary with update results and change details
        """
        if not as_of_date:
            as_of_date = date.today()
        
        # Calculate current status
        status_data = await self.calculator.calculate_transaction_status(transaction_id, as_of_date)
        new_header_status = status_data['header_status']
        
        # Get current transaction
        result = await self.session.execute(
            select(TransactionHeader)
            .where(TransactionHeader.id == transaction_id)
            .options(selectinload(TransactionHeader.transaction_lines))
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction:
            raise NotFoundError(f"Transaction {transaction_id} not found")
        
        old_header_status = transaction.current_rental_status
        header_changed = old_header_status != new_header_status
        
        changes_made = []
        
        # Update header status if needed
        if header_changed:
            # Update transaction header
            await self.session.execute(
                update(TransactionHeader)
                .where(TransactionHeader.id == transaction_id)
                .values(current_rental_status=new_header_status)
            )
            
            # Update rental lifecycle if exists
            lifecycle_result = await self.session.execute(
                select(RentalLifecycle)
                .where(RentalLifecycle.transaction_id == transaction_id)
            )
            lifecycle = lifecycle_result.scalar_one_or_none()
            
            if lifecycle:
                lifecycle.current_status = new_header_status
                lifecycle.last_status_change = datetime.utcnow()
                lifecycle.status_changed_by = changed_by
            
            # Log header status change
            header_log = await self._create_status_log(
                transaction_id=transaction_id,
                old_status=old_header_status,
                new_status=new_header_status,
                change_reason=change_reason,
                change_trigger=change_trigger,
                changed_by=changed_by,
                notes=notes,
                status_metadata={
                    'summary': status_data['summary'],
                    'as_of_date': as_of_date.isoformat()
                },
                batch_id=batch_id,
                system_generated=changed_by is None
            )
            
            changes_made.append({
                'type': 'header',
                'old_status': old_header_status,
                'new_status': new_header_status,
                'log_id': header_log.id
            })
        
        # Update line item statuses
        for line_data in status_data['line_statuses']:
            line_id = UUID(line_data['line_id'])
            new_line_status = line_data['status']
            
            # Get current line status
            line_result = await self.session.execute(
                select(TransactionLine)
                .where(TransactionLine.id == line_id)
            )
            line = line_result.scalar_one_or_none()
            
            if line:
                old_line_status = line.current_rental_status
                line_changed = old_line_status != new_line_status
                
                if line_changed:
                    # Update line status
                    line.current_rental_status = new_line_status
                    
                    # Log line status change
                    line_log = await self._create_status_log(
                        transaction_id=transaction_id,
                        transaction_line_id=line_id,
                        old_status=old_line_status,
                        new_status=new_line_status,
                        change_reason=change_reason,
                        change_trigger=change_trigger,
                        changed_by=changed_by,
                        notes=f"Line item: {line_data['description']}",
                        status_metadata={
                            'line_data': line_data,
                            'as_of_date': as_of_date.isoformat()
                        },
                        batch_id=batch_id,
                        system_generated=changed_by is None
                    )
                    
                    changes_made.append({
                        'type': 'line',
                        'line_id': line_id,
                        'sku': line_data['sku'],
                        'description': line_data['description'],
                        'old_status': old_line_status,
                        'new_status': new_line_status,
                        'log_id': line_log.id
                    })
        
        # Commit all changes
        await self.session.commit()
        
        result = {
            'transaction_id': transaction_id,
            'header_status_changed': header_changed,
            'changes_made': changes_made,
            'total_changes': len(changes_made),
            'status_data': status_data,
            'updated_at': datetime.utcnow().isoformat()
        }
        
        if changes_made:
            logger.info(f"Updated status for transaction {transaction_id}: {len(changes_made)} changes made")
        
        return result
    
    async def batch_update_overdue_statuses(
        self,
        transaction_ids: Optional[List[UUID]] = None,
        changed_by: Optional[UUID] = None,
        as_of_date: Optional[date] = None
    ) -> Dict[str, Any]:
        """
        Batch update rental statuses for overdue transactions.
        
        Args:
            transaction_ids: Specific transactions to update (None = all active rentals)
            changed_by: User ID making the change (None for system changes)
            as_of_date: Date to calculate status as of (defaults to today)
            
        Returns:
            Summary of batch update results
        """
        if not as_of_date:
            as_of_date = date.today()
        
        batch_id = f"batch_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{str(uuid4())[:8]}"
        
        # Find transactions needing status updates
        changes_needed = await self.calculator.find_status_changes_needed(
            transaction_ids=transaction_ids,
            as_of_date=as_of_date
        )
        
        results = {
            'batch_id': batch_id,
            'started_at': datetime.utcnow().isoformat(),
            'as_of_date': as_of_date.isoformat(),
            'total_checked': len(changes_needed) if transaction_ids is None else len(transaction_ids or []),
            'updates_needed': len(changes_needed),
            'successful_updates': 0,
            'failed_updates': 0,
            'transaction_results': [],
            'summary': {
                'status_changes': {},
                'priority_breakdown': {}
            }
        }
        
        # Process each transaction needing updates
        for change in changes_needed:
            try:
                update_result = await self.update_transaction_status(
                    transaction_id=change['transaction_id'],
                    changed_by=changed_by,
                    change_reason=RentalStatusChangeReason.SCHEDULED_UPDATE,
                    change_trigger=f"batch_update_{batch_id}",
                    notes=change['reason'],
                    as_of_date=as_of_date,
                    batch_id=batch_id
                )
                
                results['successful_updates'] += 1
                results['transaction_results'].append({
                    'transaction_id': change['transaction_id'],
                    'status': 'success',
                    'old_status': change['current_status'],
                    'new_status': change['calculated_status'],
                    'changes_made': update_result['total_changes']
                })
                
                # Track status changes for summary
                status_change_key = f"{change['current_status']} -> {change['calculated_status']}"
                results['summary']['status_changes'][status_change_key] = results['summary']['status_changes'].get(status_change_key, 0) + 1
                
                # Track priority breakdown
                priority = change['priority']
                results['summary']['priority_breakdown'][priority] = results['summary']['priority_breakdown'].get(priority, 0) + 1
                
            except Exception as e:
                results['failed_updates'] += 1
                results['transaction_results'].append({
                    'transaction_id': change['transaction_id'],
                    'status': 'error',
                    'error_message': str(e)
                })
                logger.error(f"Failed to update status for transaction {change['transaction_id']}: {e}")
        
        results['completed_at'] = datetime.utcnow().isoformat()
        
        logger.info(f"Batch update {batch_id} completed: {results['successful_updates']} successful, {results['failed_updates']} failed")
        
        return results
    
    async def update_status_from_return_event(
        self,
        transaction_id: UUID,
        return_event_id: UUID,
        changed_by: Optional[UUID] = None,
        notes: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Update rental status based on a return event.
        
        Args:
            transaction_id: ID of the rental transaction
            return_event_id: ID of the return event that triggered the update
            changed_by: User who processed the return
            notes: Additional notes about the return
            
        Returns:
            Status update results
        """
        return await self.update_transaction_status(
            transaction_id=transaction_id,
            changed_by=changed_by,
            change_reason=RentalStatusChangeReason.RETURN_EVENT,
            change_trigger=f"return_event_{return_event_id}",
            notes=notes or "Status updated due to return event"
        )
    
    async def get_status_history(
        self,
        transaction_id: UUID,
        line_id: Optional[UUID] = None,
        limit: int = 50
    ) -> List[Dict[str, Any]]:
        """
        Get status change history for a transaction or line item.
        
        Args:
            transaction_id: Transaction ID to get history for
            line_id: Specific line ID (None for header history)
            limit: Maximum number of records to return
            
        Returns:
            List of status change records
        """
        query = select(RentalStatusLog).where(
            RentalStatusLog.transaction_id == transaction_id
        )
        
        if line_id:
            query = query.where(RentalStatusLog.transaction_line_id == line_id)
        else:
            query = query.where(RentalStatusLog.transaction_line_id.is_(None))
        
        query = query.order_by(RentalStatusLog.changed_at.desc()).limit(limit)
        
        result = await self.session.execute(query)
        logs = result.scalars().all()
        
        return [
            {
                'id': log.id,
                'old_status': log.old_status,
                'new_status': log.new_status,
                'change_reason': log.change_reason,
                'change_trigger': log.change_trigger,
                'changed_by': log.changed_by,
                'changed_at': log.changed_at.isoformat(),
                'notes': log.notes,
                'metadata': log.status_metadata,
                'system_generated': log.system_generated,
                'batch_id': log.batch_id
            }
            for log in logs
        ]
    
    async def _create_status_log(
        self,
        transaction_id: UUID,
        new_status: str,
        change_reason: RentalStatusChangeReason,
        transaction_line_id: Optional[UUID] = None,
        old_status: Optional[str] = None,
        change_trigger: Optional[str] = None,
        changed_by: Optional[UUID] = None,
        notes: Optional[str] = None,
        status_metadata: Optional[Dict[str, Any]] = None,
        batch_id: Optional[str] = None,
        system_generated: bool = False
    ) -> RentalStatusLog:
        """Create a status change log entry."""
        log_entry = RentalStatusLog(
            transaction_id=transaction_id,
            transaction_line_id=transaction_line_id,
            old_status=old_status,
            new_status=new_status,
            change_reason=change_reason.value,
            change_trigger=change_trigger,
            changed_by=changed_by,
            notes=notes,
            status_metadata=status_metadata,
            system_generated=system_generated,
            batch_id=batch_id
        )
        
        self.session.add(log_entry)
        await self.session.flush()  # Get the ID without committing
        
        return log_entry

===== modules/transactions/services/return_processors.py â€“ 2025-07-19 12:13:41 IST =====
"""
Return processors implementing strategy pattern for type-specific return handling.
"""
from abc import ABC, abstractmethod
from typing import List, Dict, Optional, Any
from decimal import Decimal
from datetime import datetime, date
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession

from app.modules.transactions.base.models import TransactionHeader, TransactionLine
from app.modules.transactions.schemas.returns import (
    ReturnTransactionCreate,
    SaleReturnCreate,
    PurchaseReturnCreate,
    SaleReturnLineItem,
    PurchaseReturnLineItem,
)
from app.modules.transactions.rental_returns.schemas import (
    RentalReturnCreate,
    RentalReturnLineItem
)
from app.core.errors import ValidationError


class ReturnProcessor(ABC):
    """Abstract base class for return processors."""
    
    def __init__(self, transaction_service, inventory_service, session: AsyncSession):
        self.transaction_service = transaction_service
        self.inventory_service = inventory_service
        self.session = session
    
    @abstractmethod
    async def validate_return(
        self, 
        original_txn: TransactionHeader, 
        return_data: ReturnTransactionCreate
    ) -> List[str]:
        """
        Validate return based on type-specific rules.
        Returns list of validation errors.
        """
        pass
    
    @abstractmethod
    async def process_inventory(
        self, 
        return_txn: TransactionHeader, 
        return_data: ReturnTransactionCreate
    ) -> None:
        """Process inventory changes for the return."""
        pass
    
    @abstractmethod
    async def calculate_financials(
        self, 
        original_txn: TransactionHeader, 
        return_data: ReturnTransactionCreate
    ) -> Dict[str, Decimal]:
        """Calculate refunds, fees, etc."""
        pass
    
    @abstractmethod
    async def post_process(
        self, 
        return_txn: TransactionHeader, 
        return_data: ReturnTransactionCreate
    ) -> None:
        """Any post-processing steps specific to return type."""
        pass
    
    def _find_line(self, transaction: TransactionHeader, line_id: UUID) -> Optional[TransactionLine]:
        """Find a transaction line by ID."""
        return next(
            (line for line in transaction.transaction_lines if str(line.id) == str(line_id)),
            None
        )
    
    async def _validate_common_rules(
        self, 
        original_txn: TransactionHeader, 
        return_data: ReturnTransactionCreate
    ) -> List[str]:
        """Common validation rules for all return types."""
        errors = []
        
        # Check if all return line items reference valid original lines
        for item in return_data.return_items:
            original_line = self._find_line(original_txn, item.original_line_id)
            if not original_line:
                errors.append(f"Original line {item.original_line_id} not found in transaction")
                continue
            
            # Check if quantity is valid
            already_returned = original_line.returned_quantity or Decimal("0")
            if item.return_quantity > (original_line.quantity - already_returned):
                errors.append(
                    f"Cannot return {item.return_quantity} for line {item.original_line_id}. "
                    f"Original: {original_line.quantity}, Already returned: {already_returned}"
                )
        
        return errors


class SaleReturnProcessor(ReturnProcessor):
    """Processes sale returns."""
    
    async def validate_return(
        self, 
        original_txn: TransactionHeader, 
        return_data: SaleReturnCreate
    ) -> List[str]:
        """Validate sale return specific rules."""
        errors = await self._validate_common_rules(original_txn, return_data)
        
        # Check return window (30 days by default)
        days_since_sale = (datetime.now() - original_txn.transaction_date).days
        if days_since_sale > 30:
            errors.append(f"Return period expired. Sale was {days_since_sale} days ago (max: 30)")
        
        # Check if transaction is completed
        if original_txn.status != "COMPLETED":
            errors.append("Can only return completed sales")
        
        # Validate item conditions for refund method
        for item in return_data.return_items:
            if return_data.refund_method == "ORIGINAL_PAYMENT":
                if item.condition == "DAMAGED":
                    errors.append("Damaged items cannot be refunded to original payment")
                if not item.original_packaging:
                    errors.append("Original packaging required for full refund")
        
        # Validate exchange transaction
        if return_data.refund_method == "EXCHANGE" and not return_data.exchange_transaction_id:
            errors.append("Exchange transaction ID required for exchange returns")
        
        return errors
    
    async def process_inventory(
        self, 
        return_txn: TransactionHeader, 
        return_data: SaleReturnCreate
    ) -> None:
        """Add items back to stock based on condition."""
        for idx, item in enumerate(return_data.return_items):
            if not item.return_to_stock:
                continue
            
            line = return_txn.transaction_lines[idx]
            
            # Determine stock status based on condition
            if item.condition in ["NEW", "OPENED"]:
                stock_status = "AVAILABLE"
            elif item.condition == "USED":
                stock_status = "AVAILABLE_USED"
            else:  # DAMAGED
                stock_status = "REQUIRES_INSPECTION"
            
            # Adjust stock level
            await self.inventory_service.adjust_stock_level(
                item_id=line.item_id,
                location_id=return_data.restock_location_id or return_txn.location_id,
                quantity_change=abs(line.quantity),  # Make positive
                transaction_type="SALE_RETURN",
                reference_id=str(return_txn.id),
                notes=f"Sale return - Condition: {item.condition}, Status: {stock_status}"
            )
    
    async def calculate_financials(
        self, 
        original_txn: TransactionHeader, 
        return_data: SaleReturnCreate
    ) -> Dict[str, Decimal]:
        """Calculate refund amount minus any fees."""
        financials = {
            'subtotal': Decimal("0"),
            'restocking_fee': Decimal("0"),
            'shipping_deduction': Decimal("0"),
            'net_refund': Decimal("0")
        }
        
        # Calculate base refund amount
        for item in return_data.return_items:
            original_line = self._find_line(original_txn, item.original_line_id)
            if not original_line:
                continue
            
            # Calculate item refund based on condition
            item_refund = original_line.unit_price * item.return_quantity
            
            # Apply condition-based deductions
            if item.condition == "OPENED":
                item_refund *= Decimal("0.95")  # 5% deduction
            elif item.condition == "USED":
                item_refund *= Decimal("0.80")  # 20% deduction
            elif item.condition == "DAMAGED":
                item_refund *= Decimal("0.50")  # 50% deduction
            
            financials['subtotal'] += item_refund
        
        # Apply restocking fee if not all items have original packaging
        if not all(item.original_packaging for item in return_data.return_items):
            financials['restocking_fee'] = financials['subtotal'] * Decimal("0.15")  # 15% fee
        
        # Return shipping cost
        if return_data.customer_pays_shipping and return_data.return_shipping_cost:
            financials['shipping_deduction'] = return_data.return_shipping_cost
        
        # Calculate net refund
        financials['net_refund'] = (
            financials['subtotal'] - 
            financials['restocking_fee'] - 
            financials['shipping_deduction']
        )
        
        # Store the refund method for reference
        financials['refund_method'] = return_data.refund_method
        
        return financials
    
    async def post_process(
        self, 
        return_txn: TransactionHeader, 
        return_data: SaleReturnCreate
    ) -> None:
        """Handle post-processing for sale returns."""
        # Link exchange transaction if applicable
        if return_data.refund_method == "EXCHANGE" and return_data.exchange_transaction_id:
            # Update the exchange transaction to reference this return
            exchange_txn = await self.transaction_service.get_by_id(
                return_data.exchange_transaction_id
            )
            if exchange_txn:
                exchange_txn.reference_transaction_id = str(return_txn.id)
                await self.session.commit()
        
        # Schedule quality check if required
        if return_data.quality_check_required:
            # This would typically create a task in a task management system
            # For now, we'll just add a note
            return_txn.notes = (return_txn.notes or "") + "\n[QUALITY_CHECK_REQUIRED]"


class PurchaseReturnProcessor(ReturnProcessor):
    """Processes purchase returns to suppliers."""
    
    async def validate_return(
        self, 
        original_txn: TransactionHeader, 
        return_data: PurchaseReturnCreate
    ) -> List[str]:
        """Validate purchase return specific rules."""
        errors = await self._validate_common_rules(original_txn, return_data)
        
        # RMA number is usually required
        if not return_data.supplier_rma_number:
            errors.append("Supplier RMA number is required for purchase returns")
        
        # Check if transaction type is purchase
        if original_txn.transaction_type != "PURCHASE":
            errors.append("Can only create purchase returns for purchase transactions")
        
        # Validate quality claim consistency
        if return_data.quality_claim:
            has_supplier_fault = any(item.supplier_fault for item in return_data.return_items)
            if not has_supplier_fault:
                errors.append("Quality claim requires at least one item marked as supplier fault")
        
        # Check return authorization date
        if return_data.return_authorization_date:
            if return_data.return_authorization_date > date.today():
                errors.append("Return authorization date cannot be in the future")
        
        return errors
    
    async def process_inventory(
        self, 
        return_txn: TransactionHeader, 
        return_data: PurchaseReturnCreate
    ) -> None:
        """Remove items from stock for supplier return."""
        for idx, item in enumerate(return_data.return_items):
            line = return_txn.transaction_lines[idx]
            
            # Remove from stock (negative adjustment)
            await self.inventory_service.adjust_stock_level(
                item_id=line.item_id,
                location_id=return_txn.location_id,
                quantity_change=-abs(line.quantity),  # Make negative
                transaction_type="PURCHASE_RETURN",
                reference_id=str(return_txn.id),
                notes=f"Purchase return to supplier - RMA: {return_data.supplier_rma_number}"
            )
            
            # If defective, might need to track separately
            if item.supplier_fault:
                # Could create a defective inventory record
                pass
    
    async def calculate_financials(
        self, 
        original_txn: TransactionHeader, 
        return_data: PurchaseReturnCreate
    ) -> Dict[str, Decimal]:
        """Calculate expected credit from supplier."""
        financials = {
            'return_value': Decimal("0"),
            'supplier_restocking_fee': Decimal("0"),
            'expected_credit': Decimal("0"),
            'shipping_cost': Decimal("0")
        }
        
        # Calculate return value
        for item in return_data.return_items:
            original_line = self._find_line(original_txn, item.original_line_id)
            if not original_line:
                continue
            
            # Use purchase price (unit_price for purchases is cost)
            item_value = original_line.unit_price * item.return_quantity
            financials['return_value'] += item_value
        
        # Apply supplier restocking fee if specified
        if return_data.supplier_restocking_fee_percent:
            fee_rate = return_data.supplier_restocking_fee_percent / 100
            financials['supplier_restocking_fee'] = financials['return_value'] * fee_rate
        
        # Calculate expected credit
        financials['expected_credit'] = (
            financials['return_value'] - 
            financials['supplier_restocking_fee']
        )
        
        # Note shipping cost if tracked
        if return_data.return_shipping_cost:
            financials['shipping_cost'] = return_data.return_shipping_cost
        
        return financials
    
    async def post_process(
        self, 
        return_txn: TransactionHeader, 
        return_data: PurchaseReturnCreate
    ) -> None:
        """Handle post-processing for purchase returns."""
        # Create expected credit tracking
        if return_data.supplier_credit_expected and return_data.expected_credit_date:
            # This would typically create an accounts payable credit expectation
            # For now, we'll add metadata
            return_txn.notes = (return_txn.notes or "") + (
                f"\n[EXPECTED_CREDIT: {return_data.expected_credit_date}]"
            )
        
        # Track quality claims
        if return_data.quality_claim:
            return_txn.notes = (return_txn.notes or "") + "\n[QUALITY_CLAIM]"


class RentalReturnProcessor(ReturnProcessor):
    """Processes rental returns with inspection workflow."""
    
    async def validate_return(
        self, 
        original_txn: TransactionHeader, 
        return_data: RentalReturnCreate
    ) -> List[str]:
        """Validate rental return specific rules."""
        errors = await self._validate_common_rules(original_txn, return_data)
        
        # Check if transaction is a rental
        if original_txn.transaction_type != "RENTAL":
            errors.append("Can only create rental returns for rental transactions")
        
        # All rental items must be returned
        for line in original_txn.transaction_lines:
            total_being_returned = sum(
                item.return_quantity 
                for item in return_data.return_items 
                if str(item.original_line_id) == str(line.id)
            )
            
            already_returned = line.returned_quantity or Decimal("0")
            if (already_returned + total_being_returned) < line.quantity:
                errors.append(
                    f"All rental items must be returned. "
                    f"Line {line.id} missing {line.quantity - already_returned - total_being_returned} items"
                )
        
        # Validate photos for damaged items
        if return_data.photos_required:
            has_damage = any(
                item.condition_on_return in ["POOR", "DAMAGED"] 
                for item in return_data.return_items
            )
            if has_damage and not return_data.photo_urls:
                errors.append("Photos required for damaged rental returns")
        
        # Validate deposit amount
        if return_data.deposit_amount < 0:
            errors.append("Deposit amount cannot be negative")
        
        return errors
    
    async def process_inventory(
        self, 
        return_txn: TransactionHeader, 
        return_data: RentalReturnCreate
    ) -> None:
        """Update rental inventory status based on condition."""
        for idx, item in enumerate(return_data.return_items):
            line = return_txn.transaction_lines[idx]
            
            # Determine inventory status based on condition
            if item.condition_on_return in ["EXCELLENT", "GOOD"]:
                status = "AVAILABLE"
            elif item.condition_on_return == "FAIR":
                if item.cleaning_condition != "CLEAN":
                    status = "REQUIRES_CLEANING"
                else:
                    status = "AVAILABLE"
            else:  # POOR or DAMAGED
                status = "REQUIRES_INSPECTION"
            
            # Update inventory unit status if tracked by unit
            if line.inventory_unit_id:
                await self.inventory_service.update_inventory_unit_status(
                    unit_id=line.inventory_unit_id,
                    status=status,
                    condition=item.condition_on_return,
                    notes=item.damage_description
                )
            else:
                # Update general stock status
                await self.inventory_service.update_stock_condition(
                    item_id=line.item_id,
                    location_id=return_txn.location_id,
                    quantity=item.return_quantity,
                    condition=item.condition_on_return,
                    status=status
                )
            
            # Move stock from on rent back to available for all returns
            try:
                # Get stock level for this item/location
                stock_level = await self.inventory_service.stock_level_repository.get_by_item_location(
                    line.item_id, return_txn.location_id
                )
                
                if stock_level:
                    from decimal import Decimal
                    # Move quantity from on rent back to available
                    await self.inventory_service.return_from_rent(
                        stock_level_id=stock_level.id,
                        quantity=Decimal(str(item.return_quantity)),
                        transaction_id=str(return_txn.id)
                    )
                    
                    self.logger.log_debug_info("Stock returned from rent", {
                        "item_id": str(line.item_id),
                        "quantity": item.return_quantity,
                        "return_transaction_id": str(return_txn.id),
                        "stock_level_id": str(stock_level.id),
                        "condition": item.condition_on_return
                    })
                else:
                    # Log warning if no stock level found
                    self.logger.log_debug_info("No stock level found for rental return", {
                        "item_id": str(line.item_id),
                        "location_id": str(return_txn.location_id),
                        "quantity": item.return_quantity
                    })
                    
            except Exception as stock_error:
                # Log the error but don't fail the return
                self.logger.log_debug_info("Error updating stock for rental return", {
                    "item_id": str(line.item_id),
                    "error": str(stock_error),
                    "return_transaction_id": str(return_txn.id)
                })
    
    async def calculate_financials(
        self, 
        original_txn: TransactionHeader, 
        return_data: RentalReturnCreate
    ) -> Dict[str, Decimal]:
        """Calculate deposit refund after deductions."""
        financials = {
            'original_deposit': return_data.deposit_amount,
            'late_fee': Decimal("0"),
            'damage_fee': Decimal("0"),
            'cleaning_fee': Decimal("0"),
            'missing_items_fee': Decimal("0"),
            'total_deductions': Decimal("0"),
            'deposit_refund': Decimal("0")
        }
        
        # Calculate late fee if applicable
        if return_data.late_fee_applicable and return_data.late_fee_amount:
            financials['late_fee'] = return_data.late_fee_amount
        elif return_data.actual_return_date > return_data.scheduled_return_date:
            # Auto-calculate late fee
            days_late = (return_data.actual_return_date - return_data.scheduled_return_date).days
            # Use 10% of daily rate as late fee
            daily_rate = original_txn.total_amount / 30  # Rough estimate
            financials['late_fee'] = daily_rate * days_late * Decimal("0.1")
        
        # Calculate damage fees
        for item in return_data.return_items:
            if item.condition_on_return == "DAMAGED":
                if item.estimated_repair_cost:
                    financials['damage_fee'] += item.estimated_repair_cost
                else:
                    # Default damage fee based on severity
                    financials['damage_fee'] += Decimal("200")
            elif item.condition_on_return == "POOR":
                financials['damage_fee'] += Decimal("100")
            
            # Additional fee for beyond normal wear
            if item.beyond_normal_wear:
                financials['damage_fee'] += Decimal("50")
            
            # Missing accessories fee
            if item.missing_accessories:
                financials['missing_items_fee'] += Decimal("25") * len(item.missing_accessories)
        
        # Cleaning fee
        if return_data.cleaning_required and return_data.cleaning_fee:
            financials['cleaning_fee'] = return_data.cleaning_fee
        else:
            # Auto-calculate based on condition
            needs_major_cleaning = any(
                item.cleaning_condition == "MAJOR_CLEANING" 
                for item in return_data.return_items
            )
            needs_minor_cleaning = any(
                item.cleaning_condition == "MINOR_CLEANING" 
                for item in return_data.return_items
            )
            
            if needs_major_cleaning:
                financials['cleaning_fee'] = Decimal("75")
            elif needs_minor_cleaning:
                financials['cleaning_fee'] = Decimal("25")
        
        # Calculate total deductions and deposit refund
        financials['total_deductions'] = (
            financials['late_fee'] +
            financials['damage_fee'] +
            financials['cleaning_fee'] +
            financials['missing_items_fee']
        )
        
        financials['deposit_refund'] = max(
            financials['original_deposit'] - financials['total_deductions'],
            Decimal("0")
        )
        
        return financials
    
    async def post_process(
        self, 
        return_txn: TransactionHeader, 
        return_data: RentalReturnCreate
    ) -> None:
        """Handle post-processing for rental returns."""
        # Create inspection tasks for damaged items
        inspection_required = False
        
        for item in return_data.return_items:
            if item.condition_on_return in ["POOR", "DAMAGED"]:
                inspection_required = True
                # Create inspection task
                priority = "HIGH" if item.functionality_check == "NOT_WORKING" else "MEDIUM"
                
                # Add inspection requirement to notes
                inspection_note = (
                    f"\n[INSPECTION_REQUIRED: {item.condition_on_return}, "
                    f"Priority: {priority}]"
                )
                return_txn.notes = (return_txn.notes or "") + inspection_note
        
        # Handle photo documentation
        if return_data.photo_urls:
            photo_note = f"\n[PHOTOS: {len(return_data.photo_urls)} photos attached]"
            return_txn.notes = (return_txn.notes or "") + photo_note
        
        # Mark if deposit was fully refunded
        deposit_refund = return_txn.financial_summary.get('deposit_refund', Decimal("0"))
        if deposit_refund == return_data.deposit_amount:
            return_txn.notes = (return_txn.notes or "") + "\n[DEPOSIT_FULLY_REFUNDED]"
        elif deposit_refund == 0:
            return_txn.notes = (return_txn.notes or "") + "\n[DEPOSIT_FULLY_RETAINED]"

===== modules/transactions/services/return_workflows.py â€“ 2025-07-19 12:13:41 IST =====
"""
Return workflow management for different return types.
"""
from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, List, Optional, Set
from uuid import UUID
from datetime import datetime

from sqlalchemy.ext.asyncio import AsyncSession

from app.modules.transactions.base.models import TransactionHeader
from app.modules.transactions.schemas.returns import ReturnWorkflowState
import logging
logger = logging.getLogger(__name__)


class WorkflowTransition:
    """Represents a valid workflow transition."""
    
    def __init__(
        self, 
        from_state: str, 
        to_state: str, 
        condition: Optional[callable] = None,
        side_effects: Optional[List[callable]] = None
    ):
        self.from_state = from_state
        self.to_state = to_state
        self.condition = condition
        self.side_effects = side_effects or []
    
    def is_valid(self, context: Dict) -> bool:
        """Check if transition is valid given context."""
        if self.condition:
            return self.condition(context)
        return True
    
    async def execute_side_effects(self, context: Dict) -> None:
        """Execute side effects of the transition."""
        for effect in self.side_effects:
            if asyncio.iscoroutinefunction(effect):
                await effect(context)
            else:
                effect(context)


class ReturnWorkflow(ABC):
    """Abstract base class for return workflows."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self._transitions: List[WorkflowTransition] = []
        self._initialize_transitions()
    
    @abstractmethod
    def _initialize_transitions(self) -> None:
        """Initialize workflow transitions."""
        pass
    
    def get_allowed_transitions(self, current_state: str) -> List[str]:
        """Get allowed transitions from current state."""
        allowed = []
        for transition in self._transitions:
            if transition.from_state == current_state:
                allowed.append(transition.to_state)
        return allowed
    
    def can_transition(
        self, 
        current_state: str, 
        target_state: str, 
        context: Optional[Dict] = None
    ) -> bool:
        """Check if transition is allowed."""
        context = context or {}
        
        for transition in self._transitions:
            if (transition.from_state == current_state and 
                transition.to_state == target_state):
                return transition.is_valid(context)
        
        return False
    
    async def transition(
        self,
        return_id: UUID,
        current_state: str,
        target_state: str,
        context: Optional[Dict] = None
    ) -> None:
        """Execute a state transition."""
        context = context or {}
        context['return_id'] = return_id
        
        # Find the transition
        transition = None
        for t in self._transitions:
            if t.from_state == current_state and t.to_state == target_state:
                transition = t
                break
        
        if not transition:
            raise ValueError(f"Invalid transition: {current_state} â†’ {target_state}")
        
        if not transition.is_valid(context):
            raise ValueError(f"Transition conditions not met: {current_state} â†’ {target_state}")
        
        # Execute side effects
        await transition.execute_side_effects(context)
        
        # Log transition
        logger.info(
            f"Return {return_id} transitioned: {current_state} â†’ {target_state}"
        )
    
    @abstractmethod
    async def on_state_change(
        self, 
        return_id: UUID, 
        old_state: str, 
        new_state: str,
        context: Optional[Dict] = None
    ) -> None:
        """Handle state change side effects."""
        pass


class SaleReturnWorkflow(ReturnWorkflow):
    """Workflow for sale returns."""
    
    def _initialize_transitions(self) -> None:
        """Initialize sale return transitions."""
        # INITIATED â†’ VALIDATED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.INITIATED,
                ReturnWorkflowState.VALIDATED,
                side_effects=[self._create_return_tasks]
            )
        )
        
        # VALIDATED â†’ ITEMS_RECEIVED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.VALIDATED,
                ReturnWorkflowState.ITEMS_RECEIVED,
                side_effects=[self._mark_items_received]
            )
        )
        
        # ITEMS_RECEIVED â†’ INSPECTION_PENDING (if quality check required)
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.ITEMS_RECEIVED,
                ReturnWorkflowState.INSPECTION_PENDING,
                condition=lambda ctx: ctx.get('quality_check_required', False),
                side_effects=[self._create_inspection_tasks]
            )
        )
        
        # ITEMS_RECEIVED â†’ REFUND_APPROVED (if no inspection needed)
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.ITEMS_RECEIVED,
                ReturnWorkflowState.REFUND_APPROVED,
                condition=lambda ctx: not ctx.get('quality_check_required', False),
                side_effects=[self._calculate_final_refund]
            )
        )
        
        # INSPECTION_PENDING â†’ INSPECTION_COMPLETE
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.INSPECTION_PENDING,
                ReturnWorkflowState.INSPECTION_COMPLETE,
                side_effects=[self._process_inspection_results]
            )
        )
        
        # INSPECTION_COMPLETE â†’ REFUND_APPROVED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.INSPECTION_COMPLETE,
                ReturnWorkflowState.REFUND_APPROVED,
                side_effects=[self._calculate_final_refund]
            )
        )
        
        # REFUND_APPROVED â†’ REFUND_PROCESSED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.REFUND_APPROVED,
                ReturnWorkflowState.REFUND_PROCESSED,
                side_effects=[self._process_refund, self._update_inventory]
            )
        )
        
        # REFUND_PROCESSED â†’ COMPLETED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.REFUND_PROCESSED,
                ReturnWorkflowState.COMPLETED,
                side_effects=[self._finalize_return]
            )
        )
        
        # Allow cancellation from most states
        for state in [
            ReturnWorkflowState.INITIATED,
            ReturnWorkflowState.VALIDATED,
            ReturnWorkflowState.ITEMS_RECEIVED,
            ReturnWorkflowState.INSPECTION_PENDING
        ]:
            self._transitions.append(
                WorkflowTransition(
                    state,
                    ReturnWorkflowState.CANCELLED,
                    side_effects=[self._cancel_return]
                )
            )
    
    async def on_state_change(
        self, 
        return_id: UUID, 
        old_state: str, 
        new_state: str,
        context: Optional[Dict] = None
    ) -> None:
        """Handle sale return state changes."""
        logger.info(f"Sale return {return_id}: {old_state} â†’ {new_state}")
        
        # Notify relevant parties
        if new_state == ReturnWorkflowState.REFUND_PROCESSED:
            await self._notify_customer_refund_processed(return_id)
        elif new_state == ReturnWorkflowState.CANCELLED:
            await self._notify_return_cancelled(return_id)
    
    # Side effect methods
    async def _create_return_tasks(self, context: Dict) -> None:
        """Create tasks for processing the return."""
        # This would create actual tasks in a task management system
        logger.info(f"Creating return tasks for {context['return_id']}")
    
    async def _mark_items_received(self, context: Dict) -> None:
        """Mark items as received."""
        logger.info(f"Marking items received for {context['return_id']}")
    
    async def _create_inspection_tasks(self, context: Dict) -> None:
        """Create quality inspection tasks."""
        logger.info(f"Creating inspection tasks for {context['return_id']}")
    
    async def _process_inspection_results(self, context: Dict) -> None:
        """Process inspection results."""
        logger.info(f"Processing inspection results for {context['return_id']}")
    
    async def _calculate_final_refund(self, context: Dict) -> None:
        """Calculate final refund amount."""
        logger.info(f"Calculating final refund for {context['return_id']}")
    
    async def _process_refund(self, context: Dict) -> None:
        """Process the actual refund."""
        logger.info(f"Processing refund for {context['return_id']}")
    
    async def _update_inventory(self, context: Dict) -> None:
        """Update inventory for returned items."""
        logger.info(f"Updating inventory for {context['return_id']}")
    
    async def _finalize_return(self, context: Dict) -> None:
        """Finalize the return."""
        logger.info(f"Finalizing return {context['return_id']}")
    
    async def _cancel_return(self, context: Dict) -> None:
        """Cancel the return."""
        logger.info(f"Cancelling return {context['return_id']}")
    
    async def _notify_customer_refund_processed(self, return_id: UUID) -> None:
        """Notify customer that refund is processed."""
        logger.info(f"Notifying customer about refund for {return_id}")
    
    async def _notify_return_cancelled(self, return_id: UUID) -> None:
        """Notify about return cancellation."""
        logger.info(f"Notifying about cancellation of {return_id}")


class PurchaseReturnWorkflow(ReturnWorkflow):
    """Workflow for purchase returns."""
    
    def _initialize_transitions(self) -> None:
        """Initialize purchase return transitions."""
        # INITIATED â†’ VALIDATED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.INITIATED,
                ReturnWorkflowState.VALIDATED,
                side_effects=[self._generate_rma_documents]
            )
        )
        
        # VALIDATED â†’ ITEMS_RECEIVED (actually ITEMS_SHIPPED to supplier)
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.VALIDATED,
                ReturnWorkflowState.ITEMS_RECEIVED,
                side_effects=[self._ship_to_supplier, self._remove_from_inventory]
            )
        )
        
        # ITEMS_RECEIVED â†’ REFUND_APPROVED (actually CREDIT_PENDING)
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.ITEMS_RECEIVED,
                ReturnWorkflowState.REFUND_APPROVED,
                side_effects=[self._create_credit_expectation]
            )
        )
        
        # REFUND_APPROVED â†’ REFUND_PROCESSED (actually CREDIT_RECEIVED)
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.REFUND_APPROVED,
                ReturnWorkflowState.REFUND_PROCESSED,
                condition=lambda ctx: ctx.get('credit_received', False),
                side_effects=[self._process_supplier_credit]
            )
        )
        
        # REFUND_PROCESSED â†’ COMPLETED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.REFUND_PROCESSED,
                ReturnWorkflowState.COMPLETED,
                side_effects=[self._finalize_purchase_return]
            )
        )
        
        # Allow cancellation from early states
        for state in [
            ReturnWorkflowState.INITIATED,
            ReturnWorkflowState.VALIDATED
        ]:
            self._transitions.append(
                WorkflowTransition(
                    state,
                    ReturnWorkflowState.CANCELLED,
                    side_effects=[self._cancel_purchase_return]
                )
            )
    
    async def on_state_change(
        self, 
        return_id: UUID, 
        old_state: str, 
        new_state: str,
        context: Optional[Dict] = None
    ) -> None:
        """Handle purchase return state changes."""
        logger.info(f"Purchase return {return_id}: {old_state} â†’ {new_state}")
        
        if new_state == ReturnWorkflowState.ITEMS_RECEIVED:
            await self._notify_accounting_items_shipped(return_id)
        elif new_state == ReturnWorkflowState.REFUND_PROCESSED:
            await self._notify_accounting_credit_received(return_id)
    
    # Side effect methods
    async def _generate_rma_documents(self, context: Dict) -> None:
        """Generate RMA documents."""
        logger.info(f"Generating RMA documents for {context['return_id']}")
    
    async def _ship_to_supplier(self, context: Dict) -> None:
        """Process shipping to supplier."""
        logger.info(f"Processing supplier shipment for {context['return_id']}")
    
    async def _remove_from_inventory(self, context: Dict) -> None:
        """Remove items from inventory."""
        logger.info(f"Removing items from inventory for {context['return_id']}")
    
    async def _create_credit_expectation(self, context: Dict) -> None:
        """Create expected credit entry."""
        logger.info(f"Creating credit expectation for {context['return_id']}")
    
    async def _process_supplier_credit(self, context: Dict) -> None:
        """Process received supplier credit."""
        logger.info(f"Processing supplier credit for {context['return_id']}")
    
    async def _finalize_purchase_return(self, context: Dict) -> None:
        """Finalize purchase return."""
        logger.info(f"Finalizing purchase return {context['return_id']}")
    
    async def _cancel_purchase_return(self, context: Dict) -> None:
        """Cancel purchase return."""
        logger.info(f"Cancelling purchase return {context['return_id']}")
    
    async def _notify_accounting_items_shipped(self, return_id: UUID) -> None:
        """Notify accounting about shipment."""
        logger.info(f"Notifying accounting about shipment for {return_id}")
    
    async def _notify_accounting_credit_received(self, return_id: UUID) -> None:
        """Notify accounting about credit."""
        logger.info(f"Notifying accounting about credit for {return_id}")


class RentalReturnWorkflow(ReturnWorkflow):
    """Workflow for rental returns."""
    
    def _initialize_transitions(self) -> None:
        """Initialize rental return transitions."""
        # INITIATED â†’ ITEMS_RECEIVED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.INITIATED,
                ReturnWorkflowState.ITEMS_RECEIVED,
                side_effects=[self._record_actual_return]
            )
        )
        
        # ITEMS_RECEIVED â†’ INSPECTION_PENDING (always for rentals)
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.ITEMS_RECEIVED,
                ReturnWorkflowState.INSPECTION_PENDING,
                side_effects=[self._create_rental_inspection_checklist]
            )
        )
        
        # INSPECTION_PENDING â†’ INSPECTION_COMPLETE
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.INSPECTION_PENDING,
                ReturnWorkflowState.INSPECTION_COMPLETE,
                condition=lambda ctx: ctx.get('inspection_complete', False),
                side_effects=[self._process_rental_inspection]
            )
        )
        
        # INSPECTION_COMPLETE â†’ REFUND_APPROVED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.INSPECTION_COMPLETE,
                ReturnWorkflowState.REFUND_APPROVED,
                side_effects=[self._calculate_deposit_refund]
            )
        )
        
        # REFUND_APPROVED â†’ REFUND_PROCESSED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.REFUND_APPROVED,
                ReturnWorkflowState.REFUND_PROCESSED,
                side_effects=[self._process_deposit_refund]
            )
        )
        
        # REFUND_PROCESSED â†’ COMPLETED
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.REFUND_PROCESSED,
                ReturnWorkflowState.COMPLETED,
                side_effects=[self._finalize_rental_return, self._update_rental_unit_status]
            )
        )
        
        # Limited cancellation for rentals
        self._transitions.append(
            WorkflowTransition(
                ReturnWorkflowState.INITIATED,
                ReturnWorkflowState.CANCELLED,
                side_effects=[self._cancel_rental_return]
            )
        )
    
    async def on_state_change(
        self, 
        return_id: UUID, 
        old_state: str, 
        new_state: str,
        context: Optional[Dict] = None
    ) -> None:
        """Handle rental return state changes."""
        logger.info(f"Rental return {return_id}: {old_state} â†’ {new_state}")
        
        if new_state == ReturnWorkflowState.INSPECTION_COMPLETE:
            await self._notify_customer_inspection_complete(return_id)
        elif new_state == ReturnWorkflowState.REFUND_PROCESSED:
            await self._notify_customer_deposit_processed(return_id)
    
    # Side effect methods
    async def _record_actual_return(self, context: Dict) -> None:
        """Record actual return date and calculate late fees."""
        logger.info(f"Recording actual return for {context['return_id']}")
    
    async def _create_rental_inspection_checklist(self, context: Dict) -> None:
        """Create comprehensive inspection checklist."""
        logger.info(f"Creating inspection checklist for {context['return_id']}")
    
    async def _process_rental_inspection(self, context: Dict) -> None:
        """Process inspection results and calculate damages."""
        logger.info(f"Processing inspection for {context['return_id']}")
    
    async def _calculate_deposit_refund(self, context: Dict) -> None:
        """Calculate deposit refund after all deductions."""
        logger.info(f"Calculating deposit refund for {context['return_id']}")
    
    async def _process_deposit_refund(self, context: Dict) -> None:
        """Process deposit refund."""
        logger.info(f"Processing deposit refund for {context['return_id']}")
    
    async def _finalize_rental_return(self, context: Dict) -> None:
        """Finalize rental return."""
        logger.info(f"Finalizing rental return {context['return_id']}")
    
    async def _update_rental_unit_status(self, context: Dict) -> None:
        """Update rental unit availability."""
        logger.info(f"Updating rental unit status for {context['return_id']}")
    
    async def _cancel_rental_return(self, context: Dict) -> None:
        """Cancel rental return."""
        logger.info(f"Cancelling rental return {context['return_id']}")
    
    async def _notify_customer_inspection_complete(self, return_id: UUID) -> None:
        """Notify customer about inspection completion."""
        logger.info(f"Notifying customer about inspection for {return_id}")
    
    async def _notify_customer_deposit_processed(self, return_id: UUID) -> None:
        """Notify customer about deposit refund."""
        logger.info(f"Notifying customer about deposit for {return_id}")


class WorkflowManager:
    """Manages workflows for all return types."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.workflows = {
            "SALE_RETURN": SaleReturnWorkflow(session),
            "PURCHASE_RETURN": PurchaseReturnWorkflow(session),
            "RENTAL_RETURN": RentalReturnWorkflow(session)
        }
    
    def get_workflow(self, return_type: str) -> Optional[ReturnWorkflow]:
        """Get workflow for return type."""
        return self.workflows.get(return_type)
    
    async def transition_return(
        self,
        return_id: UUID,
        return_type: str,
        current_state: str,
        target_state: str,
        context: Optional[Dict] = None
    ) -> None:
        """Transition a return through workflow."""
        workflow = self.get_workflow(return_type)
        if not workflow:
            raise ValueError(f"Unknown return type: {return_type}")
        
        await workflow.transition(return_id, current_state, target_state, context)
        await workflow.on_state_change(return_id, current_state, target_state, context)
    
    def get_allowed_transitions(
        self, 
        return_type: str, 
        current_state: str
    ) -> List[str]:
        """Get allowed transitions for current state."""
        workflow = self.get_workflow(return_type)
        if not workflow:
            return []
        
        return workflow.get_allowed_transitions(current_state)


# Import for async support
import asyncio

===== modules/transactions/services/unified_returns.py â€“ 2025-07-19 12:13:41 IST =====
"""
Unified return service with factory pattern for handling all return types.
"""
from typing import Dict, List, Optional, Any, Union
from decimal import Decimal
from datetime import datetime
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession

from app.modules.transactions.base.models import (
    TransactionHeader, 
    TransactionLine,
    TransactionType,
    TransactionStatus,
    LineItemType
)
from app.modules.transactions.models.metadata import TransactionMetadata
from app.modules.transactions.models.inspections import PurchaseCreditMemo
from app.modules.transactions.rental_returns.models import RentalInspection
from app.modules.transactions.schemas import (
    TransactionHeaderCreate,
    TransactionLineCreate,
    TransactionWithLinesResponse
)
from app.modules.transactions.schemas.returns import (
    ReturnTransactionCreate,
    SaleReturnCreate,
    PurchaseReturnCreate,
    ReturnDetailsResponse,
    ReturnValidationResponse,
    PurchaseCreditMemoCreate,
    PurchaseCreditMemoResponse,
    ReturnWorkflowState,
    SaleReturnDetails,
    PurchaseReturnDetails,
)
from app.modules.transactions.rental_returns.schemas import (
    RentalReturnCreate,
    RentalInspectionCreate,
    RentalInspectionResponse,
    RentalReturnDetails
)
from app.modules.transactions.services.return_processors import (
    ReturnProcessor,
    SaleReturnProcessor,
    PurchaseReturnProcessor,
    RentalReturnProcessor
)
from app.core.errors import NotFoundError, ValidationError, ConflictError
import logging
logger = logging.getLogger(__name__)


class UnifiedReturnService:
    """
    Main service for handling all return types using factory pattern.
    """
    
    def __init__(self, transaction_service, inventory_service, session: AsyncSession):
        self.transaction_service = transaction_service
        self.inventory_service = inventory_service
        self.session = session
        
        # Initialize processors
        self.processors: Dict[str, ReturnProcessor] = {
            "SALE_RETURN": SaleReturnProcessor(transaction_service, inventory_service, session),
            "PURCHASE_RETURN": PurchaseReturnProcessor(transaction_service, inventory_service, session),
            "RENTAL_RETURN": RentalReturnProcessor(transaction_service, inventory_service, session)
        }
    
    def _get_processor(self, return_type: str) -> ReturnProcessor:
        """Get the appropriate processor for return type."""
        processor = self.processors.get(return_type)
        if not processor:
            raise ValueError(f"Unknown return type: {return_type}")
        return processor
    
    async def validate_return(
        self, 
        return_data: Union[SaleReturnCreate, PurchaseReturnCreate, RentalReturnCreate]
    ) -> ReturnValidationResponse:
        """
        Validate a return without creating it.
        
        Args:
            return_data: Return data to validate
            
        Returns:
            Validation response with errors, warnings, and estimates
        """
        try:
            # Get original transaction
            original_txn = await self.transaction_service.get_with_lines(
                return_data.original_transaction_id
            )
            if not original_txn:
                return ReturnValidationResponse(
                    is_valid=False,
                    errors=[f"Original transaction {return_data.original_transaction_id} not found"]
                )
            
            # Get processor
            processor = self._get_processor(return_data.return_type)
            
            # Run validation
            errors = await processor.validate_return(original_txn, return_data)
            
            # Calculate estimated financials if no errors
            estimated_refund = None
            estimated_fees = None
            if not errors:
                financials = await processor.calculate_financials(original_txn, return_data)
                estimated_refund = financials.get('net_refund', Decimal("0"))
                estimated_fees = {
                    k: v for k, v in financials.items() 
                    if k not in ['net_refund', 'subtotal']
                }
            
            # Add warnings (non-blocking issues)
            warnings = []
            if return_data.return_type == "SALE_RETURN":
                days_since_sale = (datetime.now() - original_txn.transaction_date).days
                if days_since_sale > 14:
                    warnings.append(f"Sale is {days_since_sale} days old. Restocking fee may apply.")
            
            return ReturnValidationResponse(
                is_valid=len(errors) == 0,
                errors=errors,
                warnings=warnings,
                estimated_refund=estimated_refund,
                estimated_fees=estimated_fees
            )
            
        except Exception as e:
            logger.error(f"Error validating return: {str(e)}")
            return ReturnValidationResponse(
                is_valid=False,
                errors=[f"Validation error: {str(e)}"]
            )
    
    async def create_return(
        self,
        return_data: Union[SaleReturnCreate, PurchaseReturnCreate, RentalReturnCreate]
    ) -> TransactionWithLinesResponse:
        """
        Create any type of return transaction.
        
        Args:
            return_data: Return data with type-specific properties
            
        Returns:
            Created return transaction with lines
        """
        # Get processor
        processor = self._get_processor(return_data.return_type)
        
        # 1. Get and validate original transaction
        original_txn = await self.transaction_service.get_with_lines(
            return_data.original_transaction_id
        )
        if not original_txn:
            raise NotFoundError(f"Original transaction {return_data.original_transaction_id} not found")
        
        # 2. Run type-specific validation
        errors = await processor.validate_return(original_txn, return_data)
        if errors:
            raise ValidationError("; ".join(errors))
        
        # 3. Calculate financials
        financials = await processor.calculate_financials(original_txn, return_data)
        
        # 4. Create return transaction
        async with self.session.begin():
            # Create header
            return_header = await self._create_return_header(
                original_txn,
                return_data,
                financials
            )
            
            # Create lines
            return_lines = await self._create_return_lines(
                original_txn,
                return_data
            )
            
            # Create the transaction
            return_txn = await self.transaction_service.create_transaction_with_lines(
                return_header,
                return_lines
            )
            
            # Store financial summary in transaction
            return_txn.financial_summary = financials
            
            # 5. Process inventory changes
            await processor.process_inventory(return_txn, return_data)
            
            # 6. Update original transaction
            await self._update_original_transaction(
                original_txn,
                return_data,
                return_txn
            )
            
            # 7. Run type-specific post-processing
            await processor.post_process(return_txn, return_data)
            
            # 8. Store type-specific metadata
            await self._store_return_metadata(return_txn, return_data)
            
            # 9. Set initial workflow state
            return_txn.return_workflow_state = ReturnWorkflowState.INITIATED
            
            await self.session.commit()
            
            # Log return creation
            logger.info(
                f"Created {return_data.return_type} transaction {return_txn.transaction_number} "
                f"for original transaction {original_txn.transaction_number}"
            )
        
        return TransactionWithLinesResponse.model_validate(return_txn)
    
    async def _create_return_header(
        self,
        original_txn: TransactionHeader,
        return_data: ReturnTransactionCreate,
        financials: Dict[str, Decimal]
    ) -> TransactionHeaderCreate:
        """Create return transaction header."""
        # Generate return number
        return_number = await self._generate_return_number(return_data.return_type)
        
        # Calculate return amounts (negative for returns)
        subtotal = -abs(financials.get('subtotal', Decimal("0")))
        fees = sum(
            v for k, v in financials.items() 
            if 'fee' in k.lower() and k != 'net_refund'
        )
        
        return TransactionHeaderCreate(
            transaction_number=return_number,
            transaction_type=TransactionType.RETURN,
            transaction_date=return_data.return_date,
            customer_id=original_txn.customer_id,
            location_id=original_txn.location_id,
            sales_person_id=return_data.processed_by,
            status=TransactionStatus.PENDING,
            reference_transaction_id=original_txn.id,
            notes=f"{return_data.return_type}: {return_data.return_reason_code} - {return_data.return_reason_notes or ''}",
            subtotal=subtotal,
            discount_amount=Decimal("0"),
            tax_amount=Decimal("0"),  # Returns typically don't have tax
            total_amount=subtotal + fees
        )
    
    async def _create_return_lines(
        self,
        original_txn: TransactionHeader,
        return_data: ReturnTransactionCreate
    ) -> List[TransactionLineCreate]:
        """Create return transaction lines."""
        return_lines = []
        
        for idx, item in enumerate(return_data.return_items):
            # Find original line
            original_line = next(
                (line for line in original_txn.transaction_lines 
                 if str(line.id) == str(item.original_line_id)),
                None
            )
            
            if not original_line:
                continue
            
            # Create return line with negative quantity
            return_line = TransactionLineCreate(
                line_number=idx + 1,
                line_type=original_line.line_type,
                item_id=original_line.item_id,
                inventory_unit_id=original_line.inventory_unit_id,
                description=f"RETURN: {original_line.description}",
                quantity=-abs(item.return_quantity),  # Negative for returns
                unit_price=original_line.unit_price,
                discount_percentage=Decimal("0"),
                discount_amount=Decimal("0"),
                tax_rate=original_line.tax_rate,
                notes=item.return_reason
            )
            
            # Add return-specific fields based on type
            if hasattr(item, 'condition'):
                return_line.return_condition = item.condition
            if hasattr(item, 'return_to_stock'):
                return_line.return_to_stock = item.return_to_stock
            
            return_lines.append(return_line)
        
        return return_lines
    
    async def _update_original_transaction(
        self,
        original_txn: TransactionHeader,
        return_data: ReturnTransactionCreate,
        return_txn: TransactionHeader
    ) -> None:
        """Update original transaction with return information."""
        # Update returned quantities on original lines
        for item in return_data.return_items:
            original_line = next(
                (line for line in original_txn.transaction_lines 
                 if str(line.id) == str(item.original_line_id)),
                None
            )
            
            if original_line:
                original_line.returned_quantity = (
                    (original_line.returned_quantity or Decimal("0")) + 
                    item.return_quantity
                )
                original_line.return_date = return_data.return_date.date()
        
        # Add return reference to notes
        return_note = f"\n[RETURN: {return_txn.transaction_number} on {return_data.return_date.date()}]"
        original_txn.notes = (original_txn.notes or "") + return_note
        
        # Update status if fully returned
        all_returned = all(
            line.returned_quantity >= line.quantity 
            for line in original_txn.transaction_lines
        )
        if all_returned and original_txn.transaction_type == TransactionType.SALE:
            original_txn.status = TransactionStatus.REFUNDED
    
    async def _store_return_metadata(
        self,
        return_txn: TransactionHeader,
        return_data: Union[SaleReturnCreate, PurchaseReturnCreate, RentalReturnCreate]
    ) -> None:
        """Store type-specific return data in metadata table."""
        # Convert return data to dict, excluding base fields and items
        metadata_content = return_data.dict(
            exclude={
                "original_transaction_id", 
                "return_date", 
                "return_reason_code",
                "return_reason_notes",
                "processed_by",
                "return_items"
            }
        )
        
        # Add return type to metadata
        metadata_content['return_type'] = return_data.return_type
        
        # Create metadata entry
        metadata = TransactionMetadata(
            transaction_id=str(return_txn.id),
            metadata_type=f"RETURN_{return_data.return_type}",
            metadata_content=metadata_content
        )
        
        self.session.add(metadata)
    
    async def get_return_details(self, return_id: UUID) -> ReturnDetailsResponse:
        """
        Get comprehensive return details including type-specific metadata.
        
        Args:
            return_id: Return transaction ID
            
        Returns:
            Return details with type-specific information
        """
        # Get transaction with lines
        return_txn = await self.transaction_service.get_with_lines(return_id)
        if not return_txn:
            raise NotFoundError(f"Return transaction {return_id} not found")
        
        if return_txn.transaction_type != TransactionType.RETURN:
            raise ValidationError(f"Transaction {return_id} is not a return")
        
        # Get metadata
        metadata_entry = await self._get_transaction_metadata(return_id)
        if not metadata_entry:
            raise NotFoundError(f"Return metadata for {return_id} not found")
        
        # Build type-specific details
        return_type = metadata_entry.metadata_content.get('return_type')
        
        if return_type == 'SALE_RETURN':
            specific_details = SaleReturnDetails(**metadata_entry.metadata_content)
        elif return_type == 'PURCHASE_RETURN':
            specific_details = PurchaseReturnDetails(**metadata_entry.metadata_content)
        elif return_type == 'RENTAL_RETURN':
            specific_details = RentalReturnDetails(**metadata_entry.metadata_content)
        else:
            raise ValueError(f"Unknown return type: {return_type}")
        
        # Build return lines with metadata
        return_lines = []
        for line in return_txn.transaction_lines:
            line_dict = {
                'id': line.id,
                'line_number': line.line_number,
                'item_id': line.item_id,
                'description': line.description,
                'quantity': abs(line.quantity),  # Show positive
                'unit_price': line.unit_price,
                'line_total': abs(line.line_total),
                'return_condition': line.return_condition,
                'return_to_stock': line.return_to_stock,
                'inspection_status': line.inspection_status,
                'notes': line.notes
            }
            return_lines.append(line_dict)
        
        return ReturnDetailsResponse(
            id=return_txn.id,
            transaction_number=return_txn.transaction_number,
            return_type=return_type,
            original_transaction_id=return_txn.reference_transaction_id,
            return_date=return_txn.transaction_date,
            status=return_txn.status,
            financial_summary=return_txn.financial_summary or {},
            specific_details=specific_details,
            return_lines=return_lines,
            created_at=return_txn.created_at,
            updated_at=return_txn.updated_at
        )
    
    async def update_return_status(
        self,
        return_id: UUID,
        new_status: str,
        notes: Optional[str] = None,
        updated_by: Optional[UUID] = None
    ) -> TransactionHeader:
        """
        Update return status with workflow validation.
        
        Args:
            return_id: Return transaction ID
            new_status: New workflow status
            notes: Optional status update notes
            updated_by: User making the update
            
        Returns:
            Updated transaction
        """
        # Get return transaction
        return_txn = await self.transaction_service.get_by_id(return_id)
        if not return_txn or return_txn.transaction_type != TransactionType.RETURN:
            raise NotFoundError(f"Return transaction {return_id} not found")
        
        # Update workflow state
        old_state = return_txn.return_workflow_state
        return_txn.return_workflow_state = new_status
        
        # Add status note
        if notes:
            status_note = f"\n[STATUS: {old_state} â†’ {new_status}] {notes}"
            return_txn.notes = (return_txn.notes or "") + status_note
        
        # Update transaction status based on workflow state
        if new_status == ReturnWorkflowState.COMPLETED:
            return_txn.status = TransactionStatus.COMPLETED
        elif new_status == ReturnWorkflowState.CANCELLED:
            return_txn.status = TransactionStatus.CANCELLED
        
        await self.session.commit()
        
        logger.info(
            f"Updated return {return_txn.transaction_number} status: "
            f"{old_state} â†’ {new_status}"
        )
        
        return return_txn
    
    async def _get_transaction_metadata(self, transaction_id: UUID) -> Optional[TransactionMetadata]:
        """Get transaction metadata."""
        result = await self.session.execute(
            select(TransactionMetadata).where(
                TransactionMetadata.transaction_id == str(transaction_id),
                TransactionMetadata.metadata_type.like("RETURN_%")
            )
        )
        return result.scalar_one_or_none()
    
    async def _generate_return_number(self, return_type: str) -> str:
        """Generate unique return number."""
        prefix_map = {
            "SALE_RETURN": "SR",
            "PURCHASE_RETURN": "PR", 
            "RENTAL_RETURN": "RR"
        }
        
        prefix = prefix_map.get(return_type, "RET")
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        
        return f"{prefix}-{timestamp}"
    
    # Inspection workflow methods
    
    async def create_rental_inspection(self, inspection_data: RentalInspectionCreate) -> RentalInspectionResponse:
        """
        Create rental return inspection record.
        
        Args:
            inspection_data: Inspection details
            
        Returns:
            Created inspection record
        """
        # Validate return exists and is rental type
        return_txn = await self.transaction_service.get_by_id(inspection_data.return_id)
        if not return_txn:
            raise NotFoundError(f"Return transaction {inspection_data.return_id} not found")
        
        # Get metadata to verify it's a rental return
        metadata_entry = await self._get_transaction_metadata(inspection_data.return_id)
        if not metadata_entry or metadata_entry.metadata_content.get('return_type') != 'RENTAL_RETURN':
            raise ValidationError("Inspection can only be created for rental returns")
        
        # Check if inspection already exists
        existing_inspection = await self.session.execute(
            select(RentalInspection).where(
                RentalInspection.return_id == str(inspection_data.return_id)
            )
        )
        if existing_inspection.scalar_one_or_none():
            raise ConflictError("Inspection already exists for this return")
        
        # Calculate financial summary from line inspections
        total_repair_cost = sum(
            item.repair_cost_estimate or Decimal("0") 
            for item in inspection_data.line_inspections
        )
        total_cleaning_cost = sum(
            item.cleaning_cost_estimate or Decimal("0")
            for item in inspection_data.line_inspections  
        )
        total_deductions = total_repair_cost + total_cleaning_cost
        
        # Calculate deposit refund
        original_deposit = metadata_entry.metadata_content.get('deposit_amount', Decimal("0"))
        deposit_refund_amount = max(Decimal("0"), Decimal(str(original_deposit)) - total_deductions)
        
        # Create inspection record
        inspection = RentalInspection(
            return_id=inspection_data.return_id,
            inspector_id=inspection_data.inspector_id,
            inspection_date=inspection_data.inspection_date,
            overall_condition=inspection_data.overall_condition,
            inspection_passed=inspection_data.inspection_passed,
            total_repair_cost=total_repair_cost,
            total_cleaning_cost=total_cleaning_cost,
            total_deductions=total_deductions,
            deposit_refund_amount=deposit_refund_amount,
            general_notes=inspection_data.general_notes,
            customer_notification_required=inspection_data.customer_notification_required,
            follow_up_actions=inspection_data.follow_up_actions,
            line_inspections=[item.model_dump() for item in inspection_data.line_inspections]
        )
        
        self.session.add(inspection)
        
        # Update return workflow state
        return_txn.return_workflow_state = ReturnWorkflowState.INSPECTION_COMPLETE
        
        # Update inventory units based on inspection results
        for line_inspection in inspection_data.line_inspections:
            if line_inspection.inventory_unit_id:
                await self._update_unit_after_inspection(line_inspection)
        
        await self.session.commit()
        
        logger.info(
            f"Created rental inspection for return {return_txn.transaction_number} "
            f"by inspector {inspection_data.inspector_id}"
        )
        
        return RentalInspectionResponse.model_validate(inspection)
    
    async def get_rental_inspection(self, return_id: UUID) -> Optional[RentalInspectionResponse]:
        """Get rental inspection for a return."""
        result = await self.session.execute(
            select(RentalInspection).where(
                RentalInspection.return_id == str(return_id)
            )
        )
        inspection = result.scalar_one_or_none()
        
        if inspection:
            return RentalInspectionResponse.model_validate(inspection)
        return None
    
    async def _update_unit_after_inspection(self, line_inspection) -> None:
        """Update inventory unit status based on inspection results."""
        if not line_inspection.inventory_unit_id:
            return
        
        # Determine new status based on inspection
        if line_inspection.recommended_action == "RETURN_TO_STOCK":
            if line_inspection.condition_rating in ["EXCELLENT", "GOOD"]:
                new_status = "AVAILABLE"
            else:
                new_status = "AVAILABLE_USED"
        elif line_inspection.recommended_action == "REPAIR_FIRST":
            new_status = "REQUIRES_REPAIR"
        elif line_inspection.recommended_action == "DEEP_CLEANING":
            new_status = "REQUIRES_CLEANING"
        elif line_inspection.recommended_action == "DISPOSAL":
            new_status = "DISPOSED"
        else:
            new_status = "REQUIRES_INSPECTION"
        
        # Update unit status
        await self.inventory_service.update_inventory_unit_status(
            unit_id=line_inspection.inventory_unit_id,
            status=new_status,
            condition=line_inspection.condition_rating,
            notes=f"Post-rental inspection: {line_inspection.inspector_notes}"
        )
    
    # Purchase credit memo methods
    
    async def create_purchase_credit_memo(self, credit_data: PurchaseCreditMemoCreate) -> PurchaseCreditMemoResponse:
        """
        Record supplier credit memo for purchase return.
        
        Args:
            credit_data: Credit memo details
            
        Returns:
            Created credit memo record
        """
        # Validate return exists and is purchase type
        return_txn = await self.transaction_service.get_by_id(credit_data.return_id)
        if not return_txn:
            raise NotFoundError(f"Return transaction {credit_data.return_id} not found")
        
        # Get metadata to verify it's a purchase return
        metadata_entry = await self._get_transaction_metadata(credit_data.return_id)
        if not metadata_entry or metadata_entry.metadata_content.get('return_type') != 'PURCHASE_RETURN':
            raise ValidationError("Credit memo can only be created for purchase returns")
        
        # Check if credit memo already exists
        existing_memo = await self.session.execute(
            select(PurchaseCreditMemo).where(
                PurchaseCreditMemo.return_id == str(credit_data.return_id)
            )
        )
        if existing_memo.scalar_one_or_none():
            raise ConflictError("Credit memo already exists for this return")
        
        # Create credit memo record
        credit_memo = PurchaseCreditMemo(
            return_id=credit_data.return_id,
            credit_memo_number=credit_data.credit_memo_number,
            credit_date=credit_data.credit_date,
            credit_amount=credit_data.credit_amount,
            credit_type=credit_data.credit_type,
            currency=credit_data.currency,
            exchange_rate=credit_data.exchange_rate,
            line_credits=credit_data.line_credits,
            credit_terms=credit_data.credit_terms,
            supplier_notes=credit_data.supplier_notes,
            received_by=credit_data.received_by
        )
        
        self.session.add(credit_memo)
        
        # Update return workflow state
        return_txn.return_workflow_state = ReturnWorkflowState.REFUND_PROCESSED
        
        # Update metadata with credit information
        metadata_entry.metadata_content.update({
            'credit_received': True,
            'credit_received_date': credit_data.credit_date.isoformat(),
            'credit_memo_number': credit_data.credit_memo_number,
            'credit_amount': float(credit_data.credit_amount)
        })
        
        await self.session.commit()
        
        logger.info(
            f"Recorded credit memo {credit_data.credit_memo_number} "
            f"for return {return_txn.transaction_number}"
        )
        
        return PurchaseCreditMemoResponse.model_validate(credit_memo)
    
    async def get_purchase_credit_memo(self, return_id: UUID) -> Optional[PurchaseCreditMemoResponse]:
        """Get purchase credit memo for a return."""
        result = await self.session.execute(
            select(PurchaseCreditMemo).where(
                PurchaseCreditMemo.return_id == str(return_id)
            )
        )
        credit_memo = result.scalar_one_or_none()
        
        if credit_memo:
            return PurchaseCreditMemoResponse.model_validate(credit_memo)
        return None


# Import for query
from sqlalchemy import select

===== modules/inventory/__init__.py â€“ 2025-07-21 17:12:23 IST =====
# Import from submodules
from .units.models import InventoryUnit
from .stock.models import StockLevel, SKUSequence
from .movements.models import StockMovement
from .units.repository import InventoryUnitRepository
from .stock.repository import StockLevelRepository
from .movements.repository import StockMovementRepository

from .enums import (
    InventoryUnitStatus, InventoryUnitCondition,
    MovementType, ReferenceType
)



# Import enums for convenience
from .enums import (
    InventoryUnitStatus, InventoryUnitCondition,
    MovementType, ReferenceType
)

# Export all models and enums
__all__ = [
    # Models
    "InventoryUnit",
    "StockLevel", 
    "SKUSequence",
    "StockMovement",
    # Enums
    "InventoryUnitStatus",
    "InventoryUnitCondition", 
    "MovementType",
    "ReferenceType",
    # Repositories
    "InventoryUnitRepository",
    "StockLevelRepository",
    "StockMovementRepository"
]

===== modules/inventory/enums.py â€“ 2025-07-20 21:17:10 IST =====
from enum import Enum


class ItemStatus(str, Enum):
    """Item status enumeration."""
    ACTIVE = "ACTIVE"
    INACTIVE = "INACTIVE"
    DISCONTINUED = "DISCONTINUED"


class InventoryUnitStatus(str, Enum):
    """Inventory unit status enumeration."""
    AVAILABLE = "AVAILABLE"
    RENTED = "RENTED"
    SOLD = "SOLD"
    MAINTENANCE = "MAINTENANCE"
    DAMAGED = "DAMAGED"
    RETIRED = "RETIRED"


class InventoryUnitCondition(str, Enum):
    """Inventory unit condition enumeration."""
    NEW = "NEW"
    EXCELLENT = "EXCELLENT"
    GOOD = "GOOD"
    FAIR = "FAIR"
    POOR = "POOR"
    DAMAGED = "DAMAGED"


class MovementType(str, Enum):
    """Stock movement type enumeration."""
    PURCHASE = "PURCHASE"
    SALE = "SALE"
    RENTAL_OUT = "RENTAL_OUT"
    RENTAL_RETURN = "RENTAL_RETURN"
    ADJUSTMENT_POSITIVE = "ADJUSTMENT_POSITIVE"
    ADJUSTMENT_NEGATIVE = "ADJUSTMENT_NEGATIVE"
    TRANSFER_IN = "TRANSFER_IN"
    TRANSFER_OUT = "TRANSFER_OUT"
    DAMAGE_LOSS = "DAMAGE_LOSS"
    THEFT_LOSS = "THEFT_LOSS"
    SYSTEM_CORRECTION = "SYSTEM_CORRECTION"


class ReferenceType(str, Enum):
    """Reference type for stock movements."""
    TRANSACTION = "TRANSACTION"
    PURCHASE_ORDER = "PURCHASE_ORDER"
    SALE_ORDER = "SALE_ORDER"
    RENTAL_CONTRACT = "RENTAL_CONTRACT"
    MANUAL_ADJUSTMENT = "MANUAL_ADJUSTMENT"
    SYSTEM_ADJUSTMENT = "SYSTEM_ADJUSTMENT"
    TRANSFER_ORDER = "TRANSFER_ORDER"


===== modules/inventory/routes.py â€“ 2025-07-21 19:37:58 IST =====
"""
app/modules/inventory/router.py
===============================

Central router that groups every inventory sub-router
under the same prefix `/inventory`.
"""
from fastapi import APIRouter
from app.modules.inventory.units.routers import router as inventory_units_router

# Root inventory router
router = APIRouter( tags=["Inventory"])

# mount the rental sub-router (it keeps its own prefix "rental")
router.include_router(inventory_units_router)


@router.get("/statistics")
async def get_customer_statistics(
   
):
    """Get customer statistics."""
    return await []

===== modules/inventory/schemas.py â€“ 2025-07-21 16:32:41 IST =====
from typing import Optional, List, Any
from datetime import datetime
from decimal import Decimal
from pydantic import BaseModel, Field, ConfigDict, field_validator, computed_field
from uuid import UUID

from app.modules.master_data.item_master.models import ItemStatus
from app.modules.inventory.enums import InventoryUnitStatus, InventoryUnitCondition, MovementType, ReferenceType
# Simplified approach - using string with pattern validation



class InventoryUnitCreate(BaseModel):
    """Schema for creating a new inventory unit."""
    item_id: UUID = Field(..., description="Item ID")
    location_id: UUID = Field(..., description="Location ID")
    unit_code: str = Field(..., max_length=50, description="Unique unit code")
    serial_number: Optional[str] = Field(None, max_length=100, description="Serial number")
    status: InventoryUnitStatus = Field(default=InventoryUnitStatus.AVAILABLE, description="Unit status")
    condition: InventoryUnitCondition = Field(default=InventoryUnitCondition.NEW, description="Unit condition")
    purchase_date: Optional[datetime] = Field(None, description="Purchase date")
    purchase_price: Decimal = Field(default=Decimal("0.00"), ge=0, description="Purchase price")
    warranty_expiry: Optional[datetime] = Field(None, description="Warranty expiry date")
    notes: Optional[str] = Field(None, description="Additional notes")


class InventoryUnitUpdate(BaseModel):
    """Schema for updating an inventory unit."""
    location_id: Optional[UUID] = Field(None, description="Location ID")
    serial_number: Optional[str] = Field(None, max_length=100, description="Serial number")
    status: Optional[InventoryUnitStatus] = Field(None, description="Unit status")
    condition: Optional[InventoryUnitCondition] = Field(None, description="Unit condition")
    purchase_date: Optional[datetime] = Field(None, description="Purchase date")
    purchase_price: Optional[Decimal] = Field(None, ge=0, description="Purchase price")
    warranty_expiry: Optional[datetime] = Field(None, description="Warranty expiry date")
    last_maintenance_date: Optional[datetime] = Field(None, description="Last maintenance date")
    next_maintenance_date: Optional[datetime] = Field(None, description="Next maintenance date")
    notes: Optional[str] = Field(None, description="Additional notes")


class InventoryUnitResponse(BaseModel):
    """Schema for inventory unit response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    item_id: UUID
    location_id: UUID
    unit_code: str
    serial_number: Optional[str]
    status: InventoryUnitStatus
    condition: InventoryUnitCondition
    purchase_date: Optional[datetime]
    purchase_price: Decimal
    warranty_expiry: Optional[datetime]
    last_maintenance_date: Optional[datetime]
    next_maintenance_date: Optional[datetime]
    notes: Optional[str]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.unit_code}"
    
    @computed_field
    @property
    def is_available(self) -> bool:
        return self.status == InventoryUnitStatus.AVAILABLE and self.is_active
    
    @computed_field
    @property
    def is_rented(self) -> bool:
        return self.status == InventoryUnitStatus.RENTED
    
    @computed_field
    @property
    def is_sold(self) -> bool:
        return self.status == InventoryUnitStatus.SOLD


class InventoryUnitListResponse(BaseModel):
    """Schema for inventory unit list response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    item_id: UUID
    location_id: UUID
    unit_code: str
    serial_number: Optional[str]
    status: InventoryUnitStatus
    condition: InventoryUnitCondition
    purchase_price: Decimal
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.unit_code}"


class InventoryUnitStatusUpdate(BaseModel):
    """Schema for updating inventory unit status."""
    status: InventoryUnitStatus = Field(..., description="New status")
    condition: Optional[InventoryUnitCondition] = Field(None, description="New condition")
    notes: Optional[str] = Field(None, description="Additional notes")


class StockLevelCreate(BaseModel):
    """Schema for creating a new stock level."""
    item_id: UUID = Field(..., description="Item ID")
    location_id: UUID = Field(..., description="Location ID")
    quantity_on_hand: Decimal = Field(default=Decimal("0"), ge=0, description="Current quantity on hand")
    quantity_available: Decimal = Field(default=Decimal("0"), ge=0, description="Available quantity")
    quantity_on_rent: Decimal = Field(default=Decimal("0"), ge=0, description="Quantity currently on rent")


class StockLevelUpdate(BaseModel):
    """Schema for updating stock level."""
    quantity_on_hand: Optional[Decimal] = Field(None, ge=0, description="Current quantity on hand")
    quantity_available: Optional[Decimal] = Field(None, ge=0, description="Available quantity")
    quantity_on_rent: Optional[Decimal] = Field(None, ge=0, description="Quantity currently on rent")



class ItemBriefResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: UUID
    name: str = Field(alias="item_name")

class LocationBriefResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: UUID
    name: str = Field(alias="location_name")

class StockLevelResponse(BaseModel):
    """Schema for stock level response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    item_id: UUID
    location_id: UUID
    quantity_on_hand: Decimal
    quantity_available: Decimal
    quantity_on_rent: Decimal
    is_active: bool
    created_at: datetime
    updated_at: datetime

    
    @computed_field
    @property
    def total_allocated(self) -> Decimal:
        """Total quantity allocated (available + on rent)."""
        return self.quantity_available + self.quantity_on_rent
    
    @computed_field
    @property
    def is_available_for_rent(self) -> bool:
        """Check if any quantity is available for rent."""
        return self.quantity_available > 0 and self.is_active


class StockLevelListResponse(BaseModel):
    """Schema for stock level list response with nested item and location details."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    item: ItemBriefResponse
    location: LocationBriefResponse
    quantity_on_hand: Decimal
    quantity_available: Decimal
    quantity_on_rent: Decimal
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def total_allocated(self) -> Decimal:
        """Total quantity allocated (available + on rent)."""
        return self.quantity_available + self.quantity_on_rent
    
    @computed_field
    @property
    def is_available_for_rent(self) -> bool:
        """Check if any quantity is available for rent."""
        return self.quantity_available > 0 and self.is_active


class StockAdjustment(BaseModel):
    """Schema for stock adjustment."""
    adjustment: int = Field(..., description="Adjustment amount (positive or negative)")
    reason: Optional[str] = Field(None, description="Reason for adjustment")


class StockReservation(BaseModel):
    """Schema for stock reservation."""
    quantity: int = Field(..., ge=1, description="Quantity to reserve")
    reason: Optional[str] = Field(None, description="Reason for reservation")


class StockReservationRelease(BaseModel):
    """Schema for releasing stock reservation."""
    quantity: int = Field(..., ge=1, description="Quantity to release")
    reason: Optional[str] = Field(None, description="Reason for release")


class InventoryUpdateRequest(BaseModel):
    """Schema for inventory update request."""
    transaction_line_item_id: UUID = Field(..., description="Transaction line item ID")
    item_id: UUID = Field(..., description="Item ID")
    location_id: UUID = Field(..., description="Location ID")
    quantity: int = Field(..., ge=1, description="Quantity to move")
    stock_movement_type: MovementType = Field(..., description="Stock movement type")
    remarks: Optional[str] = Field("", description="Additional remarks")


class InventoryUpdateResponse(BaseModel):
    """Schema for inventory update response."""
    stock_level_id: UUID
    item_id: UUID
    location_id: UUID
    quantity_on_hand: Decimal
    quantity_available: Decimal
    quantity_on_rent: Decimal
    stock_movement_id: UUID
    movement_type: MovementType
    quantity_change: Decimal


class InventoryReport(BaseModel):
    """Schema for inventory report."""
    
    items: List[Any]  # Will be ItemWithInventoryResponse from item_master
    total_items: int
    total_active_items: int
    total_inventory_units: int
    total_available_units: int
    total_rented_units: int
    items_needing_reorder: List[Any]  # Will be ItemListResponse from item_master
    
    
class InventoryUnitWithItemResponse(BaseModel):
    """Schema for inventory unit with item details."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    item_id: UUID
    location_id: UUID
    unit_code: str
    serial_number: Optional[str]
    status: InventoryUnitStatus
    condition: InventoryUnitCondition
    purchase_price: Decimal
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.unit_code}"
    
    @computed_field
    @property
    def full_display_name(self) -> str:
        """This will be populated by the service layer with item info."""
        return f"{self.unit_code}"


# Stock Movement Schemas

class StockMovementCreate(BaseModel):
    """Schema for creating a stock movement record."""
    stock_level_id: UUID = Field(..., description="Stock level ID")
    movement_type: MovementType = Field(..., description="Type of movement")
    reference_type: ReferenceType = Field(..., description="Type of reference")
    reference_id: str = Field(..., max_length=100, description="External reference ID")
    quantity_change: Decimal = Field(..., description="Quantity change (+/-)")
    quantity_before: Decimal = Field(..., ge=0, description="Quantity before movement")
    quantity_after: Decimal = Field(..., ge=0, description="Quantity after movement")
    reason: str = Field(..., max_length=500, description="Reason for movement")
    notes: Optional[str] = Field(None, description="Additional notes")
    transaction_line_id: Optional[UUID] = Field(None, description="Transaction line reference")


class StockMovementResponse(BaseModel):
    """Schema for stock movement response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    stock_level_id: UUID
    item_id: UUID
    location_id: UUID
    movement_type: MovementType
    reference_type: ReferenceType
    reference_id: Optional[str]
    quantity_change: Decimal
    quantity_before: Decimal
    quantity_after: Decimal
    reason: str
    notes: Optional[str]
    transaction_line_id: Optional[UUID]
    created_at: datetime
    updated_at: datetime
    created_by: Optional[UUID]
    is_active: bool
    
    @computed_field
    @property
    def is_increase(self) -> bool:
        """Check if this movement increases stock."""
        return self.quantity_change > 0
    
    @computed_field
    @property
    def is_decrease(self) -> bool:
        """Check if this movement decreases stock."""
        return self.quantity_change < 0
    
    @computed_field
    @property
    def display_name(self) -> str:
        """Get movement display name."""
        direction = "+" if self.quantity_change >= 0 else ""
        return f"{self.movement_type.value}: {direction}{self.quantity_change}"


class StockMovementListResponse(BaseModel):
    """Schema for stock movement list response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    movement_type: MovementType
    reference_type: ReferenceType
    reference_id: Optional[str]
    quantity_change: Decimal
    reason: str
    created_at: datetime
    created_by: Optional[UUID]


class StockMovementHistoryRequest(BaseModel):
    """Schema for requesting stock movement history."""
    stock_level_id: Optional[UUID] = Field(None, description="Filter by stock level ID")
    item_id: Optional[UUID] = Field(None, description="Filter by item ID")
    location_id: Optional[UUID] = Field(None, description="Filter by location ID")
    movement_type: Optional[MovementType] = Field(None, description="Filter by movement type")
    reference_type: Optional[ReferenceType] = Field(None, description="Filter by reference type")
    start_date: Optional[datetime] = Field(None, description="Start date for filtering")
    end_date: Optional[datetime] = Field(None, description="End date for filtering")
    skip: int = Field(default=0, ge=0, description="Number of records to skip")
    limit: int = Field(default=100, ge=1, le=1000, description="Number of records to return")


class StockMovementSummaryResponse(BaseModel):
    """Schema for stock movement summary response."""
    total_movements: int
    total_increases: Decimal
    total_decreases: Decimal
    net_change: Decimal
    movement_types: dict = Field(default_factory=dict)
    
    
class StockMovementReportRequest(BaseModel):
    """Schema for stock movement report request."""
    item_id: Optional[UUID] = Field(None, description="Filter by item ID")
    location_id: Optional[UUID] = Field(None, description="Filter by location ID")
    start_date: Optional[datetime] = Field(None, description="Start date for report")
    end_date: Optional[datetime] = Field(None, description="End date for report")
    movement_type: Optional[MovementType] = Field(None, description="Filter by movement type")
    include_summary: bool = Field(default=True, description="Include summary statistics")
    include_details: bool = Field(default=False, description="Include detailed movements")


# Item Inventory Overview and Detailed Schemas

class LocationStockInfo(BaseModel):
    """Schema for stock information at a specific location."""
    location_id: UUID
    location_name: str
    quantity_on_hand: Decimal
    quantity_available: Decimal
    quantity_on_rent: Decimal


class UnitsByStatus(BaseModel):
    """Schema for inventory units grouped by status."""
    available: int = 0
    rented: int = 0
    sold: int = 0
    maintenance: int = 0
    damaged: int = 0
    retired: int = 0


class ItemInventoryOverview(BaseModel):
    """Schema for item inventory overview - optimized for table display."""
    model_config = ConfigDict(from_attributes=True)
    
    # Item basic info
    id: UUID
    sku: str
    item_name: str
    item_status: ItemStatus
    brand_name: Optional[str]
    category_name: Optional[str]
    
    # Pricing info
    rental_rate_per_period: Optional[Decimal]
    sale_price: Optional[Decimal]
    is_rentable: bool
    is_saleable: bool
    
    # Inventory summary
    total_units: int
    units_by_status: UnitsByStatus
    
    # Stock summary
    total_quantity_on_hand: Decimal
    total_quantity_available: Decimal
    total_quantity_on_rent: Decimal
    
    # Status indicators
    stock_status: str  # IN_STOCK, LOW_STOCK, OUT_OF_STOCK
    reorder_point: int
    is_low_stock: bool
    
    # Timestamps
    created_at: datetime
    updated_at: datetime


class InventoryUnitDetail(BaseModel):
    """Schema for detailed inventory unit information."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    unit_code: str
    serial_number: Optional[str]
    status: InventoryUnitStatus
    condition: InventoryUnitCondition
    location_id: UUID
    location_name: str
    purchase_date: Optional[datetime]
    purchase_price: Decimal
    warranty_expiry: Optional[datetime]
    last_maintenance_date: Optional[datetime]
    next_maintenance_date: Optional[datetime]
    notes: Optional[str]
    created_at: datetime
    updated_at: datetime


class RecentMovement(BaseModel):
    """Schema for recent stock movements."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    movement_type: MovementType
    quantity_change: Decimal
    reason: str
    reference_type: ReferenceType
    reference_id: Optional[str]
    location_name: str
    created_at: datetime
    created_by_name: Optional[str]


class ItemInventoryDetailed(BaseModel):
    """Schema for detailed item inventory information."""
    model_config = ConfigDict(from_attributes=True)
    
    # Complete item details
    id: UUID
    sku: str
    item_name: str
    item_status: ItemStatus
    brand_id: Optional[UUID]
    brand_name: Optional[str]
    category_id: Optional[UUID]
    category_name: Optional[str]
    unit_of_measurement_id: UUID
    unit_of_measurement_name: str
    
    # Item specifications
    description: Optional[str]
    specifications: Optional[str]
    model_number: Optional[str]
    serial_number_required: bool
    warranty_period_days: str
    
    # Pricing and rental info
    rental_rate_per_period: Optional[Decimal]
    rental_period: str
    sale_price: Optional[Decimal]
    purchase_price: Optional[Decimal]
    security_deposit: Decimal
    is_rentable: bool
    is_saleable: bool
    
    # Inventory summary
    total_units: int
    units_by_status: UnitsByStatus
    
    # Detailed units list
    inventory_units: List[InventoryUnitDetail]
    
    # Stock levels by location
    stock_by_location: List[LocationStockInfo]
    
    # Aggregate stock info
    total_quantity_on_hand: Decimal
    total_quantity_available: Decimal
    total_quantity_on_rent: Decimal
    
    # Reorder info
    reorder_point: int
    stock_status: str
    is_low_stock: bool
    
    # Recent movements (last 10)
    recent_movements: List[RecentMovement]
    
    # Timestamps and audit
    is_active: bool
    created_at: datetime
    updated_at: datetime
    created_by: Optional[UUID]
    updated_by: Optional[UUID]


class ItemInventoryOverviewParams(BaseModel):
    """Query parameters for item inventory overview."""
    skip: int = Field(default=0, ge=0)
    limit: int = Field(default=100, ge=1, le=1000)
    item_status: Optional[ItemStatus] = None
    brand_id: Optional[UUID] = None
    category_id: Optional[UUID] = None
    stock_status: Optional[str] = Field(None, pattern="^(IN_STOCK|LOW_STOCK|OUT_OF_STOCK)$")
    is_rentable: Optional[bool] = None
    is_saleable: Optional[bool] = None
    search: Optional[str] = None
    sort_by: Optional[str] = Field(default="item_name", pattern="^(item_name|sku|created_at|total_units|stock_status)$")
    sort_order: Optional[str] = Field(default="asc", pattern="^(asc|desc)$")


# Inventory Update Service Schemas

class InventoryUpdateRequest(BaseModel):
    """Schema for inventory update request."""
    transaction_line_item_id: UUID = Field(..., description="Transaction line item ID")
    item_id: UUID = Field(..., description="Item ID")
    location_id: UUID = Field(..., description="Location ID")
    quantity: int = Field(..., gt=0, description="Quantity to process (always positive)")
    stock_movement_type: MovementType = Field(..., description="Type of stock movement")
    remarks: str = Field(default="", max_length=1000, description="Additional remarks")

    @field_validator('quantity')
    @classmethod
    def validate_quantity(cls, v):
        if v <= 0:
            raise ValueError('Quantity must be positive')
        return v


class InventoryUpdateResponse(BaseModel):
    """Schema for inventory update response."""
    model_config = ConfigDict(from_attributes=True)
    
    stock_movement_id: UUID = Field(..., description="Created stock movement ID")
    stock_level_id: UUID = Field(..., description="Updated stock level ID")
    item_id: UUID = Field(..., description="Item ID")
    location_id: UUID = Field(..., description="Location ID")
    movement_type: MovementType = Field(..., description="Movement type")
    quantity_change: Decimal = Field(..., description="Quantity change applied")
    quantity_before: Decimal = Field(..., description="Stock quantity before update")
    quantity_after: Decimal = Field(..., description="Stock quantity after update")
    quantity_on_rent_before: Decimal = Field(..., description="Quantity on rent before update")
    quantity_on_rent_after: Decimal = Field(..., description="Quantity on rent after update")
    quantity_available_before: Decimal = Field(..., description="Available quantity before update")
    quantity_available_after: Decimal = Field(..., description="Available quantity after update")
    created_at: datetime = Field(..., description="Creation timestamp")
    
    @computed_field
    @property
    def summary(self) -> str:
        """Get movement summary."""
        direction = "+" if self.quantity_change >= 0 else ""
        return f"{self.movement_type.value}: {direction}{self.quantity_change}"


===== modules/inventory/service.py â€“ 2025-07-21 09:52:53 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.master_data.item_master.models import Item, ItemStatus
from app.modules.master_data.locations.models import Location
from app.modules.inventory.models import (
    InventoryUnit, StockLevel, StockMovement, InventoryUnitStatus, InventoryUnitCondition,
    MovementType, ReferenceType
)
from app.modules.master_data.item_master.schemas import (
    ItemCreate, ItemUpdate, ItemResponse, ItemListResponse, ItemWithInventoryResponse,
    SKUGenerationRequest, SKUGenerationResponse, SKUBulkGenerationResponse
)
from app.modules.inventory.schemas import (
    InventoryUnitCreate, InventoryUnitUpdate, InventoryUnitResponse,
    StockLevelCreate, StockLevelUpdate, StockLevelResponse,
    StockAdjustment, StockReservation, StockReservationRelease,
    InventoryReport, StockMovementResponse, StockMovementHistoryRequest,
    StockMovementSummaryResponse, ItemInventoryOverview, ItemInventoryDetailed,
    UnitsByStatus, LocationStockInfo, InventoryUnitDetail, RecentMovement,
    ItemInventoryOverviewParams
)

# Import the segregated services
from .services import (
    ItemService, InventoryUnitService, StockLevelService, 
    StockMovementService, InventoryReportService
)
from .services.enhanced_inventory_update_service import EnhancedInventoryUpdateService


class InventoryService:
    """Service for inventory management operations - delegates to specialized services."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        # Initialize specialized services
        self.item_service = ItemService(session)
        self.inventory_unit_service = InventoryUnitService(session)
        self.stock_level_service = StockLevelService(session)
        self.stock_movement_service = StockMovementService(session)
        self.inventory_report_service = InventoryReportService(session)
        self.enhanced_inventory_update_service = EnhancedInventoryUpdateService(session)
    
    # Item operations - delegate to ItemService
    async def create_item(self, item_data: ItemCreate) -> ItemResponse:
        """Create a new item with automatic SKU generation."""
        return await self.item_service.create_item(item_data)
    
    async def get_item(self, item_id: UUID) -> ItemResponse:
        """Get item by ID."""
        return await self.item_service.get_item(item_id)
    
    async def get_item_by_code(self, item_code: str) -> ItemResponse:
        """Get item by code."""
        return await self.item_service.get_item_by_code(item_code)
    
    async def get_item_by_sku(self, sku: str) -> ItemResponse:
        """Get item by SKU."""
        return await self.item_service.get_item_by_sku(sku)
    
    async def get_items(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_status: Optional[ItemStatus] = None,
        brand_id: Optional[UUID] = None,
        category_id: Optional[UUID] = None,
        active_only: bool = True
    ) -> List[ItemListResponse]:
        """Get all items with optional filtering."""
        return await self.item_service.get_items(
            skip=skip, limit=limit, item_status=item_status,
            brand_id=brand_id, category_id=category_id, active_only=active_only
        )
    
    async def search_items(
        self, 
        search_term: str, 
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[ItemListResponse]:
        """Search items by name or code."""
        return await self.item_service.search_items(search_term, skip, limit, active_only)
    
    async def update_item(self, item_id: UUID, item_data: ItemUpdate) -> ItemResponse:
        """Update an item."""
        return await self.item_service.update_item(item_id, item_data)
    
    async def delete_item(self, item_id: UUID) -> bool:
        """Delete an item."""
        return await self.item_service.delete_item(item_id)
    
    async def get_rental_items(self, active_only: bool = True) -> List[ItemListResponse]:
        """Get all rental items."""
        return await self.item_service.get_rental_items(active_only)
    
    async def get_sale_items(self, active_only: bool = True) -> List[ItemListResponse]:
        """Get all sale items."""
        return await self.item_service.get_sale_items(active_only)
    
    async def generate_sku_preview(self, request: SKUGenerationRequest) -> SKUGenerationResponse:
        """Generate a preview of what SKU would be created."""
        return await self.item_service.generate_sku_preview(request)
    
    async def bulk_generate_skus(self) -> SKUBulkGenerationResponse:
        """Generate SKUs for all existing items that don't have them."""
        return await self.item_service.bulk_generate_skus()
    
    # Inventory Unit operations - delegate to InventoryUnitService
    async def create_inventory_unit(self, unit_data: InventoryUnitCreate) -> InventoryUnitResponse:
        """Create a new inventory unit."""
        return await self.inventory_unit_service.create_inventory_unit(unit_data)
    
    async def get_inventory_unit(self, unit_id: UUID) -> InventoryUnitResponse:
        """Get inventory unit by ID."""
        return await self.inventory_unit_service.get_inventory_unit(unit_id)
    
    async def get_inventory_units(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[InventoryUnitStatus] = None,
        condition: Optional[InventoryUnitCondition] = None,
        active_only: bool = True
    ) -> List[InventoryUnitResponse]:
        """Get all inventory units with optional filtering."""
        return await self.inventory_unit_service.get_inventory_units(
            skip=skip, limit=limit, item_id=item_id, location_id=location_id,
            status=status, condition=condition, active_only=active_only
        )
    
    async def get_available_units(
        self, 
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None
    ) -> List[InventoryUnitResponse]:
        """Get available inventory units."""
        return await self.inventory_unit_service.get_available_units(item_id, location_id)
    
    async def update_inventory_unit(self, unit_id: UUID, unit_data: InventoryUnitUpdate) -> InventoryUnitResponse:
        """Update an inventory unit."""
        return await self.inventory_unit_service.update_inventory_unit(unit_id, unit_data)
    
    async def update_unit_status(
        self, 
        unit_id: UUID, 
        status: InventoryUnitStatus,
        condition: Optional[InventoryUnitCondition] = None
    ) -> InventoryUnitResponse:
        """Update inventory unit status."""
        return await self.inventory_unit_service.update_unit_status(unit_id, status, condition)
    
    async def rent_out_unit(self, unit_id: UUID) -> InventoryUnitResponse:
        """Rent out an inventory unit."""
        return await self.inventory_unit_service.rent_out_unit(unit_id)
    
    async def return_unit_from_rent(
        self, 
        unit_id: UUID, 
        condition: Optional[InventoryUnitCondition] = None
    ) -> InventoryUnitResponse:
        """Return unit from rental."""
        return await self.inventory_unit_service.return_unit_from_rent(unit_id, condition)
    
    async def sell_unit(self, unit_id: UUID) -> InventoryUnitResponse:
        """Sell an inventory unit."""
        return await self.inventory_unit_service.sell_unit(unit_id)
    
    async def update_inventory_unit_status(
        self,
        unit_id: UUID,
        status: str,
        condition: Optional[str] = None,
        notes: Optional[str] = None
    ) -> None:
        """Update inventory unit status and condition for rental returns."""
        return await self.inventory_unit_service.update_inventory_unit_status(
            unit_id, status, condition, notes
        )
    
    async def create_initial_stock(
        self, 
        item_id: UUID, 
        item_sku: str, 
        purchase_price: Optional[Decimal], 
        quantity: int,
        location_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """Create initial stock for a new item."""
        return await self.inventory_unit_service.create_initial_stock(
            item_id, item_sku, purchase_price, quantity, location_id
        )
    
    # Stock Level operations - delegate to StockLevelService
    async def create_stock_level(self, stock_data: StockLevelCreate) -> StockLevelResponse:
        """Create a new stock level."""
        return await self.stock_level_service.create_stock_level(stock_data)
    
    async def get_stock_level(self, stock_id: UUID) -> StockLevelResponse:
        """Get stock level by ID."""
        return await self.stock_level_service.get_stock_level(stock_id)
    
    async def get_stock_levels(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        active_only: bool = True
    ) -> List[StockLevelResponse]:
        """Get all stock levels with optional filtering."""
        return await self.stock_level_service.get_stock_levels(
            skip=skip, limit=limit, item_id=item_id, location_id=location_id, active_only=active_only
        )
    
    async def update_stock_level(self, stock_id: UUID, stock_data: StockLevelUpdate) -> StockLevelResponse:
        """Update a stock level."""
        return await self.stock_level_service.update_stock_level(stock_id, stock_data)
    
    async def adjust_stock(self, stock_id: UUID, adjustment_data: StockAdjustment) -> StockLevelResponse:
        """Adjust stock quantity."""
        return await self.stock_level_service.adjust_stock(stock_id, adjustment_data)
    
    async def reserve_stock(self, stock_id: UUID, reservation_data: StockReservation) -> StockLevelResponse:
        """Reserve stock quantity."""
        return await self.stock_level_service.reserve_stock(stock_id, reservation_data)
    
    async def release_stock_reservation(self, stock_id: UUID, release_data: StockReservationRelease) -> StockLevelResponse:
        """Release stock reservation."""
        return await self.stock_level_service.release_stock_reservation(stock_id, release_data)
    
    async def get_low_stock_items(self) -> List[StockLevelResponse]:
        """Get items with low stock."""
        return await self.stock_level_service.get_low_stock_items()
    
    async def adjust_stock_level(
        self,
        item_id: UUID,
        location_id: UUID,
        quantity_change: Decimal,
        transaction_type: str,
        reference_id: str,
        notes: Optional[str] = None
    ) -> StockLevelResponse:
        """Adjust stock level for return processing."""
        return await self.stock_level_service.adjust_stock_level(
            item_id, location_id, quantity_change, transaction_type, reference_id, notes
        )
    
    async def update_stock_condition(
        self,
        item_id: UUID,
        location_id: UUID,
        quantity: Decimal,
        condition: str,
        status: str
    ) -> None:
        """Update stock condition for items without individual unit tracking."""
        return await self.stock_level_service.update_stock_condition(
            item_id, location_id, quantity, condition, status
        )
    
    async def rent_out_stock(
        self,
        stock_level_id: UUID,
        quantity: Decimal,
        transaction_id: str,
        updated_by: Optional[str] = None
    ) -> StockLevelResponse:
        """Move stock from available to on rent."""
        return await self.stock_level_service.rent_out_stock(
            stock_level_id, quantity, transaction_id, updated_by
        )
    
    async def return_from_rent(
        self,
        stock_level_id: UUID,
        quantity: Decimal,
        transaction_id: str,
        updated_by: Optional[str] = None
    ) -> StockLevelResponse:
        """Move stock from on rent back to available."""
        return await self.stock_level_service.return_from_rent(
            stock_level_id, quantity, transaction_id, updated_by
        )
    
    # Stock Movement operations - delegate to StockMovementService
    async def get_stock_movements_by_stock_level(
        self,
        stock_level_id: UUID,
        skip: int = 0,
        limit: int = 100
    ) -> List[StockMovementResponse]:
        """Get stock movements for a specific stock level."""
        return await self.stock_movement_service.get_stock_movements_by_stock_level(
            stock_level_id, skip, limit
        )
    
    async def get_stock_movements_by_item(
        self,
        item_id: UUID,
        skip: int = 0,
        limit: int = 100,
        movement_type: Optional[MovementType] = None
    ) -> List[StockMovementResponse]:
        """Get stock movements for a specific item."""
        return await self.stock_movement_service.get_stock_movements_by_item(
            item_id, skip, limit, movement_type
        )
    
    async def get_stock_movements_by_reference(
        self,
        reference_type: ReferenceType,
        reference_id: str
    ) -> List[StockMovementResponse]:
        """Get stock movements by reference."""
        return await self.stock_movement_service.get_stock_movements_by_reference(
            reference_type, reference_id
        )
    
    async def get_stock_movements_by_date_range(
        self,
        start_date: datetime,
        end_date: datetime,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        movement_type: Optional[MovementType] = None
    ) -> List[StockMovementResponse]:
        """Get stock movements within a date range."""
        return await self.stock_movement_service.get_stock_movements_by_date_range(
            start_date, end_date, item_id, location_id, movement_type
        )
    
    async def get_stock_movement_summary(
        self,
        item_id: UUID,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> StockMovementSummaryResponse:
        """Get movement summary for an item."""
        return await self.stock_movement_service.get_stock_movement_summary(
            item_id, start_date, end_date
        )
    
    async def create_manual_stock_movement(
        self,
        stock_level_id: UUID,
        movement_type: MovementType,
        quantity_change: Decimal,
        reason: str,
        notes: Optional[str] = None,
        created_by: Optional[str] = None
    ) -> StockMovementResponse:
        """Create a manual stock movement record."""
        return await self.stock_movement_service.create_manual_stock_movement(
            stock_level_id, movement_type, quantity_change, reason, notes, created_by
        )
    
    # Enhanced inventory update operations
    async def update_inventory_stock(
        self,
        transaction_line_item_id: UUID,
        item_id: UUID,
        location_id: UUID,
        quantity: int,
        stock_movement_type: MovementType,
        remarks: str = "",
        reference_type: ReferenceType = ReferenceType.TRANSACTION,
        reference_id: Optional[str] = None,
        created_by: Optional[UUID] = None
    ) -> dict:
        """Update inventory stock levels with proper rental tracking."""
        return await self.enhanced_inventory_update_service.update_inventory(
            transaction_line_item_id=transaction_line_item_id,
            item_id=item_id,
            location_id=location_id,
            quantity=quantity,
            stock_movement_type=stock_movement_type,
            remarks=remarks,
            reference_type=reference_type,
            reference_id=reference_id,
            created_by=created_by
        )
    
    # Reporting operations - delegate to InventoryReportService
    async def get_inventory_report(self) -> InventoryReport:
        """Get comprehensive inventory report."""
        return await self.inventory_report_service.get_inventory_report()
    
    async def get_items_inventory_overview(
        self,
        params: ItemInventoryOverviewParams
    ) -> List[ItemInventoryOverview]:
        """Get inventory overview for multiple items - optimized for table display."""
        return await self.inventory_report_service.get_items_inventory_overview(params)
    
    async def get_item_inventory_detailed(self, item_id: UUID) -> ItemInventoryDetailed:
        """Get detailed inventory information for a single item."""
        return await self.inventory_report_service.get_item_inventory_detailed(item_id)

===== modules/inventory/legacy_code/routes_temp.py â€“ 2025-07-21 15:55:54 IST =====
# from typing import List, Optional
# from uuid import UUID
# from datetime import datetime
# from decimal import Decimal
# from fastapi import APIRouter, Depends, HTTPException, status, Query
# from sqlalchemy.ext.asyncio import AsyncSession

# from app.shared.dependencies import get_session
# from app.modules.inventory.service import InventoryService
# from app.modules.master_data.item_master.models import ItemStatus
# from app.modules.inventory.models import InventoryUnitStatus, InventoryUnitCondition, MovementType, ReferenceType
# from app.modules.master_data.item_master.schemas import (
#     ItemCreate, ItemUpdate, ItemResponse, ItemListResponse, ItemWithInventoryResponse,
#     SKUGenerationRequest, SKUGenerationResponse, SKUBulkGenerationResponse
# )
# from app.modules.inventory.schemas import (
#     InventoryUnitCreate, InventoryUnitUpdate, InventoryUnitResponse, InventoryUnitListResponse,
#     InventoryUnitStatusUpdate,
#     StockLevelCreate, StockLevelUpdate, StockLevelResponse, StockLevelListResponse,
#     StockAdjustment, StockReservation, StockReservationRelease,
#     InventoryUpdateRequest, InventoryUpdateResponse,
#     InventoryReport, StockMovementResponse, StockMovementHistoryRequest,
#     StockMovementSummaryResponse, ItemInventoryOverview, ItemInventoryDetailed,
#     ItemInventoryOverviewParams
# )
# from app.core.errors import NotFoundError, ValidationError, ConflictError


# router = APIRouter(tags=["inventory"])


# def get_inventory_service(session: AsyncSession = Depends(get_session)) -> InventoryService:
#     """Get inventory service instance."""
#     return InventoryService(session)


# # Item endpoints
# @router.post("/items", response_model=ItemResponse, status_code=status.HTTP_201_CREATED)
# async def create_item(
#     item_data: ItemCreate,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Create a new item."""
#     try:
#         return await service.create_item(item_data)
#     except ConflictError as e:
#         raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# # Item Inventory Overview and Detailed Endpoints (must come before {item_id} route)

# @router.get("/items/overview", response_model=List[ItemInventoryOverview])
# async def get_items_inventory_overview(
#     skip: int = Query(0, ge=0),
#     limit: int = Query(100, ge=1, le=1000),
#     item_status: Optional[ItemStatus] = None,
#     brand_id: Optional[UUID] = None,
#     category_id: Optional[UUID] = None,
#     stock_status: Optional[str] = Query(None, regex="^(IN_STOCK|LOW_STOCK|OUT_OF_STOCK)$"),
#     is_rentable: Optional[bool] = None,
#     is_saleable: Optional[bool] = None,
#     search: Optional[str] = None,
#     sort_by: Optional[str] = Query(default="item_name", regex="^(item_name|sku|created_at|total_units|stock_status)$"),
#     sort_order: Optional[str] = Query(default="asc", regex="^(asc|desc)$"),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get inventory overview for all items - optimized for table display."""
#     try:
#         params = ItemInventoryOverviewParams(
#             skip=skip,
#             limit=limit,
#             item_status=item_status,
#             brand_id=brand_id,
#             category_id=category_id,
#             stock_status=stock_status,
#             is_rentable=is_rentable,
#             is_saleable=is_saleable,
#             search=search,
#             sort_by=sort_by,
#             sort_order=sort_order
#         )
#         return await service.get_items_inventory_overview(params)
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.get("/items/{item_id}/detailed", response_model=ItemInventoryDetailed)
# async def get_item_inventory_detailed(
#     item_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get detailed inventory information for a single item."""
#     try:
#         return await service.get_item_inventory_detailed(item_id)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.get("/items/rental", response_model=List[ItemListResponse])
# async def get_rental_items(
#     active_only: bool = Query(True),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get all rental items."""
#     return await service.get_rental_items(active_only=active_only)


# @router.get("/items/sale", response_model=List[ItemListResponse])
# async def get_sale_items(
#     active_only: bool = Query(True),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get all sale items."""
#     return await service.get_sale_items(active_only=active_only)


# @router.get("/items/{item_id}", response_model=ItemResponse)
# async def get_item(
#     item_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get item by ID."""
#     try:
#         return await service.get_item(item_id)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/items/code/{item_code}", response_model=ItemResponse)
# async def get_item_by_code(
#     item_code: str,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get item by code."""
#     try:
#         return await service.get_item_by_code(item_code)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/items", response_model=List[ItemListResponse])
# async def get_items(
#     skip: int = Query(0, ge=0),
#     limit: int = Query(100, ge=1, le=1000),
#     item_status: Optional[ItemStatus] = None,
#     brand_id: Optional[UUID] = None,
#     category_id: Optional[UUID] = None,
#     active_only: bool = Query(True),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get all items with optional filtering."""
#     return await service.get_items(
#         skip=skip,
#         limit=limit,
#         item_status=item_status,
#         brand_id=brand_id,
#         category_id=category_id,
#         active_only=active_only
#     )


# @router.get("/items/search/{search_term}", response_model=List[ItemListResponse])
# async def search_items(
#     search_term: str,
#     skip: int = Query(0, ge=0),
#     limit: int = Query(100, ge=1, le=1000),
#     active_only: bool = Query(True),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Search items by name or code."""
#     return await service.search_items(
#         search_term=search_term,
#         skip=skip,
#         limit=limit,
#         active_only=active_only
#     )


# @router.put("/items/{item_id}", response_model=ItemResponse)
# async def update_item(
#     item_id: UUID,
#     item_data: ItemUpdate,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Update an item."""
#     try:
#         return await service.update_item(item_id, item_data)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT)
# async def delete_item(
#     item_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Delete an item."""
#     try:
#         success = await service.delete_item(item_id)
#         if not success:
#             raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Item not found")
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# # Moved to before the {item_id} route to avoid routing conflicts


# # Inventory Unit endpoints
# @router.post("/units", response_model=InventoryUnitResponse, status_code=status.HTTP_201_CREATED)
# async def create_inventory_unit(
#     unit_data: InventoryUnitCreate,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Create a new inventory unit."""
#     try:
#         return await service.create_inventory_unit(unit_data)
#     except ConflictError as e:
#         raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
#     except (NotFoundError, ValidationError) as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.get("/units/{unit_id}", response_model=InventoryUnitResponse)
# async def get_inventory_unit(
#     unit_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get inventory unit by ID."""
#     try:
#         return await service.get_inventory_unit(unit_id)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/units", response_model=List[InventoryUnitResponse])
# async def get_inventory_units(
#     skip: int = Query(0, ge=0),
#     limit: int = Query(100, ge=1, le=1000),
#     item_id: Optional[UUID] = None,
#     location_id: Optional[UUID] = None,
#     status: Optional[InventoryUnitStatus] = None,
#     condition: Optional[InventoryUnitCondition] = None,
#     active_only: bool = Query(True),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get all inventory units with optional filtering."""
#     return await service.get_inventory_units(
#         skip=skip,
#         limit=limit,
#         item_id=item_id,
#         location_id=location_id,
#         status=status,
#         condition=condition,
#         active_only=active_only
#     )


# @router.get("/units/available", response_model=List[InventoryUnitResponse])
# async def get_available_units(
#     item_id: Optional[UUID] = None,
#     location_id: Optional[UUID] = None,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get available inventory units."""
#     return await service.get_available_units(
#         item_id=item_id,
#         location_id=location_id
#     )


# @router.put("/units/{unit_id}", response_model=InventoryUnitResponse)
# async def update_inventory_unit(
#     unit_id: UUID,
#     unit_data: InventoryUnitUpdate,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Update an inventory unit."""
#     try:
#         return await service.update_inventory_unit(unit_id, unit_data)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/units/{unit_id}/status", response_model=InventoryUnitResponse)
# async def update_unit_status(
#     unit_id: UUID,
#     status_data: InventoryUnitStatusUpdate,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Update inventory unit status."""
#     try:
#         return await service.update_unit_status(
#             unit_id=unit_id,
#             status=status_data.status,
#             condition=status_data.condition
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/units/{unit_id}/rent", response_model=InventoryUnitResponse)
# async def rent_out_unit(
#     unit_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Rent out an inventory unit."""
#     try:
#         return await service.rent_out_unit(unit_id)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/units/{unit_id}/return", response_model=InventoryUnitResponse)
# async def return_unit_from_rent(
#     unit_id: UUID,
#     condition: Optional[InventoryUnitCondition] = None,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Return unit from rental."""
#     try:
#         return await service.return_unit_from_rent(unit_id, condition)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/units/{unit_id}/sell", response_model=InventoryUnitResponse)
# async def sell_unit(
#     unit_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Sell an inventory unit."""
#     try:
#         return await service.sell_unit(unit_id)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# # Stock Level endpoints
# @router.post("/stock", response_model=StockLevelResponse, status_code=status.HTTP_201_CREATED)
# async def create_stock_level(
#     stock_data: StockLevelCreate,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Create a new stock level."""
#     try:
#         return await service.create_stock_level(stock_data)
#     except ConflictError as e:
#         raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.get("/stock/{stock_id}", response_model=StockLevelResponse)
# async def get_stock_level(
#     stock_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get stock level by ID."""
#     try:
#         return await service.get_stock_level(stock_id)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/stock", response_model=List[StockLevelListResponse])
# async def get_stock_levels(
#     skip: int = Query(0, ge=0),
#     limit: int = Query(100, ge=1, le=1000),
#     item_id: Optional[UUID] = None,
#     location_id: Optional[UUID] = None,
#     active_only: bool = Query(True),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get all stock levels with optional filtering."""
#     return await service.get_stock_levels(
#         skip=skip,
#         limit=limit,
#         item_id=item_id,
#         location_id=location_id,
#         active_only=active_only
#     )


# @router.put("/stock/{stock_id}", response_model=StockLevelResponse)
# async def update_stock_level(
#     stock_id: UUID,
#     stock_data: StockLevelUpdate,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Update a stock level."""
#     try:
#         return await service.update_stock_level(stock_id, stock_data)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/stock/{stock_id}/adjust", response_model=StockLevelResponse)
# async def adjust_stock(
#     stock_id: UUID,
#     adjustment_data: StockAdjustment,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Adjust stock quantity."""
#     try:
#         return await service.adjust_stock(stock_id, adjustment_data)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/stock/{stock_id}/reserve", response_model=StockLevelResponse)
# async def reserve_stock(
#     stock_id: UUID,
#     reservation_data: StockReservation,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Reserve stock quantity."""
#     try:
#         return await service.reserve_stock(stock_id, reservation_data)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/stock/{stock_id}/release", response_model=StockLevelResponse)
# async def release_stock_reservation(
#     stock_id: UUID,
#     release_data: StockReservationRelease,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Release stock reservation."""
#     try:
#         return await service.release_stock_reservation(stock_id, release_data)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.get("/stock/low", response_model=List[StockLevelResponse])
# async def get_low_stock_items(
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get items with low stock."""
#     return await service.get_low_stock_items()


# @router.post("/stock/update", response_model=InventoryUpdateResponse)
# async def update_inventory_stock(
#     request: InventoryUpdateRequest,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Update inventory stock levels with rental tracking."""
#     try:
#         result = await service.update_inventory_stock(
#             transaction_line_item_id=request.transaction_line_item_id,
#             item_id=request.item_id,
#             location_id=request.location_id,
#             quantity=request.quantity,
#             stock_movement_type=request.stock_movement_type,
#             remarks=request.remarks
#         )
#         return InventoryUpdateResponse(**result)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# # Reporting endpoints
# @router.get("/report", response_model=InventoryReport)
# async def get_inventory_report(
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get comprehensive inventory report."""
#     return await service.get_inventory_report()


# # SKU-specific endpoints
# @router.get("/items/sku/{sku}", response_model=ItemResponse)
# async def get_item_by_sku(
#     sku: str,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get item by SKU."""
#     try:
#         return await service.get_item_by_sku(sku)
#     except NotFoundError as e:
#         raise HTTPException(
#             status_code=status.HTTP_404_NOT_FOUND,
#             detail=str(e)
#         )


# @router.post("/skus/generate", response_model=SKUGenerationResponse)
# async def generate_sku_preview(
#     request: SKUGenerationRequest,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Generate a preview of what SKU would be created for the given brand/category."""
#     return await service.generate_sku_preview(request)


# # SKU validation endpoint removed - custom SKUs are no longer supported


# @router.post("/skus/bulk-generate", response_model=SKUBulkGenerationResponse)
# async def bulk_generate_skus(
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Generate SKUs for all existing items that don't have them."""
#     return await service.bulk_generate_skus()


# # Stock Query endpoints for initial stock integration
# @router.get("/items/{item_id}/stock", response_model=List[StockLevelResponse])
# async def get_item_stock_levels(
#     item_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get all stock levels for a specific item across all locations."""
#     try:
#         return await service.get_stock_levels(item_id=item_id)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/items/{item_id}/units", response_model=List[InventoryUnitResponse])
# async def get_item_inventory_units(
#     item_id: UUID,
#     location_id: Optional[UUID] = None,
#     status: Optional[InventoryUnitStatus] = None,
#     condition: Optional[InventoryUnitCondition] = None,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get all inventory units for a specific item with optional filtering."""
#     try:
#         return await service.get_inventory_units(
#             item_id=item_id,
#             location_id=location_id,
#             status=status,
#             condition=condition
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/items/{item_id}/stock-summary")
# async def get_item_stock_summary(
#     item_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get comprehensive stock summary for an item."""
#     try:
#         # Get all stock levels for the item
#         stock_levels = await service.get_stock_levels(item_id=item_id)
        
#         # Get all inventory units for the item
#         inventory_units = await service.get_inventory_units(item_id=item_id)
        
#         # Calculate summary statistics
#         total_on_hand = sum(float(stock.quantity_on_hand) for stock in stock_levels)
#         total_available = sum(float(stock.quantity_available) for stock in stock_levels)
#         total_on_rent = sum(float(stock.quantity_on_rent) for stock in stock_levels)
        
#         # Count units by status
#         units_by_status = {}
#         for unit in inventory_units:
#             status_key = unit.status.value
#             units_by_status[status_key] = units_by_status.get(status_key, 0) + 1
        
#         # Count units by location
#         units_by_location = {}
#         for unit in inventory_units:
#             loc_key = str(unit.location_id)
#             units_by_location[loc_key] = units_by_location.get(loc_key, 0) + 1
        
#         return {
#             "item_id": str(item_id),
#             "total_stock_levels": len(stock_levels),
#             "total_inventory_units": len(inventory_units),
#             "aggregate_quantities": {
#                 "on_hand": total_on_hand,
#                 "available": total_available,
#                 "on_rent": total_on_rent
#             },
#             "units_by_status": units_by_status,
#             "units_by_location": units_by_location,
#             "stock_levels": stock_levels,
#             "has_initial_stock": len(inventory_units) > 0
#         }
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/locations/{location_id}/stock", response_model=List[StockLevelResponse])
# async def get_location_stock_levels(
#     location_id: UUID,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get all stock levels at a specific location."""
#     try:
#         return await service.get_stock_levels(location_id=location_id)
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# # Stock Movement Endpoints

# @router.get("/stock/{stock_level_id}/movements", response_model=List[StockMovementResponse])
# async def get_stock_level_movements(
#     stock_level_id: UUID,
#     skip: int = Query(default=0, ge=0, description="Number of records to skip"),
#     limit: int = Query(default=100, ge=1, le=1000, description="Number of records to return"),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get stock movements for a specific stock level."""
#     try:
#         return await service.get_stock_movements_by_stock_level(
#             stock_level_id=stock_level_id,
#             skip=skip,
#             limit=limit
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/items/{item_id}/movements", response_model=List[StockMovementResponse])
# async def get_item_movements(
#     item_id: UUID,
#     skip: int = Query(default=0, ge=0, description="Number of records to skip"),
#     limit: int = Query(default=100, ge=1, le=1000, description="Number of records to return"),
#     movement_type: Optional[MovementType] = Query(default=None, description="Filter by movement type"),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get stock movements for a specific item."""
#     try:
#         return await service.get_stock_movements_by_item(
#             item_id=item_id,
#             skip=skip,
#             limit=limit,
#             movement_type=movement_type
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/movements/reference/{reference_type}/{reference_id}", response_model=List[StockMovementResponse])
# async def get_movements_by_reference(
#     reference_type: ReferenceType,
#     reference_id: str,
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get stock movements by reference."""
#     try:
#         return await service.get_stock_movements_by_reference(
#             reference_type=reference_type,
#             reference_id=reference_id
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/movements/range", response_model=List[StockMovementResponse])
# async def get_movements_by_date_range(
#     start_date: datetime = Query(..., description="Start date"),
#     end_date: datetime = Query(..., description="End date"),
#     item_id: Optional[UUID] = Query(default=None, description="Filter by item ID"),
#     location_id: Optional[UUID] = Query(default=None, description="Filter by location ID"),
#     movement_type: Optional[MovementType] = Query(default=None, description="Filter by movement type"),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get stock movements within a date range."""
#     try:
#         return await service.get_stock_movements_by_date_range(
#             start_date=start_date,
#             end_date=end_date,
#             item_id=item_id,
#             location_id=location_id,
#             movement_type=movement_type
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.get("/items/{item_id}/movements/summary", response_model=StockMovementSummaryResponse)
# async def get_item_movement_summary(
#     item_id: UUID,
#     start_date: Optional[datetime] = Query(default=None, description="Start date for summary"),
#     end_date: Optional[datetime] = Query(default=None, description="End date for summary"),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Get movement summary for an item."""
#     try:
#         return await service.get_stock_movement_summary(
#             item_id=item_id,
#             start_date=start_date,
#             end_date=end_date
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# @router.post("/stock/{stock_level_id}/movements/manual", response_model=StockMovementResponse)
# async def create_manual_stock_movement(
#     stock_level_id: UUID,
#     movement_type: MovementType = Query(..., description="Type of movement"),
#     quantity_change: Decimal = Query(..., description="Quantity change (+/-)"),
#     reason: str = Query(..., description="Reason for movement"),
#     notes: Optional[str] = Query(default=None, description="Additional notes"),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Create a manual stock movement."""
#     try:
#         return await service.create_manual_stock_movement(
#             stock_level_id=stock_level_id,
#             movement_type=movement_type,
#             quantity_change=quantity_change,
#             reason=reason,
#             notes=notes
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/stock/{stock_level_id}/rent-out", response_model=StockMovementResponse)
# async def rent_out_stock(
#     stock_level_id: UUID,
#     quantity: Decimal = Query(..., ge=0, description="Quantity to rent out"),
#     transaction_id: str = Query(..., description="Transaction ID"),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Move stock from available to on rent."""
#     try:
#         return await service.rent_out_stock(
#             stock_level_id=stock_level_id,
#             quantity=quantity,
#             transaction_id=transaction_id
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


# @router.post("/stock/{stock_level_id}/return-from-rent", response_model=StockMovementResponse)
# async def return_from_rent(
#     stock_level_id: UUID,
#     quantity: Decimal = Query(..., ge=0, description="Quantity to return"),
#     transaction_id: str = Query(..., description="Transaction ID"),
#     service: InventoryService = Depends(get_inventory_service)
# ):
#     """Move stock from on rent back to available."""
#     try:
#         return await service.return_from_rent(
#             stock_level_id=stock_level_id,
#             quantity=quantity,
#             transaction_id=transaction_id
#         )
#     except NotFoundError as e:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
#     except ValidationError as e:
#         raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))

===== modules/inventory/units/__init__.py â€“ 2025-07-20 21:17:04 IST =====
"""
Inventory units module.

This module contains all unit-related functionality for the inventory system:
- InventoryUnit model
- InventoryUnitRepository for data access
- Unit status and condition enums
"""

from .models import InventoryUnit
from .repository import InventoryUnitRepository

__all__ = ["InventoryUnit", "InventoryUnitRepository"]


===== modules/inventory/units/models.py â€“ 2025-07-21 20:25:47 IST =====
from typing import Optional, TYPE_CHECKING
from decimal import Decimal
from datetime import datetime
from sqlalchemy import Column, String, Numeric, Boolean, Text, DateTime, ForeignKey, Index
from sqlalchemy.orm import relationship

from app.db.base import BaseModel, UUIDType
from app.modules.inventory.enums import InventoryUnitStatus, InventoryUnitCondition

if TYPE_CHECKING:
    from app.modules.master_data.item_master.models import Item
    from app.modules.master_data.locations.models import Location


class InventoryUnit(BaseModel):
    """
    Inventory unit model for tracking individual units of items.
    
    Attributes:
        item_id: Item ID
        location_id: Location ID
        unit_code: Unique unit code
        serial_number: Serial number
        status: Unit status
        condition: Unit condition
        purchase_date: Purchase date
        purchase_price: Purchase price
        warranty_expiry: Warranty expiry date
        last_maintenance_date: Last maintenance date
        next_maintenance_date: Next maintenance date
        notes: Additional notes
        item: Item relationship
        location: Location relationship
    """
    
    __tablename__ = "inventory_units"
    
    item_id = Column(UUIDType(), ForeignKey("items.id"), nullable=False, comment="Item ID")
    location_id = Column(UUIDType(), ForeignKey("locations.id"), nullable=False, comment="Location ID")
    unit_code = Column(String(50), nullable=False, unique=True, index=True, comment="Unique unit code")
    serial_number = Column(String(100), nullable=True, comment="Serial number")
    status = Column(String(20), nullable=False, default=InventoryUnitStatus.AVAILABLE.value, comment="Unit status")
    condition = Column(String(20), nullable=False, default=InventoryUnitCondition.NEW.value, comment="Unit condition")
    purchase_date = Column(DateTime, nullable=True, comment="Purchase date")
    purchase_price = Column(Numeric(10, 2), nullable=False, default=0.00, comment="Purchase price")
    warranty_expiry = Column(DateTime, nullable=True, comment="Warranty expiry date")
    last_maintenance_date = Column(DateTime, nullable=True, comment="Last maintenance date")
    next_maintenance_date = Column(DateTime, nullable=True, comment="Next maintenance date")
    notes = Column(Text, nullable=True, comment="Additional notes")
    
    # Relationships
    item = relationship("Item", back_populates="inventory_units", lazy="select")
    # location = relationship("Location", back_populates="inventory_units", lazy="select")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_inventory_unit_code', 'unit_code'),
        Index('idx_inventory_unit_item', 'item_id'),
        Index('idx_inventory_unit_location', 'location_id'),
        Index('idx_inventory_unit_status', 'status'),
        Index('idx_inventory_unit_condition', 'condition'),
        Index('idx_inventory_unit_serial', 'serial_number'),
    )
    
    def __init__(
        self,
        item_id: str,
        location_id: str,
        unit_code: str,
        serial_number: Optional[str] = None,
        status: InventoryUnitStatus = InventoryUnitStatus.AVAILABLE,
        condition: InventoryUnitCondition = InventoryUnitCondition.NEW,
        purchase_price: Decimal = Decimal("0.00"),
        **kwargs
    ):
        """
        Initialize an Inventory Unit.
        
        Args:
            item_id: Item ID
            location_id: Location ID
            unit_code: Unique unit code
            serial_number: Serial number
            status: Unit status
            condition: Unit condition
            purchase_price: Purchase price
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.item_id = item_id
        self.location_id = location_id
        self.unit_code = unit_code
        self.serial_number = serial_number
        self.status = status.value if isinstance(status, InventoryUnitStatus) else status
        self.condition = condition.value if isinstance(condition, InventoryUnitCondition) else condition
        self.purchase_price = purchase_price
        self._validate()
    
    def _validate(self):
        """Validate inventory unit business rules."""
        # Code validation
        if not self.unit_code or not self.unit_code.strip():
            raise ValueError("Unit code cannot be empty")
        
        if len(self.unit_code) > 50:
            raise ValueError("Unit code cannot exceed 50 characters")
        
        # Serial number validation
        if self.serial_number and len(self.serial_number) > 100:
            raise ValueError("Serial number cannot exceed 100 characters")
        
        # Status validation
        if self.status not in [status.value for status in InventoryUnitStatus]:
            raise ValueError(f"Invalid unit status: {self.status}")
        
        # Condition validation
        if self.condition not in [condition.value for condition in InventoryUnitCondition]:
            raise ValueError(f"Invalid unit condition: {self.condition}")
        
        # Price validation
        if self.purchase_price < 0:
            raise ValueError("Purchase price cannot be negative")
    
    def is_available(self) -> bool:
        """Check if unit is available."""
        return self.status == InventoryUnitStatus.AVAILABLE.value and self.is_active
    
    def is_rented(self) -> bool:
        """Check if unit is rented."""
        return self.status == InventoryUnitStatus.RENTED.value
    
    def is_sold(self) -> bool:
        """Check if unit is sold."""
        return self.status == InventoryUnitStatus.SOLD.value
    
    def is_in_maintenance(self) -> bool:
        """Check if unit is in maintenance."""
        return self.status == InventoryUnitStatus.MAINTENANCE.value
    
    def is_damaged(self) -> bool:
        """Check if unit is damaged."""
        return self.status == InventoryUnitStatus.DAMAGED.value
    
    def is_retired(self) -> bool:
        """Check if unit is retired."""
        return self.status == InventoryUnitStatus.RETIRED.value
    
    def rent_out(self, updated_by: Optional[str] = None):
        """Mark unit as rented."""
        if not self.is_available():
            raise ValueError("Unit is not available for rental")
        
        self.status = InventoryUnitStatus.RENTED.value
        self.updated_by = updated_by
    
    def return_from_rent(self, condition: Optional[InventoryUnitCondition] = None, updated_by: Optional[str] = None):
        """Return unit from rental."""
        if not self.is_rented():
            raise ValueError("Unit is not currently rented")
        
        self.status = InventoryUnitStatus.AVAILABLE.value
        if condition:
            self.condition = condition.value
        
        self.updated_by = updated_by
    
    def mark_as_sold(self, updated_by: Optional[str] = None):
        """Mark unit as sold."""
        if not self.is_available():
            raise ValueError("Unit is not available for sale")
        
        self.status = InventoryUnitStatus.SOLD.value
        self.updated_by = updated_by
    
    def send_for_maintenance(self, updated_by: Optional[str] = None):
        """Send unit for maintenance."""
        self.status = InventoryUnitStatus.MAINTENANCE.value
        self.last_maintenance_date = datetime.utcnow()
        self.updated_by = updated_by
    
    def return_from_maintenance(self, condition: InventoryUnitCondition, updated_by: Optional[str] = None):
        """Return unit from maintenance."""
        if not self.is_in_maintenance():
            raise ValueError("Unit is not in maintenance")
        
        self.status = InventoryUnitStatus.AVAILABLE.value
        self.condition = condition.value
        self.updated_by = updated_by
    
    def mark_as_damaged(self, updated_by: Optional[str] = None):
        """Mark unit as damaged."""
        self.status = InventoryUnitStatus.DAMAGED.value
        self.condition = InventoryUnitCondition.DAMAGED.value
        self.updated_by = updated_by
    
    def retire(self, updated_by: Optional[str] = None):
        """Retire unit."""
        self.status = InventoryUnitStatus.RETIRED.value
        self.updated_by = updated_by
    
    @property
    def display_name(self) -> str:
        """Get unit display name."""
        return f"{self.unit_code}"
    
    @property
    def full_display_name(self) -> str:
        """Get full unit display name with item info."""
        if self.item:
            return f"{self.item.item_name} - {self.unit_code}"
        return self.unit_code
    
    def __str__(self) -> str:
        """String representation of inventory unit."""
        return self.full_display_name
    
    def __repr__(self) -> str:
        """Developer representation of inventory unit."""
        return (
            f"InventoryUnit(id={self.id}, code='{self.unit_code}', "
            f"status='{self.status}', condition='{self.condition}', "
            f"active={self.is_active})"
        )


===== modules/inventory/units/repository.py â€“ 2025-07-22 03:56:51 IST =====
from typing import Optional, List
from uuid import UUID
from decimal import Decimal
from sqlalchemy import and_, func, select, asc, literal_column, text
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from pydantic import BaseModel

from app.modules.inventory.units.models import InventoryUnit
from app.modules.inventory.enums import InventoryUnitStatus, InventoryUnitCondition
from app.modules.inventory.schemas import InventoryUnitCreate, InventoryUnitUpdate
from app.modules.inventory.units.schemas import RentableFlatRowOut
from app.modules.master_data.item_master.models import Item
from app.modules.inventory.stock.models import StockLevel
from app.modules.master_data.locations.models import Location





class InventoryUnitRepository:
    """Repository for InventoryUnit operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def create(self, unit_data: InventoryUnitCreate) -> InventoryUnit:
        """Create a new inventory unit."""
        unit = InventoryUnit(
            item_id=str(unit_data.item_id),
            location_id=str(unit_data.location_id),
            unit_code=unit_data.unit_code,
            serial_number=unit_data.serial_number,
            status=unit_data.status,
            condition=unit_data.condition,
            purchase_price=unit_data.purchase_price
        )
        
        if unit_data.purchase_date:
            unit.purchase_date = unit_data.purchase_date
        if unit_data.warranty_expiry:
            unit.warranty_expiry = unit_data.warranty_expiry
        if unit_data.notes:
            unit.notes = unit_data.notes
        
        self.session.add(unit)
        await self.session.commit()
        await self.session.refresh(unit)
        return unit
    
    async def get_by_id(self, unit_id: UUID) -> Optional[InventoryUnit]:
        """Get inventory unit by ID."""
        query = select(InventoryUnit).where(InventoryUnit.id == unit_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_code(self, unit_code: str) -> Optional[InventoryUnit]:
        """Get inventory unit by code."""
        query = select(InventoryUnit).where(InventoryUnit.unit_code == unit_code)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[InventoryUnitStatus] = None,
        condition: Optional[InventoryUnitCondition] = None,
        active_only: bool = True
    ) -> List[InventoryUnit]:
        """Get all inventory units with optional filtering."""
        query = select(InventoryUnit)
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(InventoryUnit.is_active == True)
        if item_id:
            conditions.append(InventoryUnit.item_id == str(item_id))
        if location_id:
            conditions.append(InventoryUnit.location_id == str(location_id))
        if status:
            conditions.append(InventoryUnit.status == status.value)
        if condition:
            conditions.append(InventoryUnit.condition == condition.value)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(asc(InventoryUnit.unit_code)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def count_all(
        self,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[InventoryUnitStatus] = None,
        condition: Optional[InventoryUnitCondition] = None,
        active_only: bool = True
    ) -> int:
        """Count all inventory units with optional filtering."""
        query = select(func.count(InventoryUnit.id))
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(InventoryUnit.is_active == True)
        if item_id:
            conditions.append(InventoryUnit.item_id == str(item_id))
        if location_id:
            conditions.append(InventoryUnit.location_id == str(location_id))
        if status:
            conditions.append(InventoryUnit.status == status.value)
        if condition:
            conditions.append(InventoryUnit.condition == condition.value)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        result = await self.session.execute(query)
        return result.scalar()
    
    async def get_available_units(
        self, 
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None
    ) -> List[InventoryUnit]:
        """Get available inventory units."""
        query = select(InventoryUnit).where(
            and_(
                InventoryUnit.status == InventoryUnitStatus.AVAILABLE.value,
                InventoryUnit.is_active == True
            )
        )
        
        if item_id:
            query = query.where(InventoryUnit.item_id == str(item_id))
        if location_id:
            query = query.where(InventoryUnit.location_id == str(location_id))
        
        query = query.order_by(asc(InventoryUnit.unit_code))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_rented_units(
        self, 
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None
    ) -> List[InventoryUnit]:
        """Get rented inventory units."""
        query = select(InventoryUnit).where(
            and_(
                InventoryUnit.status == InventoryUnitStatus.RENTED.value,
                InventoryUnit.is_active == True
            )
        )
        
        if item_id:
            query = query.where(InventoryUnit.item_id == str(item_id))
        if location_id:
            query = query.where(InventoryUnit.location_id == str(location_id))
        
        query = query.order_by(asc(InventoryUnit.unit_code))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_units_by_item(self, item_id: UUID, active_only: bool = True) -> List[InventoryUnit]:
        """Get inventory units by item."""
        query = select(InventoryUnit).where(InventoryUnit.item_id == str(item_id))
        
        if active_only:
            query = query.where(InventoryUnit.is_active == True)
        
        query = query.order_by(asc(InventoryUnit.unit_code))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_units_by_location(self, location_id: UUID, active_only: bool = True) -> List[InventoryUnit]:
        """Get inventory units by location."""
        query = select(InventoryUnit).where(InventoryUnit.location_id == str(location_id))
        
        if active_only:
            query = query.where(InventoryUnit.is_active == True)
        
        query = query.order_by(asc(InventoryUnit.unit_code))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def search_by_serial(self, serial_number: str, active_only: bool = True) -> List[InventoryUnit]:
        """Search inventory units by serial number."""
        query = select(InventoryUnit).where(
            InventoryUnit.serial_number.ilike(f"%{serial_number}%")
        )
        
        if active_only:
            query = query.where(InventoryUnit.is_active == True)
        
        query = query.order_by(asc(InventoryUnit.unit_code))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update(self, unit_id: UUID, unit_data: InventoryUnitUpdate) -> Optional[InventoryUnit]:
        """Update an inventory unit."""
        query = select(InventoryUnit).where(InventoryUnit.id == unit_id)
        result = await self.session.execute(query)
        unit = result.scalar_one_or_none()
        
        if not unit:
            return None
        
        # Update fields
        update_data = unit_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(unit, field, value)
        
        await self.session.commit()
        await self.session.refresh(unit)
        return unit
    
    async def delete(self, unit_id: UUID) -> bool:
        """Soft delete an inventory unit."""
        query = select(InventoryUnit).where(InventoryUnit.id == unit_id)
        result = await self.session.execute(query)
        unit = result.scalar_one_or_none()
        
        if not unit:
            return False
        
        unit.is_active = False
        await self.session.commit()
        return True


    async def list_rentable_flat(self) -> list[RentableFlatRowOut]:
        """
        Return rentable items with live stock **and** the id + serial
        of the *first* InventoryUnit that is available at each (item, location).
        """

        # ------------------------------------------------------------------
        # 1. LATERAL sub-query: first available InventoryUnit
        # ------------------------------------------------------------------
        first_unit_sq = (
            select(
                InventoryUnit.id.label("inventory_unit_id"),
                InventoryUnit.serial_number,
            )
            .where(
                InventoryUnit.item_id == StockLevel.item_id,
                InventoryUnit.location_id == StockLevel.location_id,
                InventoryUnit.status == InventoryUnitStatus.AVAILABLE.value,
                InventoryUnit.is_active.is_(True),
            )
            .order_by(InventoryUnit.serial_number)
            .limit(1)
            .lateral("first_unit")
        )

        # ------------------------------------------------------------------
        # 2. Main SELECT â€“ only the columns we need
        # ------------------------------------------------------------------
        stmt = (
            select(
                Item.id.label("item_id"),
                first_unit_sq.c.inventory_unit_id,
                Item.item_name,
                Item.description,
                Item.serial_number_required,
                Item.model_number,
                Item.security_deposit,
                Item.rental_rate_per_period,
                Item.rental_period,
                StockLevel.quantity_available,
                Location.id.label("location_id"),
                Location.location_name,
                first_unit_sq.c.serial_number,
            )
            .join(StockLevel, StockLevel.item_id == Item.id)
            .join(Location, Location.id == StockLevel.location_id)
            .outerjoin(first_unit_sq, literal_column("1") == literal_column("1"))
            .where(
                Item.is_rentable.is_(True),
                Item.item_status == "ACTIVE",
                Item.is_active.is_(True),
                StockLevel.quantity_available > 0,
                StockLevel.is_active.is_(True),
            )
            .order_by(Item.item_name, Location.location_name)
        )

        rows = (await self.session.execute(stmt)).all()

        # ------------------------------------------------------------------
        # 3. Map SQLAlchemy rows â†’ Pydantic DTO
        # ------------------------------------------------------------------
        return [
            RentableFlatRowOut(
                item_id=r.item_id,
                inventory_unit_id=r.inventory_unit_id,
                item_name=r.item_name,
                description=r.description,
                serial_number_required=r.serial_number_required,
                model_number=r.model_number,
                security_deposit=r.security_deposit,
                rental_rate_per_period=r.rental_rate_per_period,
                rental_period=r.rental_period,
                quantity_available=r.quantity_available,
                location_id=r.location_id,
                location_name=r.location_name,
                serial_number=r.serial_number,
            )
            for r in rows
        ]


===== modules/inventory/units/routers.py â€“ 2025-07-21 19:41:40 IST =====
"""
app/modules/rental/router.py
============================

FastAPI router exposing the **/rentable-flat** endpoint.
All heavy lifting is delegated to `ItemRepository`.
"""

from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.modules.inventory.units.repository import InventoryUnitRepository
from app.modules.inventory.units.schemas import RentableFlatRowOut
from app.shared.dependencies import get_session

# from app.modules.master_data.item_master.repositories import ItemRepository
# from app.modules.rental.schemas import RentableFlatRowOut

router = APIRouter(prefix="/inventory_unit", tags=["Inventory Unit Rentable"])


@router.get(
    "/rentable",
    response_model=list[RentableFlatRowOut],
    summary="Flat list of rentable items with stock & serial info",
)
async def list_rentable_flat(
    db: AsyncSession = Depends(get_session),
):
    """
    Returns a flat JSON list where each element contains:

    * Item master fields (name, description, model, deposit, rate, period)  
    * Live `quantity_available` from StockLevel  
    * Location details (id + name)  
    * First available InventoryUnit serial number at that location  

    The query executes in **one database round-trip**.
    """
    return await InventoryUnitRepository(db).list_rentable_flat()

===== modules/inventory/units/schemas.py â€“ 2025-07-22 03:48:22 IST =====
from uuid import UUID
from typing import Optional
from pydantic import BaseModel, Field
from decimal import Decimal

class RentableFlatRowOut(BaseModel):
    """
    Single flat row returned by /rentable-flat.

    Attributes
    ----------
    item_id : UUID
        Primary key of the master-data item.
    inventory_unit_id : Optional[UUID]
        Primary key of the first available InventoryUnit at this location
        (None when no such unit exists).
    item_name : str
        Human-readable item name.
    description : Optional[str]
        Long description of the item.
    serial_number_required : bool
        Flag indicating whether each unit must have a serial.
    model_number : Optional[str]
        Manufacturer's model identifier.
    security_deposit : Decimal
        Mandatory deposit amount when renting.
    rental_rate_per_period : Optional[Decimal]
        Price per rental period.
    rental_period : str
        Period specification (e.g. "1" for 1 day/week/month).
    quantity_available : Decimal
        Sum of *available* quantity at this location.
    location_id : UUID
        Primary key of the location where stock lives.
    location_name : str
        Human-readable location name.
    serial_number : Optional[str]
        First available InventoryUnit serial number at this location.
    """

    item_id: UUID
    inventory_unit_id: Optional[UUID] = None
    item_name: str
    description: Optional[str]
    serial_number_required: bool
    model_number: Optional[str]
    security_deposit: Decimal = Field(..., ge=0)
    rental_rate_per_period: Optional[Decimal] = Field(None, ge=0)
    rental_period: str
    quantity_available: Decimal = Field(..., ge=0)
    location_id: UUID
    location_name: str
    serial_number: Optional[str]

    class Config:
        orm_mode = True

===== modules/inventory/units/services.py â€“ 2025-07-21 18:23:39 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.inventory import (
    InventoryUnit, InventoryUnitStatus, InventoryUnitCondition
)
from app.modules.inventory.schemas import (
    InventoryUnitCreate, InventoryUnitUpdate, InventoryUnitResponse,
    StockLevelCreate
)
from app.modules.master_data.item_master.models import Item
from app.modules.master_data.locations.models import Location
from app.modules.master_data.locations.schemas import LocationCreate
from ..services.base_service import BaseInventoryService


class InventoryUnitService(BaseInventoryService):
    """Service for inventory unit operations."""
    
    async def create_inventory_unit(self, unit_data: InventoryUnitCreate) -> InventoryUnitResponse:
        """Create a new inventory unit."""
        # Check if unit code already exists
        existing_unit = await self.inventory_unit_repository.get_by_code(unit_data.unit_code)
        if existing_unit:
            raise ConflictError(f"Inventory unit with code '{unit_data.unit_code}' already exists")
        
        # Verify item exists
        item = await self.item_repository.get_by_id(unit_data.item_id)
        if not item:
            raise NotFoundError(f"Item with ID {unit_data.item_id} not found")
        
        # Validate serial number requirement
        if item.serial_number_required and not unit_data.serial_number:
            raise ValidationError("Serial number is required for this item")
        
        # Create inventory unit
        unit = await self.inventory_unit_repository.create(unit_data)
        
        # Update stock levels
        await self._update_stock_levels_for_unit_creation(unit)
        
        return InventoryUnitResponse.model_validate(unit)
    
    async def get_inventory_unit(self, unit_id: UUID) -> InventoryUnitResponse:
        """Get inventory unit by ID."""
        unit = await self.inventory_unit_repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Inventory unit with ID {unit_id} not found")
        
        return InventoryUnitResponse.model_validate(unit)
    
    async def get_inventory_units(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        status: Optional[InventoryUnitStatus] = None,
        condition: Optional[InventoryUnitCondition] = None,
        active_only: bool = True
    ) -> List[InventoryUnitResponse]:
        """Get all inventory units with optional filtering."""
        units = await self.inventory_unit_repository.get_all(
            skip=skip,
            limit=limit,
            item_id=item_id,
            location_id=location_id,
            status=status,
            condition=condition,
            active_only=active_only
        )
        
        return [InventoryUnitResponse.model_validate(unit) for unit in units]
    
    async def get_available_units(
        self, 
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None
    ) -> List[InventoryUnitResponse]:
        """Get available inventory units."""
        units = await self.inventory_unit_repository.get_available_units(
            item_id=item_id,
            location_id=location_id
        )
        
        return [InventoryUnitResponse.model_validate(unit) for unit in units]
    
    async def update_inventory_unit(self, unit_id: UUID, unit_data: InventoryUnitUpdate) -> InventoryUnitResponse:
        """Update an inventory unit."""
        # Check if unit exists
        existing_unit = await self.inventory_unit_repository.get_by_id(unit_id)
        if not existing_unit:
            raise NotFoundError(f"Inventory unit with ID {unit_id} not found")
        
        # Update unit
        unit = await self.inventory_unit_repository.update(unit_id, unit_data)
        return InventoryUnitResponse.model_validate(unit)
    
    async def update_unit_status(
        self, 
        unit_id: UUID, 
        status: InventoryUnitStatus,
        condition: Optional[InventoryUnitCondition] = None
    ) -> InventoryUnitResponse:
        """Update inventory unit status."""
        unit = await self.inventory_unit_repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Inventory unit with ID {unit_id} not found")
        
        # Validate status transition
        self._validate_status_transition(unit.status, status)
        
        # Update status
        unit.status = status.value
        if condition:
            unit.condition = condition.value
        
        await self.session.commit()
        await self.session.refresh(unit)
        
        return InventoryUnitResponse.model_validate(unit)
    
    async def rent_out_unit(self, unit_id: UUID) -> InventoryUnitResponse:
        """Rent out an inventory unit."""
        unit = await self.inventory_unit_repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Inventory unit with ID {unit_id} not found")
        
        if not unit.is_available():
            raise ValidationError("Unit is not available for rental")
        
        unit.rent_out()
        await self.session.commit()
        await self.session.refresh(unit)
        
        return InventoryUnitResponse.model_validate(unit)
    
    async def return_unit_from_rent(
        self, 
        unit_id: UUID, 
        condition: Optional[InventoryUnitCondition] = None
    ) -> InventoryUnitResponse:
        """Return unit from rental."""
        unit = await self.inventory_unit_repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Inventory unit with ID {unit_id} not found")
        
        if not unit.is_rented():
            raise ValidationError("Unit is not currently rented")
        
        unit.return_from_rent(condition)
        await self.session.commit()
        await self.session.refresh(unit)
        
        return InventoryUnitResponse.model_validate(unit)
    
    async def sell_unit(self, unit_id: UUID) -> InventoryUnitResponse:
        """Sell an inventory unit."""
        unit = await self.inventory_unit_repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Inventory unit with ID {unit_id} not found")
        
        if not unit.is_available():
            raise ValidationError("Unit is not available for sale")
        
        unit.mark_as_sold()
        await self.session.commit()
        await self.session.refresh(unit)
        
        return InventoryUnitResponse.model_validate(unit)
    
    async def update_inventory_unit_status(
        self,
        unit_id: UUID,
        status: str,
        condition: Optional[str] = None,
        notes: Optional[str] = None
    ) -> None:
        """Update inventory unit status and condition for rental returns."""
        unit = await self.inventory_unit_repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Inventory unit {unit_id} not found")
        
        # Update status
        if status in [s.value for s in InventoryUnitStatus]:
            unit.status = status
        else:
            raise ValidationError(f"Invalid status: {status}")
        
        # Update condition if provided
        if condition and condition in [c.value for c in InventoryUnitCondition]:
            unit.condition = condition
        
        # Add notes if provided
        if notes:
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
            status_note = f"\n[{timestamp}] Status updated to {status}: {notes}"
            unit.notes = (unit.notes or "") + status_note
        
        await self.session.commit()
    
    # Initial stock creation methods
    async def create_initial_stock(
        self, 
        item_id: UUID, 
        item_sku: str, 
        purchase_price: Optional[Decimal], 
        quantity: int,
        location_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """Create initial stock for a new item."""
        # Business rule validation
        validation_result = await self._validate_initial_stock_business_rules(
            item_id, item_sku, purchase_price, quantity, location_id
        )
        if not validation_result["valid"]:
            return {"created": False, "reason": validation_result["reason"]}
        
        try:
            # Get location
            if location_id:
                location = await self.location_repository.get_by_id(location_id)
                if not location:
                    raise NotFoundError(f"Location with ID {location_id} not found")
            else:
                location = await self.get_default_location()
            
            # Check if stock level already exists
            existing_stock = await self.stock_level_repository.get_by_item_location(
                item_id, location.id
            )
            if existing_stock:
                raise ConflictError(f"Stock level already exists for item {item_id} at location {location.id}")
            
            # Create stock level first
            stock_data = StockLevelCreate(
                item_id=item_id,
                location_id=location.id,
                quantity_on_hand=quantity,
                quantity_available=quantity,
                quantity_on_rent=Decimal("0")
            )
            
            stock_level = await self.stock_level_repository.create(stock_data)
            
            # Create individual inventory units
            created_units = []
            for i in range(1, quantity + 1):
                unit_code = self.generate_unit_code(item_sku, i)
                
                unit_data = InventoryUnitCreate(
                    item_id=item_id,
                    location_id=location.id,
                    unit_code=unit_code,
                    status=InventoryUnitStatus.AVAILABLE,
                    condition=InventoryUnitCondition.NEW,
                    purchase_price=purchase_price or Decimal("0.00"),
                    purchase_date=datetime.utcnow()
                )
                
                unit = await self.inventory_unit_repository.create(unit_data)
                created_units.append(unit.unit_code)
            
            return {
                "created": True,
                "stock_level_id": str(stock_level.id),
                "location_id": str(location.id),
                "location_name": location.location_name,
                "total_quantity": quantity,
                "unit_codes": created_units,
                "purchase_price": str(purchase_price) if purchase_price else "0.00"
            }
            
        except Exception as e:
            # Roll back the transaction on error
            await self.session.rollback()
            raise e
    
    async def get_default_location(self) -> Location:
        """Get the default location for inventory operations."""
        # Try to get the first active location
        locations = await self.location_repository.get_all(skip=0, limit=1, active_only=True)
        
        if locations:
            return locations[0]
        
        # If no locations exist, create a default one
        default_location_data = LocationCreate(
            location_code="DEFAULT",
            location_name="Default Warehouse",
            location_type="WAREHOUSE",
            address_line1="Main Storage Facility",
            city="Default City",
            state="N/A",
            postal_code="00000",
            country="USA",
            description="Default location for initial inventory"
        )
        
        return await self.location_repository.create(default_location_data)
    
    def generate_unit_code(self, item_sku: str, sequence: int) -> str:
        """Generate a unique unit code for an inventory unit."""
        return f"{item_sku}-U{sequence:03d}"
    
    def _validate_status_transition(self, current_status: str, new_status: InventoryUnitStatus):
        """Validate inventory unit status transitions."""
        valid_transitions = {
            InventoryUnitStatus.AVAILABLE.value: [
                InventoryUnitStatus.RENTED.value,
                InventoryUnitStatus.SOLD.value,
                InventoryUnitStatus.MAINTENANCE.value,
                InventoryUnitStatus.DAMAGED.value,
                InventoryUnitStatus.RETIRED.value
            ],
            InventoryUnitStatus.RENTED.value: [
                InventoryUnitStatus.AVAILABLE.value,
                InventoryUnitStatus.MAINTENANCE.value,
                InventoryUnitStatus.DAMAGED.value
            ],
            InventoryUnitStatus.SOLD.value: [],  # No transitions from sold
            InventoryUnitStatus.MAINTENANCE.value: [
                InventoryUnitStatus.AVAILABLE.value,
                InventoryUnitStatus.DAMAGED.value,
                InventoryUnitStatus.RETIRED.value
            ],
            InventoryUnitStatus.DAMAGED.value: [
                InventoryUnitStatus.MAINTENANCE.value,
                InventoryUnitStatus.RETIRED.value
            ],
            InventoryUnitStatus.RETIRED.value: []  # No transitions from retired
        }
        
        if new_status.value not in valid_transitions.get(current_status, []):
            raise ValidationError(f"Invalid status transition from {current_status} to {new_status.value}")
    
    async def _update_stock_levels_for_unit_creation(self, unit: InventoryUnit):
        """Update stock levels when a new inventory unit is created."""
        # Get or create stock level for the item/location
        stock_level = await self.stock_level_repository.get_by_item_location(
            UUID(unit.item_id), UUID(unit.location_id)
        )
        
        if stock_level:
            # Increment quantity
            current_quantity = int(stock_level.quantity_on_hand)
            new_quantity = current_quantity + 1
            stock_level.quantity_on_hand = str(new_quantity)
            
            # Update available quantity if the unit is available
            if unit.is_available():
                stock_level.quantity_available = str(int(stock_level.quantity_available) + 1)
            
            await self.session.commit()
        else:
            # Create new stock level
            stock_data = StockLevelCreate(
                item_id=UUID(unit.item_id),
                location_id=UUID(unit.location_id),
                quantity_on_hand="1",
                quantity_available="1" if unit.is_available() else "0"
            )
            await self.stock_level_repository.create(stock_data)
    
    async def _validate_initial_stock_business_rules(
        self, 
        item_id: UUID, 
        item_sku: str, 
        purchase_price: Optional[Decimal], 
        quantity: int,
        location_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """Validate business rules for initial stock creation."""
        # Rule 1: Quantity must be positive
        if quantity <= 0:
            return {"valid": False, "reason": "Quantity must be greater than 0"}
        
        # Rule 2: Quantity must be reasonable (max 10,000 units per initial creation)
        if quantity > 10000:
            return {"valid": False, "reason": "Initial stock quantity cannot exceed 10,000 units"}
        
        # Rule 3: Item must exist and be active
        try:
            item = await self.item_repository.get_by_id(item_id)
            if not item:
                return {"valid": False, "reason": f"Item with ID {item_id} not found"}
            
            if not item.is_active:
                return {"valid": False, "reason": "Cannot create stock for inactive items"}
                
        except Exception as e:
            return {"valid": False, "reason": f"Error validating item: {str(e)}"}
        
        # Rule 4: SKU must be valid and match the item
        if not item_sku or not item_sku.strip():
            return {"valid": False, "reason": "Item SKU cannot be empty"}
        
        if len(item_sku) > 50:
            return {"valid": False, "reason": "Item SKU cannot exceed 50 characters"}
        
        if item.sku != item_sku:
            return {"valid": False, "reason": f"SKU mismatch: expected {item.sku}, got {item_sku}"}
        
        # Rule 5: Purchase price validation
        if purchase_price is not None:
            if purchase_price < 0:
                return {"valid": False, "reason": "Purchase price cannot be negative"}
            
            if purchase_price > Decimal("999999.99"):
                return {"valid": False, "reason": "Purchase price cannot exceed $999,999.99"}
        
        # Rule 6: No existing stock should exist for this item (this is initial stock)
        try:
            existing_stock_levels = await self.stock_level_repository.get_all(
                item_id=item_id, skip=0, limit=1, active_only=True
            )
            if existing_stock_levels:
                return {
                    "valid": False, 
                    "reason": f"Item {item_id} already has existing stock levels. Use stock adjustment instead."
                }
            
            existing_inventory_units = await self.inventory_unit_repository.get_units_by_item(item_id)
            if existing_inventory_units:
                return {
                    "valid": False, 
                    "reason": f"Item {item_id} already has existing inventory units. Use stock adjustment instead."
                }
                
        except Exception as e:
            return {"valid": False, "reason": f"Error checking existing stock: {str(e)}"}
        
        # Rule 7: Location validation (if provided)
        if location_id:
            try:
                location = await self.location_repository.get_by_id(location_id)
                if not location:
                    return {"valid": False, "reason": f"Location with ID {location_id} not found"}
                
                if not location.is_active:
                    return {"valid": False, "reason": "Cannot create stock at inactive location"}
                    
            except Exception as e:
                return {"valid": False, "reason": f"Error validating location: {str(e)}"}
        
        # Rule 8: Unique unit code validation (ensure no conflicts)
        try:
            for i in range(1, min(quantity + 1, 6)):  # Check first 5 unit codes for conflicts
                test_unit_code = self.generate_unit_code(item_sku, i)
                existing_unit = await self.inventory_unit_repository.get_by_code(test_unit_code)
                if existing_unit:
                    return {
                        "valid": False, 
                        "reason": f"Unit code conflict: {test_unit_code} already exists"
                    }
        except Exception as e:
            return {"valid": False, "reason": f"Error validating unit codes: {str(e)}"}
        
        return {"valid": True, "reason": "All business rules passed"}
    
    async def get_rentable_catalog(
        self, skip: int = 0, limit: int = 100
    ) -> List[Item]:
        return await self.item_repo.get_rentable_items_with_available_stock(
            skip, limit
        )

===== modules/inventory/integrations/__init__.py â€“ 2025-07-21 06:22:31 IST =====
"""
Inventory Integration Modules

This package contains helper modules and utilities for integrating 
the inventory service with other modules in the application.
"""

from .transaction_helper import (
    InventoryIntegrationHelper,
    process_purchase_line_items,
    process_sale_line_items,
    process_rental_out_line_items,
    process_rental_return_line_items,
    check_transaction_stock_availability
)

from .async_transaction_helper import (
    AsyncInventoryIntegrationHelper,
    async_process_purchase_line_items,
    async_process_sale_line_items,
    async_process_rental_out_line_items,
    async_process_rental_return_line_items,
    async_check_transaction_stock_availability
)

__all__ = [
    # Sync helpers
    "InventoryIntegrationHelper",
    "process_purchase_line_items",
    "process_sale_line_items", 
    "process_rental_out_line_items",
    "process_rental_return_line_items",
    "check_transaction_stock_availability",
    # Async helpers
    "AsyncInventoryIntegrationHelper",
    "async_process_purchase_line_items",
    "async_process_sale_line_items",
    "async_process_rental_out_line_items", 
    "async_process_rental_return_line_items",
    "async_check_transaction_stock_availability"
]


===== modules/inventory/integrations/async_transaction_helper.py â€“ 2025-07-21 06:22:31 IST =====
"""
Async Inventory Integration Helper

This module provides async helper functions for transaction services to easily integrate
with the inventory update service in async contexts.
"""

from typing import Optional, List
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession

from app.modules.inventory.services import InventoryUpdateService
from app.modules.inventory.enums import MovementType, ReferenceType
from app.modules.inventory.schemas import InventoryUpdateResponse


class AsyncInventoryIntegrationHelper:
    """Async helper class for transaction services to integrate with inventory."""
    
    def __init__(self, async_session: AsyncSession):
        self.async_session = async_session
        # We'll need to get a sync session for the inventory service
        self._sync_session = None
    
    def _get_sync_session(self):
        """Get sync session from async session."""
        if self._sync_session is None:
            from sqlalchemy.orm import sessionmaker
            # Get the sync engine from async session
            sync_engine = self.async_session.bind.sync_engine
            sync_session_maker = sessionmaker(bind=sync_engine)
            self._sync_session = sync_session_maker()
        return self._sync_session
    
    def _close_sync_session(self):
        """Close sync session."""
        if self._sync_session:
            self._sync_session.close()
            self._sync_session = None
    
    async def process_purchase_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID,
        remarks: str = "",
        created_by: Optional[UUID] = None
    ) -> List[InventoryUpdateResponse]:
        """Process purchase transaction line items for inventory updates."""
        try:
            sync_session = self._get_sync_session()
            inventory_service = InventoryUpdateService(sync_session)
            
            responses = []
            for line_item in transaction_line_items:
                response = inventory_service.update_inventory(
                    transaction_line_item_id=line_item['id'],
                    item_id=line_item['item_id'],
                    location_id=location_id,
                    quantity=line_item['quantity'],
                    stock_movement_type=MovementType.PURCHASE,
                    remarks=remarks or f"Purchase transaction line item {line_item['id']}",
                    reference_type=ReferenceType.PURCHASE_ORDER,
                    created_by=created_by
                )
                responses.append(response)
            
            # Commit the sync session
            sync_session.commit()
            return responses
            
        except Exception as e:
            if self._sync_session:
                self._sync_session.rollback()
            raise
        finally:
            self._close_sync_session()
    
    async def process_sale_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID,
        remarks: str = "",
        created_by: Optional[UUID] = None
    ) -> List[InventoryUpdateResponse]:
        """Process sale transaction line items for inventory updates."""
        try:
            sync_session = self._get_sync_session()
            inventory_service = InventoryUpdateService(sync_session)
            
            responses = []
            for line_item in transaction_line_items:
                response = inventory_service.update_inventory(
                    transaction_line_item_id=line_item['id'],
                    item_id=line_item['item_id'],
                    location_id=location_id,
                    quantity=line_item['quantity'],
                    stock_movement_type=MovementType.SALE,
                    remarks=remarks or f"Sale transaction line item {line_item['id']}",
                    reference_type=ReferenceType.SALE_ORDER,
                    created_by=created_by
                )
                responses.append(response)
            
            # Commit the sync session
            sync_session.commit()
            return responses
            
        except Exception as e:
            if self._sync_session:
                self._sync_session.rollback()
            raise
        finally:
            self._close_sync_session()
    
    async def process_rental_out_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID,
        customer_name: str = "",
        remarks: str = "",
        created_by: Optional[UUID] = None
    ) -> List[InventoryUpdateResponse]:
        """Process rental out transaction line items for inventory updates."""
        try:
            sync_session = self._get_sync_session()
            inventory_service = InventoryUpdateService(sync_session)
            
            responses = []
            for line_item in transaction_line_items:
                movement_remarks = remarks or f"Rented to {customer_name}" if customer_name else f"Rental transaction line item {line_item['id']}"
                
                response = inventory_service.update_inventory(
                    transaction_line_item_id=line_item['id'],
                    item_id=line_item['item_id'],
                    location_id=location_id,
                    quantity=line_item['quantity'],
                    stock_movement_type=MovementType.RENTAL_OUT,
                    remarks=movement_remarks,
                    reference_type=ReferenceType.RENTAL_CONTRACT,
                    created_by=created_by
                )
                responses.append(response)
            
            # Commit the sync session
            sync_session.commit()
            return responses
            
        except Exception as e:
            if self._sync_session:
                self._sync_session.rollback()
            raise
        finally:
            self._close_sync_session()
    
    async def process_rental_return_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID,
        customer_name: str = "",
        remarks: str = "",
        created_by: Optional[UUID] = None
    ) -> List[InventoryUpdateResponse]:
        """Process rental return transaction line items for inventory updates."""
        try:
            sync_session = self._get_sync_session()
            inventory_service = InventoryUpdateService(sync_session)
            
            responses = []
            for line_item in transaction_line_items:
                movement_remarks = remarks or f"Returned by {customer_name}" if customer_name else f"Return transaction line item {line_item['id']}"
                
                response = inventory_service.update_inventory(
                    transaction_line_item_id=line_item['id'],
                    item_id=line_item['item_id'],
                    location_id=location_id,
                    quantity=line_item['quantity'],
                    stock_movement_type=MovementType.RENTAL_RETURN,
                    remarks=movement_remarks,
                    reference_type=ReferenceType.RENTAL_CONTRACT,
                    created_by=created_by
                )
                responses.append(response)
            
            # Commit the sync session
            sync_session.commit()
            return responses
            
        except Exception as e:
            if self._sync_session:
                self._sync_session.rollback()
            raise
        finally:
            self._close_sync_session()
    
    async def check_stock_availability_for_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID
    ) -> dict:
        """Check stock availability for all items in a transaction."""
        try:
            sync_session = self._get_sync_session()
            inventory_service = InventoryUpdateService(sync_session)
            
            availability_results = {
                'all_available': True,
                'unavailable_items': [],
                'item_details': []
            }
            
            for line_item in transaction_line_items:
                is_available = inventory_service.check_stock_availability(
                    item_id=line_item['item_id'],
                    location_id=location_id,
                    required_quantity=line_item['quantity']
                )
                
                stock_level = inventory_service.get_stock_level(
                    item_id=line_item['item_id'],
                    location_id=location_id
                )
                
                available_quantity = stock_level.quantity_available if stock_level else 0
                
                item_detail = {
                    'item_id': line_item['item_id'],
                    'required_quantity': line_item['quantity'],
                    'available_quantity': available_quantity,
                    'is_available': is_available
                }
                
                availability_results['item_details'].append(item_detail)
                
                if not is_available:
                    availability_results['all_available'] = False
                    availability_results['unavailable_items'].append(item_detail)
            
            return availability_results
            
        finally:
            self._close_sync_session()


# Convenience functions for async use

async def async_process_purchase_line_items(
    async_session: AsyncSession,
    transaction_line_items: List[dict],
    location_id: UUID,
    remarks: str = "",
    created_by: Optional[UUID] = None
) -> List[InventoryUpdateResponse]:
    """Async convenience function to process purchase transaction line items."""
    helper = AsyncInventoryIntegrationHelper(async_session)
    return await helper.process_purchase_transaction(
        transaction_line_items, location_id, remarks, created_by
    )


async def async_process_sale_line_items(
    async_session: AsyncSession,
    transaction_line_items: List[dict],
    location_id: UUID,
    remarks: str = "",
    created_by: Optional[UUID] = None
) -> List[InventoryUpdateResponse]:
    """Async convenience function to process sale transaction line items."""
    helper = AsyncInventoryIntegrationHelper(async_session)
    return await helper.process_sale_transaction(
        transaction_line_items, location_id, remarks, created_by
    )


async def async_process_rental_out_line_items(
    async_session: AsyncSession,
    transaction_line_items: List[dict],
    location_id: UUID,
    customer_name: str = "",
    remarks: str = "",
    created_by: Optional[UUID] = None
) -> List[InventoryUpdateResponse]:
    """Async convenience function to process rental out transaction line items."""
    helper = AsyncInventoryIntegrationHelper(async_session)
    return await helper.process_rental_out_transaction(
        transaction_line_items, location_id, customer_name, remarks, created_by
    )


async def async_process_rental_return_line_items(
    async_session: AsyncSession,
    transaction_line_items: List[dict],
    location_id: UUID,
    customer_name: str = "",
    remarks: str = "",
    created_by: Optional[UUID] = None
) -> List[InventoryUpdateResponse]:
    """Async convenience function to process rental return transaction line items."""
    helper = AsyncInventoryIntegrationHelper(async_session)
    return await helper.process_rental_return_transaction(
        transaction_line_items, location_id, customer_name, remarks, created_by
    )


async def async_check_transaction_stock_availability(
    async_session: AsyncSession,
    transaction_line_items: List[dict],
    location_id: UUID
) -> dict:
    """Async convenience function to check stock availability for transaction items."""
    helper = AsyncInventoryIntegrationHelper(async_session)
    return await helper.check_stock_availability_for_transaction(
        transaction_line_items, location_id
    )


===== modules/inventory/integrations/transaction_helper.py â€“ 2025-07-21 06:22:31 IST =====
"""
Inventory Integration Helper

This module provides helper functions for transaction services to easily integrate
with the inventory update service.
"""

from typing import Optional, List
from uuid import UUID
from sqlalchemy.orm import Session

from app.modules.inventory.services import InventoryUpdateService
from app.modules.inventory.enums import MovementType, ReferenceType
from app.modules.inventory.schemas import InventoryUpdateResponse


class InventoryIntegrationHelper:
    """Helper class for transaction services to integrate with inventory."""
    
    def __init__(self, db: Session):
        self.db = db
        self.inventory_service = InventoryUpdateService(db)
    
    def process_purchase_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID,
        remarks: str = "",
        created_by: Optional[UUID] = None
    ) -> List[InventoryUpdateResponse]:
        """
        Process purchase transaction line items for inventory updates.
        
        Args:
            transaction_line_items: List of dicts with keys: id, item_id, quantity
            location_id: Location where items are being added
            remarks: Additional remarks for the movements
            created_by: User who initiated the transaction
            
        Returns:
            List of InventoryUpdateResponse objects
        """
        responses = []
        
        for line_item in transaction_line_items:
            response = self.inventory_service.update_inventory(
                transaction_line_item_id=line_item['id'],
                item_id=line_item['item_id'],
                location_id=location_id,
                quantity=line_item['quantity'],
                stock_movement_type=MovementType.PURCHASE,
                remarks=remarks or f"Purchase transaction line item {line_item['id']}",
                reference_type=ReferenceType.PURCHASE_ORDER,
                created_by=created_by
            )
            responses.append(response)
        
        return responses
    
    def process_sale_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID,
        remarks: str = "",
        created_by: Optional[UUID] = None
    ) -> List[InventoryUpdateResponse]:
        """
        Process sale transaction line items for inventory updates.
        
        Args:
            transaction_line_items: List of dicts with keys: id, item_id, quantity
            location_id: Location from where items are being sold
            remarks: Additional remarks for the movements
            created_by: User who initiated the transaction
            
        Returns:
            List of InventoryUpdateResponse objects
        """
        responses = []
        
        for line_item in transaction_line_items:
            response = self.inventory_service.update_inventory(
                transaction_line_item_id=line_item['id'],
                item_id=line_item['item_id'],
                location_id=location_id,
                quantity=line_item['quantity'],
                stock_movement_type=MovementType.SALE,
                remarks=remarks or f"Sale transaction line item {line_item['id']}",
                reference_type=ReferenceType.SALE_ORDER,
                created_by=created_by
            )
            responses.append(response)
        
        return responses
    
    def process_rental_out_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID,
        customer_name: str = "",
        remarks: str = "",
        created_by: Optional[UUID] = None
    ) -> List[InventoryUpdateResponse]:
        """
        Process rental out transaction line items for inventory updates.
        
        Args:
            transaction_line_items: List of dicts with keys: id, item_id, quantity
            location_id: Location from where items are being rented
            customer_name: Name of the customer renting the items
            remarks: Additional remarks for the movements
            created_by: User who initiated the transaction
            
        Returns:
            List of InventoryUpdateResponse objects
        """
        responses = []
        
        for line_item in transaction_line_items:
            movement_remarks = remarks or f"Rented to {customer_name}" if customer_name else f"Rental transaction line item {line_item['id']}"
            
            response = self.inventory_service.update_inventory(
                transaction_line_item_id=line_item['id'],
                item_id=line_item['item_id'],
                location_id=location_id,
                quantity=line_item['quantity'],
                stock_movement_type=MovementType.RENTAL_OUT,
                remarks=movement_remarks,
                reference_type=ReferenceType.RENTAL_CONTRACT,
                created_by=created_by
            )
            responses.append(response)
        
        return responses
    
    def process_rental_return_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID,
        customer_name: str = "",
        remarks: str = "",
        created_by: Optional[UUID] = None
    ) -> List[InventoryUpdateResponse]:
        """
        Process rental return transaction line items for inventory updates.
        
        Args:
            transaction_line_items: List of dicts with keys: id, item_id, quantity
            location_id: Location to where items are being returned
            customer_name: Name of the customer returning the items
            remarks: Additional remarks for the movements
            created_by: User who initiated the transaction
            
        Returns:
            List of InventoryUpdateResponse objects
        """
        responses = []
        
        for line_item in transaction_line_items:
            movement_remarks = remarks or f"Returned by {customer_name}" if customer_name else f"Return transaction line item {line_item['id']}"
            
            response = self.inventory_service.update_inventory(
                transaction_line_item_id=line_item['id'],
                item_id=line_item['item_id'],
                location_id=location_id,
                quantity=line_item['quantity'],
                stock_movement_type=MovementType.RENTAL_RETURN,
                remarks=movement_remarks,
                reference_type=ReferenceType.RENTAL_CONTRACT,
                created_by=created_by
            )
            responses.append(response)
        
        return responses
    
    def check_stock_availability_for_transaction(
        self,
        transaction_line_items: List[dict],
        location_id: UUID
    ) -> dict:
        """
        Check stock availability for all items in a transaction.
        
        Args:
            transaction_line_items: List of dicts with keys: item_id, quantity
            location_id: Location to check stock availability
            
        Returns:
            Dict with availability status and details
        """
        availability_results = {
            'all_available': True,
            'unavailable_items': [],
            'item_details': []
        }
        
        for line_item in transaction_line_items:
            is_available = self.inventory_service.check_stock_availability(
                item_id=line_item['item_id'],
                location_id=location_id,
                required_quantity=line_item['quantity']
            )
            
            stock_level = self.inventory_service.get_stock_level(
                item_id=line_item['item_id'],
                location_id=location_id
            )
            
            available_quantity = stock_level.quantity_available if stock_level else 0
            
            item_detail = {
                'item_id': line_item['item_id'],
                'required_quantity': line_item['quantity'],
                'available_quantity': available_quantity,
                'is_available': is_available
            }
            
            availability_results['item_details'].append(item_detail)
            
            if not is_available:
                availability_results['all_available'] = False
                availability_results['unavailable_items'].append(item_detail)
        
        return availability_results


# Convenience functions for direct use without instantiating the helper class

def process_purchase_line_items(
    db: Session,
    transaction_line_items: List[dict],
    location_id: UUID,
    remarks: str = "",
    created_by: Optional[UUID] = None
) -> List[InventoryUpdateResponse]:
    """Convenience function to process purchase transaction line items."""
    helper = InventoryIntegrationHelper(db)
    return helper.process_purchase_transaction(
        transaction_line_items, location_id, remarks, created_by
    )


def process_sale_line_items(
    db: Session,
    transaction_line_items: List[dict],
    location_id: UUID,
    remarks: str = "",
    created_by: Optional[UUID] = None
) -> List[InventoryUpdateResponse]:
    """Convenience function to process sale transaction line items."""
    helper = InventoryIntegrationHelper(db)
    return helper.process_sale_transaction(
        transaction_line_items, location_id, remarks, created_by
    )


def process_rental_out_line_items(
    db: Session,
    transaction_line_items: List[dict],
    location_id: UUID,
    customer_name: str = "",
    remarks: str = "",
    created_by: Optional[UUID] = None
) -> List[InventoryUpdateResponse]:
    """Convenience function to process rental out transaction line items."""
    helper = InventoryIntegrationHelper(db)
    return helper.process_rental_out_transaction(
        transaction_line_items, location_id, customer_name, remarks, created_by
    )


def process_rental_return_line_items(
    db: Session,
    transaction_line_items: List[dict],
    location_id: UUID,
    customer_name: str = "",
    remarks: str = "",
    created_by: Optional[UUID] = None
) -> List[InventoryUpdateResponse]:
    """Convenience function to process rental return transaction line items."""
    helper = InventoryIntegrationHelper(db)
    return helper.process_rental_return_transaction(
        transaction_line_items, location_id, customer_name, remarks, created_by
    )


def check_transaction_stock_availability(
    db: Session,
    transaction_line_items: List[dict],
    location_id: UUID
) -> dict:
    """Convenience function to check stock availability for transaction items."""
    helper = InventoryIntegrationHelper(db)
    return helper.check_stock_availability_for_transaction(
        transaction_line_items, location_id
    )


===== modules/inventory/movements/__init__.py â€“ 2025-07-20 21:17:05 IST =====
"""
Inventory movements module.

This module contains all movement-related functionality for the inventory system:
- StockMovement model for tracking all stock changes
- StockMovementRepository for data access
- Movement audit trail and reporting
"""

from .models import StockMovement
from .repository import StockMovementRepository

__all__ = ["StockMovement", "StockMovementRepository"]


===== modules/inventory/movements/models.py â€“ 2025-07-20 21:17:06 IST =====
from typing import Optional, TYPE_CHECKING
from decimal import Decimal
from uuid import uuid4
from sqlalchemy import Column, String, Numeric, Boolean, Text, DateTime, ForeignKey, Index
from sqlalchemy.orm import relationship

from app.db.base import Base, TimestampMixin, AuditMixin, UUIDType
from app.modules.inventory.enums import MovementType, ReferenceType

if TYPE_CHECKING:
    from app.modules.master_data.item_master.models import Item
    from app.modules.inventory.stock.models import StockLevel


class StockMovement(Base, TimestampMixin, AuditMixin):
    """
    Stock movement model for tracking all stock changes with audit trail.
    
    This model records every change to stock levels, including the type of movement,
    quantities before and after, and references to the triggering transactions.
    Stock movements are immutable audit records and do not support soft deletion.
    
    Attributes:
        id: Primary key UUID
        stock_level_id: Reference to the stock level being modified
        item_id: Item ID for efficient querying
        location_id: Location ID for efficient querying
        movement_type: Type of movement (PURCHASE, SALE, RENTAL_OUT, etc.)
        reference_type: Type of reference (TRANSACTION, MANUAL_ADJUSTMENT, etc.)
        reference_id: External reference ID (transaction ID, etc.)
        quantity_change: Quantity change (positive for additions, negative for reductions)
        quantity_before: Quantity before the movement
        quantity_after: Quantity after the movement
        reason: Human-readable reason for the movement
        notes: Additional notes
        transaction_line_id: Optional link to specific transaction line
        is_active: Active status (for compatibility, always True for movements)
        stock_level: Relationship to stock level
        item: Relationship to item
    """
    
    __tablename__ = "stock_movements"
    
    # Primary key
    id = Column(UUIDType(), primary_key=True, default=uuid4, comment="Primary key UUID")
    
    # Core references
    stock_level_id = Column(UUIDType(), ForeignKey("stock_levels.id"), nullable=False, comment="Stock level ID")
    item_id = Column(UUIDType(), ForeignKey("items.id"), nullable=False, comment="Item ID")
    location_id = Column(UUIDType(), ForeignKey("locations.id"), nullable=False, comment="Location ID")
    
    # Active status for compatibility
    is_active = Column(Boolean, nullable=False, default=True, comment="Active status")
    
    # Movement classification
    movement_type = Column(String(50), nullable=False, comment="Type of movement")
    reference_type = Column(String(50), nullable=False, comment="Type of reference")
    reference_id = Column(String(100), nullable=True, comment="External reference ID")
    
    # Quantity tracking
    quantity_change = Column(Numeric(10, 2), nullable=False, comment="Quantity change (+/-)")
    quantity_before = Column(Numeric(10, 2), nullable=False, comment="Quantity before movement")
    quantity_after = Column(Numeric(10, 2), nullable=False, comment="Quantity after movement")
    
    # Context and audit
    reason = Column(String(500), nullable=False, comment="Reason for movement")
    notes = Column(Text, nullable=True, comment="Additional notes")
    transaction_line_id = Column(UUIDType(), nullable=True, comment="Transaction line reference")
    
    # Relationships
    stock_level = relationship("StockLevel", back_populates="stock_movements", lazy="select")
    item = relationship("Item", back_populates="stock_movements", lazy="select")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_stock_movement_stock_level', 'stock_level_id'),
        Index('idx_stock_movement_item', 'item_id'),
        Index('idx_stock_movement_location', 'location_id'),
        Index('idx_stock_movement_type', 'movement_type'),
        Index('idx_stock_movement_reference', 'reference_type', 'reference_id'),
        Index('idx_stock_movement_created', 'created_at'),
        Index('idx_stock_movement_item_created', 'item_id', 'created_at'),
        Index('idx_stock_movement_stock_created', 'stock_level_id', 'created_at'),
    )
    
    def __init__(
        self,
        stock_level_id: str,
        item_id: str,
        location_id: str,
        movement_type: MovementType,
        reference_type: ReferenceType,
        quantity_change: Decimal,
        quantity_before: Decimal,
        quantity_after: Decimal,
        reason: str,
        reference_id: Optional[str] = None,
        notes: Optional[str] = None,
        transaction_line_id: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a Stock Movement.
        
        Args:
            stock_level_id: Stock level ID
            item_id: Item ID
            location_id: Location ID
            movement_type: Type of movement
            reference_type: Type of reference
            quantity_change: Quantity change (+/-)
            quantity_before: Quantity before movement
            quantity_after: Quantity after movement
            reason: Reason for movement
            reference_id: External reference ID
            notes: Additional notes
            transaction_line_id: Transaction line reference
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.stock_level_id = stock_level_id
        self.item_id = item_id
        self.location_id = location_id
        self.movement_type = movement_type.value if isinstance(movement_type, MovementType) else movement_type
        self.reference_type = reference_type.value if isinstance(reference_type, ReferenceType) else reference_type
        self.quantity_change = quantity_change
        self.quantity_before = quantity_before
        self.quantity_after = quantity_after
        self.reason = reason
        self.reference_id = reference_id
        self.notes = notes
        self.transaction_line_id = transaction_line_id
        self._validate()
    
    def _validate(self):
        """Validate stock movement business rules."""
        # Movement type validation
        if self.movement_type not in [mt.value for mt in MovementType]:
            raise ValueError(f"Invalid movement type: {self.movement_type}")
        
        # Reference type validation
        if self.reference_type not in [rt.value for rt in ReferenceType]:
            raise ValueError(f"Invalid reference type: {self.reference_type}")
        
        # Quantity validation
        if self.quantity_before < 0:
            raise ValueError("Quantity before cannot be negative")
        
        if self.quantity_after < 0:
            raise ValueError("Quantity after cannot be negative")
        
        # Validate quantity math
        calculated_after = self.quantity_before + self.quantity_change
        if abs(calculated_after - self.quantity_after) > Decimal('0.01'):
            raise ValueError("Quantity math doesn't add up: before + change != after")
        
        # Reason validation
        if not self.reason or not self.reason.strip():
            raise ValueError("Reason cannot be empty")
        
        if len(self.reason) > 500:
            raise ValueError("Reason cannot exceed 500 characters")
        
        # Reference ID validation
        if self.reference_id and len(self.reference_id) > 100:
            raise ValueError("Reference ID cannot exceed 100 characters")
    
    def is_increase(self) -> bool:
        """Check if this movement increases stock."""
        return self.quantity_change > 0
    
    def is_decrease(self) -> bool:
        """Check if this movement decreases stock."""
        return self.quantity_change < 0
    
    def is_neutral(self) -> bool:
        """Check if this movement is neutral (no change)."""
        return self.quantity_change == 0
    
    @property
    def display_name(self) -> str:
        """Get movement display name."""
        direction = "+" if self.quantity_change >= 0 else ""
        return f"{self.movement_type}: {direction}{self.quantity_change}"
    
    @property
    def full_display_name(self) -> str:
        """Get full movement display name with item info."""
        if self.item:
            return f"{self.item.item_name} - {self.display_name}"
        return self.display_name
    
    def __str__(self) -> str:
        """String representation of stock movement."""
        return self.full_display_name
    
    def __repr__(self) -> str:
        """Developer representation of stock movement."""
        return (
            f"StockMovement(id={self.id}, type='{self.movement_type}', "
            f"change={self.quantity_change}, before={self.quantity_before}, "
            f"after={self.quantity_after}, active={self.is_active})"
        )


===== modules/inventory/movements/repository.py â€“ 2025-07-20 21:17:07 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime
from sqlalchemy import and_, select, desc
from sqlalchemy.ext.asyncio import AsyncSession

from app.modules.inventory.movements.models import StockMovement
from app.modules.inventory.enums import MovementType, ReferenceType


class StockMovementRepository:
    """Repository for StockMovement operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def create(self, movement_data: dict) -> StockMovement:
        """Create a new stock movement record."""
        movement = StockMovement(**movement_data)
        self.session.add(movement)
        await self.session.commit()
        await self.session.refresh(movement)
        return movement
    
    async def get_by_id(self, movement_id: UUID) -> Optional[StockMovement]:
        """Get stock movement by ID."""
        query = select(StockMovement).where(StockMovement.id == movement_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_stock_level(
        self,
        stock_level_id: UUID,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True
    ) -> List[StockMovement]:
        """Get stock movements for a specific stock level."""
        query = select(StockMovement).where(StockMovement.stock_level_id == stock_level_id)
        
        if active_only:
            query = query.where(StockMovement.is_active == True)
        
        query = query.order_by(desc(StockMovement.created_at)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_item(
        self,
        item_id: UUID,
        skip: int = 0,
        limit: int = 100,
        movement_type: Optional[MovementType] = None,
        active_only: bool = True
    ) -> List[StockMovement]:
        """Get stock movements for a specific item."""
        query = select(StockMovement).where(StockMovement.item_id == item_id)
        
        if movement_type:
            query = query.where(StockMovement.movement_type == movement_type.value)
        
        if active_only:
            query = query.where(StockMovement.is_active == True)
        
        query = query.order_by(desc(StockMovement.created_at)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_reference(
        self,
        reference_type: ReferenceType,
        reference_id: str,
        active_only: bool = True
    ) -> List[StockMovement]:
        """Get stock movements by reference."""
        query = select(StockMovement).where(
            and_(
                StockMovement.reference_type == reference_type.value,
                StockMovement.reference_id == reference_id
            )
        )
        
        if active_only:
            query = query.where(StockMovement.is_active == True)
        
        query = query.order_by(desc(StockMovement.created_at))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_movements_by_date_range(
        self,
        start_date: datetime,
        end_date: datetime,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        movement_type: Optional[MovementType] = None,
        active_only: bool = True
    ) -> List[StockMovement]:
        """Get stock movements within a date range with optional filters."""
        query = select(StockMovement).where(
            and_(
                StockMovement.created_at >= start_date,
                StockMovement.created_at <= end_date
            )
        )
        
        if item_id:
            query = query.where(StockMovement.item_id == item_id)
        
        if location_id:
            query = query.where(StockMovement.location_id == location_id)
        
        if movement_type:
            query = query.where(StockMovement.movement_type == movement_type.value)
        
        if active_only:
            query = query.where(StockMovement.is_active == True)
        
        query = query.order_by(desc(StockMovement.created_at))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_movement_summary(
        self,
        item_id: UUID,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """Get movement summary for an item."""
        query = select(StockMovement).where(StockMovement.item_id == item_id)
        
        if start_date:
            query = query.where(StockMovement.created_at >= start_date)
        
        if end_date:
            query = query.where(StockMovement.created_at <= end_date)
        
        query = query.where(StockMovement.is_active == True)
        
        result = await self.session.execute(query)
        movements = result.scalars().all()
        
        summary = {
            "total_movements": len(movements),
            "total_increases": sum(m.quantity_change for m in movements if m.quantity_change > 0),
            "total_decreases": abs(sum(m.quantity_change for m in movements if m.quantity_change < 0)),
            "net_change": sum(m.quantity_change for m in movements),
            "movement_types": {}
        }
        
        # Count by movement type
        for movement in movements:
            movement_type = movement.movement_type
            if movement_type not in summary["movement_types"]:
                summary["movement_types"][movement_type] = {
                    "count": 0,
                    "total_quantity": Decimal("0")
                }
            summary["movement_types"][movement_type]["count"] += 1
            summary["movement_types"][movement_type]["total_quantity"] += movement.quantity_change
        
        return summary


===== modules/inventory/stock/__init__.py â€“ 2025-07-20 21:17:05 IST =====
"""
Inventory stock module.

This module contains all stock-related functionality for the inventory system:
- StockLevel model for tracking stock quantities
- SKUSequence model for generating unique SKUs
- StockLevelRepository for data access
"""

from .models import StockLevel, SKUSequence
from .repository import StockLevelRepository

__all__ = ["StockLevel", "SKUSequence", "StockLevelRepository"]


===== modules/inventory/stock/models.py â€“ 2025-07-21 12:33:38 IST =====
from typing import Optional, TYPE_CHECKING
from decimal import Decimal
from sqlalchemy import Column, String, Numeric, Index, ForeignKey
from sqlalchemy.orm import relationship

from app.db.base import BaseModel, UUIDType

if TYPE_CHECKING:
    from app.modules.master_data.item_master.models import Item
    from app.modules.master_data.locations.models import Location


class StockLevel(BaseModel):
    """
    Stock level model for tracking item quantities at locations.
    
    This model tracks the current stock levels for items at specific locations,
    including available quantities and quantities currently on rent.
    
    Attributes:
        item_id: Item ID
        location_id: Location ID
        quantity_on_hand: Total quantity currently in stock
        quantity_available: Quantity available for rent/sale
        quantity_on_rent: Quantity currently rented out
        item: Item relationship
        location: Location relationship
        stock_movements: All stock movements for this stock level
    """
    
    __tablename__ = "stock_levels"
    
    item_id = Column(UUIDType(), ForeignKey("items.id"), nullable=False, comment="Item ID")
    location_id = Column(UUIDType(), ForeignKey("locations.id"), nullable=False, comment="Location ID")
    quantity_on_hand = Column(Numeric(10, 2), nullable=False, default=0, comment="Current quantity on hand")
    quantity_available = Column(Numeric(10, 2), nullable=False, default=0, comment="Available quantity")
    quantity_on_rent = Column(Numeric(10, 2), nullable=False, default=0, comment="Quantity currently on rent")
    
    # Relationships
    item = relationship("Item", back_populates="stock_levels", lazy="select")
    location = relationship("Location", back_populates="stock_levels", lazy="select")
    stock_movements = relationship("StockMovement", back_populates="stock_level", lazy="select", cascade="all, delete-orphan")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_stock_level_item', 'item_id'),
        Index('idx_stock_level_location', 'location_id'),
        Index('idx_stock_level_item_location', 'item_id', 'location_id', unique=True),
        # Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        item_id: str,
        location_id: str,
        quantity_on_hand: Decimal = Decimal("0"),
        **kwargs
    ):
        """
        Initialize a Stock Level.
        
        Args:
            item_id: Item ID
            location_id: Location ID
            quantity_on_hand: Current quantity on hand
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.item_id = item_id
        self.location_id = location_id
        self.quantity_on_hand = quantity_on_hand
        self.quantity_available = quantity_on_hand
        self.quantity_on_rent = Decimal("0")
        self._validate()
    
    def _validate(self):
        """Validate stock level business rules."""
        # Validate non-negative quantities
        if self.quantity_on_hand < 0:
            raise ValueError("Quantity on hand cannot be negative")
        
        if self.quantity_available < 0:
            raise ValueError("Available quantity cannot be negative")
        
        if self.quantity_on_rent < 0:
            raise ValueError("Quantity on rent cannot be negative")
        
        # Validate quantity logic
        total_allocated = self.quantity_available + self.quantity_on_rent
        if total_allocated > self.quantity_on_hand:
            raise ValueError("Total allocated quantities cannot exceed quantity on hand")
    
    def adjust_quantity(self, adjustment: Decimal, updated_by: Optional[str] = None):
        """Adjust quantity on hand."""
        new_quantity = self.quantity_on_hand + adjustment
        
        if new_quantity < 0:
            raise ValueError("Quantity adjustment would result in negative stock")
        
        # Maintain proportional allocation if reducing stock
        if adjustment < 0 and self.quantity_on_hand > 0:
            ratio = new_quantity / self.quantity_on_hand
            self.quantity_available = self.quantity_available * ratio
            self.quantity_on_rent = self.quantity_on_rent * ratio
        
        self.quantity_on_hand = new_quantity
        
        # Ensure available quantity doesn't exceed total
        if self.quantity_available > new_quantity:
            self.quantity_available = new_quantity
        
        self.updated_by = updated_by
        self._validate()
    
    def rent_out_quantity(self, quantity: Decimal, updated_by: Optional[str] = None):
        """Move quantity from available to on rent."""
        if quantity < 0:
            raise ValueError("Cannot rent negative quantity")
        
        if quantity > self.quantity_available:
            raise ValueError("Cannot rent more than available quantity")
        
        self.quantity_available -= quantity
        self.quantity_on_rent += quantity
        self.updated_by = updated_by
        self._validate()
    
    def return_from_rent(self, quantity: Decimal, updated_by: Optional[str] = None):
        """Move quantity from on rent back to available."""
        if quantity < 0:
            raise ValueError("Cannot return negative quantity")
        
        if quantity > self.quantity_on_rent:
            raise ValueError("Cannot return more than rented quantity")
        
        self.quantity_on_rent -= quantity
        self.quantity_available += quantity
        self.updated_by = updated_by
        self._validate()
    
    def is_available_for_rent(self, quantity: Decimal = Decimal("1")) -> bool:
        """Check if specified quantity is available for rent."""
        return self.quantity_available >= quantity and self.is_active
    
    def has_rented_quantity(self, quantity: Decimal = Decimal("1")) -> bool:
        """Check if specified quantity is currently on rent."""
        return self.quantity_on_rent >= quantity
    
    @property
    def display_name(self) -> str:
        """Get stock level display name."""
        item_name = "Unknown Item"
        location_name = "Unknown Location"
        
        # Check if relationships are loaded
        if hasattr(self, 'item') and self.item:
            item_name = self.item.item_name
        elif hasattr(self, 'item_id') and self.item_id:
            item_name = f"Item {self.item_id}"
            
        if hasattr(self, 'location') and self.location:
            location_name = self.location.location_name
        elif hasattr(self, 'location_id') and self.location_id:
            location_name = f"Location {self.location_id}"
            
        return f"{item_name} @ {location_name}"
    
    def __str__(self) -> str:
        """String representation of stock level."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of stock level."""
        return (
            f"StockLevel(id={self.id}, item_id={self.item_id}, "
            f"location_id={self.location_id}, on_hand={self.quantity_on_hand}, "
            f"available={self.quantity_available}, on_rent={self.quantity_on_rent}, "
            f"active={self.is_active})"
        )


class SKUSequence(BaseModel):
    """
    SKU sequence tracking model for generating unique SKUs.
    
    This model tracks the next sequence number for each brand-category combination
    to ensure unique SKU generation.
    
    Attributes:
        brand_code: Brand code for SKU generation
        category_code: Category code for SKU generation
        next_sequence: Next sequence number to use
    """
    
    __tablename__ = "sku_sequences"
    
    brand_code = Column(String(20), nullable=True, comment="Brand code")
    category_code = Column(String(20), nullable=True, comment="Category code")
    next_sequence = Column(String(10), nullable=False, default="1", comment="Next sequence number")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_sku_sequence_brand_category', 'brand_code', 'category_code', unique=True),
        Index('idx_sku_sequence_brand', 'brand_code'),
        Index('idx_sku_sequence_category', 'category_code'),
    )
    
    def __init__(
        self,
        brand_code: Optional[str] = None,
        category_code: Optional[str] = None,
        next_sequence: str = "1",
        **kwargs
    ):
        """
        Initialize a SKU Sequence.
        
        Args:
            brand_code: Brand code for SKU generation
            category_code: Category code for SKU generation  
            next_sequence: Next sequence number
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.brand_code = brand_code
        self.category_code = category_code
        self.next_sequence = next_sequence
        self._validate()
    
    def _validate(self):
        """Validate SKU sequence business rules."""
        # Brand code validation
        if self.brand_code:
            if len(self.brand_code) > 20:
                raise ValueError("Brand code cannot exceed 20 characters")
            self.brand_code = self.brand_code.upper().strip()
        
        # Category code validation
        if self.category_code:
            if len(self.category_code) > 20:
                raise ValueError("Category code cannot exceed 20 characters")
            self.category_code = self.category_code.upper().strip()
        
        # Sequence validation
        try:
            int(self.next_sequence)
        except ValueError:
            raise ValueError("Next sequence must be a valid number")
    
    def get_next_sequence_number(self) -> int:
        """Get next sequence number as integer."""
        return int(self.next_sequence)
    
    def increment_sequence(self):
        """Increment the sequence number."""
        current = int(self.next_sequence)
        self.next_sequence = str(current + 1)
    
    @property
    def sequence_key(self) -> str:
        """Get unique key for this sequence."""
        return f"{self.brand_code or 'NONE'}-{self.category_code or 'NONE'}"
    
    def __str__(self) -> str:
        """String representation of SKU sequence."""
        return f"SKU Sequence: {self.sequence_key} -> {self.next_sequence}"
    
    def __repr__(self) -> str:
        """Developer representation of SKU sequence."""
        return (
            f"SKUSequence(id={self.id}, brand_code='{self.brand_code}', "
            f"category_code='{self.category_code}', next_sequence='{self.next_sequence}')"
        )


===== modules/inventory/stock/repository.py â€“ 2025-07-21 16:34:18 IST =====
from typing import Optional, List
from uuid import UUID
from sqlalchemy import and_, select, asc, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.modules.inventory.stock.models import StockLevel
from app.modules.inventory.schemas import StockLevelCreate, StockLevelUpdate



class StockLevelRepository:
    """Repository for StockLevel operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_all_with_details(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        active_only: bool = True
    ) -> List[StockLevel]:
        """Get all stock levels with item and location details."""
        # Import here to avoid circular imports
        from app.modules.master_data.item_master.models import Item
        from app.modules.master_data.locations.models import Location
        
        # Simple query first, then manually load relationships
        query = select(StockLevel)
        
        conditions = []
        if active_only:
            conditions.append(StockLevel.is_active == True)
        if item_id:
            conditions.append(StockLevel.item_id == str(item_id))
        if location_id:
            conditions.append(StockLevel.location_id == str(location_id))
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(asc(StockLevel.item_id)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        stock_levels = result.scalars().all()
        
        # Manually load relationships to ensure they're available
        for stock_level in stock_levels:
            # Load item
            item_result = await self.session.execute(
                select(Item).where(Item.id == stock_level.item_id)
            )
            stock_level.item = item_result.scalar_one_or_none()
            
            # Load location
            location_result = await self.session.execute(
                select(Location).where(Location.id == stock_level.location_id)
            )
            stock_level.location = location_result.scalar_one_or_none()
        
        return stock_levels
    
    async def create(self, stock_data: StockLevelCreate) -> StockLevel:
        """Create a new stock level."""
        stock_level = StockLevel(
            item_id=str(stock_data.item_id),
            location_id=str(stock_data.location_id),
            quantity_on_hand=stock_data.quantity_on_hand
        )
        
        if stock_data.quantity_available:
            stock_level.quantity_available = stock_data.quantity_available
        if stock_data.quantity_on_rent:
            stock_level.quantity_on_rent = stock_data.quantity_on_rent
        
        self.session.add(stock_level)
        await self.session.commit()
        await self.session.refresh(stock_level)
        return stock_level
    
    async def get_by_id(self, stock_id: UUID) -> Optional[StockLevel]:
        """Get stock level by ID."""
        query = select(StockLevel).where(StockLevel.id == stock_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_item_location(self, item_id: UUID, location_id: UUID) -> Optional[StockLevel]:
        """Get stock level by item and location."""
        query = select(StockLevel).where(
            and_(
                StockLevel.item_id == str(item_id),
                StockLevel.location_id == str(location_id)
            )
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        active_only: bool = True
    ) -> List[StockLevel]:
        """Get all stock levels with optional filtering."""
        query = select(StockLevel)
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(StockLevel.is_active == True)
        if item_id:
            conditions.append(StockLevel.item_id == str(item_id))
        if location_id:
            conditions.append(StockLevel.location_id == str(location_id))
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(asc(StockLevel.item_id)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_stock_levels_by_item(self, item_id: UUID, active_only: bool = True) -> List[StockLevel]:
        """Get stock levels by item."""
        query = select(StockLevel).where(StockLevel.item_id == str(item_id))
        
        if active_only:
            query = query.where(StockLevel.is_active == True)
        
        query = query.order_by(asc(StockLevel.location_id))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_stock_levels_by_location(self, location_id: UUID, active_only: bool = True) -> List[StockLevel]:
        """Get stock levels by location."""
        query = select(StockLevel).where(StockLevel.location_id == str(location_id))
        
        if active_only:
            query = query.where(StockLevel.is_active == True)
        
        query = query.order_by(asc(StockLevel.item_id))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_low_stock_items(self, active_only: bool = True) -> List[StockLevel]:
        """Get items with low stock (below configurable threshold)."""
        # Since reorder_point was removed, return empty list for now
        # This method can be enhanced later with configurable thresholds
        return []
    
    async def update(self, stock_id: UUID, stock_data: StockLevelUpdate) -> Optional[StockLevel]:
        """Update a stock level."""
        query = select(StockLevel).where(StockLevel.id == stock_id)
        result = await self.session.execute(query)
        stock_level = result.scalar_one_or_none()
        
        if not stock_level:
            return None
        
        # Update fields
        update_data = stock_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(stock_level, field, value)
        
        await self.session.commit()
        await self.session.refresh(stock_level)
        return stock_level
    
    async def delete(self, stock_id: UUID) -> bool:
        """Soft delete a stock level."""
        query = select(StockLevel).where(StockLevel.id == stock_id)
        result = await self.session.execute(query)
        stock_level = result.scalar_one_or_none()
        
        if not stock_level:
            return False
        
        stock_level.is_active = False
        await self.session.commit()
        return True


===== modules/inventory/services/__init__.py â€“ 2025-07-21 14:56:09 IST =====
from .item_service import ItemService
from ..units.services import InventoryUnitService
from .stock_level_service import StockLevelService
from .stock_movement_service import StockMovementService
from .inventory_report_service import InventoryReportService
from .inventory_update_service import InventoryUpdateService

__all__ = [
    "ItemService",
    "InventoryUnitService", 
    "StockLevelService",
    "StockMovementService",
    "InventoryReportService",
    "InventoryUpdateService"
]


===== modules/inventory/services/base_service.py â€“ 2025-07-21 18:25:15 IST =====
from typing import Optional
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession



from app.modules.inventory.units.repository import InventoryUnitRepository
from app.modules.inventory.stock.repository import StockLevelRepository
from app.modules.inventory.movements.repository import StockMovementRepository
from app.modules.master_data.item_master.repository import ItemMasterRepository


from app.modules.master_data.locations.repository import LocationRepository
from app.shared.utils.sku_generator import SKUGenerator


class BaseInventoryService:
    """Base service class with common repositories and utilities."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.item_repository = ItemMasterRepository(session)
        self.inventory_unit_repository = InventoryUnitRepository(session)
        self.stock_level_repository = StockLevelRepository(session)
        self.stock_movement_repository = StockMovementRepository(session)
        self.location_repository = LocationRepository(session)
        self.sku_generator = SKUGenerator(session)


===== modules/inventory/services/enhanced_inventory_update_service.py â€“ 2025-07-21 10:26:34 IST =====
"""
Enhanced Inventory Update Service

This service handles inventory stock level updates with proper transaction line tracking
and supports the required business logic for rental operations.
"""

from uuid import UUID
from decimal import Decimal
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import select
from datetime import datetime
import logging

from app.modules.inventory.enums import MovementType, ReferenceType
from app.modules.inventory.stock.models import StockLevel
from app.modules.inventory.movements.models import StockMovement
from app.modules.master_data.item_master.models import Item
from app.modules.master_data.locations.models import Location

from app.shared.exceptions import BusinessLogicError, NotFoundError, ValidationError

logger = logging.getLogger(__name__)


class EnhancedInventoryUpdateService:
    """
    Enhanced service for updating inventory stock levels and creating stock movements.
    Supports rental operations and transaction line tracking.
    """
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def update_inventory(
        self,
        transaction_line_item_id: UUID,
        item_id: UUID,
        location_id: UUID,
        quantity: int,
        stock_movement_type: MovementType,
        remarks: str = "",
        reference_type: ReferenceType = ReferenceType.TRANSACTION,
        reference_id: Optional[str] = None,
        created_by: Optional[UUID] = None
    ) -> dict:
        """
        Update inventory stock levels and create stock movement record.
        
        Args:
            transaction_line_item_id: UUID of the transaction line item
            item_id: Item ID
            location_id: Location ID  
            quantity: Quantity to move
            stock_movement_type: Type of movement (from MovementType enum)
            remarks: Additional remarks
            reference_type: Type of reference
            reference_id: External reference ID
            created_by: User who created this movement
            
        Returns:
            Dictionary with updated stock information
        """
        try:
            logger.info(f"Starting inventory update for item {item_id}, quantity {quantity}, type {stock_movement_type}")
            
            # 1. Validate item exists
            await self._validate_item_exists(item_id)
            
            # 2. Validate location exists
            await self._validate_location_exists(location_id)
            
            # 3. Get or create stock level
            stock_level = await self._get_or_create_stock_level(item_id, location_id)
            
            # 4. Get current stock quantity
            current_stock_quantity = stock_level.quantity_on_hand
            
            # 5. Calculate new stock quantity based on movement type
            new_stock_quantity = self._calculate_new_stock_quantity(
                current_stock_quantity, Decimal(str(quantity)), stock_movement_type
            )
            
            # 6. Calculate quantity on rent
            current_quantity_on_rent = stock_level.quantity_on_rent or Decimal("0")
            quantity_on_rent = self._calculate_quantity_on_rent(
                current_quantity_on_rent, Decimal(str(quantity)), stock_movement_type
            )
            
            # 7. Calculate quantity available
            quantity_available = new_stock_quantity - quantity_on_rent
            
            # 8. Validate business rules
            if quantity_available < 0:
                raise BusinessLogicError(
                    f"Insufficient available stock. Available: {stock_level.quantity_available}, "
                    f"Required: {quantity}"
                )
            
            # 9. Create stock movement record
            stock_movement = await self._create_stock_movement(
                stock_level_id=stock_level.id,
                item_id=item_id,
                location_id=location_id,
                movement_type=stock_movement_type,
                reference_type=reference_type,
                reference_id=reference_id or str(transaction_line_item_id),
                quantity_change=self._get_quantity_change(Decimal(str(quantity)), stock_movement_type),
                quantity_before=current_stock_quantity,
                quantity_after=new_stock_quantity,
                reason=self._get_movement_reason(stock_movement_type),
                notes=remarks,
                transaction_line_id=transaction_line_item_id,
                created_by=created_by
            )
            
            # 10. Update stock level
            stock_level.quantity_on_hand = new_stock_quantity
            stock_level.quantity_on_rent = quantity_on_rent
            stock_level.quantity_available = quantity_available
            stock_level.updated_at = datetime.utcnow()
            
            # 11. Commit changes
            self.session.add(stock_movement)
            await self.session.commit()
            await self.session.refresh(stock_movement)
            await self.session.refresh(stock_level)
            
            logger.info(f"Inventory update completed for item {item_id}")
            
            return {
                "stock_level_id": stock_level.id,
                "item_id": item_id,
                "location_id": location_id,
                "quantity_on_hand": new_stock_quantity,
                "quantity_available": quantity_available,
                "quantity_on_rent": quantity_on_rent,
                "stock_movement_id": stock_movement.id,
                "movement_type": stock_movement_type,
                "quantity_change": self._get_quantity_change(Decimal(str(quantity)), stock_movement_type)
            }
            
        except SQLAlchemyError as e:
            await self.session.rollback()
            logger.error(f"Database error during inventory update: {str(e)}")
            raise BusinessLogicError(f"Failed to update inventory: {str(e)}")
        except Exception as e:
            await self.session.rollback()
            logger.error(f"Unexpected error during inventory update: {str(e)}")
            raise
    
    async def _validate_item_exists(self, item_id: UUID) -> Item:
        """Validate that the item exists."""
        query = select(Item).where(Item.id == item_id)
        result = await self.session.execute(query)
        item = result.scalar_one_or_none()
        
        if not item:
            raise NotFoundError(f"Item with ID {item_id} not found")
        
        if not item.is_active:
            raise ValidationError(f"Item {item_id} is not active")
            
        return item
    
    async def _validate_location_exists(self, location_id: UUID) -> Location:
        """Validate that the location exists."""
        query = select(Location).where(Location.id == location_id)
        result = await self.session.execute(query)
        location = result.scalar_one_or_none()
        
        if not location:
            raise NotFoundError(f"Location with ID {location_id} not found")
        
        if not location.is_active:
            raise ValidationError(f"Location {location_id} is not active")
            
        return location
    
    async def _get_or_create_stock_level(self, item_id: UUID, location_id: UUID) -> StockLevel:
        """Get existing stock level or create a new one."""
        query = select(StockLevel).where(
            StockLevel.item_id == str(item_id),
            StockLevel.location_id == str(location_id)
        )
        result = await self.session.execute(query)
        stock_level = result.scalar_one_or_none()
        
        if not stock_level:
            # Create new stock level
            stock_level = StockLevel(
                item_id=str(item_id),
                location_id=str(location_id),
                quantity_on_hand=Decimal("0"),
                quantity_available=Decimal("0"),
                quantity_on_rent=Decimal("0")
            )
            self.session.add(stock_level)
            await self.session.flush()  # Get the ID without committing
            logger.info(f"Created new stock level for item {item_id} at location {location_id}")
        
        return stock_level
    
    def _calculate_new_stock_quantity(
        self, 
        current_quantity: Decimal, 
        quantity: Decimal, 
        movement_type: MovementType
    ) -> Decimal:
        """Calculate new stock quantity based on movement type."""
        if movement_type in [MovementType.PURCHASE, MovementType.RENTAL_RETURN, 
                           MovementType.ADJUSTMENT_POSITIVE, MovementType.TRANSFER_IN]:
            return current_quantity + quantity
        elif movement_type in [MovementType.SALE, MovementType.RENTAL_OUT,
                             MovementType.ADJUSTMENT_NEGATIVE, MovementType.TRANSFER_OUT,
                             MovementType.DAMAGE_LOSS, MovementType.THEFT_LOSS]:
            return current_quantity - quantity
        else:
            return current_quantity
    
    def _calculate_quantity_on_rent(
        self, 
        current_on_rent: Decimal, 
        quantity: Decimal, 
        movement_type: MovementType
    ) -> Decimal:
        """Calculate quantity on rent based on movement type."""
        if movement_type == MovementType.RENTAL_OUT:
            return current_on_rent + quantity
        elif movement_type == MovementType.RENTAL_RETURN:
            return current_on_rent - quantity
        else:
            return current_on_rent
    
    def _get_quantity_change(self, quantity: Decimal, movement_type: MovementType) -> Decimal:
        """Get the quantity change (positive or negative) for the movement."""
        if movement_type in [MovementType.PURCHASE, MovementType.RENTAL_RETURN,
                           MovementType.ADJUSTMENT_POSITIVE, MovementType.TRANSFER_IN]:
            return quantity
        elif movement_type in [MovementType.SALE, MovementType.RENTAL_OUT,
                             MovementType.ADJUSTMENT_NEGATIVE, MovementType.TRANSFER_OUT,
                             MovementType.DAMAGE_LOSS, MovementType.THEFT_LOSS]:
            return -quantity
        else:
            return Decimal("0")
    
    def _get_movement_reason(self, movement_type: MovementType) -> str:
        """Get standard reason based on movement type."""
        reasons = {
            MovementType.PURCHASE: "Stock purchased",
            MovementType.SALE: "Stock sold",
            MovementType.RENTAL_OUT: "Stock rented out",
            MovementType.RENTAL_RETURN: "Stock returned from rental",
            MovementType.ADJUSTMENT_POSITIVE: "Positive stock adjustment",
            MovementType.ADJUSTMENT_NEGATIVE: "Negative stock adjustment",
            MovementType.TRANSFER_IN: "Stock transferred in",
            MovementType.TRANSFER_OUT: "Stock transferred out",
            MovementType.DAMAGE_LOSS: "Stock damaged/lost",
            MovementType.THEFT_LOSS: "Stock theft loss",
            MovementType.SYSTEM_CORRECTION: "System correction"
        }
        return reasons.get(movement_type, "Stock movement")
    
    async def _create_stock_movement(
        self,
        stock_level_id: UUID,
        item_id: UUID,
        location_id: UUID,
        movement_type: MovementType,
        reference_type: ReferenceType,
        reference_id: str,
        quantity_change: Decimal,
        quantity_before: Decimal,
        quantity_after: Decimal,
        reason: str,
        notes: Optional[str] = None,
        transaction_line_id: Optional[UUID] = None,
        created_by: Optional[UUID] = None
    ) -> StockMovement:
        """Create a stock movement record."""
        stock_movement = StockMovement(
            stock_level_id=str(stock_level_id),
            item_id=str(item_id),
            location_id=str(location_id),
            movement_type=movement_type.value,
            reference_type=reference_type.value,
            reference_id=reference_id,
            quantity_change=quantity_change,
            quantity_before=quantity_before,
            quantity_after=quantity_after,
            reason=reason,
            notes=notes,
            transaction_line_id=str(transaction_line_id) if transaction_line_id else None
        )
        
        if created_by:
            stock_movement.created_by = str(created_by)
        
        return stock_movement


===== modules/inventory/services/inventory_report_service.py â€“ 2025-07-21 18:25:09 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime

from app.core.errors import NotFoundError
from app.modules.master_data.item_master.schemas import (
    ItemWithInventoryResponse, ItemListResponse
)
from app.modules.inventory.schemas import (
    InventoryReport, ItemInventoryOverview, ItemInventoryDetailed,
    ItemInventoryOverviewParams, UnitsByStatus, LocationStockInfo,
    InventoryUnitDetail, RecentMovement
)
from app.modules.master_data.locations.models import Location
from app.modules.master_data.item_master.models import Item
from .base_service import BaseInventoryService


class InventoryReportService(BaseInventoryService):
    """Service for inventory reporting and analytics operations."""
    
    async def get_inventory_report(self) -> InventoryReport:
        """Get comprehensive inventory report."""
        # Get all items
        items = await self.item_repository.get_all(active_only=True)
        
        # Get inventory counts
        total_items = len(items)
        total_active_items = len([item for item in items if item.is_active])
        
        # Get all inventory units
        all_units = await self.inventory_unit_repository.get_all(active_only=True)
        total_inventory_units = len(all_units)
        total_available_units = len([unit for unit in all_units if unit.is_available()])
        total_rented_units = len([unit for unit in all_units if unit.is_rented()])
        
        # Get items needing reorder
        low_stock_items = await self.stock_level_repository.get_low_stock_items()
        items_needing_reorder = []
        for stock_level in low_stock_items:
            item = await self.item_repository.get_by_id(UUID(stock_level.item_id))
            if item:
                items_needing_reorder.append(ItemListResponse.model_validate(item))
        
        # Convert items to response format
        item_responses = [ItemWithInventoryResponse.model_validate(item) for item in items]
        
        return InventoryReport(
            items=item_responses,
            total_items=total_items,
            total_active_items=total_active_items,
            total_inventory_units=total_inventory_units,
            total_available_units=total_available_units,
            total_rented_units=total_rented_units,
            items_needing_reorder=items_needing_reorder
        )
    
    async def get_items_inventory_overview(
        self,
        params: ItemInventoryOverviewParams
    ) -> List[ItemInventoryOverview]:
        """Get inventory overview for multiple items - optimized for table display."""
        from sqlalchemy import select, func, case, and_, or_
        from sqlalchemy.orm import selectinload
        
        # Base query for items
        query = select(Item).options(
            selectinload(Item.brand),
            selectinload(Item.category),
            selectinload(Item.inventory_units),
            selectinload(Item.stock_levels)
        )
        
        # Apply filters
        filters = []
        if params.item_status:
            filters.append(Item.item_status == params.item_status.value)
        if params.brand_id:
            filters.append(Item.brand_id == params.brand_id)
        if params.category_id:
            filters.append(Item.category_id == params.category_id)
        if params.is_rentable is not None:
            filters.append(Item.is_rentable == params.is_rentable)
        if params.is_saleable is not None:
            filters.append(Item.is_saleable == params.is_saleable)
        if params.search:
            search_term = f"%{params.search}%"
            filters.append(
                or_(
                    Item.item_name.ilike(search_term),
                    Item.sku.ilike(search_term)
                )
            )
        
        # Always filter active items
        filters.append(Item.is_active == True)
        
        if filters:
            query = query.where(and_(*filters))
        
        # Execute query
        result = await self.session.execute(query)
        items = result.scalars().all()
        
        # Build overview list
        overview_list = []
        for item in items:
            # Calculate units by status
            units_by_status = UnitsByStatus()
            for unit in item.inventory_units:
                if unit.is_active:
                    status = unit.status.lower()
                    if hasattr(units_by_status, status):
                        setattr(units_by_status, status, getattr(units_by_status, status) + 1)
            
            # Calculate stock totals
            total_on_hand = Decimal("0")
            total_available = Decimal("0")
            total_on_rent = Decimal("0")
            
            for stock_level in item.stock_levels:
                if stock_level.is_active:
                    total_on_hand += stock_level.quantity_on_hand
                    total_available += stock_level.quantity_available
                    total_on_rent += stock_level.quantity_on_rent
            
            # Determine stock status
            if units_by_status.available == 0 and total_available == 0:
                stock_status = "OUT_OF_STOCK"
            elif item.is_low_stock():
                stock_status = "LOW_STOCK"
            else:
                stock_status = "IN_STOCK"
            
            overview = ItemInventoryOverview(
                id=item.id,
                sku=item.sku,
                item_name=item.item_name,
                item_status=item.item_status,
                brand_name=item.brand.name if item.brand else None,
                category_name=item.category.name if item.category else None,
                rental_rate_per_period=item.rental_rate_per_period,
                sale_price=item.sale_price,
                is_rentable=item.is_rentable,
                is_saleable=item.is_saleable,
                total_units=len([u for u in item.inventory_units if u.is_active]),
                units_by_status=units_by_status,
                total_quantity_on_hand=total_on_hand,
                total_quantity_available=total_available,
                total_quantity_on_rent=total_on_rent,
                stock_status=stock_status,
                reorder_point=item.reorder_point,
                is_low_stock=item.is_low_stock(),
                created_at=item.created_at,
                updated_at=item.updated_at
            )
            overview_list.append(overview)
        
        # Apply stock status filter if specified
        if params.stock_status:
            overview_list = [o for o in overview_list if o.stock_status == params.stock_status]
        
        # Sort results
        sort_key = params.sort_by
        reverse = params.sort_order == "desc"
        
        if sort_key == "item_name":
            overview_list.sort(key=lambda x: x.item_name, reverse=reverse)
        elif sort_key == "sku":
            overview_list.sort(key=lambda x: x.sku, reverse=reverse)
        elif sort_key == "created_at":
            overview_list.sort(key=lambda x: x.created_at, reverse=reverse)
        elif sort_key == "total_units":
            overview_list.sort(key=lambda x: x.total_units, reverse=reverse)
        elif sort_key == "stock_status":
            # Define sort order for stock status
            status_order = {"OUT_OF_STOCK": 0, "LOW_STOCK": 1, "IN_STOCK": 2}
            overview_list.sort(
                key=lambda x: status_order.get(x.stock_status, 3),
                reverse=reverse
            )
        
        # Apply pagination
        start = params.skip
        end = params.skip + params.limit
        return overview_list[start:end]
    
    async def get_item_inventory_detailed(self, item_id: UUID) -> ItemInventoryDetailed:
        """Get detailed inventory information for a single item."""
        from sqlalchemy import select
        from sqlalchemy.orm import selectinload
        
        # Get item with all relationships
        query = select(Item).options(
            selectinload(Item.brand),
            selectinload(Item.category),
            selectinload(Item.unit_of_measurement),
            selectinload(Item.inventory_units),
            selectinload(Item.stock_levels),
            selectinload(Item.stock_movements)
        ).where(Item.id == item_id)
        
        result = await self.session.execute(query)
        item = result.scalar_one_or_none()
        
        if not item:
            raise NotFoundError(f"Item with ID {item_id} not found")
        
        # Build units by status
        units_by_status = UnitsByStatus()
        inventory_unit_details = []
        
        # Get location data for units
        location_ids = set()
        for unit in item.inventory_units:
            if unit.is_active:
                location_ids.add(unit.location_id)
        
        # Fetch locations
        locations_map = {}
        if location_ids:
            loc_query = select(Location).where(Location.id.in_(location_ids))
            loc_result = await self.session.execute(loc_query)
            locations = loc_result.scalars().all()
            locations_map = {loc.id: loc.location_name for loc in locations}
        
        # Process inventory units
        for unit in item.inventory_units:
            if unit.is_active:
                status = unit.status.lower()
                if hasattr(units_by_status, status):
                    setattr(units_by_status, status, getattr(units_by_status, status) + 1)
                
                unit_detail = InventoryUnitDetail(
                    id=unit.id,
                    unit_code=unit.unit_code,
                    serial_number=unit.serial_number,
                    status=unit.status,
                    condition=unit.condition,
                    location_id=unit.location_id,
                    location_name=locations_map.get(unit.location_id, "Unknown"),
                    purchase_date=unit.purchase_date,
                    purchase_price=unit.purchase_price,
                    warranty_expiry=unit.warranty_expiry,
                    last_maintenance_date=unit.last_maintenance_date,
                    next_maintenance_date=unit.next_maintenance_date,
                    notes=unit.notes,
                    created_at=unit.created_at,
                    updated_at=unit.updated_at
                )
                inventory_unit_details.append(unit_detail)
        
        # Process stock levels by location
        stock_by_location = []
        total_on_hand = Decimal("0")
        total_available = Decimal("0")
        total_on_rent = Decimal("0")
        
        for stock_level in item.stock_levels:
            if stock_level.is_active:
                total_on_hand += stock_level.quantity_on_hand
                total_available += stock_level.quantity_available
                total_on_rent += stock_level.quantity_on_rent
                
                location_stock = LocationStockInfo(
                    location_id=stock_level.location_id,
                    location_name=locations_map.get(stock_level.location_id, "Unknown"),
                    quantity_on_hand=stock_level.quantity_on_hand,
                    quantity_available=stock_level.quantity_available,
                    quantity_on_rent=stock_level.quantity_on_rent
                )
                stock_by_location.append(location_stock)
        
        # Get recent movements (last 10)
        recent_movements = []
        if item.stock_movements:
            # Sort by created_at descending and take first 10
            sorted_movements = sorted(
                item.stock_movements,
                key=lambda x: x.created_at,
                reverse=True
            )[:10]
            
            # Get user names if needed
            user_ids = set()
            for movement in sorted_movements:
                if movement.created_by:
                    user_ids.add(movement.created_by)
            
            # For now, we'll use user IDs as names
            # In a real implementation, you'd fetch user names from the users tables
            
            for movement in sorted_movements:
                recent_movement = RecentMovement(
                    id=movement.id,
                    movement_type=movement.movement_type,
                    quantity_change=movement.quantity_change,
                    reason=movement.reason,
                    reference_type=movement.reference_type,
                    reference_id=movement.reference_id,
                    location_name=locations_map.get(movement.location_id, "Unknown"),
                    created_at=movement.created_at,
                    created_by_name=str(movement.created_by) if movement.created_by else None
                )
                recent_movements.append(recent_movement)
        
        # Determine stock status
        if units_by_status.available == 0 and total_available == 0:
            stock_status = "OUT_OF_STOCK"
        elif item.is_low_stock():
            stock_status = "LOW_STOCK"
        else:
            stock_status = "IN_STOCK"
        
        # Build detailed response
        detailed = ItemInventoryDetailed(
            id=item.id,
            sku=item.sku,
            item_name=item.item_name,
            item_status=item.item_status,
            brand_id=item.brand_id,
            brand_name=item.brand.name if item.brand else None,
            category_id=item.category_id,
            category_name=item.category.name if item.category else None,
            unit_of_measurement_id=item.unit_of_measurement_id,
            unit_of_measurement_name=item.unit_of_measurement.name if item.unit_of_measurement else "Unknown",
            description=item.description,
            specifications=item.specifications,
            model_number=item.model_number,
            serial_number_required=item.serial_number_required,
            warranty_period_days=item.warranty_period_days,
            rental_rate_per_period=item.rental_rate_per_period,
            rental_period=item.rental_period,
            sale_price=item.sale_price,
            purchase_price=item.purchase_price,
            security_deposit=item.security_deposit,
            is_rentable=item.is_rentable,
            is_saleable=item.is_saleable,
            total_units=len([u for u in item.inventory_units if u.is_active]),
            units_by_status=units_by_status,
            inventory_units=inventory_unit_details,
            stock_by_location=stock_by_location,
            total_quantity_on_hand=total_on_hand,
            total_quantity_available=total_available,
            total_quantity_on_rent=total_on_rent,
            reorder_point=item.reorder_point,
            stock_status=stock_status,
            is_low_stock=item.is_low_stock(),
            recent_movements=recent_movements,
            is_active=item.is_active,
            created_at=item.created_at,
            updated_at=item.updated_at,
            created_by=item.created_by,
            updated_by=item.updated_by
        )
        
        return detailed


===== modules/inventory/services/inventory_update_service.py â€“ 2025-07-21 09:19:59 IST =====
"""
Inventory Update Service

Internal service for updating inventory stock levels and creating stock movements.
This service is designed to be used by other modules (purchase, sale, rental, etc.)
and not directly exposed as an API endpoint.
"""

from uuid import UUID
from decimal import Decimal
from typing import Optional
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from datetime import datetime
import logging

from ..enums import MovementType, ReferenceType
from ..stock.models import StockLevel
from ..movements.models import StockMovement
from ..schemas import InventoryUpdateRequest, InventoryUpdateResponse
from ...master_data.item_master.models import Item
from ....shared.exceptions import BusinessLogicError, NotFoundError

logger = logging.getLogger(__name__)


class InventoryUpdateService:
    """
    Internal service for updating inventory stock levels and creating stock movements.
    """
    
    def __init__(self, db: Session):
        self.db = db
    
    def update_inventory(
        self,
        transaction_line_item_id: UUID,
        item_id: UUID,
        location_id: UUID,
        quantity: int,
        stock_movement_type: MovementType,
        remarks: str = "",
        reference_type: ReferenceType = ReferenceType.TRANSACTION,
        reference_id: Optional[str] = None,
        created_by: Optional[UUID] = None
    ) -> InventoryUpdateResponse:
        """
        Update inventory stock levels and create stock movement record.
        """
        try:
            logger.info(f"Starting inventory update for item {item_id}, quantity {quantity}, type {stock_movement_type}")
            
            item = self._validate_item_exists(item_id)
            
            stock_level = self._get_or_create_stock_level(item_id, location_id)
            
            current_stock_quantity = stock_level.quantity_on_hand
            current_quantity_on_rent = stock_level.quantity_on_rent or Decimal("0")
            
            new_stock_quantity = self._calculate_new_stock_quantity(
                current_stock_quantity, Decimal(str(quantity)), stock_movement_type
            )
            
            new_quantity_on_rent = self._calculate_quantity_on_rent(
                current_quantity_on_rent, Decimal(str(quantity)), stock_movement_type
            )
            
            new_quantity_available = new_stock_quantity - new_quantity_on_rent
            
            if new_quantity_available < 0:
                raise BusinessLogicError(
                    f"Insufficient available stock. Available: {stock_level.quantity_available}, "
                    f"Required: {quantity}"
                )
            
            stock_movement = self._create_stock_movement(
                stock_level_id=stock_level.id,
                item_id=item_id,
                location_id=location_id,
                movement_type=stock_movement_type,
                reference_type=reference_type,
                reference_id=reference_id or str(transaction_line_item_id),
                quantity_change=self._get_quantity_change(Decimal(str(quantity)), stock_movement_type),
                quantity_before=current_stock_quantity,
                quantity_after=new_stock_quantity,
                reason=self._get_movement_reason(stock_movement_type),
                notes=remarks,
                transaction_line_id=transaction_line_item_id,
                created_by=created_by
            )
            
            stock_level.quantity_on_hand = new_stock_quantity
            stock_level.quantity_on_rent = new_quantity_on_rent
            stock_level.quantity_available = new_quantity_available
            stock_level.updated_at = datetime.utcnow()
            
            self.db.add(stock_movement)
            self.db.commit()
            self.db.refresh(stock_movement)
            self.db.refresh(stock_level)
            
            logger.info(f"Inventory update completed for item {item_id}")
            
            return InventoryUpdateResponse(
                stock_movement_id=stock_movement.id,
                stock_level_id=stock_level.id,
                item_id=item_id,
                location_id=location_id,
                movement_type=stock_movement_type,
                quantity_change=stock_movement.quantity_change,
                quantity_before=current_stock_quantity,
                quantity_after=new_stock_quantity,
                quantity_on_rent_before=current_quantity_on_rent,
                quantity_on_rent_after=new_quantity_on_rent,
                quantity_available_before=current_stock_quantity - current_quantity_on_rent,
                quantity_available_after=new_quantity_available,
                created_at=stock_movement.created_at
            )
            
        except SQLAlchemyError as e:
            self.db.rollback()
            logger.error(f"Database error during inventory update: {str(e)}")
            raise BusinessLogicError(f"Database error during inventory update: {str(e)}")
        except Exception as e:
            self.db.rollback()
            logger.error(f"Unexpected error during inventory update: {str(e)}")
            raise
    
    def _validate_item_exists(self, item_id: UUID) -> Item:
        item = self.db.query(Item).filter(
            Item.id == item_id,
            Item.is_active == True
        ).first()
        
        if not item:
            raise NotFoundError("Item", item_id)
        
        return item
    
    def _get_or_create_stock_level(self, item_id: UUID, location_id: UUID) -> StockLevel:
        stock_level = self.db.query(StockLevel).filter(
            StockLevel.item_id == item_id,
            StockLevel.location_id == location_id,
            StockLevel.is_active == True
        ).first()
        
        if not stock_level:
            stock_level = StockLevel(
                item_id=item_id,
                location_id=location_id,
                quantity_on_hand=Decimal("0"),
                quantity_on_rent=Decimal("0"),
                quantity_available=Decimal("0"),
                is_active=True,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            self.db.add(stock_level)
            self.db.flush()
            logger.info(f"Created new stock level for item {item_id} at location {location_id}")
        
        return stock_level
    
    def _calculate_new_stock_quantity(
        self, 
        current_quantity: Decimal, 
        quantity: Decimal, 
        movement_type: MovementType
    ) -> Decimal:
        positive_movements = {
            MovementType.PURCHASE,
            MovementType.RENTAL_RETURN,
            MovementType.ADJUSTMENT_POSITIVE,
            MovementType.TRANSFER_IN,
            MovementType.SYSTEM_CORRECTION
        }
        
        negative_movements = {
            MovementType.SALE,
            MovementType.RENTAL_OUT,
            MovementType.ADJUSTMENT_NEGATIVE,
            MovementType.TRANSFER_OUT,
            MovementType.DAMAGE_LOSS,
            MovementType.THEFT_LOSS
        }
        
        if movement_type in positive_movements:
            return current_quantity + quantity
        elif movement_type in negative_movements:
            new_quantity = current_quantity - quantity
            if new_quantity < 0:
                raise BusinessLogicError(
                    f"Insufficient stock for {movement_type.value}. Current: {current_quantity}, "
                    f"Required: {quantity}"
                )
            return new_quantity
        else:
            raise BusinessLogicError(f"Unknown movement type: {movement_type}")
    
    def _calculate_quantity_on_rent(
        self, 
        current_on_rent: Decimal, 
        quantity: Decimal, 
        movement_type: MovementType
    ) -> Decimal:
        if movement_type == MovementType.RENTAL_OUT:
            return current_on_rent + quantity
        elif movement_type == MovementType.RENTAL_RETURN:
            new_on_rent = current_on_rent - quantity
            if new_on_rent < 0:
                raise BusinessLogicError(
                    f"Cannot return more than rented. Currently on rent: {current_on_rent}, "
                    f"Trying to return: {quantity}"
                )
            return new_on_rent
        else:
            return current_on_rent
    
    def _get_quantity_change(self, quantity: Decimal, movement_type: MovementType) -> Decimal:
        negative_movements = {
            MovementType.SALE,
            MovementType.RENTAL_OUT,
            MovementType.ADJUSTMENT_NEGATIVE,
            MovementType.TRANSFER_OUT,
            MovementType.DAMAGE_LOSS,
            MovementType.THEFT_LOSS
        }
        
        return -quantity if movement_type in negative_movements else quantity
    
    def _get_movement_reason(self, movement_type: MovementType) -> str:
        reason_map = {
            MovementType.PURCHASE: "Stock purchased and added to inventory",
            MovementType.SALE: "Item sold and removed from inventory",
            MovementType.RENTAL_OUT: "Item rented out to customer",
            MovementType.RENTAL_RETURN: "Item returned from rental",
            MovementType.ADJUSTMENT_POSITIVE: "Positive stock adjustment",
            MovementType.ADJUSTMENT_NEGATIVE: "Negative stock adjustment",
            MovementType.TRANSFER_IN: "Stock transferred in from another location",
            MovementType.TRANSFER_OUT: "Stock transferred out to another location",
            MovementType.DAMAGE_LOSS: "Item damaged or lost",
            MovementType.THEFT_LOSS: "Item stolen or lost due to theft",
            MovementType.SYSTEM_CORRECTION: "System correction for stock discrepancy"
        }
        
        return reason_map.get(movement_type, f"Stock movement: {movement_type.value}")
    
    def _create_stock_movement(
        self,
        stock_level_id: UUID,
        item_id: UUID,
        location_id: UUID,
        movement_type: MovementType,
        reference_type: ReferenceType,
        reference_id: str,
        quantity_change: Decimal,
        quantity_before: Decimal,
        quantity_after: Decimal,
        reason: str,
        notes: str,
        transaction_line_item_id: Optional[UUID] = None,
        created_by: Optional[UUID] = None
    ) -> StockMovement:
        return StockMovement(
            stock_level_id=stock_level_id,
            item_id=item_id,
            location_id=location_id,
            movement_type=movement_type,
            reference_type=reference_type,
            reference_id=reference_id,
            quantity_change=quantity_change,
            quantity_before=quantity_before,
            quantity_after=quantity_after,
            reason=reason,
            notes=notes,
            transaction_line_id=transaction_line_item_id,
            created_by=created_by,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
            is_active=True
        )

===== modules/inventory/services/item_service.py â€“ 2025-07-20 21:17:08 IST =====
from typing import Optional, List
from uuid import UUID
from decimal import Decimal

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.master_data.item_master.models import Item, ItemStatus
from app.modules.master_data.item_master.schemas import (
    ItemCreate, ItemUpdate, ItemResponse, ItemListResponse,
    SKUGenerationRequest, SKUGenerationResponse, SKUBulkGenerationResponse
)
from .base_service import BaseInventoryService


class ItemService(BaseInventoryService):
    """Service for item management operations."""
    
    async def create_item(self, item_data: ItemCreate) -> ItemResponse:
        """Create a new item with automatic SKU generation."""
        # Check if item code already exists
        existing_item = await self.item_repository.get_by_code(item_data.item_code)
        if existing_item:
            raise ConflictError(f"Item with code '{item_data.item_code}' already exists")
        
        # Generate SKU automatically using new format
        sku = await self.sku_generator.generate_sku(
            category_id=item_data.category_id,
            item_name=item_data.item_name,
            item_type=item_data.item_type.value
        )
        
        # Validate item type and pricing
        self._validate_item_pricing(item_data)
        
        # Create item with generated SKU
        item = await self.item_repository.create(item_data, sku)
        return ItemResponse.model_validate(item)
    
    async def get_item(self, item_id: UUID) -> ItemResponse:
        """Get item by ID."""
        item = await self.item_repository.get_by_id(item_id)
        if not item:
            raise NotFoundError(f"Item with ID {item_id} not found")
        
        return ItemResponse.model_validate(item)
    
    async def get_item_by_code(self, item_code: str) -> ItemResponse:
        """Get item by code."""
        item = await self.item_repository.get_by_code(item_code)
        if not item:
            raise NotFoundError(f"Item with code '{item_code}' not found")
        
        return ItemResponse.model_validate(item)
    
    async def get_item_by_sku(self, sku: str) -> ItemResponse:
        """Get item by SKU."""
        item = await self.item_repository.get_by_sku(sku)
        if not item:
            raise NotFoundError(f"Item with SKU '{sku}' not found")
        return ItemResponse.model_validate(item)
    
    async def get_items(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_status: Optional[ItemStatus] = None,
        brand_id: Optional[UUID] = None,
        category_id: Optional[UUID] = None,
        active_only: bool = True
    ) -> List[ItemListResponse]:
        """Get all items with optional filtering."""
        items = await self.item_repository.get_all(
            skip=skip,
            limit=limit,
            item_status=item_status,
            brand_id=brand_id,
            category_id=category_id,
            active_only=active_only
        )
        
        return [ItemListResponse.model_validate(item) for item in items]
    
    async def search_items(
        self, 
        search_term: str, 
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[ItemListResponse]:
        """Search items by name or code."""
        items = await self.item_repository.search(
            search_term=search_term,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
        
        return [ItemListResponse.model_validate(item) for item in items]
    
    async def update_item(self, item_id: UUID, item_data: ItemUpdate) -> ItemResponse:
        """Update an item."""
        # Check if item exists
        existing_item = await self.item_repository.get_by_id(item_id)
        if not existing_item:
            raise NotFoundError(f"Item with ID {item_id} not found")
        
        # Validate pricing if relevant fields are being updated
        if any(field in item_data.model_dump(exclude_unset=True) for field in [
            'rental_rate_per_period', 'rental_period', 'sale_price'
        ]):
            self._validate_item_pricing_update(existing_item, item_data)
        
        # Update item
        item = await self.item_repository.update(item_id, item_data)
        return ItemResponse.model_validate(item)
    
    async def delete_item(self, item_id: UUID) -> bool:
        """Delete an item."""
        # Check if item has inventory units
        units = await self.inventory_unit_repository.get_units_by_item(item_id)
        if units:
            raise ValidationError("Cannot delete item with existing inventory units")
        
        return await self.item_repository.delete(item_id)
    
    async def get_rental_items(self, active_only: bool = True) -> List[ItemListResponse]:
        """Get all rental items."""
        items = await self.item_repository.get_rental_items(active_only=active_only)
        return [ItemListResponse.model_validate(item) for item in items]
    
    async def get_sale_items(self, active_only: bool = True) -> List[ItemListResponse]:
        """Get all sale items."""
        items = await self.item_repository.get_sale_items(active_only=active_only)
        return [ItemListResponse.model_validate(item) for item in items]
    
    async def generate_sku_preview(self, request: SKUGenerationRequest) -> SKUGenerationResponse:
        """Generate a preview of what SKU would be created."""
        sku = await self.sku_generator.preview_sku(
            category_id=request.category_id,
            item_name=request.item_name,
            item_type=request.item_type
        )
        
        # Extract components for response
        parts = sku.split('-')
        if len(parts) == 5:
            category_code, subcategory_code, product_code, attributes_code, sequence = parts
            sequence_number = int(sequence)
        else:
            category_code = "MISC"
            subcategory_code = "ITEM"
            sequence_number = 1
        
        return SKUGenerationResponse(
            sku=sku,
            category_code=category_code,
            subcategory_code=subcategory_code,
            product_code=parts[2] if len(parts) > 2 else "PROD",
            attributes_code=parts[3] if len(parts) > 3 else "R",
            sequence_number=sequence_number
        )
    
    async def bulk_generate_skus(self) -> SKUBulkGenerationResponse:
        """Generate SKUs for all existing items that don't have them."""
        result = await self.sku_generator.bulk_generate_skus_for_existing_items()
        return SKUBulkGenerationResponse(**result)
    
    def _validate_item_pricing(self, item_data: ItemCreate):
        """Validate item pricing based on boolean fields."""
        if item_data.is_rentable:
            if not item_data.rental_rate_per_period:
                raise ValidationError("Rental rate per period is required for rentable items")
        
        if item_data.is_saleable:
            if not item_data.sale_price:
                raise ValidationError("Sale price is required for saleable items")
    
    def _validate_item_pricing_update(self, existing_item: Item, item_data: ItemUpdate):
        """Validate item pricing for updates."""
        # Get effective boolean fields after update
        is_rentable = item_data.is_rentable if item_data.is_rentable is not None else existing_item.is_rentable
        is_saleable = item_data.is_saleable if item_data.is_saleable is not None else existing_item.is_saleable
        
        # Get effective pricing after update
        rental_price = item_data.rental_rate_per_period if item_data.rental_rate_per_period is not None else existing_item.rental_rate_per_period
        sale_price = item_data.sale_price if item_data.sale_price is not None else existing_item.sale_price
        
        if is_rentable:
            if not rental_price:
                raise ValidationError("Rental price per day is required for rentable items")
        
        if is_saleable:
            if not sale_price:
                raise ValidationError("Sale price is required for saleable items")


===== modules/inventory/services/stock_level_service.py â€“ 2025-07-21 18:24:59 IST =====
from typing import Optional, List
from uuid import UUID
from decimal import Decimal
from datetime import datetime

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.inventory import ReferenceType, MovementType
from app.modules.inventory.schemas import (
    StockLevelCreate, StockLevelUpdate, StockLevelResponse, StockLevelListResponse,
    StockAdjustment, StockReservation, StockReservationRelease
)
from .base_service import BaseInventoryService


class StockLevelService(BaseInventoryService):
    """Service for stock level operations."""
    
    async def create_stock_level(self, stock_data: StockLevelCreate) -> StockLevelResponse:
        """Create a new stock level."""
        # Check if stock level already exists for this item/location
        existing_stock = await self.stock_level_repository.get_by_item_location(
            stock_data.item_id, stock_data.location_id
        )
        if existing_stock:
            raise ConflictError(f"Stock level already exists for item {stock_data.item_id} at location {stock_data.location_id}")
        
        # Create stock level
        stock_level = await self.stock_level_repository.create(stock_data)
        return StockLevelResponse.model_validate(stock_level)
    
    async def get_stock_level(self, stock_id: UUID) -> StockLevelResponse:
        """Get stock level by ID."""
        stock_level = await self.stock_level_repository.get_by_id(stock_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_id} not found")
        
        return StockLevelResponse.model_validate(stock_level)
    
    async def get_stock_levels(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        active_only: bool = True
    ) -> List[StockLevelListResponse]:
        """Get all stock levels with optional filtering."""
        stock_levels = await self.stock_level_repository.get_all_with_details(
            skip=skip,
            limit=limit,
            item_id=item_id,
            location_id=location_id,
            active_only=active_only
        )
        
        return [StockLevelListResponse.model_validate(stock) for stock in stock_levels]
    
    async def update_stock_level(self, stock_id: UUID, stock_data: StockLevelUpdate) -> StockLevelResponse:
        """Update a stock level."""
        # Check if stock level exists
        existing_stock = await self.stock_level_repository.get_by_id(stock_id)
        if not existing_stock:
            raise NotFoundError(f"Stock level with ID {stock_id} not found")
        
        # Update stock level
        stock_level = await self.stock_level_repository.update(stock_id, stock_data)
        return StockLevelResponse.model_validate(stock_level)
    
    async def adjust_stock(self, stock_id: UUID, adjustment_data: StockAdjustment) -> StockLevelResponse:
        """Adjust stock quantity."""
        stock_level = await self.stock_level_repository.get_by_id(stock_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_id} not found")
        
        stock_level.adjust_quantity(adjustment_data.adjustment)
        await self.session.commit()
        await self.session.refresh(stock_level)
        
        return StockLevelResponse.model_validate(stock_level)
    
    async def reserve_stock(self, stock_id: UUID, reservation_data: StockReservation) -> StockLevelResponse:
        """Reserve stock quantity."""
        stock_level = await self.stock_level_repository.get_by_id(stock_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_id} not found")
        
        stock_level.reserve_quantity(reservation_data.quantity)
        await self.session.commit()
        await self.session.refresh(stock_level)
        
        return StockLevelResponse.model_validate(stock_level)
    
    async def release_stock_reservation(self, stock_id: UUID, release_data: StockReservationRelease) -> StockLevelResponse:
        """Release stock reservation."""
        stock_level = await self.stock_level_repository.get_by_id(stock_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_id} not found")
        
        stock_level.release_reservation(release_data.quantity)
        await self.session.commit()
        await self.session.refresh(stock_level)
        
        return StockLevelResponse.model_validate(stock_level)
    
    async def get_low_stock_items(self) -> List[StockLevelResponse]:
        """Get items with low stock."""
        low_stock_items = await self.stock_level_repository.get_low_stock_items()
        return [StockLevelResponse.model_validate(stock) for stock in low_stock_items]
    
    async def adjust_stock_level(
        self,
        item_id: UUID,
        location_id: UUID,
        quantity_change: Decimal,
        transaction_type: str,
        reference_id: str,
        notes: Optional[str] = None
    ) -> StockLevelResponse:
        """Adjust stock level for return processing."""
        # Get current stock level
        stock_level = await self.stock_level_repository.get_by_item_location(
            item_id=item_id,
            location_id=location_id
        )
        
        quantity_before = Decimal("0")
        
        if not stock_level:
            if quantity_change < 0:
                raise ValidationError("Cannot remove from non-existent stock")
            
            # Create new stock level for positive adjustments
            stock_data = StockLevelCreate(
                item_id=item_id,
                location_id=location_id,
                quantity_on_hand=quantity_change,
                quantity_available=quantity_change
            )
            
            stock_level = await self.stock_level_repository.create(stock_data)
            quantity_before = Decimal("0")
        else:
            # Update existing stock
            quantity_before = stock_level.quantity_on_hand
            stock_level.adjust_quantity(quantity_change)
            
            await self.session.commit()
            await self.session.refresh(stock_level)
        
        quantity_after = stock_level.quantity_on_hand
        
        # Determine movement type based on transaction type
        movement_type = self._map_transaction_to_movement_type(transaction_type)
        
        # Import the stock movement service to create movement record
        from .stock_movement_service import StockMovementService
        movement_service = StockMovementService(self.session)
        
        # Create stock movement record
        await movement_service._create_stock_movement_record(
            stock_level_id=stock_level.id,
            movement_type=movement_type,
            quantity_change=quantity_change,
            quantity_before=quantity_before,
            quantity_after=quantity_after,
            reference_type=ReferenceType.TRANSACTION,
            reference_id=reference_id,
            reason=f"{transaction_type} - {notes or 'Stock adjustment'}",
            notes=notes
        )
        
        return StockLevelResponse.model_validate(stock_level)
    
    async def update_stock_condition(
        self,
        item_id: UUID,
        location_id: UUID,
        quantity: Decimal,
        condition: str,
        status: str
    ) -> None:
        """Update stock condition for items without individual unit tracking."""
        stock_level = await self.stock_level_repository.get_by_item_location(
            item_id=item_id,
            location_id=location_id
        )
        
        if not stock_level:
            raise NotFoundError(f"Stock level not found for item {item_id} at location {location_id}")
        
        # Add condition tracking to notes (simplified approach)
        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
        condition_note = f"\n[{timestamp}] {quantity} units in {condition} condition, status: {status}"
        stock_level.notes = (stock_level.notes or "") + condition_note
        
        await self.session.commit()
    
    async def rent_out_stock(
        self,
        stock_level_id: UUID,
        quantity: Decimal,
        transaction_id: str,
        updated_by: Optional[str] = None
    ) -> StockLevelResponse:
        """Move stock from available to on rent."""
        # Get current stock level
        stock_level = await self.stock_level_repository.get_by_id(stock_level_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_level_id} not found")
        
        # Move quantity from available to on rent
        stock_level.rent_out_quantity(quantity, updated_by=updated_by)
        await self.session.commit()
        await self.session.refresh(stock_level)
        
        return StockLevelResponse.model_validate(stock_level)
    
    async def return_from_rent(
        self,
        stock_level_id: UUID,
        quantity: Decimal,
        transaction_id: str,
        updated_by: Optional[str] = None
    ) -> StockLevelResponse:
        """Move stock from on rent back to available."""
        # Get current stock level
        stock_level = await self.stock_level_repository.get_by_id(stock_level_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_level_id} not found")
        
        # Move quantity from on rent to available
        stock_level.return_from_rent(quantity, updated_by=updated_by)
        await self.session.commit()
        await self.session.refresh(stock_level)
        
        return StockLevelResponse.model_validate(stock_level)
    
    def _map_transaction_to_movement_type(self, transaction_type: str) -> str:
        """Map transaction type to movement type."""
        mapping = {
            "RENTAL_OUT": MovementType.RENTAL_OUT.value,
            "RENTAL_RETURN": MovementType.RENTAL_RETURN.value,
            "SALE": MovementType.SALE.value,
            "PURCHASE": MovementType.PURCHASE.value,
            "ADJUSTMENT": MovementType.ADJUSTMENT_POSITIVE.value,
            "DAMAGE": MovementType.DAMAGE_LOSS.value,
            "TRANSFER_IN": MovementType.TRANSFER_IN.value,
            "TRANSFER_OUT": MovementType.TRANSFER_OUT.value,
        }
        return mapping.get(transaction_type, MovementType.SYSTEM_CORRECTION.value)


===== modules/inventory/services/stock_movement_service.py â€“ 2025-07-21 18:26:16 IST =====
from typing import Optional, List
from uuid import UUID
from decimal import Decimal
from datetime import datetime

from app.core.errors import NotFoundError, ValidationError
from app.modules.inventory import (
    StockMovement, MovementType, ReferenceType
)
from app.modules.inventory.schemas import (
    StockMovementResponse, StockMovementSummaryResponse
)
from .base_service import BaseInventoryService


class StockMovementService(BaseInventoryService):
    """Service for stock movement operations."""
    
    async def get_stock_movements_by_stock_level(
        self,
        stock_level_id: UUID,
        skip: int = 0,
        limit: int = 100
    ) -> List[StockMovementResponse]:
        """Get stock movements for a specific stock level."""
        movements = await self.stock_movement_repository.get_by_stock_level(
            stock_level_id=stock_level_id,
            skip=skip,
            limit=limit
        )
        return [StockMovementResponse.model_validate(movement) for movement in movements]
    
    async def get_stock_movements_by_item(
        self,
        item_id: UUID,
        skip: int = 0,
        limit: int = 100,
        movement_type: Optional[MovementType] = None
    ) -> List[StockMovementResponse]:
        """Get stock movements for a specific item."""
        movements = await self.stock_movement_repository.get_by_item(
            item_id=item_id,
            skip=skip,
            limit=limit,
            movement_type=movement_type
        )
        return [StockMovementResponse.model_validate(movement) for movement in movements]
    
    async def get_stock_movements_by_reference(
        self,
        reference_type: ReferenceType,
        reference_id: str
    ) -> List[StockMovementResponse]:
        """Get stock movements by reference."""
        movements = await self.stock_movement_repository.get_by_reference(
            reference_type=reference_type,
            reference_id=reference_id
        )
        return [StockMovementResponse.model_validate(movement) for movement in movements]
    
    async def get_stock_movements_by_date_range(
        self,
        start_date: datetime,
        end_date: datetime,
        item_id: Optional[UUID] = None,
        location_id: Optional[UUID] = None,
        movement_type: Optional[MovementType] = None
    ) -> List[StockMovementResponse]:
        """Get stock movements within a date range."""
        movements = await self.stock_movement_repository.get_movements_by_date_range(
            start_date=start_date,
            end_date=end_date,
            item_id=item_id,
            location_id=location_id,
            movement_type=movement_type
        )
        return [StockMovementResponse.model_validate(movement) for movement in movements]
    
    async def get_stock_movement_summary(
        self,
        item_id: UUID,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> StockMovementSummaryResponse:
        """Get movement summary for an item."""
        summary = await self.stock_movement_repository.get_movement_summary(
            item_id=item_id,
            start_date=start_date,
            end_date=end_date
        )
        return StockMovementSummaryResponse.model_validate(summary)
    
    async def create_manual_stock_movement(
        self,
        stock_level_id: UUID,
        movement_type: MovementType,
        quantity_change: Decimal,
        reason: str,
        notes: Optional[str] = None,
        created_by: Optional[str] = None
    ) -> StockMovementResponse:
        """Create a manual stock movement record."""
        # Get current stock level
        stock_level = await self.stock_level_repository.get_by_id(stock_level_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_level_id} not found")
        
        quantity_before = stock_level.quantity_on_hand
        
        # Update stock level
        stock_level.adjust_quantity(quantity_change, updated_by=created_by)
        await self.session.commit()
        await self.session.refresh(stock_level)
        
        quantity_after = stock_level.quantity_on_hand
        
        # Create movement record
        movement = await self._create_stock_movement_record(
            stock_level_id=stock_level_id,
            movement_type=movement_type.value,
            quantity_change=quantity_change,
            quantity_before=quantity_before,
            quantity_after=quantity_after,
            reference_type=ReferenceType.MANUAL_ADJUSTMENT,
            reference_id=f"MANUAL_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}",
            reason=reason,
            notes=notes,
            created_by=created_by
        )
        
        return StockMovementResponse.model_validate(movement)
    
    async def rent_out_stock(
        self,
        stock_level_id: UUID,
        quantity: Decimal,
        transaction_id: str,
        updated_by: Optional[str] = None
    ) -> StockMovementResponse:
        """Move stock from available to on rent."""
        # Get current stock level
        stock_level = await self.stock_level_repository.get_by_id(stock_level_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_level_id} not found")
        
        quantity_before = stock_level.quantity_available
        
        # Move quantity from available to on rent
        stock_level.rent_out_quantity(quantity, updated_by=updated_by)
        await self.session.commit()
        await self.session.refresh(stock_level)
        
        # Create movement record
        movement = await self._create_stock_movement_record(
            stock_level_id=stock_level_id,
            movement_type=MovementType.RENTAL_OUT.value,
            quantity_change=-quantity,  # Negative because it's leaving available
            quantity_before=quantity_before,
            quantity_after=stock_level.quantity_available,
            reference_type=ReferenceType.TRANSACTION,
            reference_id=transaction_id,
            reason=f"Rented out {quantity} units",
            created_by=updated_by
        )
        
        return StockMovementResponse.model_validate(movement)
    
    async def return_from_rent(
        self,
        stock_level_id: UUID,
        quantity: Decimal,
        transaction_id: str,
        updated_by: Optional[str] = None
    ) -> StockMovementResponse:
        """Move stock from on rent back to available."""
        # Get current stock level
        stock_level = await self.stock_level_repository.get_by_id(stock_level_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_level_id} not found")
        
        quantity_before = stock_level.quantity_available
        
        # Move quantity from on rent to available
        stock_level.return_from_rent(quantity, updated_by=updated_by)
        await self.session.commit()
        await self.session.refresh(stock_level)
        
        # Create movement record
        movement = await self._create_stock_movement_record(
            stock_level_id=stock_level_id,
            movement_type=MovementType.RENTAL_RETURN.value,
            quantity_change=quantity,  # Positive because it's returning to available
            quantity_before=quantity_before,
            quantity_after=stock_level.quantity_available,
            reference_type=ReferenceType.TRANSACTION,
            reference_id=transaction_id,
            reason=f"Returned {quantity} units from rent",
            created_by=updated_by
        )
        
        return StockMovementResponse.model_validate(movement)
    
    async def _create_stock_movement_record(
        self,
        stock_level_id: UUID,
        movement_type: str,
        quantity_change: Decimal,
        quantity_before: Decimal,
        quantity_after: Decimal,
        reference_type: ReferenceType,
        reference_id: str,
        reason: str,
        notes: Optional[str] = None,
        transaction_line_id: Optional[UUID] = None,
        created_by: Optional[str] = None
    ) -> StockMovement:
        """
        Create a stock movement record for audit trail.
        
        Args:
            stock_level_id: ID of the stock level being modified
            movement_type: Type of movement (from MovementType enum)
            quantity_change: Amount of change (+/-)
            quantity_before: Quantity before the movement
            quantity_after: Quantity after the movement
            reference_type: Type of reference (from ReferenceType enum)
            reference_id: External reference ID
            reason: Human-readable reason for the movement
            notes: Additional notes
            transaction_line_id: Optional transaction line reference
            created_by: User who created the movement
        
        Returns:
            The created stock movement record
        """
        # Get stock level to extract item_id and location_id
        stock_level = await self.stock_level_repository.get_by_id(stock_level_id)
        if not stock_level:
            raise NotFoundError(f"Stock level with ID {stock_level_id} not found")
        
        # Create movement data
        movement_data = {
            "stock_level_id": stock_level_id,
            "item_id": stock_level.item_id,
            "location_id": stock_level.location_id,
            "movement_type": movement_type,
            "reference_type": reference_type.value,
            "reference_id": reference_id,
            "quantity_change": quantity_change,
            "quantity_before": quantity_before,
            "quantity_after": quantity_after,
            "reason": reason,
            "notes": notes,
            "transaction_line_id": transaction_line_id,
            "created_by": created_by
        }
        
        # Create the movement record
        movement = await self.stock_movement_repository.create(movement_data)
        
        # Log the movement for debugging
        import logging
        logger = logging.getLogger(__name__)
        logger.info(
            f"Stock movement created: {movement_type} - "
            f"Stock Level: {stock_level_id}, "
            f"Change: {quantity_change}, "
            f"Before: {quantity_before}, After: {quantity_after}, "
            f"Reference: {reference_type.value}:{reference_id}"
        )
        
        return movement


===== modules/users/__init__.py â€“ 2025-07-19 12:13:41 IST =====


===== modules/users/models.py â€“ 2025-07-19 12:13:41 IST =====
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.orm import relationship, Mapped, mapped_column
from sqlalchemy.sql import func
from datetime import datetime
from typing import Optional, List

from app.db.base import Base
from app.modules.auth.models import user_roles_table, user_permissions_table, UserType, Role, Permission

# Create UserRole alias for backward compatibility
UserRole = Role


class User(Base):
    """User model"""
    __tablename__ = "users"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    username: Mapped[str] = mapped_column(String(50), unique=True, index=True, nullable=False)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
    password: Mapped[str] = mapped_column(String(255), nullable=False)
    full_name: Mapped[str] = mapped_column(String(255), nullable=False)
    
    # Enhanced name fields for frontend compatibility
    first_name: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    last_name: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    
    # Status fields
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    is_superuser: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    is_verified: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    
    # User type for hierarchy
    user_type: Mapped[str] = mapped_column(String(20), default=UserType.USER.value, nullable=False)
    
    # Optional profile fields
    phone: Mapped[Optional[str]] = mapped_column(String(20), nullable=True)
    avatar_url: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
    bio: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # Timestamps
    last_login: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    email_verified_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    refresh_tokens = relationship("RefreshToken", back_populates="user", cascade="all, delete-orphan")
    password_reset_tokens = relationship("PasswordResetToken", back_populates="user", cascade="all, delete-orphan")
    
    # RBAC relationships
    roles = relationship("Role", secondary=user_roles_table, back_populates="users")
    direct_permissions = relationship("Permission", secondary=user_permissions_table, 
                                    primaryjoin="User.id == user_permissions.c.user_id",
                                    secondaryjoin="Permission.id == user_permissions.c.permission_id")
    
    def __repr__(self):
        return f"<User(id={self.id}, email={self.email}, active={self.is_active})>"
    
    @property
    def is_authenticated(self) -> bool:
        """Check if user is authenticated"""
        return self.is_active
    
    @property
    def display_name(self) -> str:
        """Get display name for user"""
        return self.full_name or self.email
    
    @property
    def name(self) -> str:
        """Get name for frontend compatibility"""
        return self.full_name or f"{self.first_name or ''} {self.last_name or ''}".strip() or self.email
    
    @property
    def firstName(self) -> str:
        """Get first name for frontend compatibility"""
        return self.first_name or ""
    
    @property
    def lastName(self) -> str:
        """Get last name for frontend compatibility"""
        return self.last_name or ""
    
    def get_user_type(self) -> UserType:
        """Get user type enum"""
        return UserType(self.user_type)
    
    def has_role(self, role_name: str) -> bool:
        """Check if user has a specific role"""
        return any(role.name == role_name for role in self.roles)
    
    def has_permission(self, permission_name: str) -> bool:
        """Check if user has a specific permission"""
        # Superusers have all permissions
        if self.is_superuser:
            return True
            
        # Check direct permissions
        for permission in self.direct_permissions:
            if permission.name == permission_name:
                return True
                
        # Check role permissions
        for role in self.roles:
            if role.has_permission(permission_name):
                return True
        return False
    
    def get_permissions(self) -> List[str]:
        """Get all permissions for the user"""
        permissions = set()
        
        # Add direct permissions
        for permission in self.direct_permissions:
            permissions.add(permission.name)
            
        # Add role permissions
        for role in self.roles:
            permissions.update(role.get_permissions())
            
        return list(permissions)
    
    def get_role_permissions(self) -> List[str]:
        """Get all permissions from roles"""
        permissions = set()
        for role in self.roles:
            permissions.update(role.get_permissions())
        return list(permissions)
    
    def get_direct_permissions(self) -> List[str]:
        """Get all direct permissions for the user"""
        return [perm.name for perm in self.direct_permissions]
    
    def get_effective_permissions(self) -> dict:
        """Get effective permissions structure expected by frontend"""
        all_permissions = self.get_permissions()
        role_permissions = self.get_role_permissions()
        direct_permissions = self.get_direct_permissions()
        
        return {
            "userType": self.user_type,
            "isSuperuser": self.is_superuser,
            "rolePermissions": role_permissions,
            "directPermissions": direct_permissions,
            "allPermissions": all_permissions,
            "all_permissions": all_permissions,  # Snake_case fallback
        }


class UserProfile(Base):
    """Extended user profile model"""
    __tablename__ = "user_profiles"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    user_id: Mapped[int] = mapped_column(Integer, nullable=False, unique=True)
    
    # Extended profile fields
    first_name: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    last_name: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    date_of_birth: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    gender: Mapped[Optional[str]] = mapped_column(String(10), nullable=True)
    
    # Address information
    address_line1: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    address_line2: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    city: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    state: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    postal_code: Mapped[Optional[str]] = mapped_column(String(20), nullable=True)
    country: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    
    # Social links
    website: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
    linkedin: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
    twitter: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
    github: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
    
    # Preferences
    timezone: Mapped[Optional[str]] = mapped_column(String(50), nullable=True)
    language: Mapped[Optional[str]] = mapped_column(String(10), nullable=True)
    theme: Mapped[Optional[str]] = mapped_column(String(20), nullable=True)
    
    # Notification preferences
    email_notifications: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    sms_notifications: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    push_notifications: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    
    def __repr__(self):
        return f"<UserProfile(id={self.id}, user_id={self.user_id})>"


===== modules/users/routes.py â€“ 2025-07-19 12:13:41 IST =====
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional, List

from app.core.database import get_db
from app.core.dependencies import get_pagination_params, PaginationParams
from app.modules.auth.dependencies import get_current_user, get_current_superuser
from app.modules.users.models import User
from app.modules.users.services import UserService, UserProfileService, UserRoleService
from app.modules.users.schemas import (
    UserCreate,
    UserUpdate,
    UserResponse,
    UserListResponse,
    UserProfileCreate,
    UserProfileUpdate,
    UserProfileResponse,
    UserRoleCreate,
    UserRoleUpdate,
    UserRoleResponse,
    UserRoleAssignmentCreate,
    UserRoleAssignmentResponse,
    UserWithRoles,
    UserWithProfile,
    PasswordChangeRequest,
    UserStatusUpdate
)
from app.shared.models import BaseResponse, PaginatedResponse


router = APIRouter()


# User management endpoints
@router.get("/me", response_model=UserResponse)
async def get_current_user_profile(
    current_user: User = Depends(get_current_user)
):
    """Get current user profile"""
    return current_user


@router.put("/me", response_model=UserResponse)
async def update_current_user_profile(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update current user profile"""
    user_service = UserService(db)
    
    # Convert to dict and remove None values
    update_data = user_update.dict(exclude_unset=True)
    
    updated_user = await user_service.update(current_user.id, update_data)
    return updated_user


@router.post("/me/change-password", response_model=BaseResponse)
async def change_current_user_password(
    password_change: PasswordChangeRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Change current user password"""
    user_service = UserService(db)
    
    await user_service.change_password(
        current_user.id,
        password_change.current_password,
        password_change.new_password
    )
    
    return BaseResponse(message="Password changed successfully")


# User profile endpoints
@router.get("/me/profile", response_model=UserProfileResponse)
async def get_current_user_extended_profile(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get current user extended profile"""
    profile_service = UserProfileService(db)
    profile = await profile_service.get_by_user_id(current_user.id)
    
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Profile not found"
        )
    
    return profile


@router.put("/me/profile", response_model=UserProfileResponse)
async def update_current_user_extended_profile(
    profile_update: UserProfileUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update current user extended profile"""
    profile_service = UserProfileService(db)
    
    # Convert to dict and remove None values
    update_data = profile_update.dict(exclude_unset=True)
    
    profile = await profile_service.create_or_update(current_user.id, update_data)
    return profile


# Admin endpoints for user management
@router.get("/", response_model=PaginatedResponse[UserListResponse])
async def get_users(
    pagination: PaginationParams = Depends(get_pagination_params),
    search: Optional[str] = Query(None, description="Search users by email or name"),
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Get all users (admin only)"""
    user_service = UserService(db)
    
    users, total = await user_service.get_all(pagination, search)
    
    return PaginatedResponse(
        data=[UserListResponse.from_orm(user) for user in users],
        page=pagination.page,
        size=pagination.size,
        total=total,
        pages=(total + pagination.size - 1) // pagination.size
    )


@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(
    user_create: UserCreate,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Create a new user (admin only)"""
    user_service = UserService(db)
    
    user_data = user_create.dict()
    user = await user_service.create(user_data)
    
    return user


@router.get("/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Get user by ID (admin only)"""
    user_service = UserService(db)
    
    user = await user_service.get_by_id(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user


@router.put("/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: int,
    user_update: UserUpdate,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Update user (admin only)"""
    user_service = UserService(db)
    
    # Convert to dict and remove None values
    update_data = user_update.dict(exclude_unset=True)
    
    updated_user = await user_service.update(user_id, update_data)
    return updated_user


@router.patch("/{user_id}/status", response_model=UserResponse)
async def update_user_status(
    user_id: int,
    status_update: UserStatusUpdate,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Update user status (admin only)"""
    user_service = UserService(db)
    
    updated_user = await user_service.update_status(
        user_id,
        status_update.is_active,
        status_update.is_verified
    )
    return updated_user


@router.delete("/{user_id}", response_model=BaseResponse)
async def delete_user(
    user_id: int,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Delete user (admin only)"""
    user_service = UserService(db)
    
    await user_service.delete(user_id)
    return BaseResponse(message="User deleted successfully")


# Role management endpoints
@router.get("/roles/", response_model=PaginatedResponse[UserRoleResponse])
async def get_roles(
    pagination: PaginationParams = Depends(get_pagination_params),
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Get all roles (admin only)"""
    role_service = UserRoleService(db)
    
    roles, total = await role_service.get_all_roles(pagination)
    
    # Convert Role objects to UserRoleResponse
    role_responses = []
    for role in roles:
        permissions = [perm.name for perm in role.permissions] if hasattr(role, 'permissions') and role.permissions else []
        role_dict = {
            "id": role.id,
            "name": role.name,
            "description": role.description,
            "is_active": role.is_active,
            "permissions": permissions,
            "created_at": role.created_at,
            "updated_at": role.updated_at
        }
        role_responses.append(UserRoleResponse(**role_dict))
    
    return PaginatedResponse(
        data=role_responses,
        page=pagination.page,
        size=pagination.size,
        total=total,
        pages=(total + pagination.size - 1) // pagination.size
    )


@router.post("/roles/", response_model=UserRoleResponse, status_code=status.HTTP_201_CREATED)
async def create_role(
    role_create: UserRoleCreate,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Create a new role (admin only)"""
    role_service = UserRoleService(db)
    
    role_data = role_create.dict()
    role = await role_service.create_role(role_data)
    
    permissions = [perm.name for perm in role.permissions] if hasattr(role, 'permissions') and role.permissions else []
    return UserRoleResponse(
        id=role.id,
        name=role.name,
        description=role.description,
        is_active=role.is_active,
        permissions=permissions,
        created_at=role.created_at,
        updated_at=role.updated_at
    )


@router.post("/{user_id}/roles/{role_id}", response_model=UserRoleAssignmentResponse)
async def assign_role_to_user(
    user_id: int,
    role_id: int,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Assign role to user (admin only)"""
    role_service = UserRoleService(db)
    
    assignment = await role_service.assign_role(user_id, role_id, current_user.id)
    return assignment


@router.delete("/{user_id}/roles/{role_id}", response_model=BaseResponse)
async def remove_role_from_user(
    user_id: int,
    role_id: int,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Remove role from user (admin only)"""
    role_service = UserRoleService(db)
    
    await role_service.remove_role(user_id, role_id)
    return BaseResponse(message="Role removed from user successfully")


@router.get("/{user_id}/roles", response_model=List[UserRoleResponse])
async def get_user_roles(
    user_id: int,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Get user roles (admin only)"""
    role_service = UserRoleService(db)
    
    roles = await role_service.get_user_roles(user_id)
    
    # Convert Role objects to UserRoleResponse
    role_responses = []
    for role in roles:
        permissions = [perm.name for perm in role.permissions] if hasattr(role, 'permissions') and role.permissions else []
        role_dict = {
            "id": role.id,
            "name": role.name,
            "description": role.description,
            "is_active": role.is_active,
            "permissions": permissions,
            "created_at": role.created_at,
            "updated_at": role.updated_at
        }
        role_responses.append(UserRoleResponse(**role_dict))
    
    return role_responses


@router.get("/{user_id}/permissions", response_model=List[str])
async def get_user_permissions(
    user_id: int,
    current_user: User = Depends(get_current_superuser),
    db: AsyncSession = Depends(get_db)
):
    """Get user permissions (admin only)"""
    role_service = UserRoleService(db)
    
    permissions = await role_service.get_user_permissions(user_id)
    return permissions

===== modules/users/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from pydantic import BaseModel, EmailStr, Field, field_validator
from typing import Optional, List
from datetime import datetime


class UserBase(BaseModel):
    """Base user schema"""
    email: EmailStr
    full_name: str = Field(..., min_length=1, max_length=255)
    phone: Optional[str] = Field(None, max_length=20)
    bio: Optional[str] = Field(None, max_length=1000)
    
    model_config = {"from_attributes": True}


class UserCreate(UserBase):
    """User creation schema"""
    password: str = Field(..., min_length=8)
    
    @field_validator("password")
    @classmethod
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        return v


class UserUpdate(BaseModel):
    """User update schema"""
    email: Optional[EmailStr] = None
    full_name: Optional[str] = Field(None, min_length=1, max_length=255)
    phone: Optional[str] = Field(None, max_length=20)
    bio: Optional[str] = Field(None, max_length=1000)
    avatar_url: Optional[str] = Field(None, max_length=500)
    
    model_config = {"from_attributes": True}


class UserResponse(UserBase):
    """User response schema"""
    id: int
    is_active: bool
    is_superuser: bool
    is_verified: bool
    avatar_url: Optional[str]
    created_at: datetime
    updated_at: datetime
    last_login: Optional[datetime]
    email_verified_at: Optional[datetime]
    
    model_config = {"from_attributes": True}


class UserListResponse(BaseModel):
    """User list response schema"""
    id: int
    email: str
    full_name: str
    is_active: bool
    is_superuser: bool
    created_at: datetime
    last_login: Optional[datetime]
    
    model_config = {"from_attributes": True}


class UserProfileBase(BaseModel):
    """Base user profile schema"""
    first_name: Optional[str] = Field(None, max_length=100)
    last_name: Optional[str] = Field(None, max_length=100)
    date_of_birth: Optional[datetime] = None
    gender: Optional[str] = Field(None, max_length=10)
    
    # Address
    address_line1: Optional[str] = Field(None, max_length=255)
    address_line2: Optional[str] = Field(None, max_length=255)
    city: Optional[str] = Field(None, max_length=100)
    state: Optional[str] = Field(None, max_length=100)
    postal_code: Optional[str] = Field(None, max_length=20)
    country: Optional[str] = Field(None, max_length=100)
    
    # Social links
    website: Optional[str] = Field(None, max_length=500)
    linkedin: Optional[str] = Field(None, max_length=500)
    twitter: Optional[str] = Field(None, max_length=500)
    github: Optional[str] = Field(None, max_length=500)
    
    # Preferences
    timezone: Optional[str] = Field(None, max_length=50)
    language: Optional[str] = Field(None, max_length=10)
    theme: Optional[str] = Field(None, max_length=20)
    
    # Notification preferences
    email_notifications: bool = True
    sms_notifications: bool = False
    push_notifications: bool = True
    
    model_config = {"from_attributes": True}


class UserProfileCreate(UserProfileBase):
    """User profile creation schema"""
    pass


class UserProfileUpdate(UserProfileBase):
    """User profile update schema"""
    pass


class UserProfileResponse(UserProfileBase):
    """User profile response schema"""
    id: int
    user_id: int
    created_at: datetime
    updated_at: datetime
    
    model_config = {"from_attributes": True}


class UserRoleBase(BaseModel):
    """Base user role schema"""
    name: str = Field(..., min_length=1, max_length=50)
    description: Optional[str] = Field(None, max_length=255)
    is_active: bool = True
    
    model_config = {"from_attributes": True}


class UserRoleCreate(UserRoleBase):
    """User role creation schema"""
    permissions: Optional[List[str]] = []


class UserRoleUpdate(BaseModel):
    """User role update schema"""
    name: Optional[str] = Field(None, min_length=1, max_length=50)
    description: Optional[str] = Field(None, max_length=255)
    is_active: Optional[bool] = None
    permissions: Optional[List[str]] = None
    
    model_config = {"from_attributes": True}


class UserRoleResponse(UserRoleBase):
    """User role response schema"""
    id: int
    permissions: List[str]
    created_at: datetime
    updated_at: datetime
    
    model_config = {"from_attributes": True}


class UserRoleAssignmentBase(BaseModel):
    """Base user role assignment schema"""
    user_id: int
    role_id: int
    
    model_config = {"from_attributes": True}


class UserRoleAssignmentCreate(UserRoleAssignmentBase):
    """User role assignment creation schema"""
    pass


class UserRoleAssignmentResponse(UserRoleAssignmentBase):
    """User role assignment response schema"""
    id: int
    assigned_at: datetime
    assigned_by: Optional[int]
    
    model_config = {"from_attributes": True}


class UserWithRoles(UserResponse):
    """User with roles schema"""
    roles: List[UserRoleResponse] = []
    
    model_config = {"from_attributes": True}


class UserWithProfile(UserResponse):
    """User with profile schema"""
    profile: Optional[UserProfileResponse] = None
    
    model_config = {"from_attributes": True}


class PasswordChangeRequest(BaseModel):
    """Password change request schema"""
    current_password: str
    new_password: str = Field(..., min_length=8)
    
    @field_validator("new_password")
    @classmethod
    def validate_new_password(cls, v):
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        return v


class UserStatusUpdate(BaseModel):
    """User status update schema"""
    is_active: Optional[bool] = None
    is_verified: Optional[bool] = None
    
    model_config = {"from_attributes": True}

===== modules/users/services.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, and_, or_, func
from sqlalchemy.orm import selectinload
from datetime import datetime
import json

from app.core.security import get_password_hash, verify_password
from app.shared.exceptions import NotFoundError, AlreadyExistsError, ValidationError
from app.modules.users.models import User, UserProfile
from app.modules.auth.models import Role, Permission, user_roles_table
from app.core.dependencies import PaginationParams


class UserService:
    """User service for managing users"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create(self, user_data: Dict[str, Any]) -> User:
        """Create a new user"""
        # Check if user already exists by email
        if "email" in user_data:
            existing_user = await self.get_by_email(user_data["email"])
            if existing_user:
                raise AlreadyExistsError("User", "email", user_data["email"])
        
        # Check if user already exists by username
        if "username" in user_data:
            existing_user = await self.get_by_username(user_data["username"])
            if existing_user:
                raise AlreadyExistsError("User", "username", user_data["username"])
        
        # Hash password if provided
        if "password" in user_data:
            user_data["password"] = get_password_hash(user_data["password"])
        
        user = User(**user_data)
        self.db.add(user)
        await self.db.commit()
        await self.db.refresh(user)
        return user
    
    async def get_by_id(self, user_id: int) -> Optional[User]:
        """Get user by ID"""
        stmt = select(User).where(User.id == user_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_by_email(self, email: str) -> Optional[User]:
        """Get user by email"""
        stmt = select(User).where(User.email == email)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_by_username(self, username: str) -> Optional[User]:
        """Get user by username"""
        stmt = select(User).where(User.username == username)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_by_username_or_email(self, identifier: str) -> Optional[User]:
        """Get user by username or email"""
        stmt = select(User).where(
            or_(User.username == identifier, User.email == identifier)
        )
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def update(self, user_id: int, user_data: Dict[str, Any]) -> User:
        """Update user"""
        user = await self.get_by_id(user_id)
        if not user:
            raise NotFoundError("User", user_id)
        
        # Check email uniqueness if email is being updated
        if "email" in user_data and user_data["email"] != user.email:
            existing_user = await self.get_by_email(user_data["email"])
            if existing_user:
                raise AlreadyExistsError("User", "email", user_data["email"])
        
        # Update fields
        for field, value in user_data.items():
            if hasattr(user, field):
                setattr(user, field, value)
        
        await self.db.commit()
        await self.db.refresh(user)
        return user
    
    async def delete(self, user_id: int) -> bool:
        """Delete user"""
        user = await self.get_by_id(user_id)
        if not user:
            raise NotFoundError("User", user_id)
        
        await self.db.delete(user)
        await self.db.commit()
        return True
    
    async def get_all(self, pagination: PaginationParams, search: Optional[str] = None) -> tuple[List[User], int]:
        """Get all users with pagination and search"""
        query = select(User)
        
        # Add search filter
        if search:
            search_filter = or_(
                User.email.ilike(f"%{search}%"),
                User.full_name.ilike(f"%{search}%")
            )
            query = query.where(search_filter)
        
        # Get total count
        count_query = select(func.count()).select_from(query.subquery())
        total = await self.db.execute(count_query)
        total = total.scalar()
        
        # Apply pagination
        query = query.offset(pagination.offset).limit(pagination.size)
        
        result = await self.db.execute(query)
        users = result.scalars().all()
        
        return users, total
    
    async def update_last_login(self, user_id: int) -> None:
        """Update user's last login timestamp"""
        stmt = (
            update(User)
            .where(User.id == user_id)
            .values(last_login=datetime.utcnow())
        )
        await self.db.execute(stmt)
        await self.db.commit()
    
    async def change_password(self, user_id: int, current_password: str, new_password: str) -> bool:
        """Change user password"""
        user = await self.get_by_id(user_id)
        if not user:
            raise NotFoundError("User", user_id)
        
        # Verify current password
        if not verify_password(current_password, user.password):
            raise ValidationError("Current password is incorrect")
        
        # Update password
        user.password = get_password_hash(new_password)
        await self.db.commit()
        return True
    
    async def update_status(self, user_id: int, is_active: Optional[bool] = None, is_verified: Optional[bool] = None) -> User:
        """Update user status"""
        user = await self.get_by_id(user_id)
        if not user:
            raise NotFoundError("User", user_id)
        
        if is_active is not None:
            user.is_active = is_active
        
        if is_verified is not None:
            user.is_verified = is_verified
            if is_verified:
                user.email_verified_at = datetime.utcnow()
        
        await self.db.commit()
        await self.db.refresh(user)
        return user


class UserProfileService:
    """User profile service"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create_or_update(self, user_id: int, profile_data: Dict[str, Any]) -> UserProfile:
        """Create or update user profile"""
        # Check if profile exists
        existing_profile = await self.get_by_user_id(user_id)
        
        if existing_profile:
            # Update existing profile
            for field, value in profile_data.items():
                if hasattr(existing_profile, field):
                    setattr(existing_profile, field, value)
            
            await self.db.commit()
            await self.db.refresh(existing_profile)
            return existing_profile
        else:
            # Create new profile
            profile_data["user_id"] = user_id
            profile = UserProfile(**profile_data)
            self.db.add(profile)
            await self.db.commit()
            await self.db.refresh(profile)
            return profile
    
    async def get_by_user_id(self, user_id: int) -> Optional[UserProfile]:
        """Get user profile by user ID"""
        stmt = select(UserProfile).where(UserProfile.user_id == user_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def delete(self, user_id: int) -> bool:
        """Delete user profile"""
        profile = await self.get_by_user_id(user_id)
        if not profile:
            raise NotFoundError("UserProfile", user_id)
        
        await self.db.delete(profile)
        await self.db.commit()
        return True


class UserRoleService:
    """User role service for RBAC"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create_role(self, role_data: Dict[str, Any]) -> Role:
        """Create a new role"""
        # Check if role already exists
        existing_role = await self.get_role_by_name(role_data["name"])
        if existing_role:
            raise AlreadyExistsError("Role", "name", role_data["name"])
        
        # Remove permissions from role_data as we handle them separately
        permissions_list = role_data.pop("permissions", [])
        
        role = Role(**role_data)
        
        # Add permissions to role if provided
        if permissions_list:
            for perm_name in permissions_list:
                stmt = select(Permission).where(Permission.name == perm_name)
                result = await self.db.execute(stmt)
                permission = result.scalar_one_or_none()
                if permission:
                    role.permissions.append(permission)
        
        self.db.add(role)
        await self.db.commit()
        await self.db.refresh(role)
        return role
    
    async def get_role_by_id(self, role_id: int) -> Optional[Role]:
        """Get role by ID"""
        stmt = select(Role).where(Role.id == role_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_role_by_name(self, name: str) -> Optional[Role]:
        """Get role by name"""
        stmt = select(Role).where(Role.name == name)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_all_roles(self, pagination: PaginationParams) -> tuple[List[Role], int]:
        """Get all roles with pagination"""
        query = select(Role)
        
        # Get total count
        count_query = select(func.count()).select_from(Role)
        total = await self.db.execute(count_query)
        total = total.scalar()
        
        # Apply pagination
        query = query.offset(pagination.offset).limit(pagination.size)
        
        result = await self.db.execute(query)
        roles = result.scalars().all()
        
        return roles, total
    
    async def assign_role(self, user_id: int, role_id: int, assigned_by: Optional[int] = None) -> dict:
        """Assign role to user - Updated for new RBAC system"""
        # Get user and role
        user = await self.db.get(User, user_id)
        role = await self.db.get(Role, role_id)
        
        if not user or not role:
            raise NotFoundError("User or Role", f"user_id={user_id}, role_id={role_id}")
        
        # Check if assignment already exists
        if role in user.roles:
            raise AlreadyExistsError("Role assignment", "user_id and role_id", f"{user_id},{role_id}")
        
        # Add role to user
        user.roles.append(role)
        await self.db.commit()
        
        return {"user_id": user_id, "role_id": role_id, "assigned": True}
    
    async def remove_role(self, user_id: int, role_id: int) -> bool:
        """Remove role from user - Updated for new RBAC system"""
        # Get user and role
        user = await self.db.get(User, user_id)
        role = await self.db.get(Role, role_id)
        
        if not user or not role:
            raise NotFoundError("User or Role", f"user_id={user_id}, role_id={role_id}")
        
        # Check if assignment exists
        if role not in user.roles:
            raise NotFoundError("Role assignment", f"user_id={user_id}, role_id={role_id}")
        
        # Remove role from user
        user.roles.remove(role)
        await self.db.commit()
        return True
    
    async def get_user_role_assignment(self, user_id: int, role_id: int) -> Optional[dict]:
        """Get user role assignment - Updated for new RBAC system"""
        # Get user and role
        user = await self.db.get(User, user_id)
        role = await self.db.get(Role, role_id)
        
        if not user or not role:
            return None
        
        # Check if assignment exists
        if role in user.roles:
            return {"user_id": user_id, "role_id": role_id, "assigned": True}
        
        return None
    
    async def get_user_roles(self, user_id: int) -> List[Role]:
        """Get all roles for a user"""
        stmt = (
            select(Role)
            .join(user_roles_table)
            .where(user_roles_table.c.user_id == user_id)
            .where(Role.is_active == True)
        )
        result = await self.db.execute(stmt)
        return result.scalars().all()
    
    async def get_user_permissions(self, user_id: int) -> List[str]:
        """Get all permissions for a user"""
        # Get user with roles and permissions loaded
        stmt = select(User).where(User.id == user_id).options(
            selectinload(User.roles).selectinload(Role.permissions),
            selectinload(User.direct_permissions)
        )
        result = await self.db.execute(stmt)
        user = result.scalar_one_or_none()
        
        if not user:
            return []
        
        return user.get_permissions()
    
    async def user_has_permission(self, user_id: int, permission: str) -> bool:
        """Check if user has specific permission"""
        permissions = await self.get_user_permissions(user_id)
        return permission in permissions

===== modules/monitoring/__init__.py â€“ 2025-07-19 12:13:41 IST =====
# Monitoring module

===== modules/monitoring/performance_monitor.py â€“ 2025-07-19 12:13:41 IST =====
"""
Performance monitoring system for rental endpoint optimization.
Tracks metrics, identifies bottlenecks, and provides real-time insights.
"""

import time
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from decimal import Decimal
import statistics
from collections import defaultdict, deque
from functools import wraps
import json

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession


class PerformanceMetrics:
    """Singleton class to track performance metrics across the application."""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.initialize()
        return cls._instance
    
    def initialize(self):
        """Initialize metrics storage."""
        self.request_times = defaultdict(lambda: deque(maxlen=1000))
        self.query_times = defaultdict(lambda: deque(maxlen=1000))
        self.operation_times = defaultdict(lambda: deque(maxlen=1000))
        self.error_counts = defaultdict(int)
        self.success_counts = defaultdict(int)
        self.active_requests = 0
        self.start_time = datetime.now()
    
    def record_request(self, endpoint: str, duration: float, success: bool = True):
        """Record API request metrics."""
        self.request_times[endpoint].append({
            'duration': duration,
            'timestamp': datetime.now(),
            'success': success
        })
        
        if success:
            self.success_counts[endpoint] += 1
        else:
            self.error_counts[endpoint] += 1
    
    def record_query(self, query_type: str, duration: float):
        """Record database query metrics."""
        self.query_times[query_type].append({
            'duration': duration,
            'timestamp': datetime.now()
        })
    
    def record_operation(self, operation: str, duration: float, metadata: Dict = None):
        """Record specific operation metrics."""
        self.operation_times[operation].append({
            'duration': duration,
            'timestamp': datetime.now(),
            'metadata': metadata or {}
        })
    
    def get_endpoint_stats(self, endpoint: str) -> Dict[str, Any]:
        """Get statistics for a specific endpoint."""
        times = [r['duration'] for r in self.request_times[endpoint]]
        
        if not times:
            return {'error': 'No data available'}
        
        return {
            'endpoint': endpoint,
            'total_requests': len(times),
            'success_count': self.success_counts[endpoint],
            'error_count': self.error_counts[endpoint],
            'average_time': statistics.mean(times),
            'median_time': statistics.median(times),
            'min_time': min(times),
            'max_time': max(times),
            'p95_time': self._calculate_percentile(times, 95),
            'p99_time': self._calculate_percentile(times, 99),
            'std_deviation': statistics.stdev(times) if len(times) > 1 else 0
        }
    
    def get_all_stats(self) -> Dict[str, Any]:
        """Get comprehensive statistics."""
        uptime = (datetime.now() - self.start_time).total_seconds()
        
        endpoint_stats = {}
        for endpoint in self.request_times:
            endpoint_stats[endpoint] = self.get_endpoint_stats(endpoint)
        
        query_stats = {}
        for query_type in self.query_times:
            times = [q['duration'] for q in self.query_times[query_type]]
            if times:
                query_stats[query_type] = {
                    'count': len(times),
                    'average': statistics.mean(times),
                    'total': sum(times)
                }
        
        return {
            'uptime_seconds': uptime,
            'active_requests': self.active_requests,
            'endpoints': endpoint_stats,
            'queries': query_stats,
            'timestamp': datetime.now().isoformat()
        }
    
    def _calculate_percentile(self, data: List[float], percentile: int) -> float:
        """Calculate percentile value."""
        if not data:
            return 0
        sorted_data = sorted(data)
        index = (percentile / 100) * (len(sorted_data) - 1)
        if index.is_integer():
            return sorted_data[int(index)]
        lower = sorted_data[int(index)]
        upper = sorted_data[int(index) + 1]
        return lower + (upper - lower) * (index - int(index))


# Global metrics instance
metrics = PerformanceMetrics()


# Decorators for automatic performance tracking
def track_performance(operation_name: str = None):
    """Decorator to track function performance."""
    def decorator(func):
        @wraps(func)
        async def async_wrapper(*args, **kwargs):
            name = operation_name or f"{func.__module__}.{func.__name__}"
            start_time = time.perf_counter()
            
            try:
                result = await func(*args, **kwargs)
                duration = time.perf_counter() - start_time
                metrics.record_operation(name, duration)
                return result
            except Exception as e:
                duration = time.perf_counter() - start_time
                metrics.record_operation(name, duration, {'error': str(e)})
                raise
        
        @wraps(func)
        def sync_wrapper(*args, **kwargs):
            name = operation_name or f"{func.__module__}.{func.__name__}"
            start_time = time.perf_counter()
            
            try:
                result = func(*args, **kwargs)
                duration = time.perf_counter() - start_time
                metrics.record_operation(name, duration)
                return result
            except Exception as e:
                duration = time.perf_counter() - start_time
                metrics.record_operation(name, duration, {'error': str(e)})
                raise
        
        if asyncio.iscoroutinefunction(func):
            return async_wrapper
        return sync_wrapper
    
    return decorator


def track_query(query_type: str):
    """Decorator to track database query performance."""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.perf_counter()
            try:
                result = await func(*args, **kwargs)
                duration = time.perf_counter() - start_time
                metrics.record_query(query_type, duration)
                return result
            except Exception:
                duration = time.perf_counter() - start_time
                metrics.record_query(f"{query_type}_error", duration)
                raise
        return wrapper
    return decorator


class RentalPerformanceAnalyzer:
    """Specialized analyzer for rental endpoint performance."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def analyze_rental_performance(self) -> Dict[str, Any]:
        """Analyze rental endpoint performance in detail."""
        analysis = {
            'endpoint_metrics': metrics.get_endpoint_stats('/api/transactions/new-rental-optimized'),
            'operation_breakdown': await self._get_operation_breakdown(),
            'database_performance': await self._analyze_database_performance(),
            'recommendations': self._generate_recommendations()
        }
        
        return analysis
    
    async def _get_operation_breakdown(self) -> Dict[str, Any]:
        """Break down performance by operation."""
        operations = [
            'batch_validate_rental_items',
            'batch_get_stock_levels',
            'validate_stock_availability',
            'generate_transaction_number',
            'create_transaction',
            'batch_stock_updates'
        ]
        
        breakdown = {}
        for op in operations:
            op_times = [o['duration'] for o in metrics.operation_times.get(op, [])]
            if op_times:
                breakdown[op] = {
                    'count': len(op_times),
                    'average': statistics.mean(op_times),
                    'percentage': 0  # Will calculate after
                }
        
        # Calculate percentages
        total_time = sum(b['average'] for b in breakdown.values())
        if total_time > 0:
            for op in breakdown:
                breakdown[op]['percentage'] = (breakdown[op]['average'] / total_time) * 100
        
        return breakdown
    
    async def _analyze_database_performance(self) -> Dict[str, Any]:
        """Analyze database-specific performance metrics."""
        try:
            # Get connection pool stats
            pool_query = """
            SELECT 
                count(*) as total_connections,
                count(*) filter (where state = 'active') as active_connections,
                count(*) filter (where state = 'idle') as idle_connections,
                count(*) filter (where wait_event_type = 'Lock') as blocked_connections
            FROM pg_stat_activity 
            WHERE datname = current_database()
            """
            pool_result = await self.session.execute(text(pool_query))
            pool_stats = pool_result.fetchone()
            
            # Get cache hit ratio
            cache_query = """
            SELECT 
                sum(heap_blks_read) as heap_read,
                sum(heap_blks_hit) as heap_hit,
                sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read) + 0.001) as cache_hit_ratio
            FROM pg_statio_user_tables
            """
            cache_result = await self.session.execute(text(cache_query))
            cache_stats = cache_result.fetchone()
            
            # Get index usage
            index_query = """
            SELECT 
                schemaname,
                tablename,
                100 * idx_scan / (seq_scan + idx_scan + 0.001) as index_usage_percent
            FROM pg_stat_user_tables
            WHERE schemaname = 'public' 
                AND (tablename LIKE 'transaction%' OR tablename LIKE 'stock%')
            ORDER BY index_usage_percent
            """
            index_result = await self.session.execute(text(index_query))
            index_stats = index_result.fetchall()
            
            return {
                'connection_pool': {
                    'total': pool_stats[0] if pool_stats else 0,
                    'active': pool_stats[1] if pool_stats else 0,
                    'idle': pool_stats[2] if pool_stats else 0,
                    'blocked': pool_stats[3] if pool_stats else 0
                },
                'cache_performance': {
                    'hit_ratio': float(cache_stats[2]) if cache_stats else 0,
                    'heap_reads': cache_stats[0] if cache_stats else 0,
                    'heap_hits': cache_stats[1] if cache_stats else 0
                },
                'index_usage': [
                    {
                        'table': row[1],
                        'index_usage_percent': float(row[2])
                    }
                    for row in index_stats
                ]
            }
        except Exception as e:
            return {'error': f'Database analysis failed: {str(e)}'}
    
    def _generate_recommendations(self) -> List[str]:
        """Generate performance recommendations based on metrics."""
        recommendations = []
        
        # Check endpoint performance
        endpoint_stats = metrics.get_endpoint_stats('/api/transactions/new-rental-optimized')
        if endpoint_stats.get('average_time', 0) > 2.0:
            recommendations.append("Average response time exceeds 2 seconds target")
        
        if endpoint_stats.get('p95_time', 0) > 5.0:
            recommendations.append("95th percentile response time is too high (>5s)")
        
        # Check specific operations
        stock_update_times = [o['duration'] for o in metrics.operation_times.get('batch_stock_updates', [])]
        if stock_update_times and statistics.mean(stock_update_times) > 0.5:
            recommendations.append("Stock update operations are slow - ensure bulk updates are implemented")
        
        # Check error rate
        total_requests = endpoint_stats.get('total_requests', 0)
        error_count = endpoint_stats.get('error_count', 0)
        if total_requests > 0 and (error_count / total_requests) > 0.05:
            recommendations.append(f"High error rate: {(error_count/total_requests)*100:.1f}%")
        
        return recommendations


# API Routes for monitoring
from fastapi import APIRouter, Depends
from app.core.database import get_db

monitoring_router = APIRouter(prefix="/api/monitoring", tags=["monitoring"])


@monitoring_router.get("/metrics")
async def get_performance_metrics():
    """Get all performance metrics."""
    return metrics.get_all_stats()


@monitoring_router.get("/metrics/rental")
async def get_rental_performance(session: AsyncSession = Depends(get_db)):
    """Get detailed rental endpoint performance analysis."""
    analyzer = RentalPerformanceAnalyzer(session)
    return await analyzer.analyze_rental_performance()


@monitoring_router.get("/metrics/endpoint/{endpoint_path:path}")
async def get_endpoint_metrics(endpoint_path: str):
    """Get metrics for a specific endpoint."""
    endpoint = f"/api/{endpoint_path}"
    return metrics.get_endpoint_stats(endpoint)


@monitoring_router.post("/metrics/reset")
async def reset_metrics():
    """Reset all performance metrics."""
    metrics.initialize()
    return {"message": "Metrics reset successfully"}


# Middleware for automatic request tracking
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request


class PerformanceTrackingMiddleware(BaseHTTPMiddleware):
    """Middleware to automatically track request performance."""
    
    async def dispatch(self, request: Request, call_next):
        # Skip non-API routes
        if not request.url.path.startswith("/api/"):
            return await call_next(request)
        
        # Track active requests
        metrics.active_requests += 1
        start_time = time.perf_counter()
        
        try:
            response = await call_next(request)
            duration = time.perf_counter() - start_time
            
            # Record metrics
            success = 200 <= response.status_code < 400
            metrics.record_request(request.url.path, duration, success)
            
            # Add performance headers
            response.headers["X-Response-Time"] = f"{duration:.3f}"
            response.headers["X-Server-Time"] = datetime.now().isoformat()
            
            return response
        finally:
            metrics.active_requests -= 1


# Usage example:
"""
# In app/main.py:
from app.modules.monitoring.performance_monitor import monitoring_router, PerformanceTrackingMiddleware

# Add middleware
app.add_middleware(PerformanceTrackingMiddleware)

# Include monitoring routes
app.include_router(monitoring_router)

# In service methods, use decorators:
@track_performance("rental_creation")
async def create_new_rental_optimized(self, rental_data):
    # ... method implementation
    
@track_query("batch_validate_items")
async def _batch_validate_rental_items(self, item_ids):
    # ... method implementation
"""

===== modules/master_data/__init__.py â€“ 2025-07-19 12:13:41 IST =====
# Master data modules

===== modules/master_data/routes.py â€“ 2025-07-19 12:13:41 IST =====
from fastapi import APIRouter

from app.modules.master_data.brands.routes import router as brands_router
from app.modules.master_data.categories.routes import router as categories_router
from app.modules.master_data.locations.routes import router as locations_router
from app.modules.master_data.units.routes import router as units_router
from app.modules.master_data.item_master.routes import router as item_master_router

router = APIRouter()

# Include all master data sub-module routers
router.include_router(brands_router, prefix="/brands")
router.include_router(categories_router, prefix="/categories")
router.include_router(locations_router, prefix="/locations")
router.include_router(units_router, prefix="/units-of-measurement")
router.include_router(item_master_router, prefix="/item-master")

===== modules/master_data/item_master/__init__.py â€“ 2025-07-19 12:13:41 IST =====
# Item Master Module

===== modules/master_data/item_master/dependencies.py â€“ 2025-07-19 12:13:41 IST =====
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from app.shared.dependencies import get_session
from app.modules.master_data.item_master.service import ItemMasterService
from app.modules.master_data.item_master.repository import ItemMasterRepository


def get_item_master_repository(session: AsyncSession = Depends(get_session)) -> ItemMasterRepository:
    """Get item master repository instance."""
    return ItemMasterRepository(session)


def get_item_master_service(session: AsyncSession = Depends(get_session)) -> ItemMasterService:
    """Get item master service instance."""
    return ItemMasterService(session)

===== modules/master_data/item_master/models.py â€“ 2025-07-19 12:13:41 IST =====
from enum import Enum
from typing import Optional, TYPE_CHECKING
from decimal import Decimal
from sqlalchemy import Column, String, Numeric, Boolean, Text, ForeignKey, Index, Integer
from sqlalchemy.orm import relationship, validates

from app.db.base import BaseModel, UUIDType

if TYPE_CHECKING:
    from app.modules.master_data.brands.models import Brand
    from app.modules.master_data.categories.models import Category
    from app.modules.master_data.units.models import UnitOfMeasurement
    from app.modules.inventory.models import InventoryUnit, StockLevel, StockMovement
    from app.modules.transactions.base.models import TransactionLine




class ItemStatus(str, Enum):
    """Item status enumeration."""
    ACTIVE = "ACTIVE"
    INACTIVE = "INACTIVE"
    DISCONTINUED = "DISCONTINUED"


class Item(BaseModel):
    """
    Item model for master data management.
    
    Attributes:
        sku: Stock Keeping Unit
        item_name: Item name
        item_status: Status of item (ACTIVE, INACTIVE, DISCONTINUED)
        brand_id: Brand ID
        category_id: Category ID
        unit_of_measurement_id: Unit of measurement ID
        rental_rate_per_period: Rental rate per period
        rental_period: Rental period specification
        sale_price: Sale price
        security_deposit: Security deposit amount
        description: Item description
        specifications: Item specifications
        model_number: Model number
        serial_number_required: Whether serial number is required
        warranty_period_days: Warranty period in days
        reorder_level: Reorder level
        reorder_quantity: Reorder quantity
        is_rentable: Item can be rented (default: True)
        is_saleable: Item can be sold (default: False)
        brand: Brand relationship
        category: Category relationship
        unit_of_measurement: Unit of measurement relationship
        inventory_units: Inventory units
        stock_levels: Stock levels
        
    Note:
        is_rentable and is_saleable are mutually exclusive - both cannot be True at the same time.
    """
    
    __tablename__ = "items"
    
    sku = Column(String(50), nullable=False, unique=True, index=True, comment="Stock Keeping Unit")
    item_name = Column(String(200), nullable=False, comment="Item name")
    item_status = Column(String(20), nullable=False, default=ItemStatus.ACTIVE.value, comment="Item status")
    brand_id = Column(UUIDType(), ForeignKey("brands.id"), nullable=True, comment="Brand ID")
    category_id = Column(UUIDType(), ForeignKey("categories.id"), nullable=True, comment="Category ID")
    unit_of_measurement_id = Column(UUIDType(), ForeignKey("units_of_measurement.id"), nullable=False, comment="Unit of measurement ID")
    rental_rate_per_period = Column(Numeric(10, 2), nullable=True, comment="Rental rate per period")
    rental_period = Column(String(10), nullable=False, default="1", comment="Rental period (number of periods)")
    sale_price = Column(Numeric(10, 2), nullable=True, comment="Sale price")
    purchase_price = Column(Numeric(10, 2), nullable=True, comment="Purchase price")
    security_deposit = Column(Numeric(10, 2), nullable=False, default=0.00, comment="Security deposit")
    description = Column(Text, nullable=True, comment="Item description")
    specifications = Column(Text, nullable=True, comment="Item specifications")
    model_number = Column(String(100), nullable=True, comment="Model number")
    serial_number_required = Column(Boolean, nullable=False, default=False, comment="Serial number required")
    warranty_period_days = Column(String(10), nullable=False, default="0", comment="Warranty period in days")
    reorder_point = Column(Integer, nullable=False, comment="Reorder point threshold")
    is_rentable = Column(Boolean, nullable=False, default=True, comment="Item can be rented")
    is_saleable = Column(Boolean, nullable=False, default=False, comment="Item can be sold")
    
    # Relationships - re-enabled with proper foreign keys
    brand = relationship("Brand", back_populates="items", lazy="select")
    category = relationship("Category", back_populates="items", lazy="select")
    unit_of_measurement = relationship("UnitOfMeasurement", back_populates="items", lazy="select")
    inventory_units = relationship("InventoryUnit", back_populates="item", lazy="select")
    stock_levels = relationship("StockLevel", back_populates="item", lazy="select")
    stock_movements = relationship("StockMovement", back_populates="item", lazy="select")
    # transaction_lines = relationship("TransactionLine", back_populates="item", lazy="select")  # Temporarily disabled
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_item_sku', 'sku'),
        Index('idx_item_name', 'item_name'),
        Index('idx_item_status', 'item_status'),
        Index('idx_item_brand', 'brand_id'),
        Index('idx_item_category', 'category_id'),
    )
    
    def __init__(
        self,
        sku: str,
        item_name: str,
        item_status: ItemStatus = ItemStatus.ACTIVE,
        is_rentable: bool = True,
        is_saleable: bool = False,
        **kwargs
    ):
        """
        Initialize an Item.
        
        Args:
            sku: Stock Keeping Unit
            item_name: Item name
            item_status: Status of item
            is_rentable: Item can be rented (default: True)
            is_saleable: Item can be sold (default: False)
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.sku = sku
        self.item_name = item_name
        self.item_status = item_status.value if isinstance(item_status, ItemStatus) else item_status
        self.is_rentable = is_rentable
        self.is_saleable = is_saleable
        self.security_deposit = Decimal("0.00")
        self.warranty_period_days = "0"
        self.reorder_point = kwargs.get('reorder_point', 0)
        self._validate()
    
    def _validate(self):
        """Validate item business rules."""
        # Name validation
        if not self.item_name or not self.item_name.strip():
            raise ValueError("Item name cannot be empty")
        
        if len(self.item_name) > 200:
            raise ValueError("Item name cannot exceed 200 characters")
        
        # Status validation
        if self.item_status not in [status.value for status in ItemStatus]:
            raise ValueError(f"Invalid item status: {self.item_status}")
        
        # Boolean field validation
        if hasattr(self, 'is_rentable') and hasattr(self, 'is_saleable'):
            if self.is_rentable and self.is_saleable:
                raise ValueError("Item cannot be both rentable and saleable - these are mutually exclusive")
            if not self.is_rentable and not self.is_saleable:
                raise ValueError("Item must be either rentable or saleable")
        
        # Price validation
        if self.rental_rate_per_period and self.rental_rate_per_period < 0:
            raise ValueError("Rental rate per period cannot be negative")
        
        if self.sale_price and self.sale_price < 0:
            raise ValueError("Sale price cannot be negative")
        
        if self.purchase_price and self.purchase_price < 0:
            raise ValueError("Purchase price cannot be negative")
        
        if self.security_deposit < 0:
            raise ValueError("Security deposit cannot be negative")
        
        # Rental period validation
        if self.rental_period:
            try:
                period_value = int(self.rental_period)
                if period_value <= 0:
                    raise ValueError("Rental period must be a positive integer")
            except ValueError:
                raise ValueError("Rental period must be a valid positive integer")
        
        # Reorder point validation
        if hasattr(self, 'reorder_point') and self.reorder_point < 0:
            raise ValueError("Reorder point cannot be negative")
    
    
    def is_rental_item(self) -> bool:
        """Check if item is available for rental."""
        return self.is_rentable
    
    def is_sale_item(self) -> bool:
        """Check if item is available for sale."""
        return self.is_saleable
    
    def is_item_active(self) -> bool:
        """Check if item is active."""
        return self.item_status == ItemStatus.ACTIVE.value and super().is_active
    
    def is_discontinued(self) -> bool:
        """Check if item is discontinued."""
        return self.item_status == ItemStatus.DISCONTINUED.value
    
    def can_be_rented(self) -> bool:
        """Check if item can be rented."""
        return self.is_rental_item() and self.is_item_active() and self.rental_rate_per_period
    
    def can_be_sold(self) -> bool:
        """Check if item can be sold."""
        return self.is_sale_item() and self.is_item_active() and self.sale_price
    
    @property
    def display_name(self) -> str:
        """Get item display name."""
        return f"{self.item_name} ({self.sku})"
    
    @property
    def total_inventory_units(self) -> int:
        """Get total number of inventory units."""
        return len(self.inventory_units) if self.inventory_units else 0
    
    @property
    def available_units(self) -> int:
        """Get number of available inventory units."""
        if not self.inventory_units:
            return 0
        from app.modules.inventory.models import InventoryUnitStatus
        return len([unit for unit in self.inventory_units if unit.status == InventoryUnitStatus.AVAILABLE.value])
    
    @property
    def rented_units(self) -> int:
        """Get number of rented inventory units."""
        if not self.inventory_units:
            return 0
        from app.modules.inventory.models import InventoryUnitStatus
        return len([unit for unit in self.inventory_units if unit.status == InventoryUnitStatus.RENTED.value])
    
    def is_low_stock(self) -> bool:
        """Check if item stock is below reorder point."""
        if not hasattr(self, 'reorder_point') or self.reorder_point is None:
            return False
        return self.available_units <= self.reorder_point
    
    @property
    def stock_status(self) -> str:
        """Get current stock status."""
        if self.available_units == 0:
            return "OUT_OF_STOCK"
        elif self.is_low_stock():
            return "LOW_STOCK"
        else:
            return "IN_STOCK"
    
    def __str__(self) -> str:
        """String representation of item."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of item."""
        return (
            f"Item(id={self.id}, sku='{self.sku}', "
            f"name='{self.item_name}', status='{self.item_status}', "
            f"rentable={self.is_rentable}, saleable={self.is_saleable}, active={self.is_active})"
        )

===== modules/master_data/item_master/repository.py â€“ 2025-07-19 15:45:29 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from sqlalchemy import and_, or_, func, select, asc, case, Integer
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.modules.master_data.item_master.models import Item, ItemStatus
from app.modules.master_data.item_master.schemas import ItemCreate, ItemUpdate


class ItemMasterRepository:
    """Repository for Item operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def create(self, item_data: ItemCreate, sku: str) -> Item:
        """Create a new item with SKU."""
        item = Item(
            sku=sku,
            item_name=item_data.item_name,
            item_status=item_data.item_status,
            is_rentable=item_data.is_rentable,
            is_saleable=item_data.is_saleable
        )
        
        # Set optional fields
        if item_data.brand_id:
            item.brand_id = item_data.brand_id
        if item_data.category_id:
            item.category_id = item_data.category_id
        # Set required field
        item.unit_of_measurement_id = item_data.unit_of_measurement_id
        if item_data.rental_rate_per_period:
            item.rental_rate_per_period = item_data.rental_rate_per_period
        if item_data.rental_period:
            item.rental_period = item_data.rental_period
        if item_data.sale_price:
            item.sale_price = item_data.sale_price
        if item_data.purchase_price is not None:
            item.purchase_price = item_data.purchase_price
        if item_data.security_deposit:
            item.security_deposit = item_data.security_deposit
        if item_data.description:
            item.description = item_data.description
        if item_data.specifications:
            item.specifications = item_data.specifications
        if item_data.model_number:
            item.model_number = item_data.model_number
        if item_data.serial_number_required:
            item.serial_number_required = item_data.serial_number_required
        if item_data.warranty_period_days:
            item.warranty_period_days = item_data.warranty_period_days
        
        # Set reorder_point (mandatory field)
        item.reorder_point = item_data.reorder_point
        
        self.session.add(item)
        await self.session.commit()
        await self.session.refresh(item)
        return item
    
    async def get_by_id(self, item_id: UUID) -> Optional[Item]:
        """Get item by ID."""
        query = select(Item).where(Item.id == item_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_ids(self, item_ids: List[UUID]) -> List[Item]:
        """Get multiple items by IDs."""
        if not item_ids:
            return []
        
        query = select(Item).where(Item.id.in_(item_ids))
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_id_with_relations(self, item_id: UUID) -> Optional[Item]:
        """Get item by ID with relationships loaded."""
        query = (
            select(Item)
            .options(
                selectinload(Item.brand),
                selectinload(Item.category),
                selectinload(Item.unit_of_measurement),
                selectinload(Item.inventory_units),
                selectinload(Item.stock_levels)
            )
            .where(Item.id == item_id)
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    
    async def get_by_sku(self, sku: str) -> Optional[Item]:
        """Get item by SKU."""
        query = select(Item).where(Item.sku == sku)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def exists_by_sku(self, sku: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if an item with the given SKU exists."""
        query = select(func.count()).select_from(Item).where(Item.sku == sku)
        
        if exclude_id:
            query = query.where(Item.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        return count > 0
    
    async def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_status: Optional[ItemStatus] = None,
        brand_id: Optional[UUID] = None,
        category_id: Optional[UUID] = None,
        active_only: bool = True,
        # Date filters
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        updated_after: Optional[str] = None,
        updated_before: Optional[str] = None
    ) -> List[Item]:
        """Get all items with essential filtering."""
        query = select(Item)
        
        # Apply essential filters only
        conditions = []
        if active_only:
            conditions.append(Item.is_active == True)
        if item_status:
            conditions.append(Item.item_status == item_status.value)
        if brand_id:
            conditions.append(Item.brand_id == brand_id)
        if category_id:
            conditions.append(Item.category_id == category_id)
        
        # Date range filters
        if created_after:
            from datetime import datetime
            created_after_dt = datetime.fromisoformat(created_after.replace('Z', '+00:00'))
            conditions.append(Item.created_at >= created_after_dt)
        if created_before:
            from datetime import datetime
            created_before_dt = datetime.fromisoformat(created_before.replace('Z', '+00:00'))
            conditions.append(Item.created_at <= created_before_dt)
        if updated_after:
            from datetime import datetime
            updated_after_dt = datetime.fromisoformat(updated_after.replace('Z', '+00:00'))
            conditions.append(Item.updated_at >= updated_after_dt)
        if updated_before:
            from datetime import datetime
            updated_before_dt = datetime.fromisoformat(updated_before.replace('Z', '+00:00'))
            conditions.append(Item.updated_at <= updated_before_dt)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(asc(Item.item_name)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_all_with_relations(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_status: Optional[ItemStatus] = None,
        brand_ids: Optional[List[UUID]] = None,
        category_ids: Optional[List[UUID]] = None,
        active_only: bool = True,
        # Additional filters
        is_rentable: Optional[bool] = None,
        is_saleable: Optional[bool] = None,
        min_rental_rate: Optional[Decimal] = None,
        max_rental_rate: Optional[Decimal] = None,
        min_sale_price: Optional[Decimal] = None,
        max_sale_price: Optional[Decimal] = None,
        has_stock: Optional[bool] = None,
        search_term: Optional[str] = None,
        # Date filters
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        updated_after: Optional[str] = None,
        updated_before: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Get all items with relationship data and inventory aggregation."""
        from app.modules.master_data.brands.models import Brand
        from app.modules.master_data.categories.models import Category
        from app.modules.master_data.units.models import UnitOfMeasurement
        from app.modules.inventory.models import InventoryUnit, InventoryUnitStatus
        
        # Build base query with JOINs for relationship data
        query = (
            select(
                Item,
                Brand.name.label("brand_name"),
                Brand.code.label("brand_code"),
                Brand.description.label("brand_description"),
                Category.name.label("category_name"),
                Category.category_path,
                Category.category_level.label("category_level"),
                UnitOfMeasurement.name.label("unit_name"),
                UnitOfMeasurement.abbreviation,
                func.count(InventoryUnit.id).label("total_units"),
                func.sum(
                    case(
                        (InventoryUnit.status == InventoryUnitStatus.AVAILABLE.value, 1),
                        else_=0
                    )
                ).label("available_units"),
                func.sum(
                    case(
                        (InventoryUnit.status == InventoryUnitStatus.RENTED.value, 1),
                        else_=0
                    )
                ).label("rented_units")
            )
            .outerjoin(Brand, Item.brand_id == Brand.id)
            .outerjoin(Category, Item.category_id == Category.id)
            .outerjoin(UnitOfMeasurement, Item.unit_of_measurement_id == UnitOfMeasurement.id)
            .outerjoin(InventoryUnit, Item.id == InventoryUnit.item_id)
            .group_by(Item.id, Brand.id, Category.id, UnitOfMeasurement.id)
        )
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(Item.is_active == True)
        if item_status:
            conditions.append(Item.item_status == item_status.value)
        if brand_ids:
            conditions.append(Item.brand_id.in_(brand_ids))
        if category_ids:
            conditions.append(Item.category_id.in_(category_ids))
        if is_rentable is not None:
            conditions.append(Item.is_rentable == is_rentable)
        if is_saleable is not None:
            conditions.append(Item.is_saleable == is_saleable)
        if min_rental_rate:
            conditions.append(Item.rental_rate_per_period >= min_rental_rate)
        if max_rental_rate:
            conditions.append(Item.rental_rate_per_period <= max_rental_rate)
        if min_sale_price:
            conditions.append(Item.sale_price >= min_sale_price)
        if max_sale_price:
            conditions.append(Item.sale_price <= max_sale_price)
        
        # Search functionality enhanced
        if search_term:
            search_condition = or_(
                Item.item_name.ilike(f"%{search_term}%"),
                Item.sku.ilike(f"%{search_term}%"),
                Item.description.ilike(f"%{search_term}%"),
                Item.model_number.ilike(f"%{search_term}%"),
                Item.specifications.ilike(f"%{search_term}%"),
                Brand.name.ilike(f"%{search_term}%"),
                Category.name.ilike(f"%{search_term}%")
            )
            conditions.append(search_condition)
        
        # Date range filters
        if created_after:
            from datetime import datetime
            created_after_dt = datetime.fromisoformat(created_after.replace('Z', '+00:00'))
            conditions.append(Item.created_at >= created_after_dt)
        if created_before:
            from datetime import datetime
            created_before_dt = datetime.fromisoformat(created_before.replace('Z', '+00:00'))
            conditions.append(Item.created_at <= created_before_dt)
        if updated_after:
            from datetime import datetime
            updated_after_dt = datetime.fromisoformat(updated_after.replace('Z', '+00:00'))
            conditions.append(Item.updated_at >= updated_after_dt)
        if updated_before:
            from datetime import datetime
            updated_before_dt = datetime.fromisoformat(updated_before.replace('Z', '+00:00'))
            conditions.append(Item.updated_at <= updated_before_dt)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        # Apply stock filter after grouping
        if has_stock is not None:
            if has_stock:
                query = query.having(func.count(InventoryUnit.id) > 0)
            else:
                query = query.having(func.count(InventoryUnit.id) == 0)
        
        query = query.order_by(asc(Item.item_name)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        rows = result.all()
        
        # Convert to list of dictionaries with all data
        items_data = []
        for row in rows:
            item = row[0]  # Item object
            item_dict = {
                # Basic item fields
                "id": item.id,
                "sku": item.sku,
                "item_name": item.item_name,
                "item_status": item.item_status,
                "brand_id": item.brand_id,
                "category_id": item.category_id,
                "unit_of_measurement_id": item.unit_of_measurement_id,
                "rental_rate_per_period": item.rental_rate_per_period,
                "rental_period": item.rental_period,
                "sale_price": item.sale_price,
                "purchase_price": item.purchase_price,
                "security_deposit": item.security_deposit,
                "description": item.description,
                "specifications": item.specifications,
                "model_number": item.model_number,
                "serial_number_required": item.serial_number_required,
                "warranty_period_days": item.warranty_period_days,
                "reorder_point": item.reorder_point,
                "is_rentable": item.is_rentable,
                "is_saleable": item.is_saleable,
                "is_active": item.is_active,
                "created_at": item.created_at,
                "updated_at": item.updated_at,
                # Relationship data
                "brand_name": row[1],
                "brand_code": row[2],
                "brand_description": row[3],
                "category_name": row[4],
                "category_path": row[5],
                "category_level": row[6],
                "unit_name": row[7],
                "unit_abbreviation": row[8],
                # Inventory summary
                "total_units": row[9] or 0,
                "available_units": row[10] or 0,
                "rented_units": row[11] or 0,
            }
            items_data.append(item_dict)
        
        return items_data
    
    async def count_all(
        self,
        search: Optional[str] = None,
        item_status: Optional[ItemStatus] = None,
        brand_id: Optional[UUID] = None,
        category_id: Optional[UUID] = None,
        is_rentable: Optional[bool] = None,
        is_saleable: Optional[bool] = None,
        active_only: bool = True
    ) -> int:
        """Count all items with optional search and filtering."""
        query = select(func.count(Item.id))
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(Item.is_active == True)
        if item_status:
            conditions.append(Item.item_status == item_status.value)
        if brand_id:
            conditions.append(Item.brand_id == brand_id)
        if category_id:
            conditions.append(Item.category_id == category_id)
        if is_rentable is not None:
            conditions.append(Item.is_rentable == is_rentable)
        if is_saleable is not None:
            conditions.append(Item.is_saleable == is_saleable)
        
        # Apply search
        if search:
            search_condition = or_(
                Item.item_name.ilike(f"%{search}%"),
                Item.sku.ilike(f"%{search}%"),
                Item.description.ilike(f"%{search}%")
            )
            conditions.append(search_condition)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        result = await self.session.execute(query)
        return result.scalar()
    
    async def search(
        self, 
        search_term: str, 
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[Item]:
        """Search items by name or code."""
        query = select(Item).where(
            or_(
                Item.item_name.ilike(f"%{search_term}%"),
                Item.sku.ilike(f"%{search_term}%"),
                Item.description.ilike(f"%{search_term}%")
            )
        )
        
        if active_only:
            query = query.where(Item.is_active == True)
        
        query = query.order_by(asc(Item.item_name)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update(self, item_id: UUID, item_data: ItemUpdate) -> Optional[Item]:
        """Update an item."""
        query = select(Item).where(Item.id == item_id)
        result = await self.session.execute(query)
        item = result.scalar_one_or_none()
        
        if not item:
            return None
        
        # Update fields
        update_data = item_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(item, field, value)
        
        await self.session.commit()
        await self.session.refresh(item)
        return item
    
    async def delete(self, item_id: UUID) -> bool:
        """Soft delete an item."""
        query = select(Item).where(Item.id == item_id)
        result = await self.session.execute(query)
        item = result.scalar_one_or_none()
        
        if not item:
            return False
        
        item.is_active = False
        await self.session.commit()
        return True
    
    async def get_rental_items(self, active_only: bool = True) -> List[Item]:
        """Get all rental items."""
        query = select(Item).where(Item.is_rentable == True)
        
        if active_only:
            query = query.where(Item.is_active == True)
        
        query = query.order_by(asc(Item.item_name))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_sale_items(self, active_only: bool = True) -> List[Item]:
        """Get all sale items."""
        query = select(Item).where(Item.is_saleable == True)
        
        if active_only:
            query = query.where(Item.is_active == True)
        
        query = query.order_by(asc(Item.item_name))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_items_by_category(self, category_id: UUID, active_only: bool = True) -> List[Item]:
        """Get all items in a specific category."""
        query = select(Item).where(Item.category_id == category_id)
        
        if active_only:
            query = query.where(Item.is_active == True)
        
        query = query.order_by(asc(Item.item_name))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_items_by_brand(self, brand_id: UUID, active_only: bool = True) -> List[Item]:
        """Get all items for a specific brand."""
        query = select(Item).where(Item.brand_id == brand_id)
        
        if active_only:
            query = query.where(Item.is_active == True)
        
        query = query.order_by(asc(Item.item_name))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_low_stock_items_legacy(self, active_only: bool = True) -> List[Item]:
        """Legacy method - use get_low_stock_items instead."""
        query = select(Item).where(
            and_(
                Item.reorder_point > 0,
                Item.is_active == True
            )
        )
        
        if active_only:
            query = query.where(Item.is_active == True)
        
        query = query.order_by(asc(Item.item_name))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_all_with_nested_relations(
        self, 
        skip: int = 0, 
        limit: int = 100,
        item_status: Optional[ItemStatus] = None,
        brand_ids: Optional[List[UUID]] = None,
        category_ids: Optional[List[UUID]] = None,
        active_only: bool = True,
        # Additional filters
        is_rentable: Optional[bool] = None,
        is_saleable: Optional[bool] = None,
        min_rental_rate: Optional[Decimal] = None,
        max_rental_rate: Optional[Decimal] = None,
        min_sale_price: Optional[Decimal] = None,
        max_sale_price: Optional[Decimal] = None,
        has_stock: Optional[bool] = None,
        search_term: Optional[str] = None,
        # Date filters
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        updated_after: Optional[str] = None,
        updated_before: Optional[str] = None
    ) -> List[Item]:
        """Get all items with eagerly loaded relationships for nested response."""
        from app.modules.master_data.brands.models import Brand
        from app.modules.master_data.categories.models import Category
        from app.modules.master_data.units.models import UnitOfMeasurement
        
        # Build query with eager loading
        query = (
            select(Item)
            .options(
                selectinload(Item.brand),
                selectinload(Item.category),
                selectinload(Item.unit_of_measurement)
            )
        )
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(Item.is_active == True)
        if item_status:
            conditions.append(Item.item_status == item_status.value)
        if brand_ids:
            conditions.append(Item.brand_id.in_(brand_ids))
        if category_ids:
            conditions.append(Item.category_id.in_(category_ids))
        if is_rentable is not None:
            conditions.append(Item.is_rentable == is_rentable)
        if is_saleable is not None:
            conditions.append(Item.is_saleable == is_saleable)
        if min_rental_rate:
            conditions.append(Item.rental_rate_per_period >= min_rental_rate)
        if max_rental_rate:
            conditions.append(Item.rental_rate_per_period <= max_rental_rate)
        if min_sale_price:
            conditions.append(Item.sale_price >= min_sale_price)
        if max_sale_price:
            conditions.append(Item.sale_price <= max_sale_price)
        
        # Search functionality
        if search_term:
            # Need to join for search in related tables
            query = query.outerjoin(Brand, Item.brand_id == Brand.id)
            query = query.outerjoin(Category, Item.category_id == Category.id)
            
            search_condition = or_(
                Item.item_name.ilike(f"%{search_term}%"),
                Item.sku.ilike(f"%{search_term}%"),
                Item.description.ilike(f"%{search_term}%"),
                Item.model_number.ilike(f"%{search_term}%"),
                Item.specifications.ilike(f"%{search_term}%"),
                Brand.name.ilike(f"%{search_term}%"),
                Category.name.ilike(f"%{search_term}%")
            )
            conditions.append(search_condition)
        
        # Date range filters
        if created_after:
            from datetime import datetime
            created_after_dt = datetime.fromisoformat(created_after.replace('Z', '+00:00'))
            conditions.append(Item.created_at >= created_after_dt)
        if created_before:
            from datetime import datetime
            created_before_dt = datetime.fromisoformat(created_before.replace('Z', '+00:00'))
            conditions.append(Item.created_at <= created_before_dt)
        if updated_after:
            from datetime import datetime
            updated_after_dt = datetime.fromisoformat(updated_after.replace('Z', '+00:00'))
            conditions.append(Item.updated_at >= updated_after_dt)
        if updated_before:
            from datetime import datetime
            updated_before_dt = datetime.fromisoformat(updated_before.replace('Z', '+00:00'))
            conditions.append(Item.updated_at <= updated_before_dt)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(asc(Item.item_name)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().unique().all()
    
    async def get_low_stock_items(
        self, 
        location_id: Optional[UUID] = None,
        skip: int = 0,
        limit: int = 100
    ) -> List[Item]:
        """
        Get items with stock levels at or below their reorder point.
        Uses efficient JOIN with StockLevel table.
        """
        from app.modules.inventory.models import StockLevel
        
        # Build query with JOIN between items and stock_levels
        query = select(Item).join(
            StockLevel, Item.id == StockLevel.item_id
        ).where(
            and_(
                Item.is_active == True,
                Item.reorder_point > 0,  # Only include items with configured reorder points
                func.cast(StockLevel.quantity_available, Integer) <= Item.reorder_point
            )
        )
        
        # Add location filter if specified
        if location_id:
            query = query.where(StockLevel.location_id == location_id)
        
        # Add pagination
        query = query.order_by(
            # Order by urgency: out of stock first, then by how far below reorder point
            asc(func.cast(StockLevel.quantity_available, Integer)),
            asc(Item.item_name)
        ).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().unique().all()
    
    async def get_stock_alerts_summary(self) -> Dict[str, Any]:
        """
        Get summary statistics for stock alerts.
        """
        from app.modules.inventory.models import StockLevel
        
        # Count items that are out of stock
        out_of_stock_query = select(func.count(Item.id.distinct())).select_from(
            Item.__table__.join(StockLevel.__table__, Item.id == StockLevel.item_id)
        ).where(
            and_(
                Item.is_active == True,
                func.cast(StockLevel.quantity_available, Integer) == 0
            )
        )
        
        # Count items that are low stock (at or below reorder point, but not zero)
        low_stock_query = select(func.count(Item.id.distinct())).select_from(
            Item.__table__.join(StockLevel.__table__, Item.id == StockLevel.item_id)
        ).where(
            and_(
                Item.is_active == True,
                Item.reorder_point > 0,
                func.cast(StockLevel.quantity_available, Integer) > 0,
                func.cast(StockLevel.quantity_available, Integer) <= Item.reorder_point
            )
        )
        
        # Count total active items
        total_items_query = select(func.count(Item.id)).where(Item.is_active == True)
        
        # Average reorder point
        avg_reorder_point_query = select(func.avg(Item.reorder_point)).where(
            and_(Item.is_active == True, Item.reorder_point > 0)
        )
        
        # Execute all queries
        out_of_stock_result = await self.session.execute(out_of_stock_query)
        low_stock_result = await self.session.execute(low_stock_query)
        total_items_result = await self.session.execute(total_items_query)
        avg_reorder_result = await self.session.execute(avg_reorder_point_query)
        
        return {
            "out_of_stock": out_of_stock_result.scalar() or 0,
            "low_stock": low_stock_result.scalar() or 0,
            "total_items": total_items_result.scalar() or 0,
            "avg_reorder_point": float(avg_reorder_result.scalar() or 0)
        }

===== modules/master_data/item_master/routes.py â€“ 2025-07-19 12:13:41 IST =====
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.shared.dependencies import get_session
from app.modules.master_data.item_master.service import ItemMasterService
from app.modules.master_data.item_master.models import ItemStatus
from app.modules.master_data.item_master.schemas import (
    ItemCreate, ItemUpdate, ItemResponse, ItemListResponse, ItemWithInventoryResponse,
    ItemWithRelationsResponse, ItemListWithRelationsResponse, ItemNestedResponse,
    SKUGenerationRequest, SKUGenerationResponse, SKUBulkGenerationResponse
)
from app.core.errors import NotFoundError, ValidationError, ConflictError


router = APIRouter(tags=["Items"])


def get_item_master_service(session: AsyncSession = Depends(get_session)) -> ItemMasterService:
    """Get item master service instance."""
    return ItemMasterService(session)


# Item endpoints
@router.post("/", response_model=ItemResponse, status_code=status.HTTP_201_CREATED, 
             summary="Create Item", description="Create a new item with automatic SKU generation")
async def create_item(
    item_data: ItemCreate,
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Create a new item with automatic SKU generation based on category and item details."""
    try:
        return await service.create_item(item_data)
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


@router.get("/enhanced", response_model=List[ItemListWithRelationsResponse],
           summary="Get Items with Enhanced Details", 
           description="Get paginated list of items with complete relationship data and enhanced filtering")
async def get_items_with_details(
    # Pagination
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
    
    # Enhanced filters
    brand_ids: Optional[str] = Query(None, description="Comma-separated list of brand IDs"),
    category_ids: Optional[str] = Query(None, description="Comma-separated list of category IDs"),
    item_statuses: Optional[str] = Query(None, description="Comma-separated list of item statuses"),
    active_only: bool = Query(True, description="Show only active items"),
    
    # Type filters
    is_rentable: Optional[bool] = Query(None, description="Filter by rentable status"),
    is_saleable: Optional[bool] = Query(None, description="Filter by saleable status"),
    
    # Price range filters
    min_rental_rate: Optional[float] = Query(None, ge=0, description="Minimum rental rate"),
    max_rental_rate: Optional[float] = Query(None, ge=0, description="Maximum rental rate"),
    min_sale_price: Optional[float] = Query(None, ge=0, description="Minimum sale price"),
    max_sale_price: Optional[float] = Query(None, ge=0, description="Maximum sale price"),
    
    # Inventory filters
    has_stock: Optional[bool] = Query(None, description="Filter items with/without inventory"),
    
    # Search
    search: Optional[str] = Query(None, description="Search in item name, SKU, description, model, brand, category"),
    
    # Date range filters
    created_after: Optional[str] = Query(None, description="Items created after this date (ISO format)"),
    created_before: Optional[str] = Query(None, description="Items created before this date (ISO format)"),
    updated_after: Optional[str] = Query(None, description="Items updated after this date (ISO format)"),
    updated_before: Optional[str] = Query(None, description="Items updated before this date (ISO format)"),
    
    service: ItemMasterService = Depends(get_item_master_service)
):
    """
    Get items with complete relationship data including brand, category, and unit information.
    
    This endpoint provides enhanced filtering capabilities including:
    - Multiple brand/category filtering
    - Price range filtering
    - Inventory status filtering
    - Enhanced search across multiple fields
    - Date range filtering
    
    Returns complete item data with relationship information and inventory summaries.
    """
    # Parse comma-separated IDs
    brand_id_list = None
    if brand_ids:
        try:
            brand_id_list = [UUID(id.strip()) for id in brand_ids.split(',') if id.strip()]
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid brand ID format")
    
    category_id_list = None
    if category_ids:
        try:
            category_id_list = [UUID(id.strip()) for id in category_ids.split(',') if id.strip()]
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid category ID format")
    
    # Parse item statuses
    item_status = None
    if item_statuses:
        try:
            # For now, just take the first status (can be enhanced later for multiple)
            status_list = [status.strip() for status in item_statuses.split(',') if status.strip()]
            if status_list:
                item_status = ItemStatus(status_list[0])
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid item status")
    
    return await service.get_items_with_relations(
        skip=skip,
        limit=limit,
        item_status=item_status,
        brand_ids=brand_id_list,
        category_ids=category_id_list,
        active_only=active_only,
        is_rentable=is_rentable,
        is_saleable=is_saleable,
        min_rental_rate=min_rental_rate,
        max_rental_rate=max_rental_rate,
        min_sale_price=min_sale_price,
        max_sale_price=max_sale_price,
        has_stock=has_stock,
        search_term=search,
        created_after=created_after,
        created_before=created_before,
        updated_after=updated_after,
        updated_before=updated_before
    )


@router.get("/sku/{sku}", response_model=ItemResponse)
async def get_item_by_sku(
    sku: str,
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Get item by SKU."""
    try:
        return await service.get_item_by_sku(sku)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


# Stock alert endpoints - must come before parameterized routes
@router.get("/low-stock", response_model=List[ItemWithInventoryResponse],
           summary="Get Low Stock Items",
           description="Get items with stock levels at or below their reorder point")
async def get_low_stock_items_new(
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
    location_id: Optional[UUID] = Query(None, description="Filter by location"),
    service: ItemMasterService = Depends(get_item_master_service)
):
    """
    Get items that need reordering based on their reorder point configuration.
    Uses efficient JOIN pattern for optimal performance.
    """
    try:
        return await service.get_low_stock_items(
            location_id=location_id,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, 
            detail=f"Error retrieving low stock items: {str(e)}"
        )


@router.get("/stock-alerts/summary", 
           summary="Get Stock Alerts Summary",
           description="Get summary statistics for stock alerts across all items")
async def get_stock_alerts_summary_new(
    service: ItemMasterService = Depends(get_item_master_service)
):
    """
    Get comprehensive summary of stock alert statistics including:
    - Out of stock count
    - Low stock count
    - Total items
    - Average reorder point
    - Items needing attention
    """
    try:
        return await service.get_stock_alerts_summary()
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error retrieving stock alerts summary: {str(e)}"
        )


@router.get("/{item_id}", response_model=ItemResponse,
           summary="Get Item by ID", description="Retrieve a single item by its UUID")
async def get_item(
    item_id: UUID,
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Get item by ID."""
    try:
        return await service.get_item(item_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get("/", response_model=List[ItemNestedResponse],
           summary="Get Items", 
           description="Get paginated list of items with nested relationship objects")
async def get_items(
    # Pagination
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
    
    # Enhanced filters
    category_id: Optional[UUID] = Query(None, description="Filter by category ID"),
    brand_id: Optional[UUID] = Query(None, description="Filter by brand ID"),
    item_status: Optional[ItemStatus] = Query(None, description="Filter by item status"),
    active_only: bool = Query(True, description="Show only active items"),
    
    # Type filters
    is_rentable: Optional[bool] = Query(None, description="Filter by rentable status"),
    is_saleable: Optional[bool] = Query(None, description="Filter by saleable status"),
    
    # Price range filters
    min_rental_rate: Optional[float] = Query(None, ge=0, description="Minimum rental rate"),
    max_rental_rate: Optional[float] = Query(None, ge=0, description="Maximum rental rate"),
    min_sale_price: Optional[float] = Query(None, ge=0, description="Minimum sale price"),
    max_sale_price: Optional[float] = Query(None, ge=0, description="Maximum sale price"),
    
    # Inventory filters
    has_stock: Optional[bool] = Query(None, description="Filter items with/without inventory"),
    
    # Search
    search: Optional[str] = Query(None, description="Search in item name, SKU, description, model, brand, category"),
    
    # Date range filters
    created_after: Optional[str] = Query(None, description="Items created after this date (ISO format)"),
    created_before: Optional[str] = Query(None, description="Items created before this date (ISO format)"),
    updated_after: Optional[str] = Query(None, description="Items updated after this date (ISO format)"),
    updated_before: Optional[str] = Query(None, description="Items updated before this date (ISO format)"),
    
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Get all items with nested relationship format. Returns brand, category, and unit information as nested objects."""
    # Convert single IDs to lists for the service method
    brand_ids = [brand_id] if brand_id else None
    category_ids = [category_id] if category_id else None
    
    return await service.get_items_nested_format(
        skip=skip,
        limit=limit,
        item_status=item_status,
        brand_ids=brand_ids,
        category_ids=category_ids,
        active_only=active_only,
        is_rentable=is_rentable,
        is_saleable=is_saleable,
        min_rental_rate=min_rental_rate,
        max_rental_rate=max_rental_rate,
        min_sale_price=min_sale_price,
        max_sale_price=max_sale_price,
        has_stock=has_stock,
        search_term=search,
        created_after=created_after,
        created_before=created_before,
        updated_after=updated_after,
        updated_before=updated_before
    )


@router.get("/search/{search_term}", response_model=List[ItemListResponse])
async def search_items(
    search_term: str,
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
    active_only: bool = Query(True, description="Show only active items"),
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Search items by name or code."""
    return await service.search_items(
        search_term=search_term,
        skip=skip,
        limit=limit,
        active_only=active_only
    )


@router.put("/{item_id}", response_model=ItemResponse,
           summary="Update Item", description="Update an existing item (partial update supported)")
async def update_item(
    item_id: UUID,
    item_data: ItemUpdate,
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Update an item. All fields are optional - only provided fields will be updated."""
    try:
        return await service.update_item(item_id, item_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))


@router.delete("/{item_id}", status_code=status.HTTP_204_NO_CONTENT,
              summary="Delete Item", description="Soft delete an item (sets is_active to false)")
async def delete_item(
    item_id: UUID,
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Delete (soft delete) an item."""
    try:
        await service.delete_item(item_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get("/types/rental", response_model=List[ItemListResponse])
async def get_rental_items(
    active_only: bool = Query(True, description="Show only active items"),
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Get all rental items."""
    return await service.get_rental_items(active_only=active_only)


@router.get("/types/sale", response_model=List[ItemListResponse])
async def get_sale_items(
    active_only: bool = Query(True, description="Show only active items"),
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Get all sale items."""
    return await service.get_sale_items(active_only=active_only)


@router.get("/category/{category_id}", response_model=List[ItemListResponse])
async def get_items_by_category(
    category_id: UUID,
    active_only: bool = Query(True, description="Show only active items"),
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Get all items in a specific category."""
    return await service.get_items_by_category(category_id, active_only=active_only)


@router.get("/brand/{brand_id}", response_model=List[ItemListResponse])
async def get_items_by_brand(
    brand_id: UUID,
    active_only: bool = Query(True, description="Show only active items"),
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Get all items for a specific brand."""
    return await service.get_items_by_brand(brand_id, active_only=active_only)


@router.get("/low-stock/", response_model=List[ItemListResponse])
async def get_low_stock_items(
    active_only: bool = Query(True, description="Show only active items"),
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Get items that need reordering based on reorder level."""
    return await service.get_low_stock_items(active_only=active_only)


# SKU-specific endpoints
@router.post("/skus/generate", response_model=SKUGenerationResponse)
async def generate_sku_preview(
    request: SKUGenerationRequest,
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Generate a preview of what SKU would be created for the given category and item details."""
    return await service.generate_sku_preview(request)


@router.post("/skus/bulk-generate", response_model=SKUBulkGenerationResponse)
async def bulk_generate_skus(
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Generate SKUs for all existing items that don't have them."""
    return await service.bulk_generate_skus()


# Count endpoint
@router.get("/count/total")
async def count_items(
    search: Optional[str] = Query(None, description="Search term for item name, code, or SKU"),
    item_status: Optional[ItemStatus] = Query(None, description="Filter by item status"),
    brand_id: Optional[UUID] = Query(None, description="Filter by brand ID"),
    category_id: Optional[UUID] = Query(None, description="Filter by category ID"),
    is_rentable: Optional[bool] = Query(None, description="Filter by rentable status"),
    is_saleable: Optional[bool] = Query(None, description="Filter by saleable status"),
    active_only: bool = Query(True, description="Count only active items"),
    service: ItemMasterService = Depends(get_item_master_service)
):
    """Count items with optional search and filtering."""
    count = await service.count_items(
        search=search,
        item_status=item_status,
        brand_id=brand_id,
        category_id=category_id,
        is_rentable=is_rentable,
        is_saleable=is_saleable,
        active_only=active_only
    )
    return {"count": count}



===== modules/master_data/item_master/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List
from datetime import datetime
from decimal import Decimal
from pydantic import BaseModel, Field, ConfigDict, field_validator, computed_field, model_validator
from uuid import UUID

from app.modules.master_data.item_master.models import ItemStatus


# Nested relationship schemas
class BrandNested(BaseModel):
    """Nested brand information for item responses."""

    id: UUID
    name: str

    model_config = ConfigDict(from_attributes=True)


class CategoryNested(BaseModel):
    """Nested category information for item responses."""

    id: UUID
    name: str

    model_config = ConfigDict(from_attributes=True)


class UnitOfMeasurementNested(BaseModel):
    """Nested unit of measurement information for item responses."""

    id: UUID
    name: str
    code: Optional[str] = Field(None, description="Unit abbreviation/code")

    model_config = ConfigDict(from_attributes=True)


class ItemCreate(BaseModel):
    """Schema for creating a new item."""

    model_config = ConfigDict(protected_namespaces=())

    item_name: str = Field(..., max_length=200, description="Item name")
    item_status: ItemStatus = Field(default=ItemStatus.ACTIVE, description="Item status")
    brand_id: Optional[UUID] = Field(None, description="Brand ID")
    category_id: Optional[UUID] = Field(None, description="Category ID")
    unit_of_measurement_id: UUID = Field(..., description="Unit of measurement ID")
    rental_rate_per_period: Optional[Decimal] = Field(
        None, ge=0, description="Rental rate per period"
    )
    rental_period: Optional[str] = Field(
        default="1", description="Rental period (number of periods)"
    )
    sale_price: Optional[Decimal] = Field(None, ge=0, description="Sale price")
    purchase_price: Optional[Decimal] = Field(None, ge=0, description="Purchase price")
    initial_stock_quantity: Optional[int] = Field(
        None, ge=0, description="Initial stock quantity (only for creation)"
    )
    security_deposit: Decimal = Field(default=Decimal("0.00"), ge=0, description="Security deposit")
    description: Optional[str] = Field(None, description="Item description")
    specifications: Optional[str] = Field(None, description="Item specifications")
    model_number: Optional[str] = Field(None, max_length=100, description="Model number")
    serial_number_required: bool = Field(default=False, description="Serial number required")
    warranty_period_days: str = Field(default="0", description="Warranty period in days")
    reorder_point: int = Field(..., ge=0, description="Reorder point threshold (mandatory)")
    is_rentable: bool = Field(default=True, description="Item can be rented")
    is_saleable: bool = Field(default=False, description="Item can be sold")

    @field_validator("warranty_period_days", "rental_period")
    @classmethod
    def validate_numeric_string(cls, v):
        if v is not None and v != "":
            try:
                int(v)
            except ValueError:
                raise ValueError("Must be a valid number")
        return v

    @field_validator("rental_period")
    @classmethod
    def validate_rental_period(cls, v):
        if v is not None:
            try:
                period_value = int(v)
                if period_value <= 0:
                    raise ValueError("Rental period must be a positive integer")
            except ValueError:
                raise ValueError("Rental period must be a valid positive integer")
        return v

    @field_validator("is_saleable")
    @classmethod
    def validate_boolean_exclusion(cls, v, info):
        """Validate that is_rentable and is_saleable are mutually exclusive."""
        is_rentable = info.data.get("is_rentable", True)  # Default value

        if v and is_rentable:
            raise ValueError(
                "Item cannot be both rentable and saleable - these are mutually exclusive"
            )

        if not v and not is_rentable:
            raise ValueError("Item must be either rentable or saleable")

        return v


class ItemUpdate(BaseModel):
    """Schema for updating an item."""

    model_config = ConfigDict(protected_namespaces=())

    item_name: Optional[str] = Field(None, max_length=200, description="Item name")
    item_status: Optional[ItemStatus] = Field(None, description="Item status")
    brand_id: Optional[UUID] = Field(None, description="Brand ID")
    category_id: Optional[UUID] = Field(None, description="Category ID")
    unit_of_measurement_id: Optional[UUID] = Field(None, description="Unit of measurement ID")
    rental_rate_per_period: Optional[Decimal] = Field(
        None, ge=0, description="Rental rate per period"
    )
    rental_period: Optional[str] = Field(None, description="Rental period (number of periods)")
    sale_price: Optional[Decimal] = Field(None, ge=0, description="Sale price")
    purchase_price: Optional[Decimal] = Field(None, ge=0, description="Purchase price")
    security_deposit: Optional[Decimal] = Field(None, ge=0, description="Security deposit")
    description: Optional[str] = Field(None, description="Item description")
    specifications: Optional[str] = Field(None, description="Item specifications")
    model_number: Optional[str] = Field(None, max_length=100, description="Model number")
    serial_number_required: Optional[bool] = Field(None, description="Serial number required")
    warranty_period_days: Optional[str] = Field(None, description="Warranty period in days")
    reorder_point: Optional[int] = Field(None, ge=0, description="Reorder point threshold")
    is_rentable: Optional[bool] = Field(None, description="Item can be rented")
    is_saleable: Optional[bool] = Field(None, description="Item can be sold")

    @field_validator("warranty_period_days", "rental_period")
    @classmethod
    def validate_numeric_string(cls, v):
        if v is not None and v != "":
            try:
                int(v)
            except ValueError:
                raise ValueError("Must be a valid number")
        return v

    @model_validator(mode="after")
    def validate_boolean_fields(self):
        """Validate boolean field combinations for updates."""
        if self.is_rentable is not None and self.is_saleable is not None:
            if self.is_rentable and self.is_saleable:
                raise ValueError(
                    "Item cannot be both rentable and saleable - these are mutually exclusive"
                )
            if not self.is_rentable and not self.is_saleable:
                raise ValueError("Item must be either rentable or saleable")
        return self


class ItemResponse(BaseModel):
    """Schema for item response."""

    model_config = ConfigDict(from_attributes=True, protected_namespaces=())

    id: UUID
    sku: str
    item_name: str
    item_status: ItemStatus
    brand_id: Optional[UUID]
    category_id: Optional[UUID]
    unit_of_measurement_id: UUID
    rental_rate_per_period: Optional[Decimal]
    rental_period: Optional[str]
    sale_price: Optional[Decimal]
    purchase_price: Optional[Decimal]
    security_deposit: Decimal
    description: Optional[str]
    specifications: Optional[str]
    model_number: Optional[str]
    serial_number_required: bool
    warranty_period_days: str
    reorder_point: int
    is_rentable: bool
    is_saleable: bool
    is_active: Optional[bool] = True
    created_at: datetime
    updated_at: datetime

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.item_name} ({self.sku})"

    @computed_field
    @property
    def is_rental_item(self) -> bool:
        return self.is_rentable

    @computed_field
    @property
    def is_sale_item(self) -> bool:
        return self.is_saleable


class ItemListResponse(BaseModel):
    """Schema for item list response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    sku: str
    item_name: str
    item_status: ItemStatus
    brand_id: Optional[UUID]
    category_id: Optional[UUID]
    unit_of_measurement_id: Optional[UUID]
    rental_rate_per_period: Optional[Decimal]
    sale_price: Optional[Decimal]
    purchase_price: Optional[Decimal]
    is_rentable: bool
    is_saleable: bool
    is_active: bool
    created_at: datetime
    updated_at: datetime

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.item_name} ({self.sku})"


class ItemWithInventoryResponse(BaseModel):
    """Schema for item response with inventory details."""

    model_config = ConfigDict(from_attributes=True, protected_namespaces=())

    id: UUID
    sku: str
    item_name: str
    item_status: ItemStatus
    brand_id: Optional[UUID]
    category_id: Optional[UUID]
    unit_of_measurement_id: UUID
    rental_rate_per_period: Optional[Decimal]
    rental_period: Optional[str]
    sale_price: Optional[Decimal]
    purchase_price: Optional[Decimal]
    security_deposit: Decimal
    description: Optional[str]
    specifications: Optional[str]
    model_number: Optional[str]
    serial_number_required: bool
    warranty_period_days: str
    reorder_point: int
    is_rentable: bool
    is_saleable: bool
    is_active: Optional[bool] = True
    created_at: datetime
    updated_at: datetime

    # Inventory summary fields
    total_inventory_units: int = Field(default=0, description="Total number of inventory units")
    available_units: int = Field(default=0, description="Number of available units")
    rented_units: int = Field(default=0, description="Number of rented units")

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.item_name} ({self.sku})"

    @computed_field
    @property
    def is_rental_item(self) -> bool:
        return self.is_rentable

    @computed_field
    @property
    def is_sale_item(self) -> bool:
        return self.is_saleable
    
    @computed_field
    @property
    def stock_status(self) -> str:
        if self.available_units == 0:
            return "OUT_OF_STOCK"
        elif self.available_units <= self.reorder_point:
            return "LOW_STOCK"
        else:
            return "IN_STOCK"
    
    @computed_field
    @property
    def needs_reorder(self) -> bool:
        return self.available_units <= self.reorder_point


# New nested response schema as requested by user
class ItemNestedResponse(BaseModel):
    """Schema for item response with nested relationship objects."""

    model_config = ConfigDict(from_attributes=True, protected_namespaces=())

    # Basic fields with ID and SKU included
    id: UUID
    sku: str = Field(..., description="Stock Keeping Unit")
    item_name: str
    item_status: ItemStatus

    # Nested relationship objects
    brand_id: Optional[BrandNested] = Field(None, description="Brand information")
    category_id: Optional[CategoryNested] = Field(None, description="Category information")
    unit_of_measurement_id: UnitOfMeasurementNested = Field(
        ..., description="Unit of measurement information"
    )

    # Other fields
    rental_rate_per_period: Optional[Decimal] = Field(default=Decimal("0"))
    rental_period: str = Field(default="1")
    sale_price: Optional[Decimal] = Field(default=Decimal("0"))
    purchase_price: Optional[Decimal] = Field(default=Decimal("0"))
    initial_stock_quantity: Optional[int] = Field(default=0)
    security_deposit: Decimal = Field(default=Decimal("0"))
    description: Optional[str]
    specifications: Optional[str]
    model_number: Optional[str]
    serial_number_required: bool = Field(default=False)
    warranty_period_days: str = Field(default="0")
    reorder_point: int = Field(default=0)
    is_rentable: bool = Field(default=True)
    is_saleable: bool = Field(default=False)


# SKU-specific schemas
class SKUGenerationRequest(BaseModel):
    """Schema for SKU generation request."""

    category_id: Optional[UUID] = Field(None, description="Category ID for SKU generation")
    item_name: str = Field(..., description="Item name for product code generation")
    is_rentable: bool = Field(default=True, description="Item can be rented")
    is_saleable: bool = Field(default=False, description="Item can be sold")


class SKUGenerationResponse(BaseModel):
    """Schema for SKU generation response."""

    sku: str = Field(..., description="Generated SKU")
    category_code: str = Field(..., description="Category code used")
    subcategory_code: str = Field(..., description="Subcategory code used")
    product_code: str = Field(..., description="Product code (first 4 letters of item name)")
    attributes_code: str = Field(..., description="Attributes code (R/S/B)")
    sequence_number: int = Field(..., description="Sequence number used")


class SKUBulkGenerationResponse(BaseModel):
    """Schema for bulk SKU generation response."""

    total_processed: int = Field(..., description="Total items processed")
    successful_generations: int = Field(..., description="Number of successful generations")
    failed_generations: int = Field(..., description="Number of failed generations")
    errors: List[dict] = Field(default_factory=list, description="Generation errors")


# Enhanced response schemas with relationship data
class BrandInfo(BaseModel):
    """Brand information for item response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    brand_name: str
    brand_code: Optional[str] = None
    description: Optional[str] = None


class CategoryInfo(BaseModel):
    """Category information for item response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    category_name: str
    category_path: Optional[str] = None
    level: Optional[int] = None


class UnitInfo(BaseModel):
    """Unit of measurement information for item response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    unit_name: str
    abbreviation: Optional[str] = None
    symbol: Optional[str] = None


class ItemWithRelationsResponse(BaseModel):
    """Enhanced schema for item response with relationship data."""

    model_config = ConfigDict(from_attributes=True, protected_namespaces=())

    # Basic item fields
    id: UUID
    sku: str
    item_name: str
    item_status: ItemStatus
    brand_id: Optional[UUID]
    category_id: Optional[UUID]
    unit_of_measurement_id: UUID
    rental_rate_per_period: Optional[Decimal]
    rental_period: Optional[str]
    sale_price: Optional[Decimal]
    purchase_price: Optional[Decimal]
    security_deposit: Decimal
    description: Optional[str]
    specifications: Optional[str]
    model_number: Optional[str]
    serial_number_required: bool
    warranty_period_days: str
    reorder_point: int
    is_rentable: bool
    is_saleable: bool
    is_active: Optional[bool] = True
    created_at: datetime
    updated_at: datetime

    # Relationship data
    brand: Optional[BrandInfo] = None
    category: Optional[CategoryInfo] = None
    unit_of_measurement: Optional[UnitInfo] = None

    # Inventory summary fields
    total_units: int = Field(default=0, description="Total number of inventory units")
    available_units: int = Field(default=0, description="Number of available units")
    rented_units: int = Field(default=0, description="Number of rented units")

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.item_name} ({self.sku})"

    @computed_field
    @property
    def brand_name(self) -> Optional[str]:
        return self.brand.brand_name if self.brand else None

    @computed_field
    @property
    def brand_code(self) -> Optional[str]:
        return self.brand.brand_code if self.brand else None

    @computed_field
    @property
    def category_name(self) -> Optional[str]:
        return self.category.category_name if self.category else None

    @computed_field
    @property
    def category_path(self) -> Optional[str]:
        return self.category.category_path if self.category else None

    @computed_field
    @property
    def unit_name(self) -> Optional[str]:
        return self.unit_of_measurement.unit_name if self.unit_of_measurement else None

    @computed_field
    @property
    def unit_abbreviation(self) -> Optional[str]:
        return self.unit_of_measurement.abbreviation if self.unit_of_measurement else None

    @computed_field
    @property
    def is_rental_item(self) -> bool:
        return self.is_rentable

    @computed_field
    @property
    def is_sale_item(self) -> bool:
        return self.is_saleable


class ItemListWithRelationsResponse(BaseModel):
    """Enhanced schema for item list response with relationship data (lightweight)."""

    model_config = ConfigDict(from_attributes=True, protected_namespaces=())

    # Basic item fields
    id: UUID
    sku: str
    item_name: str
    item_status: ItemStatus
    brand_id: Optional[UUID]
    category_id: Optional[UUID]
    unit_of_measurement_id: UUID
    rental_rate_per_period: Optional[Decimal]
    sale_price: Optional[Decimal]
    purchase_price: Optional[Decimal]
    is_rentable: bool
    is_saleable: bool
    is_active: bool
    created_at: datetime
    updated_at: datetime

    # Relationship data (lightweight)
    brand_name: Optional[str] = None
    brand_code: Optional[str] = None
    category_name: Optional[str] = None
    category_path: Optional[str] = None
    unit_name: Optional[str] = None
    unit_abbreviation: Optional[str] = None

    # Inventory summary fields
    total_units: int = Field(default=0, description="Total number of inventory units")
    available_units: int = Field(default=0, description="Number of available units")
    rented_units: int = Field(default=0, description="Number of rented units")

    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.item_name} ({self.sku})"


===== modules/master_data/item_master/service.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List
from uuid import UUID
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
import time
import logging

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.master_data.item_master.models import Item, ItemStatus
from app.modules.master_data.item_master.repository import ItemMasterRepository
from app.modules.master_data.units.repository import UnitOfMeasurementRepository
from app.modules.master_data.item_master.schemas import (
    ItemCreate,
    ItemUpdate,
    ItemResponse,
    ItemListResponse,
    ItemWithInventoryResponse,
    ItemWithRelationsResponse,
    ItemListWithRelationsResponse,
    ItemNestedResponse,
    SKUGenerationRequest,
    SKUGenerationResponse,
    SKUBulkGenerationResponse,
    BrandNested,
    CategoryNested,
    UnitOfMeasurementNested,
)
from app.shared.utils.sku_generator import SKUGenerator


class ItemMasterService:
    """Service for item master data operations."""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.item_repository = ItemMasterRepository(session)
        self.unit_repository = UnitOfMeasurementRepository(session)
        self.sku_generator = SKUGenerator(session)
        self.logger = logging.getLogger(__name__)

    # Item operations
    async def create_item(self, item_data: ItemCreate) -> ItemResponse:
        """Create a new item with automatic SKU generation."""
        start_time = time.time()
        self.logger.info(f"Starting item creation for: {item_data.item_name}")

        try:
            # Generate SKU automatically using new format
            sku_start = time.time()
            sku = await self.sku_generator.generate_sku(
                category_id=item_data.category_id,
                item_name=item_data.item_name,
                is_rentable=item_data.is_rentable,
                is_saleable=item_data.is_saleable,
            )
            sku_time = time.time() - sku_start
            self.logger.info(f"SKU generation completed in {sku_time:.3f}s. SKU: {sku}")

            # Validate item type and pricing
            validation_start = time.time()
            self._validate_item_pricing(item_data)
            validation_time = time.time() - validation_start
            self.logger.debug(f"Item validation completed in {validation_time:.3f}s")

            # Extract initial stock quantity before creating item
            initial_stock_quantity = item_data.initial_stock_quantity
            item_data_dict = item_data.model_dump()
            # Remove initial_stock_quantity as it's not a model field
            item_data_dict.pop("initial_stock_quantity", None)

            # Create ItemCreate without initial_stock_quantity
            from app.modules.master_data.item_master.schemas import ItemCreate as ItemCreateClean

            item_data_clean = ItemCreateClean(**item_data_dict)

            # Create item with generated SKU
            db_start = time.time()
            item = await self.item_repository.create(item_data_clean, sku)
            db_time = time.time() - db_start
            self.logger.info(f"Database insertion completed in {db_time:.3f}s")

            # Create initial stock if specified
            if initial_stock_quantity and initial_stock_quantity > 0:
                try:
                    # Import inventory service to create initial stock
                    from app.modules.inventory.service import InventoryService

                    inventory_service = InventoryService(self.session)
                    stock_result = await inventory_service.create_initial_stock(
                        item_id=item.id,
                        item_sku=sku,
                        purchase_price=item_data.purchase_price,
                        quantity=initial_stock_quantity,
                    )

                    if stock_result.get("created"):
                        self.logger.info(
                            f"Created initial stock: {stock_result['total_quantity']} units "
                            f"at {stock_result['location_name']} for item {item.id}. "
                            f"Unit codes: {', '.join(stock_result['unit_codes'])}"
                        )
                    else:
                        self.logger.warning(
                            f"Failed to create initial stock: {stock_result.get('reason', 'Unknown error')}"
                        )
                except Exception as stock_error:
                    self.logger.error(
                        f"Exception during initial stock creation: {str(stock_error)}"
                    )
                    # Don't fail item creation if stock creation fails

            total_time = time.time() - start_time
            self.logger.info(
                f"Item creation completed successfully in {total_time:.3f}s. Item ID: {item.id}"
            )

            return ItemResponse.model_validate(item)

        except Exception as e:
            total_time = time.time() - start_time
            self.logger.error(f"Item creation failed after {total_time:.3f}s: {str(e)}")
            raise

    async def get_item(self, item_id: UUID) -> ItemResponse:
        """Get item by ID."""
        item = await self.item_repository.get_by_id(item_id)
        if not item:
            raise NotFoundError(f"Item with ID {item_id} not found")

        return ItemResponse.model_validate(item)

    async def get_item_by_sku(self, sku: str) -> ItemResponse:
        """Get item by SKU."""
        item = await self.item_repository.get_by_sku(sku)
        if not item:
            raise NotFoundError(f"Item with SKU '{sku}' not found")
        return ItemResponse.model_validate(item)

    async def get_items(
        self,
        skip: int = 0,
        limit: int = 100,
        category_id: Optional[UUID] = None,
        brand_id: Optional[UUID] = None,
        item_status: Optional[ItemStatus] = None,
        active_only: bool = True,
        # Date filters
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        updated_after: Optional[str] = None,
        updated_before: Optional[str] = None,
    ) -> List[ItemListResponse]:
        """Get all items with essential filtering."""
        items = await self.item_repository.get_all(
            skip=skip,
            limit=limit,
            item_status=item_status,
            brand_id=brand_id,
            category_id=category_id,
            active_only=active_only,
            # Date filters
            created_after=created_after,
            created_before=created_before,
            updated_after=updated_after,
            updated_before=updated_before,
        )

        return [ItemListResponse.model_validate(item) for item in items]

    async def get_items_with_relations(
        self,
        skip: int = 0,
        limit: int = 100,
        item_status: Optional[ItemStatus] = None,
        brand_ids: Optional[List[UUID]] = None,
        category_ids: Optional[List[UUID]] = None,
        active_only: bool = True,
        # Additional filters
        is_rentable: Optional[bool] = None,
        is_saleable: Optional[bool] = None,
        min_rental_rate: Optional[float] = None,
        max_rental_rate: Optional[float] = None,
        min_sale_price: Optional[float] = None,
        max_sale_price: Optional[float] = None,
        has_stock: Optional[bool] = None,
        search_term: Optional[str] = None,
        # Date filters
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        updated_after: Optional[str] = None,
        updated_before: Optional[str] = None,
    ) -> List[ItemListWithRelationsResponse]:
        """Get all items with relationship data and enhanced filtering."""
        from decimal import Decimal

        # Convert float parameters to Decimal for repository
        min_rental_rate_decimal = Decimal(str(min_rental_rate)) if min_rental_rate else None
        max_rental_rate_decimal = Decimal(str(max_rental_rate)) if max_rental_rate else None
        min_sale_price_decimal = Decimal(str(min_sale_price)) if min_sale_price else None
        max_sale_price_decimal = Decimal(str(max_sale_price)) if max_sale_price else None

        items_data = await self.item_repository.get_all_with_relations(
            skip=skip,
            limit=limit,
            item_status=item_status,
            brand_ids=brand_ids,
            category_ids=category_ids,
            active_only=active_only,
            is_rentable=is_rentable,
            is_saleable=is_saleable,
            min_rental_rate=min_rental_rate_decimal,
            max_rental_rate=max_rental_rate_decimal,
            min_sale_price=min_sale_price_decimal,
            max_sale_price=max_sale_price_decimal,
            has_stock=has_stock,
            search_term=search_term,
            created_after=created_after,
            created_before=created_before,
            updated_after=updated_after,
            updated_before=updated_before,
        )

        # Convert raw data to Pydantic models
        response_items = []
        for item_data in items_data:
            response_items.append(ItemListWithRelationsResponse(**item_data))

        return response_items

    async def count_items(
        self,
        search: Optional[str] = None,
        item_status: Optional[ItemStatus] = None,
        brand_id: Optional[UUID] = None,
        category_id: Optional[UUID] = None,
        is_rentable: Optional[bool] = None,
        is_saleable: Optional[bool] = None,
        active_only: bool = True,
    ) -> int:
        """Count all items with optional search and filtering."""
        return await self.item_repository.count_all(
            search=search,
            item_status=item_status,
            brand_id=brand_id,
            category_id=category_id,
            is_rentable=is_rentable,
            is_saleable=is_saleable,
            active_only=active_only,
        )

    async def search_items(
        self, search_term: str, skip: int = 0, limit: int = 100, active_only: bool = True
    ) -> List[ItemListResponse]:
        """Search items by name or code."""
        items = await self.item_repository.search(
            search_term=search_term, skip=skip, limit=limit, active_only=active_only
        )

        return [ItemListResponse.model_validate(item) for item in items]

    async def update_item(self, item_id: UUID, item_data: ItemUpdate) -> ItemResponse:
        """Update an item."""
        # Get existing item
        existing_item = await self.item_repository.get_by_id(item_id)
        if not existing_item:
            raise NotFoundError(f"Item with ID {item_id} not found")

        # Validate pricing if boolean fields or pricing is being updated
        if any(
            [
                item_data.is_rentable is not None,
                item_data.is_saleable is not None,
                item_data.rental_rate_per_period is not None,
                item_data.sale_price is not None,
            ]
        ):
            self._validate_item_pricing_update(existing_item, item_data)

        # Update item
        updated_item = await self.item_repository.update(item_id, item_data)
        if not updated_item:
            raise NotFoundError(f"Item with ID {item_id} not found")

        return ItemResponse.model_validate(updated_item)

    async def delete_item(self, item_id: UUID) -> bool:
        """Delete (soft delete) an item."""
        success = await self.item_repository.delete(item_id)
        if not success:
            raise NotFoundError(f"Item with ID {item_id} not found")
        return success

    async def get_rental_items(self, active_only: bool = True) -> List[ItemListResponse]:
        """Get all rental items."""
        items = await self.item_repository.get_rental_items(active_only=active_only)
        return [ItemListResponse.model_validate(item) for item in items]

    async def get_sale_items(self, active_only: bool = True) -> List[ItemListResponse]:
        """Get all sale items."""
        items = await self.item_repository.get_sale_items(active_only=active_only)
        return [ItemListResponse.model_validate(item) for item in items]

    async def get_items_by_category(
        self, category_id: UUID, active_only: bool = True
    ) -> List[ItemListResponse]:
        """Get all items in a specific category."""
        items = await self.item_repository.get_items_by_category(
            category_id, active_only=active_only
        )
        return [ItemListResponse.model_validate(item) for item in items]

    async def get_items_by_brand(
        self, brand_id: UUID, active_only: bool = True
    ) -> List[ItemListResponse]:
        """Get all items for a specific brand."""
        items = await self.item_repository.get_items_by_brand(brand_id, active_only=active_only)
        return [ItemListResponse.model_validate(item) for item in items]

    async def get_low_stock_items(self, active_only: bool = True) -> List[ItemListResponse]:
        """Get items that need reordering based on reorder level."""
        items = await self.item_repository.get_low_stock_items(active_only=active_only)
        return [ItemListResponse.model_validate(item) for item in items]

    async def get_items_nested_format(
        self,
        skip: int = 0,
        limit: int = 100,
        item_status: Optional[ItemStatus] = None,
        brand_ids: Optional[List[UUID]] = None,
        category_ids: Optional[List[UUID]] = None,
        active_only: bool = True,
        is_rentable: Optional[bool] = None,
        is_saleable: Optional[bool] = None,
        min_rental_rate: Optional[Decimal] = None,
        max_rental_rate: Optional[Decimal] = None,
        min_sale_price: Optional[Decimal] = None,
        max_sale_price: Optional[Decimal] = None,
        has_stock: Optional[bool] = None,
        search_term: Optional[str] = None,
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        updated_after: Optional[str] = None,
        updated_before: Optional[str] = None,
    ) -> List[ItemNestedResponse]:
        """Get items with nested relationship format."""
        # Convert decimal price filters if provided
        if min_rental_rate is not None:
            min_rental_rate = Decimal(str(min_rental_rate))
        if max_rental_rate is not None:
            max_rental_rate = Decimal(str(max_rental_rate))
        if min_sale_price is not None:
            min_sale_price = Decimal(str(min_sale_price))
        if max_sale_price is not None:
            max_sale_price = Decimal(str(max_sale_price))

        # Get items with eagerly loaded relationships
        items = await self.item_repository.get_all_with_nested_relations(
            skip=skip,
            limit=limit,
            item_status=item_status,
            brand_ids=brand_ids,
            category_ids=category_ids,
            active_only=active_only,
            is_rentable=is_rentable,
            is_saleable=is_saleable,
            min_rental_rate=min_rental_rate,
            max_rental_rate=max_rental_rate,
            min_sale_price=min_sale_price,
            max_sale_price=max_sale_price,
            has_stock=has_stock,
            search_term=search_term,
            created_after=created_after,
            created_before=created_before,
            updated_after=updated_after,
            updated_before=updated_before,
        )

        # Transform to nested format
        response_items = []
        for item in items:
            # Build nested response
            nested_item = {
                "id": item.id,
                "sku": item.sku,
                "item_name": item.item_name,
                "item_status": item.item_status,
                "brand_id": None,
                "category_id": None,
                "unit_of_measurement_id": None,
                "rental_rate_per_period": item.rental_rate_per_period or Decimal("0"),
                "rental_period": item.rental_period or "1",
                "sale_price": item.sale_price or Decimal("0"),
                "purchase_price": item.purchase_price or Decimal("0"),
                "initial_stock_quantity": 0,  # This would need to come from inventory
                "security_deposit": item.security_deposit or Decimal("0"),
                "description": item.description,
                "specifications": item.specifications,
                "model_number": item.model_number,
                "serial_number_required": item.serial_number_required,
                "warranty_period_days": item.warranty_period_days or "0",
                "reorder_level": item.reorder_point or 0,
                "reorder_quantity": 0,  # This field doesn't exist in the model
                "is_rentable": item.is_rentable,
                "is_saleable": item.is_saleable,
            }

            # Add nested brand info
            if item.brand:
                nested_item["brand_id"] = BrandNested(id=item.brand.id, name=item.brand.name)

            # Add nested category info
            if item.category:
                nested_item["category_id"] = CategoryNested(
                    id=item.category.id, name=item.category.name
                )

            # Add nested unit info (required field)
            if item.unit_of_measurement:
                nested_item["unit_of_measurement_id"] = UnitOfMeasurementNested(
                    id=item.unit_of_measurement.id,
                    name=item.unit_of_measurement.name,
                    code=item.unit_of_measurement.abbreviation,
                )
            elif item.unit_of_measurement_id:
                # Fallback: if relationship not loaded but ID exists, fetch the unit
                unit = await self.unit_repository.get_by_id(item.unit_of_measurement_id)
                if unit:
                    nested_item["unit_of_measurement_id"] = UnitOfMeasurementNested(
                        id=unit.id, name=unit.name, code=unit.abbreviation
                    )
                else:
                    # Data inconsistency: unit ID exists but unit not found
                    raise ValueError(
                        f"Unit of measurement with ID {item.unit_of_measurement_id} not found for item {item.item_name}"
                    )
            else:
                # This should not happen if database constraints are correct
                raise ValueError(f"Item {item.item_name} has no unit of measurement")

            response_items.append(ItemNestedResponse(**nested_item))

        return response_items

    # SKU-specific operations
    async def generate_sku_preview(self, request: SKUGenerationRequest) -> SKUGenerationResponse:
        """Generate a preview of what SKU would be created."""
        sku = await self.sku_generator.preview_sku(
            category_id=request.category_id,
            item_name=request.item_name,
            is_rentable=request.is_rentable,
            is_saleable=request.is_saleable,
        )

        # Extract components for response
        parts = sku.split("-")
        if len(parts) == 5:
            category_code, subcategory_code, product_code, attributes_code, sequence = parts
            sequence_number = int(sequence)
        else:
            category_code = "MISC"
            subcategory_code = "ITEM"
            product_code = parts[2] if len(parts) > 2 else "PROD"
            attributes_code = parts[3] if len(parts) > 3 else "R"
            sequence_number = 1

        return SKUGenerationResponse(
            sku=sku,
            category_code=category_code,
            subcategory_code=subcategory_code,
            product_code=product_code,
            attributes_code=attributes_code,
            sequence_number=sequence_number,
        )

    async def bulk_generate_skus(self) -> SKUBulkGenerationResponse:
        """Generate SKUs for all existing items that don't have them."""
        result = await self.sku_generator.bulk_generate_skus_for_existing_items()
        return SKUBulkGenerationResponse(**result)

    # Helper methods
    def _validate_item_pricing(self, item_data: ItemCreate):
        """Validate item pricing based on boolean fields."""
        if item_data.is_rentable:
            if not item_data.rental_rate_per_period:
                raise ValidationError("Rental rate per period is required for rentable items")

        if item_data.is_saleable:
            if not item_data.sale_price:
                raise ValidationError("Sale price is required for saleable items")

    def _validate_item_pricing_update(self, existing_item: Item, item_data: ItemUpdate):
        """Validate item pricing for updates."""
        # Get effective boolean fields after update
        is_rentable = (
            item_data.is_rentable
            if item_data.is_rentable is not None
            else existing_item.is_rentable
        )
        is_saleable = (
            item_data.is_saleable
            if item_data.is_saleable is not None
            else existing_item.is_saleable
        )

        # Get effective pricing after update
        rental_rate = (
            item_data.rental_rate_per_period
            if item_data.rental_rate_per_period is not None
            else existing_item.rental_rate_per_period
        )
        sale_price = (
            item_data.sale_price if item_data.sale_price is not None else existing_item.sale_price
        )

        if is_rentable:
            if not rental_rate:
                raise ValidationError("Rental rate per period is required for rentable items")

        if is_saleable:
            if not sale_price:
                raise ValidationError("Sale price is required for saleable items")
    
    async def get_low_stock_items(
        self, 
        location_id: Optional[UUID] = None,
        skip: int = 0,
        limit: int = 100
    ) -> List[ItemWithInventoryResponse]:
        """
        Get items with stock levels at or below their reorder point.
        Uses efficient JOIN pattern to avoid copying reorder_point data.
        
        Args:
            location_id: Optional location filter
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            List of items that need reordering
        """
        try:
            low_stock_items = await self.item_repository.get_low_stock_items(
                location_id=location_id,
                skip=skip,
                limit=limit
            )
            
            return [
                ItemWithInventoryResponse.model_validate(item) 
                for item in low_stock_items
            ]
            
        except Exception as e:
            self.logger.error(f"Error fetching low stock items: {str(e)}")
            raise
    
    async def get_stock_alerts_summary(self) -> dict:
        """
        Get summary of stock alerts across all items.
        
        Returns:
            Dictionary with stock alert counts and statistics
        """
        try:
            summary = await self.item_repository.get_stock_alerts_summary()
            
            return {
                "out_of_stock_count": summary.get("out_of_stock", 0),
                "low_stock_count": summary.get("low_stock", 0),
                "total_items": summary.get("total_items", 0),
                "average_reorder_point": summary.get("avg_reorder_point", 0),
                "items_needing_attention": summary.get("out_of_stock", 0) + summary.get("low_stock", 0)
            }
            
        except Exception as e:
            self.logger.error(f"Error fetching stock alerts summary: {str(e)}")
            raise


===== modules/master_data/brands/__init__.py â€“ 2025-07-19 12:13:41 IST =====
# Brands module
from .routes import router
from .models import Brand
from .schemas import BrandCreate, BrandUpdate, BrandResponse
from .service import BrandService
from .repository import BrandRepository

__all__ = [
    "router",
    "Brand",
    "BrandCreate",
    "BrandUpdate", 
    "BrandResponse",
    "BrandService",
    "BrandRepository"
]

===== modules/master_data/brands/models.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, TYPE_CHECKING
from sqlalchemy import Column, String, Text, Index
from sqlalchemy.orm import relationship

from app.db.base import BaseModel, NamedModelMixin, CodedModelMixin

# if TYPE_CHECKING:
    # from app.modules.inventory.models import Item  # Commented out - Item model not currently imported


class Brand(BaseModel, NamedModelMixin, CodedModelMixin):
    """
    Brand model for product brands.
    
    Attributes:
        name: Brand name (from NamedModelMixin)
        code: Unique brand code (from CodedModelMixin)
        description: Brand description (from NamedModelMixin)
        items: Related items under this brand (currently disabled - Item model not imported)
    """
    
    __tablename__ = "brands"
    
    # Override name and code lengths from mixins
    name = Column(String(100), nullable=False, unique=True, index=True, comment="Brand name")
    code = Column(String(20), nullable=True, unique=True, index=True, comment="Unique brand code")
    
    # Relationships
    items = relationship("Item", back_populates="brand", lazy="select")
    
    # Additional indexes for performance
    __table_args__ = (
        Index('idx_brand_name_active', 'name', 'is_active'),
        Index('idx_brand_code_active', 'code', 'is_active'),
    )
    
    def __init__(
        self,
        name: str,
        code: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a Brand.
        
        Args:
            name: Brand name
            code: Optional unique brand code
            description: Optional brand description
            **kwargs: Additional BaseModel fields
        """
        super().__init__(name=name, code=code, description=description, **kwargs)
        self._validate()
    
    def _validate(self):
        """Validate brand business rules."""
        # Name validation
        if not self.name or not self.name.strip():
            raise ValueError("Brand name cannot be empty")
        
        if len(self.name) > 100:
            raise ValueError("Brand name cannot exceed 100 characters")
        
        # Code validation
        if self.code:
            if not self.code.strip():
                raise ValueError("Brand code cannot be empty if provided")
            
            if len(self.code) > 20:
                raise ValueError("Brand code cannot exceed 20 characters")
            
            # Brand code should be uppercase alphanumeric with hyphens/underscores
            if not self.code.replace("-", "").replace("_", "").isalnum():
                raise ValueError("Brand code must contain only letters, numbers, hyphens, and underscores")
            
            # Auto-uppercase the code
            self.code = self.code.upper()
        
        # Description validation
        if self.description and len(self.description) > 1000:
            raise ValueError("Brand description cannot exceed 1000 characters")
    
    def update_info(
        self,
        name: Optional[str] = None,
        code: Optional[str] = None,
        description: Optional[str] = None,
        updated_by: Optional[str] = None
    ):
        """
        Update brand information.
        
        Args:
            name: New brand name
            code: New brand code
            description: New description
            updated_by: User making the update
        """
        if name is not None:
            if not name or not name.strip():
                raise ValueError("Brand name cannot be empty")
            if len(name) > 100:
                raise ValueError("Brand name cannot exceed 100 characters")
            self.name = name.strip()
        
        if code is not None:
            if code and not code.strip():
                raise ValueError("Brand code cannot be empty if provided")
            if code and len(code) > 20:
                raise ValueError("Brand code cannot exceed 20 characters")
            if code and not code.replace("-", "").replace("_", "").isalnum():
                raise ValueError("Brand code must contain only letters, numbers, hyphens, and underscores")
            self.code = code.upper().strip() if code else None
        
        if description is not None:
            if description and len(description) > 1000:
                raise ValueError("Brand description cannot exceed 1000 characters")
            self.description = description.strip() if description else None
        
        self.updated_by = updated_by
    
    @property
    def display_name(self) -> str:
        """Get display name for the brand."""
        if self.code:
            return f"{self.name} ({self.code})"
        return self.name
    
    @property
    def has_items(self) -> bool:
        """Check if brand has associated items."""
        # return bool(self.items)  # Commented out - Item relationship not available
        return False  # Temporary return until Item model is imported
    
    def can_delete(self) -> bool:
        """Check if brand can be deleted."""
        # Can only delete if no items are associated
        return not self.has_items and self.is_active
    
    def __str__(self) -> str:
        """String representation of brand."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of brand."""
        return f"<Brand(id={self.id}, name='{self.name}', code='{self.code}', active={self.is_active})>"

===== modules/master_data/brands/repository.py â€“ 2025-07-19 12:13:41 IST =====
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import select, func, or_, and_, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from .models import Brand
# from app.shared.pagination import Page


class BrandRepository:
    """Repository for brand data access operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with database session."""
        self.session = session
    
    async def create(self, brand_data: dict) -> Brand:
        """Create a new brand."""
        brand = Brand(**brand_data)
        self.session.add(brand)
        await self.session.commit()
        await self.session.refresh(brand)
        return brand
    
    async def get_by_id(self, brand_id: UUID) -> Optional[Brand]:
        """Get brand by ID."""
        query = select(Brand).where(Brand.id == brand_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_name(self, name: str) -> Optional[Brand]:
        """Get brand by name."""
        query = select(Brand).where(Brand.name == name)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_code(self, code: str) -> Optional[Brand]:
        """Get brand by code."""
        query = select(Brand).where(Brand.code == code)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def list(
        self,
        skip: int = 0,
        limit: int = 100,
        filters: Optional[Dict[str, Any]] = None,
        sort_by: str = "name",
        sort_order: str = "asc",
        include_inactive: bool = False
    ) -> List[Brand]:
        """List brands with optional filters and sorting."""
        query = select(Brand)
        
        # Apply base filters
        if not include_inactive:
            query = query.where(Brand.is_active == True)
        
        # Apply additional filters
        if filters:
            query = self._apply_filters(query, filters)
        
        # Apply sorting
        if sort_order.lower() == "desc":
            query = query.order_by(desc(getattr(Brand, sort_by)))
        else:
            query = query.order_by(asc(getattr(Brand, sort_by)))
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_paginated(
        self,
        page: int = 1,
        page_size: int = 20,
        filters: Optional[Dict[str, Any]] = None,
        sort_by: str = "name",
        sort_order: str = "asc",
        include_inactive: bool = False
    ) -> List[Brand]:
        """Get paginated brands."""
        query = select(Brand)
        
        # Apply base filters
        if not include_inactive:
            query = query.where(Brand.is_active == True)
        
        # Apply additional filters
        if filters:
            query = self._apply_filters(query, filters)
        
        # Apply sorting
        if sort_order.lower() == "desc":
            query = query.order_by(desc(getattr(Brand, sort_by)))
        else:
            query = query.order_by(asc(getattr(Brand, sort_by)))
        
        # Calculate pagination
        skip = (page - 1) * page_size
        limit = page_size
        
        result = await self.session.execute(query.offset(skip).limit(limit))
        return result.scalars().all()
    
    async def update(self, brand_id: UUID, update_data: dict) -> Optional[Brand]:
        """Update existing brand."""
        brand = await self.get_by_id(brand_id)
        if not brand:
            return None
        
        # Update fields using the model's update method
        brand.update_info(**update_data)
        
        await self.session.commit()
        await self.session.refresh(brand)
        
        return brand
    
    async def delete(self, brand_id: UUID) -> bool:
        """Soft delete brand by setting is_active to False."""
        brand = await self.get_by_id(brand_id)
        if not brand:
            return False
        
        brand.is_active = False
        await self.session.commit()
        
        return True
    
    async def hard_delete(self, brand_id: UUID) -> bool:
        """Hard delete brand from database."""
        brand = await self.get_by_id(brand_id)
        if not brand:
            return False
        
        # Check if brand can be deleted
        if not brand.can_delete():
            return False
        
        await self.session.delete(brand)
        await self.session.commit()
        
        return True
    
    async def count(
        self,
        filters: Optional[Dict[str, Any]] = None,
        include_inactive: bool = False
    ) -> int:
        """Count brands matching filters."""
        query = select(func.count()).select_from(Brand)
        
        # Apply base filters
        if not include_inactive:
            query = query.where(Brand.is_active == True)
        
        # Apply additional filters
        if filters:
            query = self._apply_filters(query, filters)
        
        result = await self.session.execute(query)
        return result.scalar_one()
    
    async def exists_by_name(self, name: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a brand with the given name exists."""
        query = select(func.count()).select_from(Brand).where(
            Brand.name == name
        )
        
        if exclude_id:
            query = query.where(Brand.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0
    
    async def exists_by_code(self, code: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a brand with the given code exists."""
        query = select(func.count()).select_from(Brand).where(
            Brand.code == code
        )
        
        if exclude_id:
            query = query.where(Brand.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0
    
    async def search(
        self,
        search_term: str,
        limit: int = 10,
        include_inactive: bool = False
    ) -> List[Brand]:
        """Search brands by name, code, or description."""
        search_pattern = f"%{search_term}%"
        
        query = select(Brand).where(
            or_(
                Brand.name.ilike(search_pattern),
                Brand.code.ilike(search_pattern),
                Brand.description.ilike(search_pattern)
            )
        )
        
        if not include_inactive:
            query = query.where(Brand.is_active == True)
        
        query = query.order_by(Brand.name).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_active_brands(self) -> List[Brand]:
        """Get all active brands."""
        query = select(Brand).where(Brand.is_active == True).order_by(Brand.name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_inactive_brands(self) -> List[Brand]:
        """Get all inactive brands."""
        query = select(Brand).where(Brand.is_active == False).order_by(Brand.name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_brands_with_items(self) -> List[Brand]:
        """Get brands that have associated items."""
        query = select(Brand).options(selectinload(Brand.items)).where(
            Brand.items.any()
        ).order_by(Brand.name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_brands_without_items(self) -> List[Brand]:
        """Get brands that have no associated items."""
        query = select(Brand).where(
            ~Brand.items.any()
        ).order_by(Brand.name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def bulk_activate(self, brand_ids: List[UUID]) -> int:
        """Activate multiple brands."""
        query = select(Brand).where(Brand.id.in_(brand_ids))
        result = await self.session.execute(query)
        brands = result.scalars().all()
        
        count = 0
        for brand in brands:
            if not brand.is_active:
                brand.is_active = True
                count += 1
        
        await self.session.commit()
        return count
    
    async def bulk_deactivate(self, brand_ids: List[UUID]) -> int:
        """Deactivate multiple brands."""
        query = select(Brand).where(Brand.id.in_(brand_ids))
        result = await self.session.execute(query)
        brands = result.scalars().all()
        
        count = 0
        for brand in brands:
            if brand.is_active:
                brand.is_active = False
                count += 1
        
        await self.session.commit()
        return count
    
    async def get_statistics(self) -> Dict[str, Any]:
        """Get brand statistics."""
        # Count all brands
        total_query = select(func.count()).select_from(Brand)
        total_result = await self.session.execute(total_query)
        total_brands = total_result.scalar_one()
        
        # Count active brands
        active_query = select(func.count()).select_from(Brand).where(Brand.is_active == True)
        active_result = await self.session.execute(active_query)
        active_brands = active_result.scalar_one()
        
        # Count brands with items (when items relationship is available)
        with_items_query = select(func.count()).select_from(Brand).where(
            Brand.items.any()
        )
        try:
            with_items_result = await self.session.execute(with_items_query)
            brands_with_items = with_items_result.scalar_one()
        except:
            # If items relationship is not available yet, set to 0
            brands_with_items = 0
        
        return {
            "total_brands": total_brands,
            "active_brands": active_brands,
            "inactive_brands": total_brands - active_brands,
            "brands_with_items": brands_with_items,
            "brands_without_items": total_brands - brands_with_items
        }
    
    async def get_most_used_brands(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get brands with most items."""
        # This will be implemented when items relationship is fully available
        # For now, return empty list
        return []
    
    def _apply_filters(self, query, filters: Dict[str, Any]):
        """Apply filters to query."""
        for key, value in filters.items():
            if value is None:
                continue
            
            if key == "name":
                query = query.where(Brand.name.ilike(f"%{value}%"))
            elif key == "code":
                query = query.where(Brand.code.ilike(f"%{value}%"))
            elif key == "description":
                query = query.where(Brand.description.ilike(f"%{value}%"))
            elif key == "is_active":
                query = query.where(Brand.is_active == value)
            elif key == "search":
                search_pattern = f"%{value}%"
                query = query.where(
                    or_(
                        Brand.name.ilike(search_pattern),
                        Brand.code.ilike(search_pattern),
                        Brand.description.ilike(search_pattern)
                    )
                )
            elif key == "created_after":
                query = query.where(Brand.created_at >= value)
            elif key == "created_before":
                query = query.where(Brand.created_at <= value)
            elif key == "updated_after":
                query = query.where(Brand.updated_at >= value)
            elif key == "updated_before":
                query = query.where(Brand.updated_at <= value)
            elif key == "created_by":
                query = query.where(Brand.created_by == value)
            elif key == "updated_by":
                query = query.where(Brand.updated_by == value)
        
        return query

===== modules/master_data/brands/routes.py â€“ 2025-07-20 02:35:43 IST =====
from typing import Optional, List
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from fastapi.responses import JSONResponse

from .service import BrandService
from .schemas import (
    BrandCreate, BrandUpdate, BrandResponse, BrandSummary,
    BrandList, BrandFilter, BrandSort, BrandStats,
    BrandBulkOperation, BrandBulkResult, BrandExport,
    BrandImport, BrandImportResult
)
from app.shared.dependencies import get_brand_service
from app.core.errors import (
    NotFoundError, ConflictError, ValidationError,
    BusinessRuleError
)


router = APIRouter(tags=["brands"])


@router.post("/", response_model=BrandResponse, status_code=status.HTTP_201_CREATED)
async def create_brand(
    brand_data: BrandCreate,
    service: BrandService = Depends(get_brand_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Create a new brand."""
    try:
        return await service.create_brand(brand_data, created_by=current_user_id)
    except ConflictError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/{brand_id}", response_model=BrandResponse)
async def get_brand(
    brand_id: UUID,
    service: BrandService = Depends(get_brand_service)
):
    """Get a brand by ID."""
    try:
        return await service.get_brand(brand_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/by-name/{brand_name}", response_model=BrandResponse)
async def get_brand_by_name(
    brand_name: str,
    service: BrandService = Depends(get_brand_service)
):
    """Get a brand by name."""
    try:
        return await service.get_brand_by_name(brand_name)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/by-code/{brand_code}", response_model=BrandResponse)
async def get_brand_by_code(
    brand_code: str,
    service: BrandService = Depends(get_brand_service)
):
    """Get a brand by code."""
    try:
        return await service.get_brand_by_code(brand_code.upper())
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/", response_model=BrandList)
async def list_brands(
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    name: Optional[str] = Query(None, description="Filter by name (partial match)"),
    code: Optional[str] = Query(None, description="Filter by code (partial match)"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    search: Optional[str] = Query(None, description="Search in name and code"),
    sort_field: str = Query("name", description="Field to sort by"),
    sort_direction: str = Query("asc", description="Sort direction (asc/desc)"),
    include_inactive: bool = Query(False, description="Include inactive brands"),
    service: BrandService = Depends(get_brand_service)
):
    """List brands with pagination, filtering, and sorting."""
    # Create filter object
    filters = BrandFilter(
        name=name,
        code=code,
        is_active=is_active,
        search=search
    )
    
    # Create sort object
    sort_options = BrandSort(
        field=sort_field,
        direction=sort_direction
    )
    
    try:
        return await service.list_brands(
            page=page,
            page_size=page_size,
            filters=filters,
            sort=sort_options,
            include_inactive=include_inactive
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.put("/{brand_id}", response_model=BrandResponse)
async def update_brand(
    brand_id: UUID,
    brand_data: BrandUpdate,
    service: BrandService = Depends(get_brand_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Update an existing brand."""
    try:
        return await service.update_brand(
            brand_id=brand_id,
            brand_data=brand_data,
            updated_by=current_user_id
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ConflictError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.delete("/{brand_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_brand(
    brand_id: UUID,
    service: BrandService = Depends(get_brand_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Delete (deactivate) a brand."""
    try:
        success = await service.delete_brand(brand_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Brand with id {brand_id} not found"
            )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except BusinessRuleError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/search/", response_model=List[BrandSummary])
async def search_brands(
    q: str = Query(..., min_length=1, description="Search query"),
    limit: int = Query(10, ge=1, le=50, description="Maximum results"),
    include_inactive: bool = Query(False, description="Include inactive brands"),
    service: BrandService = Depends(get_brand_service)
):
    """Search brands by name, code, or description."""
    return await service.search_brands(
        search_term=q,
        limit=limit,
        include_inactive=include_inactive
    )


@router.get("/active/", response_model=List[BrandSummary])
async def get_active_brands(
    service: BrandService = Depends(get_brand_service)
):
    """Get all active brands."""
    return await service.get_active_brands()


@router.get("/stats/", response_model=BrandStats)
async def get_brand_statistics(
    service: BrandService = Depends(get_brand_service)
):
    """Get brand statistics."""
    return await service.get_brand_statistics()


@router.post("/{brand_id}/activate", response_model=BrandResponse)
async def activate_brand(
    brand_id: UUID,
    service: BrandService = Depends(get_brand_service)
):
    """Activate a brand."""
    try:
        return await service.activate_brand(brand_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.post("/{brand_id}/deactivate", response_model=BrandResponse)
async def deactivate_brand(
    brand_id: UUID,
    service: BrandService = Depends(get_brand_service)
):
    """Deactivate a brand."""
    try:
        return await service.deactivate_brand(brand_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.post("/bulk-operation", response_model=BrandBulkResult)
async def bulk_brand_operation(
    operation: BrandBulkOperation,
    service: BrandService = Depends(get_brand_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Perform bulk operations on brands."""
    try:
        return await service.bulk_operation(
            operation=operation,
            updated_by=current_user_id
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/export/", response_model=List[BrandExport])
async def export_brands(
    include_inactive: bool = Query(False, description="Include inactive brands"),
    service: BrandService = Depends(get_brand_service)
):
    """Export brands data."""
    return await service.export_brands(include_inactive=include_inactive)


@router.post("/import/", response_model=BrandImportResult)
async def import_brands(
    brands_data: List[BrandImport],
    service: BrandService = Depends(get_brand_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Import brands data."""
    try:
        return await service.import_brands(
            import_data=brands_data,
            created_by=current_user_id
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


===== modules/master_data/brands/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional
from pydantic import BaseModel, ConfigDict, Field, validator
from datetime import datetime
from uuid import UUID


class BrandBase(BaseModel):
    """Base brand schema with common fields."""
    
    name: str = Field(..., min_length=1, max_length=100, description="Brand name")
    code: Optional[str] = Field(None, min_length=1, max_length=20, description="Unique brand code")
    description: Optional[str] = Field(None, max_length=1000, description="Brand description")
    
    @validator('name')
    def validate_name(cls, v):
        if not v or not v.strip():
            raise ValueError('Brand name cannot be empty')
        return v.strip()
    
    @validator('code')
    def validate_code(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Brand code cannot be empty if provided')
            
            # Check for valid characters (letters, numbers, hyphens, underscores)
            if not v.replace('-', '').replace('_', '').isalnum():
                raise ValueError('Brand code must contain only letters, numbers, hyphens, and underscores')
            
            return v.upper().strip()
        return v
    
    @validator('description')
    def validate_description(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class BrandCreate(BrandBase):
    """Schema for creating a new brand."""
    pass


class BrandUpdate(BaseModel):
    """Schema for updating an existing brand."""
    
    name: Optional[str] = Field(None, min_length=1, max_length=100, description="Brand name")
    code: Optional[str] = Field(None, min_length=1, max_length=20, description="Unique brand code")
    description: Optional[str] = Field(None, max_length=1000, description="Brand description")
    is_active: Optional[bool] = Field(None, description="Brand active status")
    
    @validator('name')
    def validate_name(cls, v):
        if v is not None:
            if not v or not v.strip():
                raise ValueError('Brand name cannot be empty')
            return v.strip()
        return v
    
    @validator('code')
    def validate_code(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Brand code cannot be empty if provided')
            
            # Check for valid characters (letters, numbers, hyphens, underscores)
            if not v.replace('-', '').replace('_', '').isalnum():
                raise ValueError('Brand code must contain only letters, numbers, hyphens, and underscores')
            
            return v.upper().strip()
        return v
    
    @validator('description')
    def validate_description(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class BrandResponse(BrandBase):
    """Schema for brand response with all fields."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Brand unique identifier")
    is_active: bool = Field(True, description="Brand active status")
    created_at: datetime = Field(..., description="Brand creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Brand last update timestamp")
    created_by: Optional[str] = Field(None, description="User who created the brand")
    updated_by: Optional[str] = Field(None, description="User who last updated the brand")
    display_name: str = Field(..., description="Brand display name (computed)")
    has_items: bool = Field(False, description="Whether brand has associated items")
    
    @validator('display_name', pre=True, always=True)
    def compute_display_name(cls, v, values):
        """Compute display name from name and code."""
        name = values.get('name', '')
        code = values.get('code')
        if code:
            return f"{name} ({code})"
        return name


class BrandSummary(BaseModel):
    """Schema for brand summary with minimal fields."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Brand unique identifier")
    name: str = Field(..., description="Brand name")
    code: Optional[str] = Field(None, description="Brand code")
    is_active: bool = Field(True, description="Brand active status")
    display_name: str = Field(..., description="Brand display name")
    
    @validator('display_name', pre=True, always=True)
    def compute_display_name(cls, v, values):
        """Compute display name from name and code."""
        name = values.get('name', '')
        code = values.get('code')
        if code:
            return f"{name} ({code})"
        return name


class BrandList(BaseModel):
    """Schema for paginated brand list response."""
    
    items: list[BrandSummary] = Field(..., description="List of brand summaries")
    total: int = Field(..., description="Total number of brands")
    page: int = Field(..., description="Current page number")
    page_size: int = Field(..., description="Number of items per page")
    total_pages: int = Field(..., description="Total number of pages")
    has_next: bool = Field(..., description="Whether there are more pages")
    has_previous: bool = Field(..., description="Whether there are previous pages")


class BrandFilter(BaseModel):
    """Schema for brand filtering and search."""
    
    name: Optional[str] = Field(None, description="Filter by brand name (partial match)")
    code: Optional[str] = Field(None, description="Filter by brand code (partial match)")
    is_active: Optional[bool] = Field(None, description="Filter by active status")
    search: Optional[str] = Field(None, description="Search in name and code")
    
    @validator('name', 'code', 'search')
    def validate_string_filters(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class BrandSort(BaseModel):
    """Schema for brand sorting options."""
    
    field: str = Field('name', description="Field to sort by")
    direction: str = Field('asc', description="Sort direction (asc/desc)")
    
    @validator('field')
    def validate_field(cls, v):
        allowed_fields = ['name', 'code', 'created_at', 'updated_at', 'is_active']
        if v not in allowed_fields:
            raise ValueError(f'Sort field must be one of: {", ".join(allowed_fields)}')
        return v
    
    @validator('direction')
    def validate_direction(cls, v):
        if v.lower() not in ['asc', 'desc']:
            raise ValueError('Sort direction must be "asc" or "desc"')
        return v.lower()


class BrandStats(BaseModel):
    """Schema for brand statistics."""
    
    total_brands: int = Field(..., description="Total number of brands")
    active_brands: int = Field(..., description="Number of active brands")
    inactive_brands: int = Field(..., description="Number of inactive brands")
    brands_with_items: int = Field(..., description="Number of brands with associated items")
    brands_without_items: int = Field(..., description="Number of brands without items")
    most_used_brands: list[dict] = Field(..., description="Top brands by item count")
    
    @validator('most_used_brands')
    def validate_most_used_brands(cls, v):
        """Validate the structure of most_used_brands."""
        for brand in v:
            if not isinstance(brand, dict) or 'name' not in brand or 'item_count' not in brand:
                raise ValueError('Each brand in most_used_brands must have name and item_count')
        return v


class BrandBulkOperation(BaseModel):
    """Schema for bulk brand operations."""
    
    brand_ids: list[UUID] = Field(..., min_items=1, description="List of brand IDs")
    operation: str = Field(..., description="Operation to perform (activate/deactivate)")
    
    @validator('operation')
    def validate_operation(cls, v):
        if v not in ['activate', 'deactivate']:
            raise ValueError('Operation must be "activate" or "deactivate"')
        return v


class BrandBulkResult(BaseModel):
    """Schema for bulk operation results."""
    
    success_count: int = Field(..., description="Number of successful operations")
    failure_count: int = Field(..., description="Number of failed operations")
    errors: list[dict] = Field(..., description="List of errors for failed operations")
    
    @validator('errors')
    def validate_errors(cls, v):
        """Validate the structure of errors."""
        for error in v:
            if not isinstance(error, dict) or 'brand_id' not in error or 'error' not in error:
                raise ValueError('Each error must have brand_id and error fields')
        return v


class BrandExport(BaseModel):
    """Schema for brand export data."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str
    code: Optional[str]
    description: Optional[str]
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime]
    created_by: Optional[str]
    updated_by: Optional[str]
    item_count: int = Field(0, description="Number of items under this brand")


class BrandImport(BaseModel):
    """Schema for brand import data."""
    
    name: str = Field(..., min_length=1, max_length=100)
    code: Optional[str] = Field(None, min_length=1, max_length=20)
    description: Optional[str] = Field(None, max_length=1000)
    is_active: bool = Field(True)
    
    @validator('name')
    def validate_name(cls, v):
        if not v or not v.strip():
            raise ValueError('Brand name cannot be empty')
        return v.strip()
    
    @validator('code')
    def validate_code(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Brand code cannot be empty if provided')
            
            # Check for valid characters (letters, numbers, hyphens, underscores)
            if not v.replace('-', '').replace('_', '').isalnum():
                raise ValueError('Brand code must contain only letters, numbers, hyphens, and underscores')
            
            return v.upper().strip()
        return v
    
    @validator('description')
    def validate_description(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class BrandImportResult(BaseModel):
    """Schema for brand import results."""
    
    total_processed: int = Field(..., description="Total number of brands processed")
    successful_imports: int = Field(..., description="Number of successful imports")
    failed_imports: int = Field(..., description="Number of failed imports")
    skipped_imports: int = Field(..., description="Number of skipped imports (duplicates)")
    errors: list[dict] = Field(..., description="List of import errors")
    
    @validator('errors')
    def validate_errors(cls, v):
        """Validate the structure of errors."""
        for error in v:
            if not isinstance(error, dict) or 'row' not in error or 'error' not in error:
                raise ValueError('Each error must have row and error fields')
        return v

===== modules/master_data/brands/service.py â€“ 2025-07-19 12:13:41 IST =====
from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime

from .repository import BrandRepository
from .models import Brand
from .schemas import (
    BrandCreate, BrandUpdate, BrandResponse, BrandSummary, 
    BrandList, BrandFilter, BrandSort, BrandStats,
    BrandBulkOperation, BrandBulkResult, BrandExport,
    BrandImport, BrandImportResult
)
from app.shared.pagination import Page
from app.core.errors import (
    NotFoundError, ConflictError, ValidationError, 
    BusinessRuleError
)


class BrandService:
    """Service layer for brand business logic."""
    
    def __init__(self, repository: BrandRepository):
        """Initialize service with repository."""
        self.repository = repository
    
    async def create_brand(
        self,
        brand_data: BrandCreate,
        created_by: Optional[str] = None
    ) -> BrandResponse:
        """Create a new brand.
        
        Args:
            brand_data: Brand creation data
            created_by: User creating the brand
            
        Returns:
            Created brand response
            
        Raises:
            ConflictError: If brand name or code already exists
            ValidationError: If brand data is invalid
        """
        # Check if brand name already exists
        if await self.repository.exists_by_name(brand_data.name):
            raise ConflictError(f"Brand with name '{brand_data.name}' already exists")
        
        # Check if brand code already exists
        if brand_data.code and await self.repository.exists_by_code(brand_data.code):
            raise ConflictError(f"Brand with code '{brand_data.code}' already exists")
        
        # Prepare brand data
        create_data = brand_data.model_dump()
        create_data.update({
            "created_by": created_by,
            "updated_by": created_by
        })
        
        # Create brand
        brand = await self.repository.create(create_data)
        
        # Convert to response
        return await self._to_response(brand)
    
    async def get_brand(self, brand_id: UUID) -> BrandResponse:
        """Get brand by ID.
        
        Args:
            brand_id: Brand UUID
            
        Returns:
            Brand response
            
        Raises:
            NotFoundError: If brand not found
        """
        brand = await self.repository.get_by_id(brand_id)
        if not brand:
            raise NotFoundError(f"Brand with id {brand_id} not found")
        
        return await self._to_response(brand)
    
    async def get_brand_by_name(self, name: str) -> BrandResponse:
        """Get brand by name.
        
        Args:
            name: Brand name
            
        Returns:
            Brand response
            
        Raises:
            NotFoundError: If brand not found
        """
        brand = await self.repository.get_by_name(name)
        if not brand:
            raise NotFoundError(f"Brand with name '{name}' not found")
        
        return await self._to_response(brand)
    
    async def get_brand_by_code(self, code: str) -> BrandResponse:
        """Get brand by code.
        
        Args:
            code: Brand code
            
        Returns:
            Brand response
            
        Raises:
            NotFoundError: If brand not found
        """
        brand = await self.repository.get_by_code(code)
        if not brand:
            raise NotFoundError(f"Brand with code '{code}' not found")
        
        return await self._to_response(brand)
    
    async def update_brand(
        self,
        brand_id: UUID,
        brand_data: BrandUpdate,
        updated_by: Optional[str] = None
    ) -> BrandResponse:
        """Update an existing brand.
        
        Args:
            brand_id: Brand UUID
            brand_data: Brand update data
            updated_by: User updating the brand
            
        Returns:
            Updated brand response
            
        Raises:
            NotFoundError: If brand not found
            ConflictError: If name or code already exists
            ValidationError: If update data is invalid
        """
        # Get existing brand
        existing_brand = await self.repository.get_by_id(brand_id)
        if not existing_brand:
            raise NotFoundError(f"Brand with id {brand_id} not found")
        
        # Prepare update data
        update_data = {}
        
        # Check name uniqueness if provided
        if brand_data.name is not None and brand_data.name != existing_brand.name:
            if await self.repository.exists_by_name(brand_data.name, exclude_id=brand_id):
                raise ConflictError(f"Brand with name '{brand_data.name}' already exists")
            update_data["name"] = brand_data.name
        
        # Check code uniqueness if provided
        if brand_data.code is not None and brand_data.code != existing_brand.code:
            if brand_data.code and await self.repository.exists_by_code(brand_data.code, exclude_id=brand_id):
                raise ConflictError(f"Brand with code '{brand_data.code}' already exists")
            update_data["code"] = brand_data.code
        
        # Update other fields
        if brand_data.description is not None:
            update_data["description"] = brand_data.description
        
        if brand_data.is_active is not None:
            update_data["is_active"] = brand_data.is_active
        
        # Add updated_by
        update_data["updated_by"] = updated_by
        
        # Update brand
        updated_brand = await self.repository.update(brand_id, update_data)
        if not updated_brand:
            raise NotFoundError(f"Brand with id {brand_id} not found")
        
        return await self._to_response(updated_brand)
    
    async def delete_brand(self, brand_id: UUID) -> bool:
        """Soft delete a brand.
        
        Args:
            brand_id: Brand UUID
            
        Returns:
            True if deleted successfully
            
        Raises:
            NotFoundError: If brand not found
            BusinessRuleError: If brand has associated items
        """
        brand = await self.repository.get_by_id(brand_id)
        if not brand:
            raise NotFoundError(f"Brand with id {brand_id} not found")
        
        # Check if brand can be deleted
        if not brand.can_delete():
            raise BusinessRuleError("Cannot delete brand with associated items")
        
        return await self.repository.delete(brand_id)
    
    async def list_brands(
        self,
        page: int = 1,
        page_size: int = 20,
        filters: Optional[BrandFilter] = None,
        sort: Optional[BrandSort] = None,
        include_inactive: bool = False
    ) -> BrandList:
        """List brands with pagination and filtering.
        
        Args:
            page: Page number (1-based)
            page_size: Items per page
            filters: Filter criteria
            sort: Sort options
            include_inactive: Include inactive brands
            
        Returns:
            Paginated brand list
        """
        # Convert filters to dict
        filter_dict = {}
        if filters:
            filter_data = filters.model_dump(exclude_none=True)
            for key, value in filter_data.items():
                if value is not None:
                    filter_dict[key] = value
        
        # Set sort options
        sort_by = sort.field if sort and sort.field else "name"
        sort_order = sort.direction if sort and sort.direction else "asc"
        
        # Get paginated brands
        brands_list = await self.repository.get_paginated(
            page=page,
            page_size=page_size,
            filters=filter_dict,
            sort_by=sort_by,
            sort_order=sort_order,
            include_inactive=include_inactive
        )
        
        # Convert to summaries
        brand_summaries = []
        for brand in brands_list:
            summary = BrandSummary.model_validate(brand)
            brand_summaries.append(summary)
        
        # Return list response (simplified pagination for now)
        total_items = len(brand_summaries)
        total_pages = (total_items + page_size - 1) // page_size
        
        return BrandList(
            items=brand_summaries,
            total=total_items,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
            has_next=page < total_pages,
            has_previous=page > 1
        )
    
    async def search_brands(
        self,
        search_term: str,
        limit: int = 10,
        include_inactive: bool = False
    ) -> List[BrandSummary]:
        """Search brands by name, code, or description.
        
        Args:
            search_term: Search term
            limit: Maximum results
            include_inactive: Include inactive brands
            
        Returns:
            List of brand summaries
        """
        brands = await self.repository.search(
            search_term=search_term,
            limit=limit,
            include_inactive=include_inactive
        )
        
        return [BrandSummary.model_validate(brand) for brand in brands]
    
    async def get_active_brands(self) -> List[BrandSummary]:
        """Get all active brands.
        
        Returns:
            List of active brand summaries
        """
        brands = await self.repository.get_active_brands()
        return [BrandSummary.model_validate(brand) for brand in brands]
    
    async def get_brand_statistics(self) -> BrandStats:
        """Get brand statistics.
        
        Returns:
            Brand statistics
        """
        stats = await self.repository.get_statistics()
        most_used = await self.repository.get_most_used_brands()
        
        return BrandStats(
            total_brands=stats["total_brands"],
            active_brands=stats["active_brands"],
            inactive_brands=stats["inactive_brands"],
            brands_with_items=stats["brands_with_items"],
            brands_without_items=stats["brands_without_items"],
            most_used_brands=most_used
        )
    
    async def bulk_operation(
        self,
        operation: BrandBulkOperation,
        updated_by: Optional[str] = None
    ) -> BrandBulkResult:
        """Perform bulk operations on brands.
        
        Args:
            operation: Bulk operation data
            updated_by: User performing the operation
            
        Returns:
            Bulk operation result
        """
        success_count = 0
        errors = []
        
        for brand_id in operation.brand_ids:
            try:
                if operation.operation == "activate":
                    count = await self.repository.bulk_activate([brand_id])
                    success_count += count
                elif operation.operation == "deactivate":
                    count = await self.repository.bulk_deactivate([brand_id])
                    success_count += count
            except Exception as e:
                errors.append({
                    "brand_id": str(brand_id),
                    "error": str(e)
                })
        
        return BrandBulkResult(
            success_count=success_count,
            failure_count=len(errors),
            errors=errors
        )
    
    async def export_brands(
        self,
        include_inactive: bool = False
    ) -> List[BrandExport]:
        """Export brands data.
        
        Args:
            include_inactive: Include inactive brands
            
        Returns:
            List of brand export data
        """
        brands = await self.repository.list(
            skip=0,
            limit=10000,  # Large limit for export
            include_inactive=include_inactive
        )
        
        export_data = []
        for brand in brands:
            export_item = BrandExport.model_validate(brand)
            # Add item count (when available)
            export_item.item_count = len(brand.items) if brand.items else 0
            export_data.append(export_item)
        
        return export_data
    
    async def import_brands(
        self,
        import_data: List[BrandImport],
        created_by: Optional[str] = None
    ) -> BrandImportResult:
        """Import brands data.
        
        Args:
            import_data: List of brand import data
            created_by: User importing the data
            
        Returns:
            Import operation result
        """
        total_processed = len(import_data)
        successful_imports = 0
        failed_imports = 0
        skipped_imports = 0
        errors = []
        
        for row, brand_data in enumerate(import_data, 1):
            try:
                # Check if brand already exists
                if await self.repository.exists_by_name(brand_data.name):
                    skipped_imports += 1
                    continue
                
                if brand_data.code and await self.repository.exists_by_code(brand_data.code):
                    skipped_imports += 1
                    continue
                
                # Create brand
                create_data = brand_data.model_dump()
                create_data.update({
                    "created_by": created_by,
                    "updated_by": created_by
                })
                
                await self.repository.create(create_data)
                successful_imports += 1
                
            except Exception as e:
                failed_imports += 1
                errors.append({
                    "row": row,
                    "error": str(e)
                })
        
        return BrandImportResult(
            total_processed=total_processed,
            successful_imports=successful_imports,
            failed_imports=failed_imports,
            skipped_imports=skipped_imports,
            errors=errors
        )
    
    async def activate_brand(self, brand_id: UUID) -> BrandResponse:
        """Activate a brand.
        
        Args:
            brand_id: Brand UUID
            
        Returns:
            Updated brand response
        """
        brand = await self.repository.get_by_id(brand_id)
        if not brand:
            raise NotFoundError(f"Brand with id {brand_id} not found")
        
        if brand.is_active:
            return await self._to_response(brand)
        
        updated_brand = await self.repository.update(brand_id, {"is_active": True})
        return await self._to_response(updated_brand)
    
    async def deactivate_brand(self, brand_id: UUID) -> BrandResponse:
        """Deactivate a brand.
        
        Args:
            brand_id: Brand UUID
            
        Returns:
            Updated brand response
        """
        brand = await self.repository.get_by_id(brand_id)
        if not brand:
            raise NotFoundError(f"Brand with id {brand_id} not found")
        
        if not brand.is_active:
            return await self._to_response(brand)
        
        updated_brand = await self.repository.update(brand_id, {"is_active": False})
        return await self._to_response(updated_brand)
    
    async def _to_response(self, brand: Brand) -> BrandResponse:
        """Convert brand model to response schema.
        
        Args:
            brand: Brand model
            
        Returns:
            Brand response schema
        """
        # Convert to dict and add computed fields
        brand_dict = {
            "id": brand.id,
            "name": brand.name,
            "code": brand.code,
            "description": brand.description,
            "is_active": brand.is_active,
            "created_at": brand.created_at,
            "updated_at": brand.updated_at,
            "created_by": brand.created_by,
            "updated_by": brand.updated_by,
            "display_name": brand.display_name,
            "has_items": brand.has_items
        }
        
        return BrandResponse(**brand_dict)

===== modules/master_data/units/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""
Unit of measurement module for master data.

This module provides functionality for managing units of measurement
used throughout the rental management system.
"""

from .models import UnitOfMeasurement
from .repository import UnitOfMeasurementRepository
from .service import UnitOfMeasurementService
from .schemas import (
    UnitOfMeasurementCreate,
    UnitOfMeasurementUpdate,
    UnitOfMeasurementResponse,
    UnitOfMeasurementSummary,
    UnitOfMeasurementList,
    UnitOfMeasurementFilter,
    UnitOfMeasurementSort,
    UnitOfMeasurementStats,
    UnitOfMeasurementBulkOperation,
    UnitOfMeasurementBulkResult,
    UnitOfMeasurementExport,
    UnitOfMeasurementImport,
    UnitOfMeasurementImportResult,
)

__all__ = [
    "UnitOfMeasurement",
    "UnitOfMeasurementRepository",
    "UnitOfMeasurementService",
    "UnitOfMeasurementCreate",
    "UnitOfMeasurementUpdate",
    "UnitOfMeasurementResponse",
    "UnitOfMeasurementSummary",
    "UnitOfMeasurementList",
    "UnitOfMeasurementFilter",
    "UnitOfMeasurementSort",
    "UnitOfMeasurementStats",
    "UnitOfMeasurementBulkOperation",
    "UnitOfMeasurementBulkResult",
    "UnitOfMeasurementExport",
    "UnitOfMeasurementImport",
    "UnitOfMeasurementImportResult",
]

===== modules/master_data/units/models.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, TYPE_CHECKING
from sqlalchemy import Column, String, Text, Index
from sqlalchemy.orm import relationship, validates

from app.db.base import BaseModel, NamedModelMixin

if TYPE_CHECKING:
    from app.modules.master_data.item_master.models import Item


class UnitOfMeasurement(BaseModel, NamedModelMixin):
    """
    Unit of measurement model for items in the inventory.
    
    Attributes:
        name: Unit name (from NamedModelMixin)
        abbreviation: Unit abbreviation (e.g., "kg", "pcs", "m")
        description: Unit description (from NamedModelMixin)
        items: Items using this unit
    """
    
    __tablename__ = "units_of_measurement"
    
    # Override name column with specific constraints
    name = Column(String(50), nullable=False, unique=True, index=True, comment="Unit name")
    abbreviation = Column(String(10), nullable=True, unique=True, index=True, comment="Unit abbreviation")
    
    # Relationships
    items = relationship("Item", back_populates="unit_of_measurement", lazy="select")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_unit_name_active', 'name', 'is_active'),
        Index('idx_unit_abbreviation_active', 'abbreviation', 'is_active'),
    )
    
    def __init__(
        self,
        name: str,
        abbreviation: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a Unit of Measurement.
        
        Args:
            name: Unit name
            abbreviation: Unit abbreviation
            description: Unit description
            **kwargs: Additional BaseModel fields
        """
        super().__init__(name=name, description=description, **kwargs)
        self.abbreviation = abbreviation
        self._validate()
    
    def _validate(self):
        """Validate unit business rules."""
        # Name validation
        if not self.name or not self.name.strip():
            raise ValueError("Unit name cannot be empty")
        
        if len(self.name) > 50:
            raise ValueError("Unit name cannot exceed 50 characters")
        
        # Abbreviation validation
        if self.abbreviation:
            if not self.abbreviation.strip():
                raise ValueError("Unit abbreviation cannot be empty if provided")
            
            if len(self.abbreviation) > 10:
                raise ValueError("Unit abbreviation cannot exceed 10 characters")
        
        # Description validation
        if self.description and len(self.description) > 500:
            raise ValueError("Unit description cannot exceed 500 characters")
    
    @validates('name')
    def validate_name(self, key, value):
        """Validate unit name."""
        if not value or not value.strip():
            raise ValueError("Unit name cannot be empty")
        if len(value) > 50:
            raise ValueError("Unit name cannot exceed 50 characters")
        return value.strip()
    
    @validates('abbreviation')
    def validate_abbreviation(self, key, value):
        """Validate unit abbreviation."""
        if value is not None:
            if not value.strip():
                raise ValueError("Unit abbreviation cannot be empty if provided")
            if len(value) > 10:
                raise ValueError("Unit abbreviation cannot exceed 10 characters")
            return value.strip()
        return value
    
    @validates('description')
    def validate_description(self, key, value):
        """Validate unit description."""
        if value is not None:
            if len(value) > 500:
                raise ValueError("Unit description cannot exceed 500 characters")
            return value.strip() if value.strip() else None
        return value
    
    def update_details(
        self,
        name: Optional[str] = None,
        abbreviation: Optional[str] = None,
        description: Optional[str] = None,
        updated_by: Optional[str] = None
    ):
        """
        Update unit details.
        
        Args:
            name: New unit name
            abbreviation: New unit abbreviation
            description: New unit description
            updated_by: User making the update
        """
        if name is not None:
            if not name or not name.strip():
                raise ValueError("Unit name cannot be empty")
            if len(name) > 50:
                raise ValueError("Unit name cannot exceed 50 characters")
            self.name = name.strip()
        
        if abbreviation is not None:
            if abbreviation and not abbreviation.strip():
                raise ValueError("Unit abbreviation cannot be empty if provided")
            if abbreviation and len(abbreviation) > 10:
                raise ValueError("Unit abbreviation cannot exceed 10 characters")
            self.abbreviation = abbreviation.strip() if abbreviation else None
        
        if description is not None:
            if description and len(description) > 500:
                raise ValueError("Unit description cannot exceed 500 characters")
            self.description = description.strip() if description else None
        
        self.updated_by = updated_by
    
    def has_items(self) -> bool:
        """Check if unit has associated items."""
        # return bool(self.items)  # Temporarily disabled - relationship not active
        return False
    
    def can_delete(self) -> bool:
        """Check if unit can be deleted."""
        # Can only delete if no items are associated
        return not self.has_items() and self.is_active
    
    @property
    def display_name(self) -> str:
        """Get display name for the unit."""
        if self.abbreviation:
            return f"{self.name} ({self.abbreviation})"
        return self.name
    
    @property
    def item_count(self) -> int:
        """Get number of items using this unit."""
        # return len(self.items) if self.items else 0  # Temporarily disabled - relationship not active
        return 0
    
    def __str__(self) -> str:
        """String representation of unit."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of unit."""
        return (
            f"UnitOfMeasurement(id={self.id}, name='{self.name}', "
            f"abbreviation='{self.abbreviation}', active={self.is_active})"
        )

===== modules/master_data/units/repository.py â€“ 2025-07-19 12:13:41 IST =====
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import select, func, or_, and_, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from .models import UnitOfMeasurement


class UnitOfMeasurementRepository:
    """Repository for unit of measurement data access operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with database session."""
        self.session = session
    
    async def create(self, unit_data: dict) -> UnitOfMeasurement:
        """Create a new unit of measurement."""
        unit = UnitOfMeasurement(**unit_data)
        self.session.add(unit)
        await self.session.commit()
        await self.session.refresh(unit)
        return unit
    
    async def get_by_id(self, unit_id: UUID) -> Optional[UnitOfMeasurement]:
        """Get unit of measurement by ID."""
        query = select(UnitOfMeasurement).where(UnitOfMeasurement.id == unit_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_name(self, name: str) -> Optional[UnitOfMeasurement]:
        """Get unit of measurement by name."""
        query = select(UnitOfMeasurement).where(UnitOfMeasurement.name == name)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_abbreviation(self, abbreviation: str) -> Optional[UnitOfMeasurement]:
        """Get unit of measurement by abbreviation."""
        query = select(UnitOfMeasurement).where(UnitOfMeasurement.abbreviation == abbreviation)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def list(
        self,
        skip: int = 0,
        limit: int = 100,
        filters: Optional[Dict[str, Any]] = None,
        sort_by: str = "name",
        sort_order: str = "asc",
        include_inactive: bool = False
    ) -> List[UnitOfMeasurement]:
        """List units of measurement with optional filters and sorting."""
        query = select(UnitOfMeasurement)
        
        # Apply base filters
        if not include_inactive:
            query = query.where(UnitOfMeasurement.is_active == True)
        
        # Apply additional filters
        if filters:
            query = self._apply_filters(query, filters)
        
        # Apply sorting
        if sort_order.lower() == "desc":
            query = query.order_by(desc(getattr(UnitOfMeasurement, sort_by)))
        else:
            query = query.order_by(asc(getattr(UnitOfMeasurement, sort_by)))
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_paginated(
        self,
        page: int = 1,
        page_size: int = 20,
        filters: Optional[Dict[str, Any]] = None,
        sort_by: str = "name",
        sort_order: str = "asc",
        include_inactive: bool = False
    ) -> List[UnitOfMeasurement]:
        """Get paginated units of measurement."""
        query = select(UnitOfMeasurement)
        
        # Apply base filters
        if not include_inactive:
            query = query.where(UnitOfMeasurement.is_active == True)
        
        # Apply additional filters
        if filters:
            query = self._apply_filters(query, filters)
        
        # Apply sorting
        if sort_order.lower() == "desc":
            query = query.order_by(desc(getattr(UnitOfMeasurement, sort_by)))
        else:
            query = query.order_by(asc(getattr(UnitOfMeasurement, sort_by)))
        
        # Calculate pagination
        skip = (page - 1) * page_size
        limit = page_size
        
        result = await self.session.execute(query.offset(skip).limit(limit))
        return result.scalars().all()
    
    async def update(self, unit_id: UUID, update_data: dict) -> Optional[UnitOfMeasurement]:
        """Update existing unit of measurement."""
        unit = await self.get_by_id(unit_id)
        if not unit:
            return None
        
        # Update fields using the model's update method
        unit.update_details(**update_data)
        
        await self.session.commit()
        await self.session.refresh(unit)
        
        return unit
    
    async def delete(self, unit_id: UUID) -> bool:
        """Soft delete unit of measurement by setting is_active to False."""
        unit = await self.get_by_id(unit_id)
        if not unit:
            return False
        
        unit.is_active = False
        await self.session.commit()
        
        return True
    
    async def hard_delete(self, unit_id: UUID) -> bool:
        """Hard delete unit of measurement from database."""
        unit = await self.get_by_id(unit_id)
        if not unit:
            return False
        
        # Check if unit can be deleted
        if not unit.can_delete():
            return False
        
        await self.session.delete(unit)
        await self.session.commit()
        
        return True
    
    async def count(
        self,
        filters: Optional[Dict[str, Any]] = None,
        include_inactive: bool = False
    ) -> int:
        """Count units of measurement matching filters."""
        query = select(func.count()).select_from(UnitOfMeasurement)
        
        # Apply base filters
        if not include_inactive:
            query = query.where(UnitOfMeasurement.is_active == True)
        
        # Apply additional filters
        if filters:
            query = self._apply_filters(query, filters)
        
        result = await self.session.execute(query)
        return result.scalar_one()
    
    async def exists_by_name(self, name: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a unit of measurement with the given name exists."""
        query = select(func.count()).select_from(UnitOfMeasurement).where(
            UnitOfMeasurement.name == name
        )
        
        if exclude_id:
            query = query.where(UnitOfMeasurement.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0
    
    async def exists_by_abbreviation(self, abbreviation: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a unit of measurement with the given abbreviation exists."""
        query = select(func.count()).select_from(UnitOfMeasurement).where(
            UnitOfMeasurement.abbreviation == abbreviation
        )
        
        if exclude_id:
            query = query.where(UnitOfMeasurement.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0
    
    async def search(
        self,
        search_term: str,
        limit: int = 10,
        include_inactive: bool = False
    ) -> List[UnitOfMeasurement]:
        """Search units of measurement by name, abbreviation, or description."""
        search_pattern = f"%{search_term}%"
        
        query = select(UnitOfMeasurement).where(
            or_(
                UnitOfMeasurement.name.ilike(search_pattern),
                UnitOfMeasurement.abbreviation.ilike(search_pattern),
                UnitOfMeasurement.description.ilike(search_pattern)
            )
        )
        
        if not include_inactive:
            query = query.where(UnitOfMeasurement.is_active == True)
        
        query = query.order_by(UnitOfMeasurement.name).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_active_units(self) -> List[UnitOfMeasurement]:
        """Get all active units of measurement."""
        query = select(UnitOfMeasurement).where(UnitOfMeasurement.is_active == True).order_by(UnitOfMeasurement.name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_inactive_units(self) -> List[UnitOfMeasurement]:
        """Get all inactive units of measurement."""
        query = select(UnitOfMeasurement).where(UnitOfMeasurement.is_active == False).order_by(UnitOfMeasurement.name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_units_with_items(self) -> List[UnitOfMeasurement]:
        """Get units of measurement that have associated items."""
        # This will be implemented when items relationship is fully available
        query = select(UnitOfMeasurement).where(
            UnitOfMeasurement.is_active == True
        ).order_by(UnitOfMeasurement.name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_units_without_items(self) -> List[UnitOfMeasurement]:
        """Get units of measurement that have no associated items."""
        # This will be implemented when items relationship is fully available
        query = select(UnitOfMeasurement).where(
            UnitOfMeasurement.is_active == True
        ).order_by(UnitOfMeasurement.name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def bulk_activate(self, unit_ids: List[UUID]) -> int:
        """Activate multiple units of measurement."""
        query = select(UnitOfMeasurement).where(UnitOfMeasurement.id.in_(unit_ids))
        result = await self.session.execute(query)
        units = result.scalars().all()
        
        count = 0
        for unit in units:
            if not unit.is_active:
                unit.is_active = True
                count += 1
        
        await self.session.commit()
        return count
    
    async def bulk_deactivate(self, unit_ids: List[UUID]) -> int:
        """Deactivate multiple units of measurement."""
        query = select(UnitOfMeasurement).where(UnitOfMeasurement.id.in_(unit_ids))
        result = await self.session.execute(query)
        units = result.scalars().all()
        
        count = 0
        for unit in units:
            if unit.is_active:
                unit.is_active = False
                count += 1
        
        await self.session.commit()
        return count
    
    async def get_statistics(self) -> Dict[str, Any]:
        """Get unit of measurement statistics."""
        # Count all units
        total_query = select(func.count()).select_from(UnitOfMeasurement)
        total_result = await self.session.execute(total_query)
        total_units = total_result.scalar_one()
        
        # Count active units
        active_query = select(func.count()).select_from(UnitOfMeasurement).where(UnitOfMeasurement.is_active == True)
        active_result = await self.session.execute(active_query)
        active_units = active_result.scalar_one()
        
        # Count units with items (when items relationship is available)
        units_with_items = 0  # Temporary until items relationship is available
        
        return {
            "total_units": total_units,
            "active_units": active_units,
            "inactive_units": total_units - active_units,
            "units_with_items": units_with_items,
            "units_without_items": total_units - units_with_items
        }
    
    async def get_most_used_units(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get units of measurement with most items."""
        # This will be implemented when items relationship is fully available
        # For now, return empty list
        return []
    
    def _apply_filters(self, query, filters: Dict[str, Any]):
        """Apply filters to query."""
        for key, value in filters.items():
            if value is None:
                continue
            
            if key == "name":
                query = query.where(UnitOfMeasurement.name.ilike(f"%{value}%"))
            elif key == "abbreviation":
                query = query.where(UnitOfMeasurement.abbreviation.ilike(f"%{value}%"))
            elif key == "description":
                query = query.where(UnitOfMeasurement.description.ilike(f"%{value}%"))
            elif key == "is_active":
                query = query.where(UnitOfMeasurement.is_active == value)
            elif key == "search":
                search_pattern = f"%{value}%"
                query = query.where(
                    or_(
                        UnitOfMeasurement.name.ilike(search_pattern),
                        UnitOfMeasurement.abbreviation.ilike(search_pattern),
                        UnitOfMeasurement.description.ilike(search_pattern)
                    )
                )
            elif key == "created_after":
                query = query.where(UnitOfMeasurement.created_at >= value)
            elif key == "created_before":
                query = query.where(UnitOfMeasurement.created_at <= value)
            elif key == "updated_after":
                query = query.where(UnitOfMeasurement.updated_at >= value)
            elif key == "updated_before":
                query = query.where(UnitOfMeasurement.updated_at <= value)
            elif key == "created_by":
                query = query.where(UnitOfMeasurement.created_by == value)
            elif key == "updated_by":
                query = query.where(UnitOfMeasurement.updated_by == value)
        
        return query

===== modules/master_data/units/routes.py â€“ 2025-07-20 02:35:37 IST =====
from typing import Optional, List
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from fastapi.responses import JSONResponse

from .service import UnitOfMeasurementService
from .schemas import (
    UnitOfMeasurementCreate, UnitOfMeasurementUpdate, UnitOfMeasurementResponse, 
    UnitOfMeasurementSummary, UnitOfMeasurementList, UnitOfMeasurementFilter, 
    UnitOfMeasurementSort, UnitOfMeasurementStats, UnitOfMeasurementBulkOperation, 
    UnitOfMeasurementBulkResult, UnitOfMeasurementExport, UnitOfMeasurementImport, 
    UnitOfMeasurementImportResult
)
from app.shared.dependencies import get_unit_of_measurement_service
from app.core.errors import (
    NotFoundError, ConflictError, ValidationError,
    BusinessRuleError
)


router = APIRouter(tags=["units-of-measurement"])


@router.post("/", response_model=UnitOfMeasurementResponse, status_code=status.HTTP_201_CREATED)
async def create_unit_of_measurement(
    unit_data: UnitOfMeasurementCreate,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Create a new unit of measurement."""
    try:
        return await service.create_unit(unit_data, created_by=current_user_id)
    except ConflictError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/{unit_id}", response_model=UnitOfMeasurementResponse)
async def get_unit_of_measurement(
    unit_id: UUID,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Get a unit of measurement by ID."""
    try:
        return await service.get_unit(unit_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/by-name/{unit_name}", response_model=UnitOfMeasurementResponse)
async def get_unit_of_measurement_by_name(
    unit_name: str,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Get a unit of measurement by name."""
    try:
        return await service.get_unit_by_name(unit_name)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/by-abbreviation/{unit_abbreviation}", response_model=UnitOfMeasurementResponse)
async def get_unit_of_measurement_by_abbreviation(
    unit_abbreviation: str,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Get a unit of measurement by abbreviation."""
    try:
        return await service.get_unit_by_abbreviation(unit_abbreviation)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/", response_model=UnitOfMeasurementList)
async def list_units_of_measurement(
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    name: Optional[str] = Query(None, description="Filter by name (partial match)"),
    abbreviation: Optional[str] = Query(None, description="Filter by abbreviation (partial match)"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    search: Optional[str] = Query(None, description="Search in name and abbreviation"),
    sort_field: str = Query("name", description="Field to sort by"),
    sort_direction: str = Query("asc", description="Sort direction (asc/desc)"),
    include_inactive: bool = Query(False, description="Include inactive units"),
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """List units of measurement with pagination, filtering, and sorting."""
    # Create filter object
    filters = UnitOfMeasurementFilter(
        name=name,
        abbreviation=abbreviation,
        is_active=is_active,
        search=search
    )
    
    # Create sort object
    sort_options = UnitOfMeasurementSort(
        field=sort_field,
        direction=sort_direction
    )
    
    try:
        return await service.list_units(
            page=page,
            page_size=page_size,
            filters=filters,
            sort=sort_options,
            include_inactive=include_inactive
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.put("/{unit_id}", response_model=UnitOfMeasurementResponse)
async def update_unit_of_measurement(
    unit_id: UUID,
    unit_data: UnitOfMeasurementUpdate,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Update an existing unit of measurement."""
    try:
        return await service.update_unit(
            unit_id=unit_id,
            unit_data=unit_data,
            updated_by=current_user_id
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ConflictError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.delete("/{unit_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_unit_of_measurement(
    unit_id: UUID,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Delete (deactivate) a unit of measurement."""
    try:
        success = await service.delete_unit(unit_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Unit with id {unit_id} not found"
            )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except BusinessRuleError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/search/", response_model=List[UnitOfMeasurementSummary])
async def search_units_of_measurement(
    q: str = Query(..., min_length=1, description="Search query"),
    limit: int = Query(10, ge=1, le=50, description="Maximum results"),
    include_inactive: bool = Query(False, description="Include inactive units"),
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Search units of measurement by name, abbreviation, or description."""
    return await service.search_units(
        search_term=q,
        limit=limit,
        include_inactive=include_inactive
    )


@router.get("/active/", response_model=List[UnitOfMeasurementSummary])
async def get_active_units_of_measurement(
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Get all active units of measurement."""
    return await service.get_active_units()


@router.get("/stats/", response_model=UnitOfMeasurementStats)
async def get_unit_of_measurement_statistics(
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Get unit of measurement statistics."""
    return await service.get_unit_statistics()


@router.post("/{unit_id}/activate", response_model=UnitOfMeasurementResponse)
async def activate_unit_of_measurement(
    unit_id: UUID,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Activate a unit of measurement."""
    try:
        return await service.activate_unit(unit_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.post("/{unit_id}/deactivate", response_model=UnitOfMeasurementResponse)
async def deactivate_unit_of_measurement(
    unit_id: UUID,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Deactivate a unit of measurement."""
    try:
        return await service.deactivate_unit(unit_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.post("/bulk-operation", response_model=UnitOfMeasurementBulkResult)
async def bulk_unit_of_measurement_operation(
    operation: UnitOfMeasurementBulkOperation,
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Perform bulk operations on units of measurement."""
    try:
        return await service.bulk_operation(
            operation=operation,
            updated_by=current_user_id
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/export/", response_model=List[UnitOfMeasurementExport])
async def export_units_of_measurement(
    include_inactive: bool = Query(False, description="Include inactive units"),
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service)
):
    """Export units of measurement data."""
    return await service.export_units(include_inactive=include_inactive)


@router.post("/import/", response_model=UnitOfMeasurementImportResult)
async def import_units_of_measurement(
    units_data: List[UnitOfMeasurementImport],
    service: UnitOfMeasurementService = Depends(get_unit_of_measurement_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Import units of measurement data."""
    try:
        return await service.import_units(
            import_data=units_data,
            created_by=current_user_id
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


===== modules/master_data/units/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional
from pydantic import BaseModel, ConfigDict, Field, validator
from datetime import datetime
from uuid import UUID


class UnitOfMeasurementBase(BaseModel):
    """Base unit of measurement schema with common fields."""
    
    name: str = Field(..., min_length=1, max_length=50, description="Unit name")
    abbreviation: Optional[str] = Field(None, min_length=1, max_length=10, description="Unit abbreviation")
    description: Optional[str] = Field(None, max_length=500, description="Unit description")
    
    @validator('name')
    def validate_name(cls, v):
        if not v or not v.strip():
            raise ValueError('Unit name cannot be empty')
        return v.strip()
    
    @validator('abbreviation')
    def validate_abbreviation(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Unit abbreviation cannot be empty if provided')
            return v.strip()
        return v
    
    @validator('description')
    def validate_description(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class UnitOfMeasurementCreate(UnitOfMeasurementBase):
    """Schema for creating a new unit of measurement."""
    pass


class UnitOfMeasurementUpdate(BaseModel):
    """Schema for updating an existing unit of measurement."""
    
    name: Optional[str] = Field(None, min_length=1, max_length=50, description="Unit name")
    abbreviation: Optional[str] = Field(None, min_length=1, max_length=10, description="Unit abbreviation")
    description: Optional[str] = Field(None, max_length=500, description="Unit description")
    is_active: Optional[bool] = Field(None, description="Unit active status")
    
    @validator('name')
    def validate_name(cls, v):
        if v is not None:
            if not v or not v.strip():
                raise ValueError('Unit name cannot be empty')
            return v.strip()
        return v
    
    @validator('abbreviation')
    def validate_abbreviation(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Unit abbreviation cannot be empty if provided')
            return v.strip()
        return v
    
    @validator('description')
    def validate_description(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class UnitOfMeasurementResponse(UnitOfMeasurementBase):
    """Schema for unit of measurement response with all fields."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Unit unique identifier")
    is_active: bool = Field(True, description="Unit active status")
    created_at: datetime = Field(..., description="Unit creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Unit last update timestamp")
    created_by: Optional[str] = Field(None, description="User who created the unit")
    updated_by: Optional[str] = Field(None, description="User who last updated the unit")
    display_name: str = Field(..., description="Unit display name (computed)")
    item_count: int = Field(0, description="Number of items using this unit")
    
    @validator('display_name', pre=True, always=True)
    def compute_display_name(cls, v, values):
        """Compute display name from name and abbreviation."""
        name = values.get('name', '')
        abbreviation = values.get('abbreviation')
        if abbreviation:
            return f"{name} ({abbreviation})"
        return name


class UnitOfMeasurementSummary(BaseModel):
    """Schema for unit of measurement summary with minimal fields."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Unit unique identifier")
    name: str = Field(..., description="Unit name")
    abbreviation: Optional[str] = Field(None, description="Unit abbreviation")
    is_active: bool = Field(True, description="Unit active status")
    display_name: str = Field(..., description="Unit display name")
    
    @validator('display_name', pre=True, always=True)
    def compute_display_name(cls, v, values):
        """Compute display name from name and abbreviation."""
        name = values.get('name', '')
        abbreviation = values.get('abbreviation')
        if abbreviation:
            return f"{name} ({abbreviation})"
        return name


class UnitOfMeasurementList(BaseModel):
    """Schema for paginated unit of measurement list response."""
    
    items: list[UnitOfMeasurementSummary] = Field(..., description="List of unit summaries")
    total: int = Field(..., description="Total number of units")
    page: int = Field(..., description="Current page number")
    page_size: int = Field(..., description="Number of items per page")
    total_pages: int = Field(..., description="Total number of pages")
    has_next: bool = Field(..., description="Whether there are more pages")
    has_previous: bool = Field(..., description="Whether there are previous pages")


class UnitOfMeasurementFilter(BaseModel):
    """Schema for unit of measurement filtering and search."""
    
    name: Optional[str] = Field(None, description="Filter by unit name (partial match)")
    abbreviation: Optional[str] = Field(None, description="Filter by unit abbreviation (partial match)")
    is_active: Optional[bool] = Field(None, description="Filter by active status")
    search: Optional[str] = Field(None, description="Search in name and abbreviation")
    
    @validator('name', 'abbreviation', 'search')
    def validate_string_filters(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class UnitOfMeasurementSort(BaseModel):
    """Schema for unit of measurement sorting options."""
    
    field: str = Field('name', description="Field to sort by")
    direction: str = Field('asc', description="Sort direction (asc/desc)")
    
    @validator('field')
    def validate_field(cls, v):
        allowed_fields = ['name', 'abbreviation', 'created_at', 'updated_at', 'is_active']
        if v not in allowed_fields:
            raise ValueError(f'Sort field must be one of: {", ".join(allowed_fields)}')
        return v
    
    @validator('direction')
    def validate_direction(cls, v):
        if v.lower() not in ['asc', 'desc']:
            raise ValueError('Sort direction must be "asc" or "desc"')
        return v.lower()


class UnitOfMeasurementStats(BaseModel):
    """Schema for unit of measurement statistics."""
    
    total_units: int = Field(..., description="Total number of units")
    active_units: int = Field(..., description="Number of active units")
    inactive_units: int = Field(..., description="Number of inactive units")
    units_with_items: int = Field(..., description="Number of units with associated items")
    units_without_items: int = Field(..., description="Number of units without items")
    most_used_units: list[dict] = Field(..., description="Top units by item count")
    
    @validator('most_used_units')
    def validate_most_used_units(cls, v):
        """Validate the structure of most_used_units."""
        for unit in v:
            if not isinstance(unit, dict) or 'name' not in unit or 'item_count' not in unit:
                raise ValueError('Each unit in most_used_units must have name and item_count')
        return v


class UnitOfMeasurementBulkOperation(BaseModel):
    """Schema for bulk unit of measurement operations."""
    
    unit_ids: list[UUID] = Field(..., min_items=1, description="List of unit IDs")
    operation: str = Field(..., description="Operation to perform (activate/deactivate)")
    
    @validator('operation')
    def validate_operation(cls, v):
        if v not in ['activate', 'deactivate']:
            raise ValueError('Operation must be "activate" or "deactivate"')
        return v


class UnitOfMeasurementBulkResult(BaseModel):
    """Schema for bulk operation results."""
    
    success_count: int = Field(..., description="Number of successful operations")
    failure_count: int = Field(..., description="Number of failed operations")
    errors: list[dict] = Field(..., description="List of errors for failed operations")
    
    @validator('errors')
    def validate_errors(cls, v):
        """Validate the structure of errors."""
        for error in v:
            if not isinstance(error, dict) or 'unit_id' not in error or 'error' not in error:
                raise ValueError('Each error must have unit_id and error fields')
        return v


class UnitOfMeasurementExport(BaseModel):
    """Schema for unit of measurement export data."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str
    abbreviation: Optional[str]
    description: Optional[str]
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime]
    created_by: Optional[str]
    updated_by: Optional[str]
    item_count: int = Field(0, description="Number of items using this unit")


class UnitOfMeasurementImport(BaseModel):
    """Schema for unit of measurement import data."""
    
    name: str = Field(..., min_length=1, max_length=50)
    abbreviation: Optional[str] = Field(None, min_length=1, max_length=10)
    description: Optional[str] = Field(None, max_length=500)
    is_active: bool = Field(True)
    
    @validator('name')
    def validate_name(cls, v):
        if not v or not v.strip():
            raise ValueError('Unit name cannot be empty')
        return v.strip()
    
    @validator('abbreviation')
    def validate_abbreviation(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Unit abbreviation cannot be empty if provided')
            return v.strip()
        return v
    
    @validator('description')
    def validate_description(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class UnitOfMeasurementImportResult(BaseModel):
    """Schema for unit of measurement import results."""
    
    total_processed: int = Field(..., description="Total number of units processed")
    successful_imports: int = Field(..., description="Number of successful imports")
    failed_imports: int = Field(..., description="Number of failed imports")
    skipped_imports: int = Field(..., description="Number of skipped imports (duplicates)")
    errors: list[dict] = Field(..., description="List of import errors")
    
    @validator('errors')
    def validate_errors(cls, v):
        """Validate the structure of errors."""
        for error in v:
            if not isinstance(error, dict) or 'row' not in error or 'error' not in error:
                raise ValueError('Each error must have row and error fields')
        return v

===== modules/master_data/units/service.py â€“ 2025-07-19 12:13:41 IST =====
from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime

from .repository import UnitOfMeasurementRepository
from .models import UnitOfMeasurement
from .schemas import (
    UnitOfMeasurementCreate, UnitOfMeasurementUpdate, UnitOfMeasurementResponse, 
    UnitOfMeasurementSummary, UnitOfMeasurementList, UnitOfMeasurementFilter, 
    UnitOfMeasurementSort, UnitOfMeasurementStats, UnitOfMeasurementBulkOperation, 
    UnitOfMeasurementBulkResult, UnitOfMeasurementExport, UnitOfMeasurementImport, 
    UnitOfMeasurementImportResult
)
from app.core.errors import (
    NotFoundError, ConflictError, ValidationError, 
    BusinessRuleError
)


class UnitOfMeasurementService:
    """Service layer for unit of measurement business logic."""
    
    def __init__(self, repository: UnitOfMeasurementRepository):
        """Initialize service with repository."""
        self.repository = repository
    
    async def create_unit(
        self,
        unit_data: UnitOfMeasurementCreate,
        created_by: Optional[str] = None
    ) -> UnitOfMeasurementResponse:
        """Create a new unit of measurement.
        
        Args:
            unit_data: Unit creation data
            created_by: User creating the unit
            
        Returns:
            Created unit response
            
        Raises:
            ConflictError: If unit name or abbreviation already exists
            ValidationError: If unit data is invalid
        """
        # Check if unit name already exists
        if await self.repository.exists_by_name(unit_data.name):
            raise ConflictError(f"Unit with name '{unit_data.name}' already exists")
        
        # Check if unit abbreviation already exists
        if unit_data.abbreviation and await self.repository.exists_by_abbreviation(unit_data.abbreviation):
            raise ConflictError(f"Unit with abbreviation '{unit_data.abbreviation}' already exists")
        
        # Prepare unit data
        create_data = unit_data.model_dump()
        create_data.update({
            "created_by": created_by,
            "updated_by": created_by
        })
        
        # Create unit
        unit = await self.repository.create(create_data)
        
        # Convert to response
        return await self._to_response(unit)
    
    async def get_unit(self, unit_id: UUID) -> UnitOfMeasurementResponse:
        """Get unit of measurement by ID.
        
        Args:
            unit_id: Unit UUID
            
        Returns:
            Unit response
            
        Raises:
            NotFoundError: If unit not found
        """
        unit = await self.repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Unit with id {unit_id} not found")
        
        return await self._to_response(unit)
    
    async def get_unit_by_name(self, name: str) -> UnitOfMeasurementResponse:
        """Get unit of measurement by name.
        
        Args:
            name: Unit name
            
        Returns:
            Unit response
            
        Raises:
            NotFoundError: If unit not found
        """
        unit = await self.repository.get_by_name(name)
        if not unit:
            raise NotFoundError(f"Unit with name '{name}' not found")
        
        return await self._to_response(unit)
    
    async def get_unit_by_abbreviation(self, abbreviation: str) -> UnitOfMeasurementResponse:
        """Get unit of measurement by abbreviation.
        
        Args:
            abbreviation: Unit abbreviation
            
        Returns:
            Unit response
            
        Raises:
            NotFoundError: If unit not found
        """
        unit = await self.repository.get_by_abbreviation(abbreviation)
        if not unit:
            raise NotFoundError(f"Unit with abbreviation '{abbreviation}' not found")
        
        return await self._to_response(unit)
    
    async def update_unit(
        self,
        unit_id: UUID,
        unit_data: UnitOfMeasurementUpdate,
        updated_by: Optional[str] = None
    ) -> UnitOfMeasurementResponse:
        """Update an existing unit of measurement.
        
        Args:
            unit_id: Unit UUID
            unit_data: Unit update data
            updated_by: User updating the unit
            
        Returns:
            Updated unit response
            
        Raises:
            NotFoundError: If unit not found
            ConflictError: If name or abbreviation already exists
            ValidationError: If update data is invalid
        """
        # Get existing unit
        existing_unit = await self.repository.get_by_id(unit_id)
        if not existing_unit:
            raise NotFoundError(f"Unit with id {unit_id} not found")
        
        # Prepare update data
        update_data = {}
        
        # Check name uniqueness if provided
        if unit_data.name is not None and unit_data.name != existing_unit.name:
            if await self.repository.exists_by_name(unit_data.name, exclude_id=unit_id):
                raise ConflictError(f"Unit with name '{unit_data.name}' already exists")
            update_data["name"] = unit_data.name
        
        # Check abbreviation uniqueness if provided
        if unit_data.abbreviation is not None and unit_data.abbreviation != existing_unit.abbreviation:
            if unit_data.abbreviation and await self.repository.exists_by_abbreviation(unit_data.abbreviation, exclude_id=unit_id):
                raise ConflictError(f"Unit with abbreviation '{unit_data.abbreviation}' already exists")
            update_data["abbreviation"] = unit_data.abbreviation
        
        # Update other fields
        if unit_data.description is not None:
            update_data["description"] = unit_data.description
        
        if unit_data.is_active is not None:
            update_data["is_active"] = unit_data.is_active
        
        # Add updated_by
        update_data["updated_by"] = updated_by
        
        # Update unit
        updated_unit = await self.repository.update(unit_id, update_data)
        if not updated_unit:
            raise NotFoundError(f"Unit with id {unit_id} not found")
        
        return await self._to_response(updated_unit)
    
    async def delete_unit(self, unit_id: UUID) -> bool:
        """Soft delete a unit of measurement.
        
        Args:
            unit_id: Unit UUID
            
        Returns:
            True if deleted successfully
            
        Raises:
            NotFoundError: If unit not found
            BusinessRuleError: If unit has associated items
        """
        unit = await self.repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Unit with id {unit_id} not found")
        
        # Check if unit can be deleted
        if not unit.can_delete():
            raise BusinessRuleError("Cannot delete unit with associated items")
        
        return await self.repository.delete(unit_id)
    
    async def list_units(
        self,
        page: int = 1,
        page_size: int = 20,
        filters: Optional[UnitOfMeasurementFilter] = None,
        sort: Optional[UnitOfMeasurementSort] = None,
        include_inactive: bool = False
    ) -> UnitOfMeasurementList:
        """List units of measurement with pagination and filtering.
        
        Args:
            page: Page number (1-based)
            page_size: Items per page
            filters: Filter criteria
            sort: Sort options
            include_inactive: Include inactive units
            
        Returns:
            Paginated unit list
        """
        # Convert filters to dict
        filter_dict = {}
        if filters:
            filter_data = filters.model_dump(exclude_none=True)
            for key, value in filter_data.items():
                if value is not None:
                    filter_dict[key] = value
        
        # Set sort options
        sort_by = sort.field if sort else "name"
        sort_order = sort.direction if sort else "asc"
        
        # Get total count
        total_count = await self.repository.count(
            filters=filter_dict,
            include_inactive=include_inactive
        )
        
        # Get paginated units
        units_list = await self.repository.get_paginated(
            page=page,
            page_size=page_size,
            filters=filter_dict,
            sort_by=sort_by,
            sort_order=sort_order,
            include_inactive=include_inactive
        )
        
        # Convert to summaries
        unit_summaries = []
        for unit in units_list:
            summary = UnitOfMeasurementSummary.model_validate(unit)
            unit_summaries.append(summary)
        
        # Calculate pagination
        total_pages = (total_count + page_size - 1) // page_size
        
        return UnitOfMeasurementList(
            items=unit_summaries,
            total=total_count,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
            has_next=page < total_pages,
            has_previous=page > 1
        )
    
    async def search_units(
        self,
        search_term: str,
        limit: int = 10,
        include_inactive: bool = False
    ) -> List[UnitOfMeasurementSummary]:
        """Search units of measurement by name, abbreviation, or description.
        
        Args:
            search_term: Search term
            limit: Maximum results
            include_inactive: Include inactive units
            
        Returns:
            List of unit summaries
        """
        units = await self.repository.search(
            search_term=search_term,
            limit=limit,
            include_inactive=include_inactive
        )
        
        return [UnitOfMeasurementSummary.model_validate(unit) for unit in units]
    
    async def get_active_units(self) -> List[UnitOfMeasurementSummary]:
        """Get all active units of measurement.
        
        Returns:
            List of active unit summaries
        """
        units = await self.repository.get_active_units()
        return [UnitOfMeasurementSummary.model_validate(unit) for unit in units]
    
    async def get_unit_statistics(self) -> UnitOfMeasurementStats:
        """Get unit of measurement statistics.
        
        Returns:
            Unit statistics
        """
        stats = await self.repository.get_statistics()
        most_used = await self.repository.get_most_used_units()
        
        return UnitOfMeasurementStats(
            total_units=stats["total_units"],
            active_units=stats["active_units"],
            inactive_units=stats["inactive_units"],
            units_with_items=stats["units_with_items"],
            units_without_items=stats["units_without_items"],
            most_used_units=most_used
        )
    
    async def bulk_operation(
        self,
        operation: UnitOfMeasurementBulkOperation,
        updated_by: Optional[str] = None
    ) -> UnitOfMeasurementBulkResult:
        """Perform bulk operations on units of measurement.
        
        Args:
            operation: Bulk operation data
            updated_by: User performing the operation
            
        Returns:
            Bulk operation result
        """
        success_count = 0
        errors = []
        
        for unit_id in operation.unit_ids:
            try:
                if operation.operation == "activate":
                    count = await self.repository.bulk_activate([unit_id])
                    success_count += count
                elif operation.operation == "deactivate":
                    count = await self.repository.bulk_deactivate([unit_id])
                    success_count += count
            except Exception as e:
                errors.append({
                    "unit_id": str(unit_id),
                    "error": str(e)
                })
        
        return UnitOfMeasurementBulkResult(
            success_count=success_count,
            failure_count=len(errors),
            errors=errors
        )
    
    async def export_units(
        self,
        include_inactive: bool = False
    ) -> List[UnitOfMeasurementExport]:
        """Export units of measurement data.
        
        Args:
            include_inactive: Include inactive units
            
        Returns:
            List of unit export data
        """
        units = await self.repository.list(
            skip=0,
            limit=10000,  # Large limit for export
            include_inactive=include_inactive
        )
        
        export_data = []
        for unit in units:
            export_item = UnitOfMeasurementExport.model_validate(unit)
            # Add item count (when available)
            export_item.item_count = unit.item_count
            export_data.append(export_item)
        
        return export_data
    
    async def import_units(
        self,
        import_data: List[UnitOfMeasurementImport],
        created_by: Optional[str] = None
    ) -> UnitOfMeasurementImportResult:
        """Import units of measurement data.
        
        Args:
            import_data: List of unit import data
            created_by: User importing the data
            
        Returns:
            Import operation result
        """
        total_processed = len(import_data)
        successful_imports = 0
        failed_imports = 0
        skipped_imports = 0
        errors = []
        
        for row, unit_data in enumerate(import_data, 1):
            try:
                # Check if unit already exists
                if await self.repository.exists_by_name(unit_data.name):
                    skipped_imports += 1
                    continue
                
                if unit_data.abbreviation and await self.repository.exists_by_abbreviation(unit_data.abbreviation):
                    skipped_imports += 1
                    continue
                
                # Create unit
                create_data = unit_data.model_dump()
                create_data.update({
                    "created_by": created_by,
                    "updated_by": created_by
                })
                
                await self.repository.create(create_data)
                successful_imports += 1
                
            except Exception as e:
                failed_imports += 1
                errors.append({
                    "row": row,
                    "error": str(e)
                })
        
        return UnitOfMeasurementImportResult(
            total_processed=total_processed,
            successful_imports=successful_imports,
            failed_imports=failed_imports,
            skipped_imports=skipped_imports,
            errors=errors
        )
    
    async def activate_unit(self, unit_id: UUID) -> UnitOfMeasurementResponse:
        """Activate a unit of measurement.
        
        Args:
            unit_id: Unit UUID
            
        Returns:
            Updated unit response
        """
        unit = await self.repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Unit with id {unit_id} not found")
        
        if unit.is_active:
            return await self._to_response(unit)
        
        updated_unit = await self.repository.update(unit_id, {"is_active": True})
        return await self._to_response(updated_unit)
    
    async def deactivate_unit(self, unit_id: UUID) -> UnitOfMeasurementResponse:
        """Deactivate a unit of measurement.
        
        Args:
            unit_id: Unit UUID
            
        Returns:
            Updated unit response
        """
        unit = await self.repository.get_by_id(unit_id)
        if not unit:
            raise NotFoundError(f"Unit with id {unit_id} not found")
        
        if not unit.is_active:
            return await self._to_response(unit)
        
        updated_unit = await self.repository.update(unit_id, {"is_active": False})
        return await self._to_response(updated_unit)
    
    async def _to_response(self, unit: UnitOfMeasurement) -> UnitOfMeasurementResponse:
        """Convert unit model to response schema.
        
        Args:
            unit: Unit model
            
        Returns:
            Unit response schema
        """
        # Convert to dict and add computed fields
        unit_dict = {
            "id": unit.id,
            "name": unit.name,
            "abbreviation": unit.abbreviation,
            "description": unit.description,
            "is_active": unit.is_active,
            "created_at": unit.created_at,
            "updated_at": unit.updated_at,
            "created_by": unit.created_by,
            "updated_by": unit.updated_by,
            "display_name": unit.display_name,
            "item_count": unit.item_count
        }
        
        return UnitOfMeasurementResponse(**unit_dict)

===== modules/master_data/locations/__init__.py â€“ 2025-07-19 12:13:41 IST =====
# Locations module

===== modules/master_data/locations/models.py â€“ 2025-07-21 09:52:53 IST =====
from enum import Enum
from typing import Optional, TYPE_CHECKING
from sqlalchemy import Column, String, Text, ForeignKey, Index
from sqlalchemy.orm import relationship, validates
import re

from app.db.base import BaseModel, UUIDType

if TYPE_CHECKING:
    from app.modules.inventory.models import InventoryUnit, StockLevel


class LocationType(str, Enum):
    """Location type enumeration."""
    STORE = "STORE"
    WAREHOUSE = "WAREHOUSE"
    SERVICE_CENTER = "SERVICE_CENTER"


class Location(BaseModel):
    """
    Location model representing physical locations.
    
    Attributes:
        location_code: Unique code for the location
        location_name: Name of the location
        location_type: Type of location (STORE, WAREHOUSE, SERVICE_CENTER)
        address: Street address
        city: City
        state: State/Province
        country: Country
        postal_code: Postal/ZIP code
        contact_number: Phone number
        email: Email address
        manager_user_id: UUID of the manager user
        inventory_units: Inventory units at this location
        stock_levels: Stock levels at this location
    """
    
    __tablename__ = "locations"
    
    location_code = Column(String(20), nullable=False, unique=True, index=True, comment="Unique location code")
    location_name = Column(String(100), nullable=False, comment="Location name")
    location_type = Column(String(20), nullable=False, comment="Location type")
    address = Column(Text, nullable=False, comment="Street address")
    city = Column(String(100), nullable=False, comment="City")
    state = Column(String(100), nullable=False, comment="State/Province")
    country = Column(String(100), nullable=False, comment="Country")
    postal_code = Column(String(20), nullable=True, comment="Postal/ZIP code")
    contact_number = Column(String(20), nullable=True, comment="Phone number")
    email = Column(String(255), nullable=True, comment="Email address")
    manager_user_id = Column(UUIDType(), nullable=True, comment="Manager user ID")
    
    # Relationships
    # inventory_units = relationship("InventoryUnit", back_populates="location", lazy="select")  # Temporarily disabled
    stock_levels = relationship("StockLevel", back_populates="location", lazy="select")
    # transactions = relationship("TransactionHeader", back_populates="location", lazy="select")  # Temporarily disabled
    # rental_returns = relationship("RentalReturn", back_populates="return_location", lazy="select")  # Temporarily disabled
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_location_code', 'location_code'),
        Index('idx_location_name', 'location_name'),
        Index('idx_location_type', 'location_type'),
        Index('idx_location_city', 'city'),
        Index('idx_location_state', 'state'),
        Index('idx_location_country', 'country'),
        Index('idx_location_manager', 'manager_user_id'),
# Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        location_code: str,
        location_name: str,
        location_type: LocationType,
        address: str,
        city: str,
        state: str,
        country: str,
        postal_code: Optional[str] = None,
        contact_number: Optional[str] = None,
        email: Optional[str] = None,
        manager_user_id: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a Location.
        
        Args:
            location_code: Unique code for the location
            location_name: Name of the location
            location_type: Type of location
            address: Street address
            city: City
            state: State/Province
            country: Country
            postal_code: Postal/ZIP code
            contact_number: Phone number
            email: Email address
            manager_user_id: Manager user ID
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.location_code = location_code
        self.location_name = location_name
        self.location_type = location_type.value if isinstance(location_type, LocationType) else location_type
        self.address = address
        self.city = city
        self.state = state
        self.country = country
        self.postal_code = postal_code
        self.contact_number = contact_number
        self.email = email
        self.manager_user_id = manager_user_id
        self._validate()
    
    def _validate(self):
        """Validate location business rules."""
        # Code validation
        if not self.location_code or not self.location_code.strip():
            raise ValueError("Location code cannot be empty")
        
        if len(self.location_code) > 20:
            raise ValueError("Location code cannot exceed 20 characters")
        
        # Name validation
        if not self.location_name or not self.location_name.strip():
            raise ValueError("Location name cannot be empty")
        
        if len(self.location_name) > 100:
            raise ValueError("Location name cannot exceed 100 characters")
        
        # Type validation
        if self.location_type not in [lt.value for lt in LocationType]:
            raise ValueError(f"Invalid location type: {self.location_type}")
        
        # Address validation
        if not self.address or not self.address.strip():
            raise ValueError("Address cannot be empty")
        
        # City validation
        if not self.city or not self.city.strip():
            raise ValueError("City cannot be empty")
        
        if len(self.city) > 100:
            raise ValueError("City cannot exceed 100 characters")
        
        # State validation
        if not self.state or not self.state.strip():
            raise ValueError("State cannot be empty")
        
        if len(self.state) > 100:
            raise ValueError("State cannot exceed 100 characters")
        
        # Country validation
        if not self.country or not self.country.strip():
            raise ValueError("Country cannot be empty")
        
        if len(self.country) > 100:
            raise ValueError("Country cannot exceed 100 characters")
        
        # Postal code validation
        if self.postal_code and len(self.postal_code) > 20:
            raise ValueError("Postal code cannot exceed 20 characters")
        
        # Email validation
        if self.email:
            if len(self.email) > 255:
                raise ValueError("Email cannot exceed 255 characters")
            
            # Basic email format validation
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            if not re.match(email_pattern, self.email):
                raise ValueError("Invalid email format")
        
        # Contact number validation
        if self.contact_number:
            if len(self.contact_number) > 20:
                raise ValueError("Contact number cannot exceed 20 characters")
            
            # Basic phone number validation (digits, spaces, hyphens, parentheses, plus)
            phone_pattern = r'^[\+]?[0-9\s\-\(\)\.]+$'
            if not re.match(phone_pattern, self.contact_number):
                raise ValueError("Invalid contact number format")
    
    @validates('location_code')
    def validate_location_code(self, key, value):
        """Validate location code."""
        if not value or not value.strip():
            raise ValueError("Location code cannot be empty")
        if len(value) > 20:
            raise ValueError("Location code cannot exceed 20 characters")
        return value.strip().upper()
    
    @validates('location_name')
    def validate_location_name(self, key, value):
        """Validate location name."""
        if not value or not value.strip():
            raise ValueError("Location name cannot be empty")
        if len(value) > 100:
            raise ValueError("Location name cannot exceed 100 characters")
        return value.strip()
    
    @validates('location_type')
    def validate_location_type(self, key, value):
        """Validate location type."""
        if isinstance(value, LocationType):
            return value.value
        if value not in [lt.value for lt in LocationType]:
            raise ValueError(f"Invalid location type: {value}")
        return value
    
    @validates('email')
    def validate_email(self, key, value):
        """Validate email format."""
        if value:
            if len(value) > 255:
                raise ValueError("Email cannot exceed 255 characters")
            
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            if not re.match(email_pattern, value):
                raise ValueError("Invalid email format")
        return value
    
    @validates('contact_number')
    def validate_contact_number(self, key, value):
        """Validate contact number format."""
        if value:
            if len(value) > 20:
                raise ValueError("Contact number cannot exceed 20 characters")
            
            phone_pattern = r'^[\+]?[0-9\s\-\(\)\.]+$'
            if not re.match(phone_pattern, value):
                raise ValueError("Invalid contact number format")
        return value
    
    def update_details(
        self,
        location_name: Optional[str] = None,
        address: Optional[str] = None,
        city: Optional[str] = None,
        state: Optional[str] = None,
        country: Optional[str] = None,
        postal_code: Optional[str] = None,
        updated_by: Optional[str] = None
    ):
        """
        Update location details.
        
        Args:
            location_name: New location name
            address: New address
            city: New city
            state: New state
            country: New country
            postal_code: New postal code
            updated_by: User making the update
        """
        if location_name is not None:
            if not location_name or not location_name.strip():
                raise ValueError("Location name cannot be empty")
            if len(location_name) > 100:
                raise ValueError("Location name cannot exceed 100 characters")
            self.location_name = location_name.strip()
        
        if address is not None:
            if not address or not address.strip():
                raise ValueError("Address cannot be empty")
            self.address = address.strip()
        
        if city is not None:
            if not city or not city.strip():
                raise ValueError("City cannot be empty")
            if len(city) > 100:
                raise ValueError("City cannot exceed 100 characters")
            self.city = city.strip()
        
        if state is not None:
            if not state or not state.strip():
                raise ValueError("State cannot be empty")
            if len(state) > 100:
                raise ValueError("State cannot exceed 100 characters")
            self.state = state.strip()
        
        if country is not None:
            if not country or not country.strip():
                raise ValueError("Country cannot be empty")
            if len(country) > 100:
                raise ValueError("Country cannot exceed 100 characters")
            self.country = country.strip()
        
        if postal_code is not None:
            if postal_code and len(postal_code) > 20:
                raise ValueError("Postal code cannot exceed 20 characters")
            self.postal_code = postal_code.strip() if postal_code else None
        
        self.updated_by = updated_by
    
    def update_contact_info(
        self,
        contact_number: Optional[str] = None,
        email: Optional[str] = None,
        updated_by: Optional[str] = None
    ):
        """
        Update location contact information.
        
        Args:
            contact_number: New contact number
            email: New email address
            updated_by: User making the update
        """
        if contact_number is not None:
            if contact_number:
                if len(contact_number) > 20:
                    raise ValueError("Contact number cannot exceed 20 characters")
                
                phone_pattern = r'^[\+]?[0-9\s\-\(\)\.]+$'
                if not re.match(phone_pattern, contact_number):
                    raise ValueError("Invalid contact number format")
            
            self.contact_number = contact_number.strip() if contact_number else None
        
        if email is not None:
            if email:
                if len(email) > 255:
                    raise ValueError("Email cannot exceed 255 characters")
                
                email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
                if not re.match(email_pattern, email):
                    raise ValueError("Invalid email format")
            
            self.email = email.strip() if email else None
        
        self.updated_by = updated_by
    
    def assign_manager(self, manager_user_id: str, updated_by: Optional[str] = None):
        """
        Assign a manager to the location.
        
        Args:
            manager_user_id: Manager user ID
            updated_by: User making the update
        """
        self.manager_user_id = manager_user_id
        self.updated_by = updated_by
    
    def remove_manager(self, updated_by: Optional[str] = None):
        """
        Remove the manager from the location.
        
        Args:
            updated_by: User making the update
        """
        self.manager_user_id = None
        self.updated_by = updated_by
    
    def get_full_address(self) -> str:
        """Get the full formatted address."""
        parts = [self.address, self.city, self.state]
        if self.postal_code:
            parts.append(self.postal_code)
        parts.append(self.country)
        return ", ".join(parts)
    
    def is_store(self) -> bool:
        """Check if location is a store."""
        return self.location_type == LocationType.STORE.value
    
    def is_warehouse(self) -> bool:
        """Check if location is a warehouse."""
        return self.location_type == LocationType.WAREHOUSE.value
    
    def is_service_center(self) -> bool:
        """Check if location is a service center."""
        return self.location_type == LocationType.SERVICE_CENTER.value
    
    def has_inventory(self) -> bool:
        """Check if location has inventory units."""
        # Temporarily disabled relationship - return False
        return False
    
    def has_stock(self) -> bool:
        """Check if location has stock levels."""
        # Temporarily disabled relationship - return False
        return False
    
    def can_delete(self) -> bool:
        """Check if location can be deleted."""
        # Can only delete if no inventory units or stock levels
        return (
            self.is_active and 
            not self.has_inventory() and 
            not self.has_stock()
        )
    
    def get_location_type_display(self) -> str:
        """Get display name for location type."""
        type_display = {
            LocationType.STORE.value: "Store",
            LocationType.WAREHOUSE.value: "Warehouse",
            LocationType.SERVICE_CENTER.value: "Service Center"
        }
        return type_display.get(self.location_type, self.location_type)
    
    @property
    def display_name(self) -> str:
        """Get display name for the location."""
        return f"{self.location_name} ({self.location_code})"
    
    @property
    def short_address(self) -> str:
        """Get short address (city, state, country)."""
        return f"{self.city}, {self.state}, {self.country}"
    
    @property
    def inventory_count(self) -> int:
        """Get number of inventory units at this location."""
        # Temporarily disabled relationship - return 0
        return 0
    
    @property
    def stock_item_count(self) -> int:
        """Get number of stock items at this location."""
        # Temporarily disabled relationship - return 0
        return 0
    
    def __str__(self) -> str:
        """String representation of location."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of location."""
        return (
            f"Location(id={self.id}, code='{self.location_code}', "
            f"name='{self.location_name}', type='{self.location_type}', "
            f"city='{self.city}', active={self.is_active})"
        )

===== modules/master_data/locations/repository.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, or_
from sqlalchemy.orm import selectinload

from .models import Location
from app.shared.repository import BaseRepository


class LocationRepository(BaseRepository[Location]):
    """Repository for location operations."""
    
    def __init__(self, session: AsyncSession):
        super().__init__(Location, session)
    
    async def get_by_code(self, location_code: str) -> Optional[Location]:
        """Get location by code."""
        query = select(Location).where(Location.location_code == location_code)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_type(self, location_type: str, active_only: bool = True) -> List[Location]:
        """Get locations by type."""
        query = select(Location).where(Location.location_type == location_type)
        
        if active_only:
            query = query.where(Location.is_active == True)
        
        query = query.order_by(Location.location_name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_manager(self, manager_user_id: UUID, active_only: bool = True) -> List[Location]:
        """Get locations by manager."""
        query = select(Location).where(Location.manager_user_id == manager_user_id)
        
        if active_only:
            query = query.where(Location.is_active == True)
        
        query = query.order_by(Location.location_name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_city(self, city: str, active_only: bool = True) -> List[Location]:
        """Get locations by city."""
        query = select(Location).where(Location.city.ilike(f"%{city}%"))
        
        if active_only:
            query = query.where(Location.is_active == True)
        
        query = query.order_by(Location.location_name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_state(self, state: str, active_only: bool = True) -> List[Location]:
        """Get locations by state."""
        query = select(Location).where(Location.state.ilike(f"%{state}%"))
        
        if active_only:
            query = query.where(Location.is_active == True)
        
        query = query.order_by(Location.location_name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_country(self, country: str, active_only: bool = True) -> List[Location]:
        """Get locations by country."""
        query = select(Location).where(Location.country.ilike(f"%{country}%"))
        
        if active_only:
            query = query.where(Location.is_active == True)
        
        query = query.order_by(Location.location_name)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def search(
        self,
        search_term: str,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True
    ) -> List[Location]:
        """Search locations by name, code, or address."""
        search_conditions = [
            Location.location_name.ilike(f"%{search_term}%"),
            Location.location_code.ilike(f"%{search_term}%"),
            Location.address.ilike(f"%{search_term}%"),
            Location.city.ilike(f"%{search_term}%"),
            Location.state.ilike(f"%{search_term}%"),
            Location.country.ilike(f"%{search_term}%")
        ]
        
        query = select(Location).where(or_(*search_conditions))
        
        if active_only:
            query = query.where(Location.is_active == True)
        
        query = query.order_by(Location.location_name).offset(skip).limit(limit)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        location_type: Optional[str] = None,
        active_only: bool = True
    ) -> List[Location]:
        """Get all locations with filtering."""
        query = select(Location)
        
        if active_only:
            query = query.where(Location.is_active == True)
        
        if location_type:
            query = query.where(Location.location_type == location_type)
        
        query = query.order_by(Location.location_name).offset(skip).limit(limit)
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def count_all(
        self,
        location_type: Optional[str] = None,
        active_only: bool = True
    ) -> int:
        """Count locations with filtering."""
        query = select(func.count(Location.id))
        
        if active_only:
            query = query.where(Location.is_active == True)
        
        if location_type:
            query = query.where(Location.location_type == location_type)
        
        result = await self.session.execute(query)
        return result.scalar()
    
    async def exists_by_code(self, location_code: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if location exists by code."""
        query = select(func.count(Location.id)).where(Location.location_code == location_code)
        
        if exclude_id:
            query = query.where(Location.id != exclude_id)
        
        result = await self.session.execute(query)
        return result.scalar() > 0
    
    async def get_statistics(self):
        """Get location statistics."""
        # Total and active counts
        total_count = await self.session.execute(select(func.count(Location.id)))
        active_count = await self.session.execute(
            select(func.count(Location.id)).where(Location.is_active == True)
        )
        
        # Count by type
        type_counts = await self.session.execute(
            select(Location.location_type, func.count(Location.id))
            .where(Location.is_active == True)
            .group_by(Location.location_type)
        )
        
        # Count by country
        country_counts = await self.session.execute(
            select(Location.country, func.count(Location.id))
            .where(Location.is_active == True)
            .group_by(Location.country)
            .order_by(func.count(Location.id).desc())
            .limit(10)
        )
        
        # Count by state
        state_counts = await self.session.execute(
            select(Location.state, func.count(Location.id))
            .where(Location.is_active == True)
            .group_by(Location.state)
            .order_by(func.count(Location.id).desc())
            .limit(10)
        )
        
        return {
            "total_locations": total_count.scalar(),
            "active_locations": active_count.scalar(),
            "locations_by_type": dict(type_counts.fetchall()),
            "locations_by_country": dict(country_counts.fetchall()),
            "locations_by_state": dict(state_counts.fetchall())
        }

===== modules/master_data/locations/routes.py â€“ 2025-07-20 02:35:29 IST =====
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.shared.dependencies import get_session
from app.modules.master_data.locations.service import LocationService
from app.modules.master_data.locations.schemas import (
    LocationCreate, LocationUpdate, LocationResponse
)


router = APIRouter(tags=["Master Data - Locations"])


# Dependency to get location service
async def get_location_service(session: AsyncSession = Depends(get_session)) -> LocationService:
    return LocationService(session)


# Location CRUD endpoints
@router.post("/", response_model=LocationResponse, status_code=status.HTTP_201_CREATED)
async def create_location(
    location_data: LocationCreate,
    service: LocationService = Depends(get_location_service)
):
    """Create a new location."""
    try:
        return await service.create_location(location_data)
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/", response_model=List[LocationResponse])
async def list_locations(
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    location_type: Optional[str] = Query(None, description="Filter by location type"),
    active_only: bool = Query(True, description="Show only active locations"),
    service: LocationService = Depends(get_location_service)
):
    """List locations with optional filtering."""
    return await service.list_locations(
        skip=skip,
        limit=limit,
        location_type=location_type,
        active_only=active_only
    )


@router.get("/search", response_model=List[LocationResponse])
async def search_locations(
    search_term: str = Query(..., min_length=2, description="Search term"),
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Show only active locations"),
    service: LocationService = Depends(get_location_service)
):
    """Search locations by name, code, or address."""
    return await service.search_locations(
        search_term=search_term,
        skip=skip,
        limit=limit,
        active_only=active_only
    )


@router.get("/count")
async def count_locations(
    location_type: Optional[str] = Query(None, description="Filter by location type"),
    active_only: bool = Query(True, description="Show only active locations"),
    service: LocationService = Depends(get_location_service)
):
    """Count locations with optional filtering."""
    count = await service.count_locations(
        location_type=location_type,
        active_only=active_only
    )
    return {"count": count}


@router.get("/{location_id}", response_model=LocationResponse)
async def get_location(
    location_id: UUID,
    service: LocationService = Depends(get_location_service)
):
    """Get location by ID."""
    location = await service.get_location(location_id)
    if not location:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Location not found")
    
    return location


@router.get("/code/{location_code}", response_model=LocationResponse)
async def get_location_by_code(
    location_code: str,
    service: LocationService = Depends(get_location_service)
):
    """Get location by code."""
    location = await service.get_location_by_code(location_code)
    if not location:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Location not found")
    
    return location


@router.put("/{location_id}", response_model=LocationResponse)
async def update_location(
    location_id: UUID,
    update_data: LocationUpdate,
    service: LocationService = Depends(get_location_service)
):
    """Update location information."""
    try:
        return await service.update_location(location_id, update_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ConflictError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{location_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_location(
    location_id: UUID,
    service: LocationService = Depends(get_location_service)
):
    """Delete location."""
    success = await service.delete_location(location_id)
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Location not found")


# Location type specific endpoints
@router.get("/type/{location_type}", response_model=List[LocationResponse])
async def get_locations_by_type(
    location_type: str,
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Show only active locations"),
    service: LocationService = Depends(get_location_service)
):
    """Get locations by type."""
    return await service.list_locations(
        skip=skip,
        limit=limit,
        location_type=location_type,
        active_only=active_only
    )


# Bulk operations endpoints
@router.post("/bulk/activate", status_code=status.HTTP_204_NO_CONTENT)
async def bulk_activate_locations(
    location_ids: List[UUID],
    service: LocationService = Depends(get_location_service)
):
    """Bulk activate locations."""
    # TODO: Implement bulk activation
    pass


@router.post("/bulk/deactivate", status_code=status.HTTP_204_NO_CONTENT)
async def bulk_deactivate_locations(
    location_ids: List[UUID],
    service: LocationService = Depends(get_location_service)
):
    """Bulk deactivate locations."""
    # TODO: Implement bulk deactivation
    pass


# Export endpoints
@router.get("/export/csv")
async def export_locations_csv(
    location_type: Optional[str] = Query(None, description="Filter by location type"),
    active_only: bool = Query(True, description="Show only active locations"),
    service: LocationService = Depends(get_location_service)
):
    """Export locations to CSV."""
    # TODO: Implement CSV export
    return {"message": "CSV export not yet implemented"}


@router.get("/export/xlsx")
async def export_locations_xlsx(
    location_type: Optional[str] = Query(None, description="Filter by location type"),
    active_only: bool = Query(True, description="Show only active locations"),
    service: LocationService = Depends(get_location_service)
):
    """Export locations to Excel."""
    # TODO: Implement Excel export
    return {"message": "Excel export not yet implemented"}


===== modules/master_data/locations/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional
from datetime import datetime
from pydantic import BaseModel, Field, ConfigDict
from uuid import UUID


class LocationCreate(BaseModel):
    """Schema for creating a new location."""
    location_code: str = Field(..., max_length=20, description="Unique location code")
    location_name: str = Field(..., max_length=100, description="Location name")
    location_type: str = Field(..., max_length=20, description="Location type")
    address: str = Field(..., description="Street address")
    city: str = Field(..., max_length=100, description="City")
    state: str = Field(..., max_length=100, description="State")
    country: str = Field(..., max_length=100, description="Country")
    postal_code: Optional[str] = Field(None, max_length=20, description="Postal code")
    contact_number: Optional[str] = Field(None, max_length=20, description="Contact number")
    email: Optional[str] = Field(None, max_length=255, description="Email address")
    manager_user_id: Optional[UUID] = Field(None, description="Manager user ID")


class LocationUpdate(BaseModel):
    """Schema for updating a location."""
    location_name: Optional[str] = Field(None, max_length=100, description="Location name")
    location_type: Optional[str] = Field(None, max_length=20, description="Location type")
    address: Optional[str] = Field(None, description="Street address")
    city: Optional[str] = Field(None, max_length=100, description="City")
    state: Optional[str] = Field(None, max_length=100, description="State")
    country: Optional[str] = Field(None, max_length=100, description="Country")
    postal_code: Optional[str] = Field(None, max_length=20, description="Postal code")
    contact_number: Optional[str] = Field(None, max_length=20, description="Contact number")
    email: Optional[str] = Field(None, max_length=255, description="Email address")
    manager_user_id: Optional[UUID] = Field(None, description="Manager user ID")


class LocationResponse(BaseModel):
    """Schema for location response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    location_code: str
    location_name: str
    location_type: str
    address: Optional[str] = None
    city: str
    state: str
    country: str
    postal_code: Optional[str] = None
    contact_number: Optional[str] = None
    email: Optional[str] = None
    manager_user_id: Optional[UUID] = None
    created_at: datetime
    updated_at: datetime
    is_active: bool

===== modules/master_data/locations/service.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession

from .repository import LocationRepository
from .models import Location
from .schemas import LocationCreate, LocationUpdate, LocationResponse
from app.core.errors import ValidationError, NotFoundError, ConflictError


class LocationService:
    """Location service."""
    
    def __init__(self, session: AsyncSession):
        """Initialize service with database session."""
        self.session = session
        self.repository = LocationRepository(session)
    
    async def create_location(self, location_data: LocationCreate) -> LocationResponse:
        """Create a new location."""
        # Check if location code already exists
        existing_location = await self.repository.get_by_code(location_data.location_code)
        if existing_location:
            raise ConflictError(f"Location with code '{location_data.location_code}' already exists")
        
        # Create location - map schema fields to model fields
        location_dict = location_data.model_dump()
        
        # Map schema fields to model fields
        mapped_dict = {
            'location_code': location_dict.get('location_code'),
            'location_name': location_dict.get('location_name'),
            'location_type': location_dict.get('location_type'),
            'address': location_dict.get('address'),
            'city': location_dict.get('city'),
            'state': location_dict.get('state'),
            'country': location_dict.get('country'),
            'postal_code': location_dict.get('postal_code'),
            'contact_number': location_dict.get('contact_number'),
            'email': location_dict.get('email'),
            'manager_user_id': location_dict.get('manager_user_id'),
        }
        
        # Remove None values
        mapped_dict = {k: v for k, v in mapped_dict.items() if v is not None}
        
        location = await self.repository.create(mapped_dict)
        
        # Map model fields back to response schema format
        response_data = {
            'id': location.id,
            'location_code': location.location_code,
            'location_name': location.location_name,
            'location_type': location.location_type,
            'address': location.address,
            'city': location.city,
            'state': location.state,
            'country': location.country,
            'postal_code': location.postal_code,
            'contact_number': location.contact_number,
            'email': location.email,
            'manager_user_id': location.manager_user_id,
            'created_at': location.created_at,
            'updated_at': location.updated_at,
            'is_active': location.is_active if hasattr(location, 'is_active') else True,
        }
        return LocationResponse(**response_data)
    
    async def get_location(self, location_id: UUID) -> Optional[LocationResponse]:
        """Get location by ID."""
        location = await self.repository.get_by_id(location_id)
        if not location:
            return None
        
        # Map model fields to response schema format
        response_data = {
            'id': location.id,
            'location_code': location.location_code,
            'location_name': location.location_name,
            'location_type': location.location_type,
            'address': location.address,
            'city': location.city,
            'state': location.state,
            'country': location.country,
            'postal_code': location.postal_code,
            'contact_number': location.contact_number,
            'email': location.email,
            'manager_user_id': location.manager_user_id,
            'created_at': location.created_at,
            'updated_at': location.updated_at,
            'is_active': location.is_active if hasattr(location, 'is_active') else True,
        }
        return LocationResponse(**response_data)
    
    async def get_location_by_code(self, location_code: str) -> Optional[LocationResponse]:
        """Get location by code."""
        location = await self.repository.get_by_code(location_code)
        if not location:
            return None
        
        # Map model fields to response schema format
        response_data = {
            'id': location.id,
            'location_code': location.location_code,
            'location_name': location.location_name,
            'location_type': location.location_type,
            'address': location.address,
            'city': location.city,
            'state': location.state,
            'country': location.country,
            'postal_code': location.postal_code,
            'contact_number': location.contact_number,
            'email': location.email,
            'manager_user_id': location.manager_user_id,
            'created_at': location.created_at,
            'updated_at': location.updated_at,
            'is_active': location.is_active if hasattr(location, 'is_active') else True,
        }
        return LocationResponse(**response_data)
    
    async def update_location(self, location_id: UUID, update_data: LocationUpdate) -> LocationResponse:
        """Update location information."""
        location = await self.repository.get_by_id(location_id)
        if not location:
            raise NotFoundError("Location not found")
        
        # Update location
        update_dict = update_data.model_dump(exclude_unset=True)
        updated_location = await self.repository.update(location_id, update_dict)
        
        # Map model fields to response schema format
        response_data = {
            'id': updated_location.id,
            'location_code': updated_location.location_code,
            'location_name': updated_location.location_name,
            'location_type': updated_location.location_type,
            'address_line1': updated_location.address,
            'address_line2': None,
            'city': updated_location.city,
            'state': updated_location.state,
            'postal_code': updated_location.postal_code,
            'country': updated_location.country,
            'phone': updated_location.contact_number,
            'email': updated_location.email,
            'manager_user_id': updated_location.manager_user_id,
            'operating_hours': None,
            'capacity': None,
            'description': None,
            'created_at': updated_location.created_at,
            'updated_at': updated_location.updated_at,
            'is_active': updated_location.is_active if hasattr(updated_location, 'is_active') else True,
        }
        return LocationResponse(**response_data)
    
    async def delete_location(self, location_id: UUID) -> bool:
        """Delete location."""
        return await self.repository.delete(location_id)
    
    async def list_locations(
        self,
        skip: int = 0,
        limit: int = 100,
        location_type: Optional[str] = None,
        active_only: bool = True
    ) -> List[LocationResponse]:
        """List locations with filtering."""
        locations = await self.repository.get_all(
            skip=skip,
            limit=limit,
            location_type=location_type,
            active_only=active_only
        )
        
        # Map model fields to response schema format
        result = []
        for location in locations:
            response_data = {
                'id': location.id,
                'location_code': location.location_code,
                'location_name': location.location_name,
                'location_type': location.location_type,
                'address': location.address,
                'city': location.city,
                'state': location.state,
                'country': location.country,
                'postal_code': location.postal_code,
                'contact_number': location.contact_number,
                'email': location.email,
                'manager_user_id': location.manager_user_id,
                'created_at': location.created_at,
                'updated_at': location.updated_at,
                'is_active': location.is_active if hasattr(location, 'is_active') else True,
            }
            result.append(LocationResponse(**response_data))
        
        return result
    
    async def search_locations(
        self,
        search_term: str,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True
    ) -> List[LocationResponse]:
        """Search locations."""
        locations = await self.repository.search(
            search_term=search_term,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
        
        # Map model fields to response schema format
        result = []
        for location in locations:
            response_data = {
                'id': location.id,
                'location_code': location.location_code,
                'location_name': location.location_name,
                'location_type': location.location_type,
                'address': location.address,
                'city': location.city,
                'state': location.state,
                'country': location.country,
                'postal_code': location.postal_code,
                'contact_number': location.contact_number,
                'email': location.email,
                'manager_user_id': location.manager_user_id,
                'created_at': location.created_at,
                'updated_at': location.updated_at,
                'is_active': location.is_active if hasattr(location, 'is_active') else True,
            }
            result.append(LocationResponse(**response_data))
        
        return result
    
    async def count_locations(
        self,
        location_type: Optional[str] = None,
        active_only: bool = True
    ) -> int:
        """Count locations with filtering."""
        return await self.repository.count_all(
            location_type=location_type,
            active_only=active_only
        )

===== modules/master_data/categories/__init__.py â€“ 2025-07-19 12:13:41 IST =====
# Categories module
from .routes import router
from .models import Category, CategoryPath
from .schemas import CategoryCreate, CategoryUpdate, CategoryResponse
from .service import CategoryService
from .repository import CategoryRepository

__all__ = [
    "router",
    "Category",
    "CategoryPath",
    "CategoryCreate",
    "CategoryUpdate", 
    "CategoryResponse",
    "CategoryService",
    "CategoryRepository"
]

===== modules/master_data/categories/models.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, TYPE_CHECKING
from sqlalchemy import Column, String, Integer, Boolean, ForeignKey, Index
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property
from uuid import UUID

from app.db.base import BaseModel, UUIDType

if TYPE_CHECKING:
    from app.modules.master_data.item_master.models import Item


class Category(BaseModel):
    """
    Category model with hierarchical support.
    
    Attributes:
        name: Category name
        parent_category_id: UUID of parent category (None for root categories)
        category_path: Full path like "Electronics/Computers/Laptops"
        category_level: Hierarchy level (1=root, 2=sub, etc.)
        display_order: Sort order within parent
        is_leaf: True if category has no children
        parent: Parent category relationship
        children: Child categories relationship
        items: Items in this category
    """
    
    __tablename__ = "categories"
    
    name = Column(String(100), nullable=False, comment="Category name")
    parent_category_id = Column(UUIDType(), ForeignKey("categories.id"), nullable=True, comment="Parent category ID")
    category_path = Column(String(500), nullable=False, index=True, comment="Full category path")
    category_level = Column(Integer, nullable=False, default=1, comment="Hierarchy level")
    display_order = Column(Integer, nullable=False, default=0, comment="Display order within parent")
    is_leaf = Column(Boolean, nullable=False, default=True, comment="True if category has no children")
    
    # Self-referential relationship - temporarily disabled to prevent async issues
    # parent = relationship("Category", remote_side="Category.id", back_populates="children")
    # children = relationship("Category", back_populates="parent", cascade="all, delete-orphan")
    
    # Items in this category
    items = relationship("Item", back_populates="category", lazy="select")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_category_parent', 'parent_category_id'),
        Index('idx_category_path', 'category_path'),
        Index('idx_category_active_leaf', 'is_active', 'is_leaf'),
        Index('idx_category_level', 'category_level'),
        Index('idx_category_display_order', 'display_order'),
        Index('idx_category_parent_order', 'parent_category_id', 'display_order'),
        # Unique constraint: category name must be unique within parent
        Index('uk_category_name_parent', 'name', 'parent_category_id', unique=True),
    )
    
    def __init__(
        self,
        name: str,
        parent_category_id: Optional[UUID] = None,
        category_path: Optional[str] = None,
        category_level: int = 1,
        display_order: int = 0,
        is_leaf: bool = True,
        **kwargs
    ):
        """
        Initialize a Category.
        
        Args:
            name: Category name
            parent_category_id: UUID of parent category (None for root categories)
            category_path: Full path like "Electronics/Computers/Laptops"
            category_level: Hierarchy level (1=root, 2=sub, etc.)
            display_order: Sort order within parent
            is_leaf: True if category has no children
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.name = name
        self.parent_category_id = parent_category_id
        self.category_path = category_path or name
        self.category_level = category_level
        self.display_order = display_order
        self.is_leaf = is_leaf
        self._validate()
    
    def _validate(self):
        """Validate category business rules."""
        # Name validation
        if not self.name or not self.name.strip():
            raise ValueError("Category name cannot be empty")
        
        if len(self.name) > 100:
            raise ValueError("Category name cannot exceed 100 characters")
        
        # Level validation
        if self.category_level < 1:
            raise ValueError("Category level must be at least 1")
        
        # Display order validation
        if self.display_order < 0:
            raise ValueError("Display order cannot be negative")
        
        # Root categories should not have parent
        if self.category_level == 1 and self.parent_category_id is not None:
            raise ValueError("Root categories cannot have a parent")
        
        # Non-root categories must have parent
        if self.category_level > 1 and self.parent_category_id is None:
            raise ValueError("Non-root categories must have a parent")
        
        # Path validation
        if not self.category_path:
            raise ValueError("Category path cannot be empty")
        
        if len(self.category_path) > 500:
            raise ValueError("Category path cannot exceed 500 characters")
    
    @validates('name')
    def validate_name(self, key, value):
        """Validate category name."""
        if not value or not value.strip():
            raise ValueError("Category name cannot be empty")
        if len(value) > 100:
            raise ValueError("Category name cannot exceed 100 characters")
        return value.strip()
    
    @validates('category_level')
    def validate_level(self, key, value):
        """Validate category level."""
        if value < 1:
            raise ValueError("Category level must be at least 1")
        return value
    
    @validates('display_order')
    def validate_display_order(self, key, value):
        """Validate display order."""
        if value < 0:
            raise ValueError("Display order cannot be negative")
        return value
    
    @validates('category_path')
    def validate_path(self, key, value):
        """Validate category path."""
        if not value:
            raise ValueError("Category path cannot be empty")
        if len(value) > 500:
            raise ValueError("Category path cannot exceed 500 characters")
        return value.strip()
    
    def update_info(
        self,
        name: Optional[str] = None,
        display_order: Optional[int] = None,
        updated_by: Optional[str] = None
    ):
        """
        Update category information.
        
        Args:
            name: New category name
            display_order: New display order
            updated_by: User making the update
        """
        if name is not None:
            if not name or not name.strip():
                raise ValueError("Category name cannot be empty")
            if len(name) > 100:
                raise ValueError("Category name cannot exceed 100 characters")
            self.name = name.strip()
        
        if display_order is not None:
            if display_order < 0:
                raise ValueError("Display order cannot be negative")
            self.display_order = display_order
        
        self.updated_by = updated_by
    
    def update_path(self, new_path: str, updated_by: Optional[str] = None):
        """
        Update category path. Usually called when parent category is renamed.
        
        Args:
            new_path: New category path
            updated_by: User making the update
        """
        if not new_path:
            raise ValueError("Category path cannot be empty")
        if len(new_path) > 500:
            raise ValueError("Category path cannot exceed 500 characters")
        
        self.category_path = new_path
        self.updated_by = updated_by
    
    def mark_as_parent(self, updated_by: Optional[str] = None):
        """Mark category as parent (not leaf)."""
        self.is_leaf = False
        self.updated_by = updated_by
    
    def mark_as_leaf(self, updated_by: Optional[str] = None):
        """Mark category as leaf (no children)."""
        self.is_leaf = True
        self.updated_by = updated_by
    
    def move_to_parent(
        self,
        new_parent_id: Optional[UUID],
        new_level: int,
        new_path: str,
        updated_by: Optional[str] = None
    ):
        """
        Move category to a new parent.
        
        Args:
            new_parent_id: New parent category ID
            new_level: New category level
            new_path: New category path
            updated_by: User making the update
        """
        if new_level < 1:
            raise ValueError("Category level must be at least 1")
        
        if new_level == 1 and new_parent_id is not None:
            raise ValueError("Root categories cannot have a parent")
        
        if new_level > 1 and new_parent_id is None:
            raise ValueError("Non-root categories must have a parent")
        
        self.parent_category_id = new_parent_id
        self.category_level = new_level
        self.category_path = new_path
        self.updated_by = updated_by
    
    @hybrid_property
    def child_count(self) -> int:
        """Get number of direct children."""
        # Always return 0 to prevent lazy loading in async context
        # Child count will be calculated explicitly in the service layer
        return 0
    
    @hybrid_property
    def item_count(self) -> int:
        """Get number of items in this category."""
        # items relationship is temporarily disabled
        # if self.items:
        #     return len(self.items)
        return 0
    
    def can_have_items(self) -> bool:
        """Check if this category can have items assigned."""
        return self.is_leaf
    
    def can_have_children(self) -> bool:
        """Check if this category can have child categories."""
        return True  # Any category can have children
    
    def can_delete(self) -> bool:
        """Check if category can be deleted."""
        # Can only delete if no children and no items
        return (
            self.is_active and 
            self.child_count == 0 and 
            self.item_count == 0
        )
    
    def is_root(self) -> bool:
        """Check if this is a root category."""
        return self.category_level == 1 and self.parent_category_id is None
    
    def is_descendant_of(self, ancestor_path: str) -> bool:
        """Check if this category is a descendant of the given ancestor path."""
        if not ancestor_path:
            return False
        return self.category_path.startswith(f"{ancestor_path}/")
    
    def is_ancestor_of(self, descendant_path: str) -> bool:
        """Check if this category is an ancestor of the given descendant path."""
        if not descendant_path:
            return False
        return descendant_path.startswith(f"{self.category_path}/")
    
    def get_path_segments(self) -> List[str]:
        """Get category path as a list of segments."""
        if not self.category_path:
            return []
        return self.category_path.split("/")
    
    def get_depth(self) -> int:
        """Get the depth of this category in the hierarchy."""
        return self.category_level
    
    def get_breadcrumb(self) -> List[str]:
        """Get breadcrumb trail as list of category names."""
        return self.get_path_segments()
    
    def get_parent_path(self) -> Optional[str]:
        """Get parent category path."""
        if self.is_root():
            return None
        
        segments = self.get_path_segments()
        if len(segments) <= 1:
            return None
        
        return "/".join(segments[:-1])
    
    def generate_path(self, parent_path: Optional[str] = None) -> str:
        """Generate category path based on parent path and current name."""
        if parent_path:
            return f"{parent_path}/{self.name}"
        return self.name
    
    @property
    def full_name(self) -> str:
        """Get full category name with path."""
        return self.category_path
    
    @property
    def has_children(self) -> bool:
        """Check if category has children."""
        return not self.is_leaf
    
    @property
    def has_items(self) -> bool:
        """Check if category has items."""
        # items relationship is temporarily disabled
        return False
    
    def __str__(self) -> str:
        """String representation of category."""
        return f"Category({self.category_path})"
    
    def __repr__(self) -> str:
        """Developer representation of category."""
        return (
            f"Category(id={self.id}, name='{self.name}', "
            f"path='{self.category_path}', level={self.category_level}, "
            f"is_leaf={self.is_leaf}, active={self.is_active})"
        )


class CategoryPath:
    """Value object for managing category paths."""
    
    def __init__(self, path: str):
        """Initialize category path."""
        if not path:
            raise ValueError("Category path cannot be empty")
        self.path = path.strip().strip("/")  # Remove leading/trailing slashes and whitespace
    
    def append(self, segment: str) -> "CategoryPath":
        """Append a segment to the path."""
        if not segment or not segment.strip():
            raise ValueError("Path segment cannot be empty")
        segment = segment.strip()
        return CategoryPath(f"{self.path}/{segment}")
    
    def parent_path(self) -> Optional["CategoryPath"]:
        """Get the parent path, or None if this is root."""
        segments = self.path.split("/")
        if len(segments) <= 1:
            return None
        return CategoryPath("/".join(segments[:-1]))
    
    def replace_segment(self, old_segment: str, new_segment: str) -> "CategoryPath":
        """Replace a segment in the path."""
        if not old_segment or not new_segment:
            raise ValueError("Segments cannot be empty")
        
        segments = self.path.split("/")
        new_segments = [new_segment.strip() if seg == old_segment else seg for seg in segments]
        return CategoryPath("/".join(new_segments))
    
    def starts_with(self, prefix: str) -> bool:
        """Check if path starts with a prefix."""
        if not prefix:
            return False
        return self.path.startswith(prefix)
    
    def get_segments(self) -> List[str]:
        """Get path segments as a list."""
        return self.path.split("/")
    
    def get_level(self) -> int:
        """Get the level (depth) of this path."""
        return len(self.get_segments())
    
    def get_last_segment(self) -> str:
        """Get the last segment (category name)."""
        segments = self.get_segments()
        return segments[-1] if segments else ""
    
    def get_first_segment(self) -> str:
        """Get the first segment (root category name)."""
        segments = self.get_segments()
        return segments[0] if segments else ""
    
    def is_root(self) -> bool:
        """Check if this is a root path (single segment)."""
        return len(self.get_segments()) == 1
    
    def is_descendant_of(self, ancestor: "CategoryPath") -> bool:
        """Check if this path is a descendant of the given ancestor."""
        return self.path.startswith(f"{ancestor.path}/")
    
    def is_ancestor_of(self, descendant: "CategoryPath") -> bool:
        """Check if this path is an ancestor of the given descendant."""
        return descendant.path.startswith(f"{self.path}/")
    
    def common_ancestor(self, other: "CategoryPath") -> Optional["CategoryPath"]:
        """Find the common ancestor path with another path."""
        self_segments = self.get_segments()
        other_segments = other.get_segments()
        
        common_segments = []
        for i in range(min(len(self_segments), len(other_segments))):
            if self_segments[i] == other_segments[i]:
                common_segments.append(self_segments[i])
            else:
                break
        
        if not common_segments:
            return None
        
        return CategoryPath("/".join(common_segments))
    
    def __str__(self) -> str:
        """String representation."""
        return self.path
    
    def __eq__(self, other) -> bool:
        """Check equality."""
        if not isinstance(other, CategoryPath):
            return False
        return self.path == other.path
    
    def __hash__(self) -> int:
        """Hash for use in sets and dicts."""
        return hash(self.path)
    
    def __lt__(self, other) -> bool:
        """Less than comparison for sorting."""
        if not isinstance(other, CategoryPath):
            return NotImplemented
        return self.path < other.path

===== modules/master_data/categories/repository.py â€“ 2025-07-20 19:09:46 IST =====
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from sqlalchemy import select, func, or_, and_, desc, asc, text
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload, joinedload
from pydantic import BaseModel
from math import ceil

from .models import Category, CategoryPath
from app.shared.repository import BaseRepository


class PageInfo(BaseModel):
    """Pagination information."""

    total_items: int
    page: int
    page_size: int
    total_pages: int
    has_next: bool
    has_previous: bool


class PaginationResult(BaseModel):
    """Pagination result container."""

    items: List[Category]
    page_info: PageInfo

    class Config:
        arbitrary_types_allowed = True


class CategoryRepository(BaseRepository[Category]):
    """Repository for category data access operations."""

    def __init__(self, session: AsyncSession):
        """Initialize repository with database session."""
        super().__init__(Category, session)

    # Methods inherited from BaseRepository:
    # - create(obj_data: Dict[str, Any]) -> Category
    # - get_by_id(id: UUID) -> Optional[Category]
    # - get_all(...) -> List[Category]
    # - update(id: UUID, obj_data: Dict[str, Any]) -> Optional[Category]
    # - delete(id: UUID) -> bool  (soft delete)
    # - count_all(...) -> int
    # - exists(id: UUID) -> bool
    # - search(...) -> List[Category]
    # - get_paginated(...) -> Dict[str, Any]

    # Category-specific methods

    async def get_by_code(self, category_code: str) -> Optional[Category]:
        """Get category by code."""
        return await self.get_by_field("category_code", category_code)

    async def get_by_slug(self, slug: str) -> Optional[Category]:
        """Get category by slug."""
        return await self.get_by_field("slug", slug)

    async def get_by_parent_id(self, parent_id: UUID) -> List[Category]:
        """Get all categories by parent ID."""
        query = select(Category).where(
            and_(
                Category.parent_category_id == parent_id,
                Category.is_active == True
            )
        ).order_by(asc(Category.display_order), asc(Category.category_name))
        
        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_root_categories(self) -> List[Category]:
        """Get all root categories (categories with no parent)."""
        query = select(Category).where(
            and_(
                Category.parent_category_id == None,
                Category.is_active == True
            )
        ).order_by(asc(Category.display_order), asc(Category.category_name))
        
        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_with_children(self, category_id: UUID) -> Optional[Category]:
        """Get category with its children loaded."""
        query = select(Category).options(
            selectinload(Category.children)
        ).where(Category.id == category_id)
        
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_with_parent(self, category_id: UUID) -> Optional[Category]:
        """Get category with its parent loaded."""
        query = select(Category).options(
            selectinload(Category.parent)
        ).where(Category.id == category_id)
        
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_full_tree(self) -> List[Category]:
        """Get all categories with parent-child relationships loaded."""
        query = select(Category).options(
            selectinload(Category.children),
            selectinload(Category.parent)
        ).where(Category.is_active == True)
        
        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_ancestors(self, category_id: UUID) -> List[Category]:
        """Get all ancestors of a category (parent, grandparent, etc.)."""
        # Use recursive CTE
        cte_query = text("""
            WITH RECURSIVE ancestors AS (
                SELECT c.* 
                FROM categories c 
                WHERE c.id = :category_id
                
                UNION ALL
                
                SELECT c.* 
                FROM categories c 
                INNER JOIN ancestors a ON c.id = a.parent_category_id
            )
            SELECT * FROM ancestors WHERE id != :category_id ORDER BY level DESC;
        """)
        
        result = await self.session.execute(cte_query, {"category_id": str(category_id)})
        rows = result.fetchall()
        
        # Convert rows to Category objects
        categories = []
        for row in rows:
            category = await self.get_by_id(UUID(row.id))
            if category:
                categories.append(category)
        
        return categories

    async def get_descendants(self, category_id: UUID) -> List[Category]:
        """Get all descendants of a category (children, grandchildren, etc.)."""
        # Use recursive CTE
        cte_query = text("""
            WITH RECURSIVE descendants AS (
                SELECT c.* 
                FROM categories c 
                WHERE c.id = :category_id
                
                UNION ALL
                
                SELECT c.* 
                FROM categories c 
                INNER JOIN descendants d ON c.parent_category_id = d.id
            )
            SELECT * FROM descendants WHERE id != :category_id;
        """)
        
        result = await self.session.execute(cte_query, {"category_id": str(category_id)})
        rows = result.fetchall()
        
        # Convert rows to Category objects
        categories = []
        for row in rows:
            category = await self.get_by_id(UUID(row.id))
            if category:
                categories.append(category)
        
        return categories

    async def exists_by_code(self, category_code: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a category with the given code exists."""
        query = select(func.count()).select_from(Category).where(
            Category.category_code == category_code
        )
        
        if exclude_id:
            query = query.where(Category.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0

    async def exists_by_slug(self, slug: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a category with the given slug exists."""
        query = select(func.count()).select_from(Category).where(
            Category.slug == slug
        )
        
        if exclude_id:
            query = query.where(Category.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0

    async def exists_by_name_and_parent(
        self, 
        name: str, 
        parent_id: Optional[UUID] = None, 
        exclude_id: Optional[UUID] = None
    ) -> bool:
        """Check if a category with the given name exists under the specified parent."""
        query = select(func.count()).select_from(Category).where(
            Category.name == name,
            Category.parent_category_id == parent_id,
            Category.is_active == True
        )
        
        if exclude_id:
            query = query.where(Category.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0

    async def update_hierarchy(self, category_id: UUID, new_parent_id: Optional[UUID]) -> bool:
        """Update category hierarchy by changing its parent."""
        category = await self.get_by_id(category_id)
        if not category:
            return False
        
        # Prevent setting self as parent
        if new_parent_id and new_parent_id == category_id:
            return False
        
        # Prevent creating circular references
        if new_parent_id:
            ancestors = await self.get_ancestors(new_parent_id)
            if any(a.id == category_id for a in ancestors):
                return False
        
        category.parent_category_id = new_parent_id
        await self.session.commit()
        
        return True

    async def get_category_paths(self, category_id: UUID) -> List[CategoryPath]:
        """Get all paths for a category."""
        query = select(CategoryPath).where(
            CategoryPath.descendant_id == category_id
        ).order_by(asc(CategoryPath.depth))
        
        result = await self.session.execute(query)
        return result.scalars().all()

    async def rebuild_paths(self) -> None:
        """Rebuild the category paths table (closure table)."""
        # Clear existing paths
        await self.session.execute(text("DELETE FROM category_paths"))
        
        # Rebuild paths using recursive CTE
        rebuild_query = text("""
            INSERT INTO category_paths (ancestor_id, descendant_id, depth)
            WITH RECURSIVE category_tree AS (
                -- Base case: each category is its own ancestor at depth 0
                SELECT id as ancestor_id, id as descendant_id, 0 as depth
                FROM categories
                
                UNION ALL
                
                -- Recursive case: find all ancestor-descendant relationships
                SELECT ct.ancestor_id, c.id as descendant_id, ct.depth + 1
                FROM categories c
                INNER JOIN category_tree ct ON c.parent_category_id = ct.descendant_id
            )
            SELECT ancestor_id, descendant_id, depth FROM category_tree;
        """)
        
        await self.session.execute(rebuild_query)
        await self.session.commit()

    async def get_item_count(self, category_id: UUID, include_descendants: bool = False) -> int:
        """Get count of items in a category."""
        if include_descendants:
            # Get all descendant category IDs
            descendants = await self.get_descendants(category_id)
            category_ids = [category_id] + [d.id for d in descendants]
            
            query = text("""
                SELECT COUNT(DISTINCT i.id) 
                FROM items i 
                WHERE i.category_id = ANY(:category_ids) 
                AND i.is_active = true
            """)
            
            result = await self.session.execute(
                query, 
                {"category_ids": category_ids}
            )
        else:
            query = text("""
                SELECT COUNT(*) 
                FROM items 
                WHERE category_id = :category_id 
                AND is_active = true
            """)
            
            result = await self.session.execute(
                query, 
                {"category_id": category_id}
            )
        
        return result.scalar_one()

    async def search(
        self,
        search_term: str,
        limit: int = 10,
        include_inactive: bool = False
    ) -> List[Category]:
        """Search categories by name, code, or description.
        
        Overrides base search to search specific Category fields.
        """
        search_fields = ["category_name", "category_code", "description"]
        return await super().search(
            search_term=search_term,
            search_fields=search_fields,
            limit=limit,
            active_only=not include_inactive
        )

    async def get_breadcrumb(self, category_id: UUID) -> List[Dict[str, Any]]:
        """Get breadcrumb path for a category."""
        ancestors = await self.get_ancestors(category_id)
        category = await self.get_by_id(category_id)
        
        breadcrumb = []
        for ancestor in ancestors:
            breadcrumb.append({
                "id": str(ancestor.id),
                "name": ancestor.category_name,
                "slug": ancestor.slug
            })
        
        if category:
            breadcrumb.append({
                "id": str(category.id),
                "name": category.category_name,
                "slug": category.slug
            })
        
        return breadcrumb

===== modules/master_data/categories/routes.py â€“ 2025-07-20 02:35:22 IST =====
from typing import Optional, List
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from fastapi.responses import JSONResponse

from .service import CategoryService
from .schemas import (
    CategoryCreate, CategoryUpdate, CategoryMove, CategoryResponse, 
    CategorySummary, CategoryTree, CategoryList, CategoryFilter, 
    CategorySort, CategoryStats, CategoryBulkOperation, CategoryBulkResult,
    CategoryExport, CategoryImport, CategoryImportResult, CategoryHierarchy,
    CategoryValidation
)
from app.shared.dependencies import get_category_service
from app.core.errors import (
    NotFoundError, ConflictError, ValidationError,
    BusinessRuleError
)


router = APIRouter(tags=["categories"])


@router.post("/", response_model=CategoryResponse, status_code=status.HTTP_201_CREATED)
async def create_category(
    category_data: CategoryCreate,
    service: CategoryService = Depends(get_category_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Create a new category."""
    try:
        return await service.create_category(category_data, created_by=current_user_id)
    except ConflictError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/parents/", response_model=List[CategorySummary])
async def get_parent_categories(
    service: CategoryService = Depends(get_category_service)
):
    """Get all categories that are not marked as leaf (is_leaf = False).
    
    This includes both categories that currently have children and categories
    that are marked as non-leaf but don't currently have subcategories.
    """
    return await service.get_parent_categories()


@router.get("/{category_id}", response_model=CategoryResponse)
async def get_category(
    category_id: UUID,
    service: CategoryService = Depends(get_category_service)
):
    """Get a category by ID."""
    try:
        return await service.get_category(category_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/by-path/{path:path}", response_model=CategoryResponse)
async def get_category_by_path(
    path: str,
    service: CategoryService = Depends(get_category_service)
):
    """Get a category by path."""
    try:
        return await service.get_category_by_path(path)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/", response_model=CategoryList)
async def list_categories(
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    name: Optional[str] = Query(None, description="Filter by name (partial match)"),
    parent_id: Optional[UUID] = Query(None, description="Filter by parent category ID"),
    level: Optional[int] = Query(None, ge=1, description="Filter by category level"),
    is_leaf: Optional[bool] = Query(None, description="Filter by leaf status"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    search: Optional[str] = Query(None, description="Search in name and path"),
    path_contains: Optional[str] = Query(None, description="Filter by path containing text"),
    has_items: Optional[bool] = Query(None, description="Filter by whether category has items"),
    has_children: Optional[bool] = Query(None, description="Filter by whether category has children"),
    sort_field: str = Query("name", description="Field to sort by"),
    sort_direction: str = Query("asc", description="Sort direction (asc/desc)"),
    include_inactive: bool = Query(False, description="Include inactive categories"),
    service: CategoryService = Depends(get_category_service)
):
    """List categories with pagination, filtering, and sorting."""
    # Create filter object
    filters = CategoryFilter(
        name=name,
        parent_id=parent_id,
        level=level,
        is_leaf=is_leaf,
        is_active=is_active,
        search=search,
        path_contains=path_contains,
        has_items=has_items,
        has_children=has_children
    )
    
    # Create sort object
    sort_options = CategorySort(
        field=sort_field,
        direction=sort_direction
    )
    
    try:
        return await service.list_categories(
            page=page,
            page_size=page_size,
            filters=filters,
            sort=sort_options,
            include_inactive=include_inactive
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.put("/{category_id}", response_model=CategoryResponse)
async def update_category(
    category_id: UUID,
    category_data: CategoryUpdate,
    service: CategoryService = Depends(get_category_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Update an existing category."""
    try:
        return await service.update_category(
            category_id=category_id,
            category_data=category_data,
            updated_by=current_user_id
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ConflictError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post("/{category_id}/move", response_model=CategoryResponse)
async def move_category(
    category_id: UUID,
    move_data: CategoryMove,
    service: CategoryService = Depends(get_category_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Move category to a new parent."""
    try:
        return await service.move_category(
            category_id=category_id,
            move_data=move_data,
            updated_by=current_user_id
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except BusinessRuleError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.delete("/{category_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_category(
    category_id: UUID,
    service: CategoryService = Depends(get_category_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Delete (deactivate) a category."""
    try:
        success = await service.delete_category(category_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Category with id {category_id} not found"
            )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except BusinessRuleError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/tree/", response_model=List[CategoryTree])
async def get_category_tree(
    root_id: Optional[UUID] = Query(None, description="Root category ID (None for full tree)"),
    include_inactive: bool = Query(False, description="Include inactive categories"),
    service: CategoryService = Depends(get_category_service)
):
    """Get hierarchical category tree."""
    return await service.get_category_tree(
        root_id=root_id,
        include_inactive=include_inactive
    )


@router.get("/{category_id}/hierarchy", response_model=CategoryHierarchy)
async def get_category_hierarchy(
    category_id: UUID,
    service: CategoryService = Depends(get_category_service)
):
    """Get category hierarchy information."""
    try:
        return await service.get_category_hierarchy(category_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/search/", response_model=List[CategorySummary])
async def search_categories(
    q: str = Query(..., min_length=1, description="Search query"),
    limit: int = Query(10, ge=1, le=50, description="Maximum results"),
    include_inactive: bool = Query(False, description="Include inactive categories"),
    service: CategoryService = Depends(get_category_service)
):
    """Search categories by name or path."""
    return await service.search_categories(
        search_term=q,
        limit=limit,
        include_inactive=include_inactive
    )


@router.get("/roots/", response_model=List[CategorySummary])
async def get_root_categories(
    service: CategoryService = Depends(get_category_service)
):
    """Get all root categories."""
    return await service.get_root_categories()


@router.get("/leaves/", response_model=List[CategorySummary])
async def get_leaf_categories(
    service: CategoryService = Depends(get_category_service)
):
    """Get all leaf categories."""
    return await service.get_leaf_categories()


@router.get("/{parent_id}/children", response_model=List[CategorySummary])
async def get_category_children(
    parent_id: UUID,
    service: CategoryService = Depends(get_category_service)
):
    """Get direct children of a category."""
    try:
        return await service.get_category_children(parent_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/stats/", response_model=CategoryStats)
async def get_category_statistics(
    service: CategoryService = Depends(get_category_service)
):
    """Get category statistics."""
    return await service.get_category_statistics()


@router.post("/bulk-operation", response_model=CategoryBulkResult)
async def bulk_category_operation(
    operation: CategoryBulkOperation,
    service: CategoryService = Depends(get_category_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Perform bulk operations on categories."""
    try:
        return await service.bulk_operation(
            operation=operation,
            updated_by=current_user_id
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/export/", response_model=List[CategoryExport])
async def export_categories(
    include_inactive: bool = Query(False, description="Include inactive categories"),
    service: CategoryService = Depends(get_category_service)
):
    """Export categories data."""
    return await service.export_categories(include_inactive=include_inactive)


@router.post("/import/", response_model=CategoryImportResult)
async def import_categories(
    categories_data: List[CategoryImport],
    service: CategoryService = Depends(get_category_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Import categories data."""
    try:
        return await service.import_categories(
            import_data=categories_data,
            created_by=current_user_id
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/{category_id}/validate/{operation}", response_model=CategoryValidation)
async def validate_category_operation(
    category_id: UUID,
    operation: str,
    service: CategoryService = Depends(get_category_service)
):
    """Validate category operation."""
    return await service.validate_category_operation(
        category_id=category_id,
        operation=operation
    )




===== modules/master_data/categories/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, ConfigDict, Field, validator
from datetime import datetime
from uuid import UUID


class CategoryBase(BaseModel):
    """Base category schema with common fields."""
    
    name: str = Field(..., min_length=1, max_length=100, description="Category name")
    parent_category_id: Optional[UUID] = Field(None, description="Parent category ID")
    display_order: int = Field(0, ge=0, description="Display order within parent")
    
    @validator('name')
    def validate_name(cls, v):
        if not v or not v.strip():
            raise ValueError('Category name cannot be empty')
        return v.strip()


class CategoryCreate(CategoryBase):
    """Schema for creating a new category."""
    pass


class CategoryUpdate(BaseModel):
    """Schema for updating an existing category."""
    
    name: Optional[str] = Field(None, min_length=1, max_length=100, description="Category name")
    display_order: Optional[int] = Field(None, ge=0, description="Display order within parent")
    is_active: Optional[bool] = Field(None, description="Category active status")
    is_leaf: Optional[bool] = Field(None, description="Whether category is a leaf (has no children)")
    
    @validator('name')
    def validate_name(cls, v):
        if v is not None:
            if not v or not v.strip():
                raise ValueError('Category name cannot be empty')
            return v.strip()
        return v


class CategoryMove(BaseModel):
    """Schema for moving a category to a new parent."""
    
    new_parent_id: Optional[UUID] = Field(None, description="New parent category ID (None for root)")
    new_display_order: int = Field(0, ge=0, description="Display order in new parent")


class CategoryResponse(CategoryBase):
    """Schema for category response with all fields."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Category unique identifier")
    category_path: str = Field(..., description="Full category path")
    category_level: int = Field(..., ge=1, description="Category hierarchy level")
    is_leaf: bool = Field(..., description="True if category has no children")
    is_active: bool = Field(True, description="Category active status")
    created_at: datetime = Field(..., description="Category creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Category last update timestamp")
    created_by: Optional[str] = Field(None, description="User who created the category")
    updated_by: Optional[str] = Field(None, description="User who last updated the category")
    
    # Computed fields
    child_count: int = Field(0, description="Number of direct children")
    item_count: int = Field(0, description="Number of items in this category")
    can_have_items: bool = Field(True, description="Whether category can have items")
    can_have_children: bool = Field(True, description="Whether category can have children")
    can_delete: bool = Field(False, description="Whether category can be deleted")
    is_root: bool = Field(False, description="Whether this is a root category")
    has_children: bool = Field(False, description="Whether category has children")
    has_items: bool = Field(False, description="Whether category has items")
    breadcrumb: List[str] = Field(default_factory=list, description="Breadcrumb trail")
    full_name: str = Field(..., description="Full category name with path")


class CategorySummary(BaseModel):
    """Schema for category summary with minimal fields."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Category unique identifier")
    name: str = Field(..., description="Category name")
    category_path: str = Field(..., description="Full category path")
    category_level: int = Field(..., description="Category hierarchy level")
    parent_category_id: Optional[UUID] = Field(None, description="Parent category ID")
    display_order: int = Field(0, description="Display order within parent")
    is_leaf: bool = Field(..., description="True if category has no children")
    is_active: bool = Field(True, description="Category active status")
    child_count: int = Field(0, description="Number of direct children")
    item_count: int = Field(0, description="Number of items in this category")


class CategoryTree(BaseModel):
    """Schema for hierarchical category tree."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Category unique identifier")
    name: str = Field(..., description="Category name")
    category_path: str = Field(..., description="Full category path")
    category_level: int = Field(..., description="Category hierarchy level")
    parent_category_id: Optional[UUID] = Field(None, description="Parent category ID")
    display_order: int = Field(0, description="Display order within parent")
    is_leaf: bool = Field(..., description="True if category has no children")
    is_active: bool = Field(True, description="Category active status")
    child_count: int = Field(0, description="Number of direct children")
    item_count: int = Field(0, description="Number of items in this category")
    children: List["CategoryTree"] = Field(default_factory=list, description="Child categories")


class CategoryList(BaseModel):
    """Schema for paginated category list response."""
    
    items: List[CategorySummary] = Field(..., description="List of category summaries")
    total: int = Field(..., description="Total number of categories")
    page: int = Field(..., description="Current page number")
    page_size: int = Field(..., description="Number of items per page")
    total_pages: int = Field(..., description="Total number of pages")
    has_next: bool = Field(..., description="Whether there are more pages")
    has_previous: bool = Field(..., description="Whether there are previous pages")


class CategoryFilter(BaseModel):
    """Schema for category filtering and search."""
    
    name: Optional[str] = Field(None, description="Filter by category name (partial match)")
    parent_id: Optional[UUID] = Field(None, description="Filter by parent category ID")
    level: Optional[int] = Field(None, ge=1, description="Filter by category level")
    is_leaf: Optional[bool] = Field(None, description="Filter by leaf status")
    is_active: Optional[bool] = Field(None, description="Filter by active status")
    search: Optional[str] = Field(None, description="Search in name and path")
    path_contains: Optional[str] = Field(None, description="Filter by path containing text")
    has_items: Optional[bool] = Field(None, description="Filter by whether category has items")
    has_children: Optional[bool] = Field(None, description="Filter by whether category has children")
    
    @validator('name', 'search', 'path_contains')
    def validate_string_filters(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class CategorySort(BaseModel):
    """Schema for category sorting options."""
    
    field: str = Field('name', description="Field to sort by")
    direction: str = Field('asc', description="Sort direction (asc/desc)")
    
    @validator('field')
    def validate_field(cls, v):
        allowed_fields = [
            'name', 'category_path', 'category_level', 'display_order',
            'created_at', 'updated_at', 'is_active'
        ]
        if v not in allowed_fields:
            raise ValueError(f'Sort field must be one of: {", ".join(allowed_fields)}')
        return v
    
    @validator('direction')
    def validate_direction(cls, v):
        if v.lower() not in ['asc', 'desc']:
            raise ValueError('Sort direction must be "asc" or "desc"')
        return v.lower()


class CategoryStats(BaseModel):
    """Schema for category statistics."""
    
    total_categories: int = Field(..., description="Total number of categories")
    active_categories: int = Field(..., description="Number of active categories")
    inactive_categories: int = Field(..., description="Number of inactive categories")
    root_categories: int = Field(..., description="Number of root categories")
    leaf_categories: int = Field(..., description="Number of leaf categories")
    categories_with_items: int = Field(..., description="Number of categories with items")
    categories_without_items: int = Field(..., description="Number of categories without items")
    max_depth: int = Field(..., description="Maximum category depth")
    avg_children_per_category: float = Field(..., description="Average number of children per category")
    most_used_categories: List[Dict[str, Any]] = Field(..., description="Top categories by item count")
    
    @validator('most_used_categories')
    def validate_most_used_categories(cls, v):
        """Validate the structure of most_used_categories."""
        for category in v:
            if not isinstance(category, dict) or 'name' not in category or 'item_count' not in category:
                raise ValueError('Each category in most_used_categories must have name and item_count')
        return v


class CategoryBulkOperation(BaseModel):
    """Schema for bulk category operations."""
    
    category_ids: List[UUID] = Field(..., min_items=1, description="List of category IDs")
    operation: str = Field(..., description="Operation to perform (activate/deactivate/delete)")
    
    @validator('operation')
    def validate_operation(cls, v):
        if v not in ['activate', 'deactivate', 'delete']:
            raise ValueError('Operation must be "activate", "deactivate", or "delete"')
        return v


class CategoryBulkResult(BaseModel):
    """Schema for bulk operation results."""
    
    success_count: int = Field(..., description="Number of successful operations")
    failure_count: int = Field(..., description="Number of failed operations")
    errors: List[Dict[str, Any]] = Field(..., description="List of errors for failed operations")
    
    @validator('errors')
    def validate_errors(cls, v):
        """Validate the structure of errors."""
        for error in v:
            if not isinstance(error, dict) or 'category_id' not in error or 'error' not in error:
                raise ValueError('Each error must have category_id and error fields')
        return v


class CategoryExport(BaseModel):
    """Schema for category export data."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    name: str
    parent_category_id: Optional[UUID]
    category_path: str
    category_level: int
    display_order: int
    is_leaf: bool
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime]
    created_by: Optional[str]
    updated_by: Optional[str]
    child_count: int = Field(0, description="Number of direct children")
    item_count: int = Field(0, description="Number of items in this category")


class CategoryImport(BaseModel):
    """Schema for category import data."""
    
    name: str = Field(..., min_length=1, max_length=100)
    parent_category_path: Optional[str] = Field(None, description="Parent category path")
    display_order: int = Field(0, ge=0)
    is_active: bool = Field(True)
    
    @validator('name')
    def validate_name(cls, v):
        if not v or not v.strip():
            raise ValueError('Category name cannot be empty')
        return v.strip()
    
    @validator('parent_category_path')
    def validate_parent_path(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class CategoryImportResult(BaseModel):
    """Schema for category import results."""
    
    total_processed: int = Field(..., description="Total number of categories processed")
    successful_imports: int = Field(..., description="Number of successful imports")
    failed_imports: int = Field(..., description="Number of failed imports")
    skipped_imports: int = Field(..., description="Number of skipped imports (duplicates)")
    errors: List[Dict[str, Any]] = Field(..., description="List of import errors")
    
    @validator('errors')
    def validate_errors(cls, v):
        """Validate the structure of errors."""
        for error in v:
            if not isinstance(error, dict) or 'row' not in error or 'error' not in error:
                raise ValueError('Each error must have row and error fields')
        return v


class CategoryPath(BaseModel):
    """Schema for category path operations."""
    
    path: str = Field(..., description="Category path")
    segments: List[str] = Field(..., description="Path segments")
    level: int = Field(..., ge=1, description="Path depth level")
    is_root: bool = Field(..., description="Whether this is a root path")
    parent_path: Optional[str] = Field(None, description="Parent path")
    
    @validator('path')
    def validate_path(cls, v):
        if not v or not v.strip():
            raise ValueError('Category path cannot be empty')
        return v.strip()
    
    @validator('segments')
    def validate_segments(cls, v):
        if not v:
            raise ValueError('Path segments cannot be empty')
        for segment in v:
            if not segment or not segment.strip():
                raise ValueError('Path segments cannot contain empty values')
        return v


class CategoryHierarchy(BaseModel):
    """Schema for category hierarchy operations."""
    
    category_id: UUID = Field(..., description="Category ID")
    ancestors: List[CategorySummary] = Field(..., description="Ancestor categories")
    descendants: List[CategorySummary] = Field(..., description="Descendant categories")
    siblings: List[CategorySummary] = Field(..., description="Sibling categories")
    depth: int = Field(..., ge=1, description="Category depth in hierarchy")
    path_to_root: List[CategorySummary] = Field(..., description="Path from category to root")


class CategoryValidation(BaseModel):
    """Schema for category validation results."""
    
    is_valid: bool = Field(..., description="Whether category is valid")
    errors: List[str] = Field(..., description="List of validation errors")
    warnings: List[str] = Field(..., description="List of validation warnings")
    can_create: bool = Field(..., description="Whether category can be created")
    can_update: bool = Field(..., description="Whether category can be updated")
    can_delete: bool = Field(..., description="Whether category can be deleted")
    can_move: bool = Field(..., description="Whether category can be moved")


# Enable forward references for recursive models
CategoryTree.model_rebuild()

===== modules/master_data/categories/service.py â€“ 2025-07-20 14:14:24 IST =====
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from datetime import datetime

from .repository import CategoryRepository
from .models import Category, CategoryPath
from .schemas import (
    CategoryCreate, CategoryUpdate, CategoryMove, CategoryResponse, 
    CategorySummary, CategoryTree, CategoryList, CategoryFilter, 
    CategorySort, CategoryStats, CategoryBulkOperation, CategoryBulkResult,
    CategoryExport, CategoryImport, CategoryImportResult, CategoryHierarchy,
    CategoryValidation
)
from app.shared.pagination import Page
from app.core.errors import (
    NotFoundError, ConflictError, ValidationError, 
    BusinessRuleError
)


class CategoryService:
    """Service layer for category business logic."""
    
    def __init__(self, repository: CategoryRepository):
        """Initialize service with repository."""
        self.repository = repository
    
    async def create_category(
        self,
        category_data: CategoryCreate,
        created_by: Optional[str] = None
    ) -> CategoryResponse:
        """Create a new category.
        
        Args:
            category_data: Category creation data
            created_by: User creating the category
            
        Returns:
            Created category response
            
        Raises:
            ConflictError: If category name already exists under same parent
            ValidationError: If category data is invalid
            NotFoundError: If parent category not found
        """
        # Check if parent exists
        parent_category = None
        if category_data.parent_category_id:
            parent_category = await self.repository.get_by_id(category_data.parent_category_id)
            if not parent_category:
                raise NotFoundError(f"Parent category with id {category_data.parent_category_id} not found")
        
        # Check for duplicate name under same parent
        if await self.repository.exists_by_name_and_parent(
            category_data.name, 
            category_data.parent_category_id
        ):
            parent_name = parent_category.name if parent_category else "root"
            raise ConflictError(f"Category with name '{category_data.name}' already exists under '{parent_name}'")
        
        # Calculate hierarchy details
        if parent_category:
            category_level = parent_category.category_level + 1
            category_path = f"{parent_category.category_path}/{category_data.name}"
            
            # Update parent to mark as non-leaf
            if parent_category.is_leaf:
                await self.repository.update(
                    parent_category.id,
                    {"is_leaf": False, "updated_by": created_by}
                )
        else:
            category_level = 1
            category_path = category_data.name
        
        # Prepare category data
        create_data = category_data.model_dump()
        create_data.update({
            "category_level": category_level,
            "category_path": category_path,
            "is_leaf": True,  # New categories are always leaf initially
            "created_by": created_by,
            "updated_by": created_by
        })
        
        # Create category
        category = await self.repository.create(create_data)
        
        # Convert to response
        return await self._to_response(category)
    
    async def get_category(self, category_id: UUID) -> CategoryResponse:
        """Get category by ID.
        
        Args:
            category_id: Category UUID
            
        Returns:
            Category response
            
        Raises:
            NotFoundError: If category not found
        """
        category = await self.repository.get_by_id(category_id)
        if not category:
            raise NotFoundError(f"Category with id {category_id} not found")
        
        return await self._to_response(category)
    
    async def get_category_by_path(self, path: str) -> CategoryResponse:
        """Get category by path.
        
        Args:
            path: Category path
            
        Returns:
            Category response
            
        Raises:
            NotFoundError: If category not found
        """
        category = await self.repository.get_by_path(path)
        if not category:
            raise NotFoundError(f"Category with path '{path}' not found")
        
        return await self._to_response(category)
    
    async def update_category(
        self,
        category_id: UUID,
        category_data: CategoryUpdate,
        updated_by: Optional[str] = None
    ) -> CategoryResponse:
        """Update an existing category.
        
        Args:
            category_id: Category UUID
            category_data: Category update data
            updated_by: User updating the category
            
        Returns:
            Updated category response
            
        Raises:
            NotFoundError: If category not found
            ConflictError: If name already exists under same parent
            ValidationError: If update data is invalid
        """
        # Get existing category
        existing_category = await self.repository.get_by_id(category_id)
        if not existing_category:
            raise NotFoundError(f"Category with id {category_id} not found")
        
        # Prepare update data
        update_data = {"updated_by": updated_by}
        path_update_needed = False
        
        # Check name uniqueness if provided
        if category_data.name is not None and category_data.name != existing_category.name:
            if await self.repository.exists_by_name_and_parent(
                category_data.name, 
                existing_category.parent_category_id,
                exclude_id=category_id
            ):
                raise ConflictError(f"Category with name '{category_data.name}' already exists under same parent")
            
            update_data["name"] = category_data.name
            path_update_needed = True
        
        # Update display order
        if category_data.display_order is not None:
            update_data["display_order"] = category_data.display_order
        
        # Update active status
        if category_data.is_active is not None:
            update_data["is_active"] = category_data.is_active
        
        # Update leaf status
        if category_data.is_leaf is not None:
            update_data["is_leaf"] = category_data.is_leaf
        
        # Update path if name changed
        if path_update_needed:
            parent_path = existing_category.get_parent_path()
            if parent_path:
                new_path = f"{parent_path}/{category_data.name}"
            else:
                new_path = category_data.name
            
            update_data["category_path"] = new_path
        
        # Update category
        updated_category = await self.repository.update(category_id, update_data)
        if not updated_category:
            raise NotFoundError(f"Category with id {category_id} not found")
        
        # Update descendant paths if name changed
        if path_update_needed:
            await self._update_descendant_paths_after_rename(updated_category)
        
        return await self._to_response(updated_category)
    
    async def move_category(
        self,
        category_id: UUID,
        move_data: CategoryMove,
        updated_by: Optional[str] = None
    ) -> CategoryResponse:
        """Move category to a new parent.
        
        Args:
            category_id: Category UUID
            move_data: Move operation data
            updated_by: User performing the move
            
        Returns:
            Updated category response
            
        Raises:
            NotFoundError: If category or new parent not found
            BusinessRuleError: If move would create cycle
        """
        # Get existing category
        category = await self.repository.get_by_id(category_id)
        if not category:
            raise NotFoundError(f"Category with id {category_id} not found")
        
        # Validate move operation
        await self._validate_move_operation(category, move_data.new_parent_id)
        
        # Update old parent if needed
        if category.parent_category_id:
            await self._update_parent_leaf_status(category.parent_category_id)
        
        # Move category
        moved_category = await self.repository.move_category(
            category_id=category_id,
            new_parent_id=move_data.new_parent_id,
            updated_by=updated_by
        )
        
        # Update display order
        if move_data.new_display_order != moved_category.display_order:
            await self.repository.update(
                category_id,
                {"display_order": move_data.new_display_order, "updated_by": updated_by}
            )
        
        # Update new parent if needed
        if move_data.new_parent_id:
            await self._update_parent_leaf_status(move_data.new_parent_id)
        
        return await self._to_response(moved_category)
    
    async def delete_category(self, category_id: UUID) -> bool:
        """Soft delete a category.
        
        Args:
            category_id: Category UUID
            
        Returns:
            True if deleted successfully
            
        Raises:
            NotFoundError: If category not found
            BusinessRuleError: If category has children or items
        """
        category = await self.repository.get_by_id(category_id)
        if not category:
            raise NotFoundError(f"Category with id {category_id} not found")
        
        # Check if category can be deleted
        if not category.can_delete():
            raise BusinessRuleError("Cannot delete category with children or items")
        
        success = await self.repository.delete(category_id)
        
        # Update parent leaf status if needed
        if success and category.parent_category_id:
            await self._update_parent_leaf_status(category.parent_category_id)
        
        return success
    
    async def get_category_tree(
        self,
        root_id: Optional[UUID] = None,
        include_inactive: bool = False
    ) -> List[CategoryTree]:
        """Get hierarchical category tree.
        
        Args:
            root_id: Root category ID (None for full tree)
            include_inactive: Include inactive categories
            
        Returns:
            List of category trees
        """
        # Get all categories in tree
        categories = await self.repository.get_tree(root_id)
        
        if not include_inactive:
            categories = [cat for cat in categories if cat.is_active]
        
        # Build tree structure
        category_dict = {cat.id: cat for cat in categories}
        tree_nodes = {}
        
        # Create tree nodes
        for category in categories:
            tree_node = CategoryTree(
                id=category.id,
                name=category.name,
                category_path=category.category_path,
                category_level=category.category_level,
                parent_category_id=category.parent_category_id,
                display_order=category.display_order,
                is_leaf=category.is_leaf,
                is_active=category.is_active,
                child_count=category.child_count,
                item_count=category.item_count,
                children=[]
            )
            tree_nodes[category.id] = tree_node
        
        # Build parent-child relationships
        root_nodes = []
        for category in categories:
            tree_node = tree_nodes[category.id]
            
            if category.parent_category_id and category.parent_category_id in tree_nodes:
                parent_node = tree_nodes[category.parent_category_id]
                parent_node.children.append(tree_node)
            else:
                root_nodes.append(tree_node)
        
        # Sort children by display order and name
        def sort_children(node):
            node.children.sort(key=lambda x: (x.display_order, x.name))
            for child in node.children:
                sort_children(child)
        
        for root in root_nodes:
            sort_children(root)
        
        # Sort root nodes
        root_nodes.sort(key=lambda x: (x.display_order, x.name))
        
        return root_nodes
    
    async def get_category_hierarchy(self, category_id: UUID) -> CategoryHierarchy:
        """Get category hierarchy information.
        
        Args:
            category_id: Category UUID
            
        Returns:
            Category hierarchy information
            
        Raises:
            NotFoundError: If category not found
        """
        category = await self.repository.get_by_id(category_id)
        if not category:
            raise NotFoundError(f"Category with id {category_id} not found")
        
        # Get ancestors
        ancestors = await self.repository.get_ancestors(category_id)
        ancestor_summaries = [await self._to_summary(cat) for cat in ancestors]
        
        # Get descendants
        descendants = await self.repository.get_descendants(category_id)
        descendant_summaries = [await self._to_summary(cat) for cat in descendants]
        
        # Get siblings
        siblings = await self.repository.get_siblings(category_id)
        sibling_summaries = [await self._to_summary(cat) for cat in siblings]
        
        # Build path to root
        path_to_root = ancestor_summaries + [await self._to_summary(category)]
        
        return CategoryHierarchy(
            category_id=category_id,
            ancestors=ancestor_summaries,
            descendants=descendant_summaries,
            siblings=sibling_summaries,
            depth=category.category_level,
            path_to_root=path_to_root
        )
    
    async def list_categories(
        self,
        page: int = 1,
        page_size: int = 20,
        filters: Optional[CategoryFilter] = None,
        sort: Optional[CategorySort] = None,
        include_inactive: bool = False
    ) -> CategoryList:
        """List categories with pagination and filtering.
        
        Args:
            page: Page number (1-based)
            page_size: Items per page
            filters: Filter criteria
            sort: Sort options
            include_inactive: Include inactive categories
            
        Returns:
            Paginated category list
        """
        # Convert filters to dict
        filter_dict = {}
        if filters:
            filter_data = filters.model_dump(exclude_none=True)
            for key, value in filter_data.items():
                if value is not None:
                    filter_dict[key] = value
        
        # Set sort options
        sort_by = sort.field if sort else "name"
        sort_order = sort.direction if sort else "asc"
        
        # Get paginated categories
        page_result = await self.repository.get_paginated(
            page=page,
            page_size=page_size,
            filters=filter_dict,
            sort_by=sort_by,
            sort_order=sort_order,
            include_inactive=include_inactive
        )
        
        # Convert to summaries
        category_summaries = []
        for category in page_result["items"]:
            summary = await self._to_summary(category)
            category_summaries.append(summary)
        
        # Return list response
        return CategoryList(
            items=category_summaries,
            total=page_result["total"],
            page=page_result["page"],
            page_size=page_result["page_size"],
            total_pages=page_result["total_pages"],
            has_next=page_result["has_next"],
            has_previous=page_result["has_prev"]
        )
    
    async def search_categories(
        self,
        search_term: str,
        limit: int = 10,
        include_inactive: bool = False
    ) -> List[CategorySummary]:
        """Search categories by name or path.
        
        Args:
            search_term: Search term
            limit: Maximum results
            include_inactive: Include inactive categories
            
        Returns:
            List of category summaries
        """
        categories = await self.repository.search(
            search_term=search_term,
            limit=limit,
            include_inactive=include_inactive
        )
        
        return [await self._to_summary(cat) for cat in categories]
    
    async def get_root_categories(self) -> List[CategorySummary]:
        """Get all root categories.
        
        Returns:
            List of root category summaries
        """
        categories = await self.repository.get_root_categories()
        return [await self._to_summary(cat) for cat in categories]
    
    async def get_leaf_categories(self) -> List[CategorySummary]:
        """Get all leaf categories.
        
        Returns:
            List of leaf category summaries
        """
        categories = await self.repository.get_leaf_categories()
        return [await self._to_summary(cat) for cat in categories]
    
    async def get_parent_categories(self) -> List[CategorySummary]:
        """Get all categories that are not marked as leaf (is_leaf = False).
        
        This includes both categories that currently have children and categories
        that are marked as non-leaf but don't currently have subcategories.
        
        Returns:
            List of non-leaf category summaries
        """
        categories = await self.repository.get_parent_categories()
        return [await self._to_summary(cat) for cat in categories]
    
    async def get_category_children(self, parent_id: UUID) -> List[CategorySummary]:
        """Get direct children of a category.
        
        Args:
            parent_id: Parent category ID
            
        Returns:
            List of child category summaries
            
        Raises:
            NotFoundError: If parent category not found
        """
        parent = await self.repository.get_by_id(parent_id)
        if not parent:
            raise NotFoundError(f"Parent category with id {parent_id} not found")
        
        children = await self.repository.get_by_parent_id(parent_id)
        return [await self._to_summary(cat) for cat in children]
    
    async def get_category_statistics(self) -> CategoryStats:
        """Get category statistics.
        
        Returns:
            Category statistics
        """
        stats = await self.repository.get_statistics()
        most_used = await self.repository.get_most_used_categories()
        
        return CategoryStats(
            total_categories=stats["total_categories"],
            active_categories=stats["active_categories"],
            inactive_categories=stats["inactive_categories"],
            root_categories=stats["root_categories"],
            leaf_categories=stats["leaf_categories"],
            categories_with_items=stats["categories_with_items"],
            categories_without_items=stats["categories_without_items"],
            max_depth=stats["max_depth"],
            avg_children_per_category=stats["avg_children_per_category"],
            most_used_categories=most_used
        )
    
    async def bulk_operation(
        self,
        operation: CategoryBulkOperation,
        updated_by: Optional[str] = None
    ) -> CategoryBulkResult:
        """Perform bulk operations on categories.
        
        Args:
            operation: Bulk operation data
            updated_by: User performing the operation
            
        Returns:
            Bulk operation result
        """
        success_count = 0
        errors = []
        
        for category_id in operation.category_ids:
            try:
                if operation.operation == "activate":
                    count = await self.repository.bulk_activate([category_id])
                    success_count += count
                elif operation.operation == "deactivate":
                    count = await self.repository.bulk_deactivate([category_id])
                    success_count += count
                elif operation.operation == "delete":
                    category = await self.repository.get_by_id(category_id)
                    if category and category.can_delete():
                        await self.repository.delete(category_id)
                        success_count += 1
                    else:
                        errors.append({
                            "category_id": str(category_id),
                            "error": "Cannot delete category with children or items"
                        })
            except Exception as e:
                errors.append({
                    "category_id": str(category_id),
                    "error": str(e)
                })
        
        return CategoryBulkResult(
            success_count=success_count,
            failure_count=len(errors),
            errors=errors
        )
    
    async def export_categories(
        self,
        include_inactive: bool = False
    ) -> List[CategoryExport]:
        """Export categories data.
        
        Args:
            include_inactive: Include inactive categories
            
        Returns:
            List of category export data
        """
        categories = await self.repository.list(
            skip=0,
            limit=10000,  # Large limit for export
            include_inactive=include_inactive
        )
        
        export_data = []
        for category in categories:
            export_item = CategoryExport(
                id=category.id,
                name=category.name,
                parent_category_id=category.parent_category_id,
                category_path=category.category_path,
                category_level=category.category_level,
                display_order=category.display_order,
                is_leaf=category.is_leaf,
                is_active=category.is_active,
                created_at=category.created_at,
                updated_at=category.updated_at,
                created_by=category.created_by,
                updated_by=category.updated_by,
                child_count=category.child_count,
                item_count=category.item_count
            )
            export_data.append(export_item)
        
        return export_data
    
    async def import_categories(
        self,
        import_data: List[CategoryImport],
        created_by: Optional[str] = None
    ) -> CategoryImportResult:
        """Import categories data.
        
        Args:
            import_data: List of category import data
            created_by: User importing the data
            
        Returns:
            Import operation result
        """
        total_processed = len(import_data)
        successful_imports = 0
        failed_imports = 0
        skipped_imports = 0
        errors = []
        
        for row, category_data in enumerate(import_data, 1):
            try:
                # Find parent category if specified
                parent_id = None
                if category_data.parent_category_path:
                    parent_category = await self.repository.get_by_path(
                        category_data.parent_category_path
                    )
                    if parent_category:
                        parent_id = parent_category.id
                    else:
                        errors.append({
                            "row": row,
                            "error": f"Parent category '{category_data.parent_category_path}' not found"
                        })
                        failed_imports += 1
                        continue
                
                # Check if category already exists
                if await self.repository.exists_by_name_and_parent(
                    category_data.name, parent_id
                ):
                    skipped_imports += 1
                    continue
                
                # Create category
                create_request = CategoryCreate(
                    name=category_data.name,
                    parent_category_id=parent_id,
                    display_order=category_data.display_order
                )
                
                await self.create_category(create_request, created_by=created_by)
                successful_imports += 1
                
            except Exception as e:
                failed_imports += 1
                errors.append({
                    "row": row,
                    "error": str(e)
                })
        
        return CategoryImportResult(
            total_processed=total_processed,
            successful_imports=successful_imports,
            failed_imports=failed_imports,
            skipped_imports=skipped_imports,
            errors=errors
        )
    
    async def validate_category_operation(
        self,
        category_id: UUID,
        operation: str,
        data: Optional[Dict[str, Any]] = None
    ) -> CategoryValidation:
        """Validate category operation.
        
        Args:
            category_id: Category ID
            operation: Operation type (create/update/delete/move)
            data: Operation data
            
        Returns:
            Validation result
        """
        category = await self.repository.get_by_id(category_id)
        
        errors = []
        warnings = []
        can_create = True
        can_update = True
        can_delete = True
        can_move = True
        
        if operation == "delete":
            if category:
                if not category.can_delete():
                    can_delete = False
                    errors.append("Cannot delete category with children or items")
            else:
                can_delete = False
                errors.append("Category not found")
        
        elif operation == "move":
            if category and data and "new_parent_id" in data:
                try:
                    await self._validate_move_operation(category, data["new_parent_id"])
                except Exception as e:
                    can_move = False
                    errors.append(str(e))
        
        return CategoryValidation(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            can_create=can_create,
            can_update=can_update,
            can_delete=can_delete,
            can_move=can_move
        )
    
    async def _validate_move_operation(
        self,
        category: Category,
        new_parent_id: Optional[UUID]
    ):
        """Validate move operation to prevent cycles."""
        if new_parent_id is None:
            return  # Moving to root is always valid
        
        # Check if new parent exists
        new_parent = await self.repository.get_by_id(new_parent_id)
        if not new_parent:
            raise NotFoundError(f"New parent category {new_parent_id} not found")
        
        # Check for cycle - new parent cannot be a descendant of current category
        if new_parent.is_descendant_of(category.category_path):
            raise BusinessRuleError("Cannot move category to its own descendant")
        
        # Check if moving to same parent
        if new_parent_id == category.parent_category_id:
            raise BusinessRuleError("Category is already under this parent")
    
    async def _update_parent_leaf_status(self, parent_id: UUID):
        """Update parent category leaf status based on children."""
        parent = await self.repository.get_by_id(parent_id)
        if not parent:
            return
        
        children = await self.repository.get_by_parent_id(parent_id)
        active_children = [child for child in children if child.is_active]
        
        should_be_leaf = len(active_children) == 0
        
        if parent.is_leaf != should_be_leaf:
            await self.repository.update(
                parent_id,
                {"is_leaf": should_be_leaf}
            )
    
    async def _update_descendant_paths_after_rename(self, category: Category):
        """Update descendant paths after category rename."""
        descendants = await self.repository.get_descendants(category.id)
        
        for descendant in descendants:
            # Calculate new path
            old_segments = descendant.get_path_segments()
            category_segments = category.get_path_segments()
            
            # Replace the category part of the path
            descendant_relative_segments = old_segments[len(category_segments):]
            new_path_segments = category_segments + descendant_relative_segments
            new_path = "/".join(new_path_segments)
            
            # Update descendant
            await self.repository.update(
                descendant.id,
                {"category_path": new_path}
            )
    
    async def _to_response(self, category: Category) -> CategoryResponse:
        """Convert category model to response schema."""
        # Extract all needed attributes first to avoid lazy loading issues
        category_id = category.id
        category_name = category.name
        parent_category_id = category.parent_category_id
        category_path = category.category_path
        category_level = category.category_level
        display_order = category.display_order
        is_leaf = category.is_leaf
        is_active = category.is_active
        created_at = category.created_at
        updated_at = category.updated_at
        created_by = category.created_by
        updated_by = category.updated_by
        item_count = category.item_count
        
        # Calculate child count efficiently without loading all children
        child_count = 0
        if not is_leaf:
            # Use a simple count query instead of loading all children
            from sqlalchemy import select, func
            from .models import Category as CategoryModel
            
            stmt = select(func.count(CategoryModel.id)).where(
                CategoryModel.parent_category_id == category_id,
                CategoryModel.is_active == True
            )
            result = await self.repository.session.execute(stmt)
            child_count = result.scalar() or 0
        
        return CategoryResponse(
            id=category_id,
            name=category_name,
            parent_category_id=parent_category_id,
            category_path=category_path,
            category_level=category_level,
            display_order=display_order,
            is_leaf=is_leaf,
            is_active=is_active,
            created_at=created_at,
            updated_at=updated_at,
            created_by=created_by,
            updated_by=updated_by,
            child_count=child_count,
            item_count=item_count,
            can_have_items=category.can_have_items(),
            can_have_children=category.can_have_children(),
            can_delete=category.can_delete(),
            is_root=category.is_root(),
            has_children=category.has_children,
            has_items=category.has_items,
            breadcrumb=category.get_breadcrumb(),
            full_name=category.full_name
        )
    
    async def _to_summary(self, category: Category) -> CategorySummary:
        """Convert category model to summary schema."""
        # Avoid accessing category.id multiple times to prevent lazy loading issues
        # Extract all needed attributes first
        category_id = category.id
        category_name = category.name
        category_path = category.category_path
        category_level = category.category_level
        parent_category_id = category.parent_category_id
        display_order = category.display_order
        is_leaf = category.is_leaf
        is_active = category.is_active
        item_count = category.item_count
        
        # Calculate child count efficiently without loading all children
        child_count = 0
        if not is_leaf:
            # Use a simple count query instead of loading all children
            from sqlalchemy import select, func
            from .models import Category as CategoryModel
            
            stmt = select(func.count(CategoryModel.id)).where(
                CategoryModel.parent_category_id == category_id,
                CategoryModel.is_active == True
            )
            result = await self.repository.session.execute(stmt)
            child_count = result.scalar() or 0
        
        return CategorySummary(
            id=category_id,
            name=category_name,
            category_path=category_path,
            category_level=category_level,
            parent_category_id=parent_category_id,
            display_order=display_order,
            is_leaf=is_leaf,
            is_active=is_active,
            child_count=child_count,
            item_count=item_count
        )

===== modules/analytics/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""Analytics module for business intelligence and reporting."""

from .models import (
    AnalyticsReport,
    BusinessMetric,
    SystemAlert,
    ReportType,
    ReportStatus,
    ReportFormat,
    MetricType,
    AlertSeverity,
    AlertStatus,
)

__all__ = [
    "AnalyticsReport",
    "BusinessMetric", 
    "SystemAlert",
    "ReportType",
    "ReportStatus",
    "ReportFormat",
    "MetricType",
    "AlertSeverity",
    "AlertStatus",
]

===== modules/analytics/models.py â€“ 2025-07-19 12:13:41 IST =====
from enum import Enum
from typing import Optional, Dict, Any, List
from decimal import Decimal
from datetime import datetime, date
from sqlalchemy import Column, String, Numeric, Boolean, Text, DateTime, ForeignKey, Index, JSON
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property

from app.db.base import BaseModel, UUIDType


class ReportType(str, Enum):
    """Report type enumeration."""
    SALES = "SALES"
    RENTALS = "RENTALS"
    INVENTORY = "INVENTORY"
    CUSTOMER = "CUSTOMER"
    SUPPLIER = "SUPPLIER"
    FINANCIAL = "FINANCIAL"
    PERFORMANCE = "PERFORMANCE"
    SYSTEM = "SYSTEM"


class ReportStatus(str, Enum):
    """Report status enumeration."""
    PENDING = "PENDING"
    GENERATING = "GENERATING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


class ReportFormat(str, Enum):
    """Report format enumeration."""
    PDF = "PDF"
    EXCEL = "EXCEL"
    CSV = "CSV"
    JSON = "JSON"


class MetricType(str, Enum):
    """Metric type enumeration."""
    COUNTER = "COUNTER"
    GAUGE = "GAUGE"
    HISTOGRAM = "HISTOGRAM"
    PERCENTAGE = "PERCENTAGE"
    CURRENCY = "CURRENCY"


class AlertSeverity(str, Enum):
    """Alert severity enumeration."""
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"


class AlertStatus(str, Enum):
    """Alert status enumeration."""
    ACTIVE = "ACTIVE"
    RESOLVED = "RESOLVED"
    ACKNOWLEDGED = "ACKNOWLEDGED"
    SUPPRESSED = "SUPPRESSED"


class AnalyticsReport(BaseModel):
    """
    Analytics report model for generating and storing business reports.
    
    Attributes:
        report_name: Name of the report
        report_type: Type of report (SALES, RENTALS, etc.)
        report_format: Format of the report (PDF, EXCEL, CSV, JSON)
        report_status: Current status of the report
        start_date: Start date for report data
        end_date: End date for report data
        filters: JSON filters applied to the report
        parameters: Additional report parameters
        file_path: Path to the generated report file
        file_size: Size of the generated report file in bytes
        generated_by: User who generated the report
        generated_at: When the report was generated
        error_message: Error message if report generation failed
        report_metadata: Additional metadata about the report
    """
    
    __tablename__ = "analytics_reports"
    
    report_name = Column(String(200), nullable=False, comment="Name of the report")
    report_type = Column(String(20), nullable=False, comment="Type of report")
    report_format = Column(String(10), nullable=False, comment="Format of the report")
    report_status = Column(String(20), nullable=False, default=ReportStatus.PENDING.value, comment="Current status")
    start_date = Column(DateTime, nullable=True, comment="Start date for report data")
    end_date = Column(DateTime, nullable=True, comment="End date for report data")
    filters = Column(JSON, nullable=True, comment="JSON filters applied to the report")
    parameters = Column(JSON, nullable=True, comment="Additional report parameters")
    file_path = Column(String(500), nullable=True, comment="Path to the generated report file")
    file_size = Column(String(20), nullable=True, comment="Size of the generated report file")
    generated_by = Column(UUIDType(), nullable=False, comment="User who generated the report")  # ForeignKey("users.id") - temporarily disabled
    generated_at = Column(DateTime, nullable=True, comment="When the report was generated")
    error_message = Column(Text, nullable=True, comment="Error message if generation failed")
    report_metadata = Column(JSON, nullable=True, comment="Additional metadata about the report")
    
    # Relationships
    # generated_by_user = relationship("User", back_populates="generated_reports", lazy="select")  # Temporarily disabled
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_analytics_report_type', 'report_type'),
        Index('idx_analytics_report_status', 'report_status'),
        Index('idx_analytics_report_generated_by', 'generated_by'),
        Index('idx_analytics_report_generated_at', 'generated_at'),
        Index('idx_analytics_report_date_range', 'start_date', 'end_date'),
# Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        report_name: str,
        report_type: ReportType,
        report_format: ReportFormat,
        generated_by: str,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        filters: Optional[Dict[str, Any]] = None,
        parameters: Optional[Dict[str, Any]] = None,
        **kwargs
    ):
        """
        Initialize an Analytics Report.
        
        Args:
            report_name: Name of the report
            report_type: Type of report
            report_format: Format of the report
            generated_by: User who generated the report
            start_date: Start date for report data
            end_date: End date for report data
            filters: JSON filters applied to the report
            parameters: Additional report parameters
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.report_name = report_name
        self.report_type = report_type.value if isinstance(report_type, ReportType) else report_type
        self.report_format = report_format.value if isinstance(report_format, ReportFormat) else report_format
        self.generated_by = generated_by
        self.start_date = start_date
        self.end_date = end_date
        self.filters = filters or {}
        self.parameters = parameters or {}
        self.report_status = ReportStatus.PENDING.value
        self._validate()
    
    def _validate(self):
        """Validate analytics report business rules."""
        if not self.report_name or not self.report_name.strip():
            raise ValueError("Report name cannot be empty")
        
        if len(self.report_name) > 200:
            raise ValueError("Report name cannot exceed 200 characters")
        
        if self.report_type not in [rt.value for rt in ReportType]:
            raise ValueError(f"Invalid report type: {self.report_type}")
        
        if self.report_format not in [rf.value for rf in ReportFormat]:
            raise ValueError(f"Invalid report format: {self.report_format}")
        
        if self.start_date and self.end_date and self.start_date > self.end_date:
            raise ValueError("Start date cannot be after end date")
    
    def start_generation(self):
        """Start report generation."""
        self.report_status = ReportStatus.GENERATING.value
        self.generated_at = datetime.utcnow()
    
    def complete_generation(self, file_path: str, file_size: int):
        """Complete report generation."""
        self.report_status = ReportStatus.COMPLETED.value
        self.file_path = file_path
        self.file_size = str(file_size)
        self.error_message = None
    
    def fail_generation(self, error_message: str):
        """Fail report generation."""
        self.report_status = ReportStatus.FAILED.value
        self.error_message = error_message
    
    def cancel_generation(self):
        """Cancel report generation."""
        self.report_status = ReportStatus.CANCELLED.value
    
    def is_completed(self) -> bool:
        """Check if report generation is completed."""
        return self.report_status == ReportStatus.COMPLETED.value
    
    def is_failed(self) -> bool:
        """Check if report generation failed."""
        return self.report_status == ReportStatus.FAILED.value
    
    @property
    def display_name(self) -> str:
        """Get report display name."""
        return f"{self.report_name} ({self.report_type})"
    
    @property
    def file_size_mb(self) -> Optional[float]:
        """Get file size in MB."""
        if self.file_size:
            try:
                return float(self.file_size) / (1024 * 1024)
            except ValueError:
                return None
        return None
    
    def __str__(self) -> str:
        """String representation of analytics report."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of analytics report."""
        return (
            f"AnalyticsReport(id={self.id}, name='{self.report_name}', "
            f"type='{self.report_type}', status='{self.report_status}', "
            f"active={self.is_active})"
        )


class BusinessMetric(BaseModel):
    """
    Business metric model for tracking key performance indicators.
    
    Attributes:
        metric_name: Name of the metric
        metric_type: Type of metric (COUNTER, GAUGE, etc.)
        category: Category of the metric
        current_value: Current value of the metric
        previous_value: Previous value of the metric
        target_value: Target value for the metric
        unit: Unit of measurement
        calculation_method: How the metric is calculated
        tracked_date: Date when the metric was tracked
        metric_metadata: Additional metadata about the metric
    """
    
    __tablename__ = "business_metrics"
    
    metric_name = Column(String(100), nullable=False, comment="Name of the metric")
    metric_type = Column(String(20), nullable=False, comment="Type of metric")
    category = Column(String(50), nullable=False, comment="Category of the metric")
    current_value = Column(Numeric(15, 4), nullable=False, comment="Current value of the metric")
    previous_value = Column(Numeric(15, 4), nullable=True, comment="Previous value of the metric")
    target_value = Column(Numeric(15, 4), nullable=True, comment="Target value for the metric")
    unit = Column(String(20), nullable=True, comment="Unit of measurement")
    calculation_method = Column(Text, nullable=True, comment="How the metric is calculated")
    tracked_date = Column(DateTime, nullable=False, default=datetime.utcnow, comment="Date when tracked")
    metric_metadata = Column(JSON, nullable=True, comment="Additional metadata about the metric")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_business_metric_name', 'metric_name'),
        Index('idx_business_metric_type', 'metric_type'),
        Index('idx_business_metric_category', 'category'),
        Index('idx_business_metric_tracked_date', 'tracked_date'),
        Index('idx_business_metric_name_date', 'metric_name', 'tracked_date'),
# Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        metric_name: str,
        metric_type: MetricType,
        category: str,
        current_value: Decimal,
        previous_value: Optional[Decimal] = None,
        target_value: Optional[Decimal] = None,
        unit: Optional[str] = None,
        calculation_method: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a Business Metric.
        
        Args:
            metric_name: Name of the metric
            metric_type: Type of metric
            category: Category of the metric
            current_value: Current value of the metric
            previous_value: Previous value of the metric
            target_value: Target value for the metric
            unit: Unit of measurement
            calculation_method: How the metric is calculated
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.metric_name = metric_name
        self.metric_type = metric_type.value if isinstance(metric_type, MetricType) else metric_type
        self.category = category
        self.current_value = current_value
        self.previous_value = previous_value
        self.target_value = target_value
        self.unit = unit
        self.calculation_method = calculation_method
        self.tracked_date = datetime.utcnow()
        self._validate()
    
    def _validate(self):
        """Validate business metric business rules."""
        if not self.metric_name or not self.metric_name.strip():
            raise ValueError("Metric name cannot be empty")
        
        if len(self.metric_name) > 100:
            raise ValueError("Metric name cannot exceed 100 characters")
        
        if not self.category or not self.category.strip():
            raise ValueError("Category cannot be empty")
        
        if len(self.category) > 50:
            raise ValueError("Category cannot exceed 50 characters")
        
        if self.metric_type not in [mt.value for mt in MetricType]:
            raise ValueError(f"Invalid metric type: {self.metric_type}")
        
        if self.unit and len(self.unit) > 20:
            raise ValueError("Unit cannot exceed 20 characters")
    
    def update_value(self, new_value: Decimal):
        """Update metric value."""
        self.previous_value = self.current_value
        self.current_value = new_value
        self.tracked_date = datetime.utcnow()
    
    def get_change_percentage(self) -> Optional[Decimal]:
        """Get percentage change from previous value."""
        if self.previous_value is None or self.previous_value == 0:
            return None
        
        change = ((self.current_value - self.previous_value) / self.previous_value) * 100
        return change.quantize(Decimal('0.01'))
    
    def get_target_achievement(self) -> Optional[Decimal]:
        """Get target achievement percentage."""
        if self.target_value is None or self.target_value == 0:
            return None
        
        achievement = (self.current_value / self.target_value) * 100
        return achievement.quantize(Decimal('0.01'))
    
    def is_target_met(self) -> bool:
        """Check if target is met."""
        if self.target_value is None:
            return False
        return self.current_value >= self.target_value
    
    @property
    def display_name(self) -> str:
        """Get metric display name."""
        return f"{self.metric_name} ({self.category})"
    
    @property
    def formatted_value(self) -> str:
        """Get formatted current value."""
        if self.unit:
            return f"{self.current_value} {self.unit}"
        return str(self.current_value)
    
    def __str__(self) -> str:
        """String representation of business metric."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of business metric."""
        return (
            f"BusinessMetric(id={self.id}, name='{self.metric_name}', "
            f"type='{self.metric_type}', value={self.current_value}, "
            f"active={self.is_active})"
        )


class SystemAlert(BaseModel):
    """
    System alert model for monitoring and alerting.
    
    Attributes:
        alert_name: Name of the alert
        alert_type: Type of alert (SYSTEM, BUSINESS, PERFORMANCE)
        severity: Severity level of the alert
        status: Current status of the alert
        message: Alert message
        description: Detailed description of the alert
        source: Source of the alert
        trigger_condition: Condition that triggered the alert
        resolution_notes: Notes on how the alert was resolved
        acknowledged_by: User who acknowledged the alert
        acknowledged_at: When the alert was acknowledged
        resolved_by: User who resolved the alert
        resolved_at: When the alert was resolved
        alert_metadata: Additional metadata about the alert
    """
    
    __tablename__ = "system_alerts"
    
    alert_name = Column(String(100), nullable=False, comment="Name of the alert")
    alert_type = Column(String(20), nullable=False, comment="Type of alert")
    severity = Column(String(20), nullable=False, comment="Severity level of the alert")
    status = Column(String(20), nullable=False, default=AlertStatus.ACTIVE.value, comment="Current status")
    message = Column(Text, nullable=False, comment="Alert message")
    description = Column(Text, nullable=True, comment="Detailed description of the alert")
    source = Column(String(100), nullable=True, comment="Source of the alert")
    trigger_condition = Column(Text, nullable=True, comment="Condition that triggered the alert")
    resolution_notes = Column(Text, nullable=True, comment="Notes on how the alert was resolved")
    acknowledged_by = Column(UUIDType(), nullable=True, comment="User who acknowledged the alert")  # ForeignKey("users.id") - temporarily disabled
    acknowledged_at = Column(DateTime, nullable=True, comment="When the alert was acknowledged")
    resolved_by = Column(UUIDType(), nullable=True, comment="User who resolved the alert")  # ForeignKey("users.id") - temporarily disabled
    resolved_at = Column(DateTime, nullable=True, comment="When the alert was resolved")
    alert_metadata = Column(JSON, nullable=True, comment="Additional metadata about the alert")
    
    # Relationships
    # acknowledged_by_user = relationship("User", foreign_keys=[acknowledged_by], back_populates="acknowledged_alerts", lazy="select")  # Temporarily disabled
    # resolved_by_user = relationship("User", foreign_keys=[resolved_by], back_populates="resolved_alerts", lazy="select")  # Temporarily disabled
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('idx_system_alert_name', 'alert_name'),
        Index('idx_system_alert_type', 'alert_type'),
        Index('idx_system_alert_severity', 'severity'),
        Index('idx_system_alert_status', 'status'),
        Index('idx_system_alert_source', 'source'),
        Index('idx_system_alert_created_at', 'created_at'),
        Index('idx_system_alert_severity_status', 'severity', 'status'),
# Removed is_active index - column is inherited from BaseModel
    )
    
    def __init__(
        self,
        alert_name: str,
        alert_type: str,
        severity: AlertSeverity,
        message: str,
        description: Optional[str] = None,
        source: Optional[str] = None,
        trigger_condition: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a System Alert.
        
        Args:
            alert_name: Name of the alert
            alert_type: Type of alert
            severity: Severity level of the alert
            message: Alert message
            description: Detailed description of the alert
            source: Source of the alert
            trigger_condition: Condition that triggered the alert
            **kwargs: Additional BaseModel fields
        """
        super().__init__(**kwargs)
        self.alert_name = alert_name
        self.alert_type = alert_type
        self.severity = severity.value if isinstance(severity, AlertSeverity) else severity
        self.message = message
        self.description = description
        self.source = source
        self.trigger_condition = trigger_condition
        self.status = AlertStatus.ACTIVE.value
        self._validate()
    
    def _validate(self):
        """Validate system alert business rules."""
        if not self.alert_name or not self.alert_name.strip():
            raise ValueError("Alert name cannot be empty")
        
        if len(self.alert_name) > 100:
            raise ValueError("Alert name cannot exceed 100 characters")
        
        if not self.alert_type or not self.alert_type.strip():
            raise ValueError("Alert type cannot be empty")
        
        if len(self.alert_type) > 20:
            raise ValueError("Alert type cannot exceed 20 characters")
        
        if self.severity not in [s.value for s in AlertSeverity]:
            raise ValueError(f"Invalid severity: {self.severity}")
        
        if not self.message or not self.message.strip():
            raise ValueError("Alert message cannot be empty")
        
        if self.source and len(self.source) > 100:
            raise ValueError("Source cannot exceed 100 characters")
    
    def acknowledge(self, acknowledged_by: str, notes: Optional[str] = None):
        """Acknowledge the alert."""
        self.status = AlertStatus.ACKNOWLEDGED.value
        self.acknowledged_by = acknowledged_by
        self.acknowledged_at = datetime.utcnow()
        
        if notes:
            self.resolution_notes = notes
    
    def resolve(self, resolved_by: str, resolution_notes: str):
        """Resolve the alert."""
        self.status = AlertStatus.RESOLVED.value
        self.resolved_by = resolved_by
        self.resolved_at = datetime.utcnow()
        self.resolution_notes = resolution_notes
    
    def suppress(self):
        """Suppress the alert."""
        self.status = AlertStatus.SUPPRESSED.value
    
    def is_active(self) -> bool:
        """Check if alert is active."""
        return self.status == AlertStatus.ACTIVE.value
    
    def is_resolved(self) -> bool:
        """Check if alert is resolved."""
        return self.status == AlertStatus.RESOLVED.value
    
    def is_critical(self) -> bool:
        """Check if alert is critical."""
        return self.severity == AlertSeverity.CRITICAL.value
    
    @property
    def display_name(self) -> str:
        """Get alert display name."""
        return f"{self.alert_name} ({self.severity})"
    
    @property
    def duration(self) -> Optional[int]:
        """Get alert duration in minutes."""
        if self.resolved_at:
            return int((self.resolved_at - self.created_at).total_seconds() / 60)
        return int((datetime.utcnow() - self.created_at).total_seconds() / 60)
    
    def __str__(self) -> str:
        """String representation of system alert."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of system alert."""
        return (
            f"SystemAlert(id={self.id}, name='{self.alert_name}', "
            f"severity='{self.severity}', status='{self.status}', "
            f"active={self.is_active})"
        )

===== modules/analytics/repository.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from datetime import datetime, date
from decimal import Decimal
from sqlalchemy import and_, or_, func, select, update, delete, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload, joinedload

from app.modules.analytics.models import (
    AnalyticsReport, BusinessMetric, SystemAlert,
    ReportType, ReportStatus, ReportFormat, MetricType,
    AlertSeverity, AlertStatus
)
from app.modules.analytics.schemas import (
    AnalyticsReportCreate, AnalyticsReportUpdate,
    BusinessMetricCreate, BusinessMetricUpdate,
    SystemAlertCreate, SystemAlertUpdate,
    AnalyticsSearch, MetricSearch, AlertSearch
)


class AnalyticsReportRepository:
    """Repository for AnalyticsReport operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def create(self, report_data: AnalyticsReportCreate, generated_by: UUID) -> AnalyticsReport:
        """Create a new analytics report."""
        report = AnalyticsReport(
            report_name=report_data.report_name,
            report_type=report_data.report_type,
            report_format=report_data.report_format,
            generated_by=str(generated_by),
            start_date=report_data.start_date,
            end_date=report_data.end_date,
            filters=report_data.filters,
            parameters=report_data.parameters
        )
        
        self.session.add(report)
        await self.session.commit()
        await self.session.refresh(report)
        return report
    
    async def get_by_id(self, report_id: UUID) -> Optional[AnalyticsReport]:
        """Get analytics report by ID."""
        query = select(AnalyticsReport).where(AnalyticsReport.id == report_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        report_type: Optional[ReportType] = None,
        report_status: Optional[ReportStatus] = None,
        generated_by: Optional[UUID] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        active_only: bool = True
    ) -> List[AnalyticsReport]:
        """Get all analytics reports with optional filtering."""
        query = select(AnalyticsReport)
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(AnalyticsReport.is_active == True)
        if report_type:
            conditions.append(AnalyticsReport.report_type == report_type.value)
        if report_status:
            conditions.append(AnalyticsReport.report_status == report_status.value)
        if generated_by:
            conditions.append(AnalyticsReport.generated_by == str(generated_by))
        if start_date:
            conditions.append(AnalyticsReport.start_date >= start_date)
        if end_date:
            conditions.append(AnalyticsReport.end_date <= end_date)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(desc(AnalyticsReport.created_at)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def search(
        self, 
        search_params: AnalyticsSearch,
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[AnalyticsReport]:
        """Search analytics reports."""
        query = select(AnalyticsReport)
        
        conditions = []
        if active_only:
            conditions.append(AnalyticsReport.is_active == True)
        
        if search_params.report_type:
            conditions.append(AnalyticsReport.report_type == search_params.report_type.value)
        if search_params.report_status:
            conditions.append(AnalyticsReport.report_status == search_params.report_status.value)
        if search_params.generated_by:
            conditions.append(AnalyticsReport.generated_by == str(search_params.generated_by))
        if search_params.start_date:
            conditions.append(AnalyticsReport.start_date >= search_params.start_date)
        if search_params.end_date:
            conditions.append(AnalyticsReport.end_date <= search_params.end_date)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(desc(AnalyticsReport.created_at)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update(self, report_id: UUID, report_data: AnalyticsReportUpdate) -> Optional[AnalyticsReport]:
        """Update an analytics report."""
        query = select(AnalyticsReport).where(AnalyticsReport.id == report_id)
        result = await self.session.execute(query)
        report = result.scalar_one_or_none()
        
        if not report:
            return None
        
        # Update fields
        update_data = report_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(report, field, value)
        
        await self.session.commit()
        await self.session.refresh(report)
        return report
    
    async def delete(self, report_id: UUID) -> bool:
        """Soft delete an analytics report."""
        query = select(AnalyticsReport).where(AnalyticsReport.id == report_id)
        result = await self.session.execute(query)
        report = result.scalar_one_or_none()
        
        if not report:
            return False
        
        report.is_active = False
        await self.session.commit()
        return True
    
    async def get_by_type(self, report_type: ReportType, limit: int = 10) -> List[AnalyticsReport]:
        """Get reports by type."""
        query = select(AnalyticsReport).where(
            and_(
                AnalyticsReport.report_type == report_type.value,
                AnalyticsReport.is_active == True
            )
        ).order_by(desc(AnalyticsReport.created_at)).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_status(self, status: ReportStatus, limit: int = 10) -> List[AnalyticsReport]:
        """Get reports by status."""
        query = select(AnalyticsReport).where(
            and_(
                AnalyticsReport.report_status == status.value,
                AnalyticsReport.is_active == True
            )
        ).order_by(desc(AnalyticsReport.created_at)).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_pending_reports(self) -> List[AnalyticsReport]:
        """Get pending reports."""
        return await self.get_by_status(ReportStatus.PENDING)
    
    async def get_failed_reports(self) -> List[AnalyticsReport]:
        """Get failed reports."""
        return await self.get_by_status(ReportStatus.FAILED)
    
    async def count_by_status(self, status: ReportStatus) -> int:
        """Count reports by status."""
        query = select(func.count(AnalyticsReport.id)).where(
            and_(
                AnalyticsReport.report_status == status.value,
                AnalyticsReport.is_active == True
            )
        )
        result = await self.session.execute(query)
        return result.scalar()
    
    async def get_report_summary(self) -> Dict[str, Any]:
        """Get report summary statistics."""
        query = select(AnalyticsReport).where(AnalyticsReport.is_active == True)
        result = await self.session.execute(query)
        reports = result.scalars().all()
        
        total_reports = len(reports)
        pending_reports = len([r for r in reports if r.report_status == ReportStatus.PENDING.value])
        completed_reports = len([r for r in reports if r.report_status == ReportStatus.COMPLETED.value])
        failed_reports = len([r for r in reports if r.report_status == ReportStatus.FAILED.value])
        
        # Count by type
        type_counts = {}
        for report_type in ReportType:
            type_counts[report_type.value] = len([r for r in reports if r.report_type == report_type.value])
        
        return {
            'total_reports': total_reports,
            'pending_reports': pending_reports,
            'completed_reports': completed_reports,
            'failed_reports': failed_reports,
            'reports_by_type': type_counts
        }


class BusinessMetricRepository:
    """Repository for BusinessMetric operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def create(self, metric_data: BusinessMetricCreate) -> BusinessMetric:
        """Create a new business metric."""
        metric = BusinessMetric(
            metric_name=metric_data.metric_name,
            metric_type=metric_data.metric_type,
            category=metric_data.category,
            current_value=metric_data.current_value,
            previous_value=metric_data.previous_value,
            target_value=metric_data.target_value,
            unit=metric_data.unit,
            calculation_method=metric_data.calculation_method
        )
        
        self.session.add(metric)
        await self.session.commit()
        await self.session.refresh(metric)
        return metric
    
    async def get_by_id(self, metric_id: UUID) -> Optional[BusinessMetric]:
        """Get business metric by ID."""
        query = select(BusinessMetric).where(BusinessMetric.id == metric_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_name(self, metric_name: str) -> Optional[BusinessMetric]:
        """Get business metric by name."""
        query = select(BusinessMetric).where(
            and_(
                BusinessMetric.metric_name == metric_name,
                BusinessMetric.is_active == True
            )
        )
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        metric_type: Optional[MetricType] = None,
        category: Optional[str] = None,
        has_target: Optional[bool] = None,
        active_only: bool = True
    ) -> List[BusinessMetric]:
        """Get all business metrics with optional filtering."""
        query = select(BusinessMetric)
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(BusinessMetric.is_active == True)
        if metric_type:
            conditions.append(BusinessMetric.metric_type == metric_type.value)
        if category:
            conditions.append(BusinessMetric.category == category)
        if has_target is not None:
            if has_target:
                conditions.append(BusinessMetric.target_value.is_not(None))
            else:
                conditions.append(BusinessMetric.target_value.is_(None))
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(desc(BusinessMetric.tracked_date)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def search(
        self, 
        search_params: MetricSearch,
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[BusinessMetric]:
        """Search business metrics."""
        query = select(BusinessMetric)
        
        conditions = []
        if active_only:
            conditions.append(BusinessMetric.is_active == True)
        
        if search_params.metric_type:
            conditions.append(BusinessMetric.metric_type == search_params.metric_type.value)
        if search_params.category:
            conditions.append(BusinessMetric.category == search_params.category)
        if search_params.has_target is not None:
            if search_params.has_target:
                conditions.append(BusinessMetric.target_value.is_not(None))
            else:
                conditions.append(BusinessMetric.target_value.is_(None))
        if search_params.target_met is not None:
            if search_params.target_met:
                conditions.append(BusinessMetric.current_value >= BusinessMetric.target_value)
            else:
                conditions.append(BusinessMetric.current_value < BusinessMetric.target_value)
        if search_params.tracked_from:
            conditions.append(BusinessMetric.tracked_date >= search_params.tracked_from)
        if search_params.tracked_to:
            conditions.append(BusinessMetric.tracked_date <= search_params.tracked_to)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(desc(BusinessMetric.tracked_date)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update(self, metric_id: UUID, metric_data: BusinessMetricUpdate) -> Optional[BusinessMetric]:
        """Update a business metric."""
        query = select(BusinessMetric).where(BusinessMetric.id == metric_id)
        result = await self.session.execute(query)
        metric = result.scalar_one_or_none()
        
        if not metric:
            return None
        
        # Update fields
        update_data = metric_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(metric, field, value)
        
        await self.session.commit()
        await self.session.refresh(metric)
        return metric
    
    async def delete(self, metric_id: UUID) -> bool:
        """Soft delete a business metric."""
        query = select(BusinessMetric).where(BusinessMetric.id == metric_id)
        result = await self.session.execute(query)
        metric = result.scalar_one_or_none()
        
        if not metric:
            return False
        
        metric.is_active = False
        await self.session.commit()
        return True
    
    async def get_by_category(self, category: str) -> List[BusinessMetric]:
        """Get metrics by category."""
        query = select(BusinessMetric).where(
            and_(
                BusinessMetric.category == category,
                BusinessMetric.is_active == True
            )
        ).order_by(desc(BusinessMetric.tracked_date))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_metrics_with_targets(self) -> List[BusinessMetric]:
        """Get metrics that have targets set."""
        query = select(BusinessMetric).where(
            and_(
                BusinessMetric.target_value.is_not(None),
                BusinessMetric.is_active == True
            )
        ).order_by(desc(BusinessMetric.tracked_date))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_metrics_meeting_targets(self) -> List[BusinessMetric]:
        """Get metrics that are meeting their targets."""
        query = select(BusinessMetric).where(
            and_(
                BusinessMetric.target_value.is_not(None),
                BusinessMetric.current_value >= BusinessMetric.target_value,
                BusinessMetric.is_active == True
            )
        ).order_by(desc(BusinessMetric.tracked_date))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_metric_history(self, metric_name: str, limit: int = 30) -> List[BusinessMetric]:
        """Get metric history by name."""
        query = select(BusinessMetric).where(
            and_(
                BusinessMetric.metric_name == metric_name,
                BusinessMetric.is_active == True
            )
        ).order_by(desc(BusinessMetric.tracked_date)).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()


class SystemAlertRepository:
    """Repository for SystemAlert operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def create(self, alert_data: SystemAlertCreate) -> SystemAlert:
        """Create a new system alert."""
        alert = SystemAlert(
            alert_name=alert_data.alert_name,
            alert_type=alert_data.alert_type,
            severity=alert_data.severity,
            message=alert_data.message,
            description=alert_data.description,
            source=alert_data.source,
            trigger_condition=alert_data.trigger_condition
        )
        
        self.session.add(alert)
        await self.session.commit()
        await self.session.refresh(alert)
        return alert
    
    async def get_by_id(self, alert_id: UUID) -> Optional[SystemAlert]:
        """Get system alert by ID."""
        query = select(SystemAlert).where(SystemAlert.id == alert_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        alert_type: Optional[str] = None,
        severity: Optional[AlertSeverity] = None,
        status: Optional[AlertStatus] = None,
        source: Optional[str] = None,
        active_only: bool = True
    ) -> List[SystemAlert]:
        """Get all system alerts with optional filtering."""
        query = select(SystemAlert)
        
        # Apply filters
        conditions = []
        if active_only:
            conditions.append(SystemAlert.is_active == True)
        if alert_type:
            conditions.append(SystemAlert.alert_type == alert_type)
        if severity:
            conditions.append(SystemAlert.severity == severity.value)
        if status:
            conditions.append(SystemAlert.status == status.value)
        if source:
            conditions.append(SystemAlert.source == source)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(desc(SystemAlert.created_at)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def search(
        self, 
        search_params: AlertSearch,
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[SystemAlert]:
        """Search system alerts."""
        query = select(SystemAlert)
        
        conditions = []
        if active_only:
            conditions.append(SystemAlert.is_active == True)
        
        if search_params.alert_type:
            conditions.append(SystemAlert.alert_type == search_params.alert_type)
        if search_params.severity:
            conditions.append(SystemAlert.severity == search_params.severity.value)
        if search_params.status:
            conditions.append(SystemAlert.status == search_params.status.value)
        if search_params.source:
            conditions.append(SystemAlert.source == search_params.source)
        if search_params.created_from:
            conditions.append(SystemAlert.created_at >= search_params.created_from)
        if search_params.created_to:
            conditions.append(SystemAlert.created_at <= search_params.created_to)
        if search_params.resolved_from:
            conditions.append(SystemAlert.resolved_at >= search_params.resolved_from)
        if search_params.resolved_to:
            conditions.append(SystemAlert.resolved_at <= search_params.resolved_to)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(desc(SystemAlert.created_at)).offset(skip).limit(limit)
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update(self, alert_id: UUID, alert_data: SystemAlertUpdate) -> Optional[SystemAlert]:
        """Update a system alert."""
        query = select(SystemAlert).where(SystemAlert.id == alert_id)
        result = await self.session.execute(query)
        alert = result.scalar_one_or_none()
        
        if not alert:
            return None
        
        # Update fields
        update_data = alert_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(alert, field, value)
        
        await self.session.commit()
        await self.session.refresh(alert)
        return alert
    
    async def delete(self, alert_id: UUID) -> bool:
        """Soft delete a system alert."""
        query = select(SystemAlert).where(SystemAlert.id == alert_id)
        result = await self.session.execute(query)
        alert = result.scalar_one_or_none()
        
        if not alert:
            return False
        
        alert.is_active = False
        await self.session.commit()
        return True
    
    async def get_active_alerts(self) -> List[SystemAlert]:
        """Get active alerts."""
        query = select(SystemAlert).where(
            and_(
                SystemAlert.status == AlertStatus.ACTIVE.value,
                SystemAlert.is_active == True
            )
        ).order_by(desc(SystemAlert.created_at))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_critical_alerts(self) -> List[SystemAlert]:
        """Get critical alerts."""
        query = select(SystemAlert).where(
            and_(
                SystemAlert.severity == AlertSeverity.CRITICAL.value,
                SystemAlert.status == AlertStatus.ACTIVE.value,
                SystemAlert.is_active == True
            )
        ).order_by(desc(SystemAlert.created_at))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_severity(self, severity: AlertSeverity) -> List[SystemAlert]:
        """Get alerts by severity."""
        query = select(SystemAlert).where(
            and_(
                SystemAlert.severity == severity.value,
                SystemAlert.is_active == True
            )
        ).order_by(desc(SystemAlert.created_at))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def get_by_status(self, status: AlertStatus) -> List[SystemAlert]:
        """Get alerts by status."""
        query = select(SystemAlert).where(
            and_(
                SystemAlert.status == status.value,
                SystemAlert.is_active == True
            )
        ).order_by(desc(SystemAlert.created_at))
        
        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def count_by_severity(self, severity: AlertSeverity) -> int:
        """Count alerts by severity."""
        query = select(func.count(SystemAlert.id)).where(
            and_(
                SystemAlert.severity == severity.value,
                SystemAlert.status == AlertStatus.ACTIVE.value,
                SystemAlert.is_active == True
            )
        )
        result = await self.session.execute(query)
        return result.scalar()
    
    async def count_by_status(self, status: AlertStatus) -> int:
        """Count alerts by status."""
        query = select(func.count(SystemAlert.id)).where(
            and_(
                SystemAlert.status == status.value,
                SystemAlert.is_active == True
            )
        )
        result = await self.session.execute(query)
        return result.scalar()
    
    async def get_alert_summary(self) -> Dict[str, Any]:
        """Get alert summary statistics."""
        query = select(SystemAlert).where(SystemAlert.is_active == True)
        result = await self.session.execute(query)
        alerts = result.scalars().all()
        
        total_alerts = len(alerts)
        active_alerts = len([a for a in alerts if a.status == AlertStatus.ACTIVE.value])
        resolved_alerts = len([a for a in alerts if a.status == AlertStatus.RESOLVED.value])
        
        # Count by severity
        severity_counts = {}
        for severity in AlertSeverity:
            severity_counts[severity.value] = len([a for a in alerts if a.severity == severity.value])
        
        # Count by status
        status_counts = {}
        for status in AlertStatus:
            status_counts[status.value] = len([a for a in alerts if a.status == status.value])
        
        return {
            'total_alerts': total_alerts,
            'active_alerts': active_alerts,
            'resolved_alerts': resolved_alerts,
            'alerts_by_severity': severity_counts,
            'alerts_by_status': status_counts
        }

===== modules/analytics/routes.py â€“ 2025-07-20 11:44:10 IST =====
from typing import List, Optional
from uuid import UUID
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.shared.dependencies import get_session
from app.modules.analytics.service import AnalyticsService
from app.modules.analytics.models import (
    ReportType, ReportStatus, ReportFormat, MetricType,
    AlertSeverity, AlertStatus
)
from app.modules.analytics.schemas import (
    AnalyticsReportCreate, AnalyticsReportUpdate, AnalyticsReportResponse,
    AnalyticsReportListResponse, BusinessMetricCreate, BusinessMetricUpdate,
    BusinessMetricResponse, BusinessMetricListResponse, SystemAlertCreate,
    SystemAlertUpdate, SystemAlertResponse, SystemAlertListResponse,
    AnalyticsSearch, MetricSearch, AlertSearch, AnalyticsDashboard,
    SystemHealthSummary, AlertAcknowledgeRequest, AlertResolveRequest,
    MetricValueUpdate, ReportGenerationRequest
)


router = APIRouter(tags=["Analytics & System Management"])


# Dependency to get analytics service
async def get_analytics_service(session: AsyncSession = Depends(get_session)) -> AnalyticsService:
    return AnalyticsService(session)


# Analytics Report endpoints
@router.post("/reports", response_model=AnalyticsReportResponse, status_code=status.HTTP_201_CREATED)
async def create_report(
    report_data: AnalyticsReportCreate,
    generated_by: UUID = Query(..., description="User ID generating the report"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Create a new analytics report."""
    try:
        return await service.create_report(report_data, generated_by)
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/reports/{report_id}", response_model=AnalyticsReportResponse)
async def get_report(
    report_id: UUID,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get analytics report by ID."""
    try:
        return await service.get_report(report_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get("/reports", response_model=List[AnalyticsReportListResponse])
async def get_reports(
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    report_type: Optional[ReportType] = Query(None, description="Filter by report type"),
    report_status: Optional[ReportStatus] = Query(None, description="Filter by report status"),
    generated_by: Optional[UUID] = Query(None, description="Filter by generator"),
    start_date: Optional[datetime] = Query(None, description="Filter by start date"),
    end_date: Optional[datetime] = Query(None, description="Filter by end date"),
    active_only: bool = Query(True, description="Only active reports"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get all analytics reports with optional filtering."""
    try:
        return await service.get_reports(
            skip=skip,
            limit=limit,
            report_type=report_type,
            report_status=report_status,
            generated_by=generated_by,
            start_date=start_date,
            end_date=end_date,
            active_only=active_only
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.post("/reports/search", response_model=List[AnalyticsReportListResponse])
async def search_reports(
    search_params: AnalyticsSearch,
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Only active reports"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Search analytics reports."""
    try:
        return await service.search_reports(
            search_params=search_params,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.put("/reports/{report_id}", response_model=AnalyticsReportResponse)
async def update_report(
    report_id: UUID,
    report_data: AnalyticsReportUpdate,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Update an analytics report."""
    try:
        return await service.update_report(report_id, report_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/reports/{report_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_report(
    report_id: UUID,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Delete an analytics report."""
    try:
        success = await service.delete_report(report_id)
        if not success:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Report not found")
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.post("/reports/{report_id}/generate", response_model=AnalyticsReportResponse)
async def generate_report(
    report_id: UUID,
    generation_request: ReportGenerationRequest,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Generate a report."""
    try:
        return await service.generate_report(report_id, generation_request)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


# Business Metric endpoints
@router.post("/metrics", response_model=BusinessMetricResponse, status_code=status.HTTP_201_CREATED)
async def create_metric(
    metric_data: BusinessMetricCreate,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Create a new business metric."""
    try:
        return await service.create_metric(metric_data)
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/metrics/{metric_id}", response_model=BusinessMetricResponse)
async def get_metric(
    metric_id: UUID,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get business metric by ID."""
    try:
        return await service.get_metric(metric_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get("/metrics", response_model=List[BusinessMetricListResponse])
async def get_metrics(
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    metric_type: Optional[MetricType] = Query(None, description="Filter by metric type"),
    category: Optional[str] = Query(None, description="Filter by category"),
    has_target: Optional[bool] = Query(None, description="Filter by target presence"),
    active_only: bool = Query(True, description="Only active metrics"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get all business metrics with optional filtering."""
    try:
        return await service.get_metrics(
            skip=skip,
            limit=limit,
            metric_type=metric_type,
            category=category,
            has_target=has_target,
            active_only=active_only
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.post("/metrics/search", response_model=List[BusinessMetricListResponse])
async def search_metrics(
    search_params: MetricSearch,
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Only active metrics"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Search business metrics."""
    try:
        return await service.search_metrics(
            search_params=search_params,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.put("/metrics/{metric_id}", response_model=BusinessMetricResponse)
async def update_metric(
    metric_id: UUID,
    metric_data: BusinessMetricUpdate,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Update a business metric."""
    try:
        return await service.update_metric(metric_id, metric_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/metrics/{metric_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_metric(
    metric_id: UUID,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Delete a business metric."""
    try:
        success = await service.delete_metric(metric_id)
        if not success:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Metric not found")
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.patch("/metrics/{metric_id}/value", response_model=BusinessMetricResponse)
async def update_metric_value(
    metric_id: UUID,
    value_update: MetricValueUpdate,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Update metric value."""
    try:
        return await service.update_metric_value(metric_id, value_update)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/metrics/{metric_name}/history", response_model=List[BusinessMetricResponse])
async def get_metric_history(
    metric_name: str,
    limit: int = Query(30, ge=1, le=100, description="Maximum records to return"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get metric history by name."""
    try:
        return await service.get_metric_history(metric_name, limit)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.post("/metrics/calculate", response_model=List[BusinessMetricResponse])
async def calculate_key_metrics(
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Calculate and update key business metrics."""
    try:
        return await service.calculate_key_metrics()
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


# System Alert endpoints
@router.post("/alerts", response_model=SystemAlertResponse, status_code=status.HTTP_201_CREATED)
async def create_alert(
    alert_data: SystemAlertCreate,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Create a new system alert."""
    try:
        return await service.create_alert(alert_data)
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/alerts/{alert_id}", response_model=SystemAlertResponse)
async def get_alert(
    alert_id: UUID,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get system alert by ID."""
    try:
        return await service.get_alert(alert_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get("/alerts", response_model=List[SystemAlertListResponse])
async def get_alerts(
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    alert_type: Optional[str] = Query(None, description="Filter by alert type"),
    severity: Optional[AlertSeverity] = Query(None, description="Filter by severity"),
    alert_status: Optional[AlertStatus] = Query(None, description="Filter by status"),
    source: Optional[str] = Query(None, description="Filter by source"),
    active_only: bool = Query(True, description="Only active alerts"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get all system alerts with optional filtering."""
    try:
        return await service.get_alerts(
            skip=skip,
            limit=limit,
            alert_type=alert_type,
            severity=severity,
            status=alert_status,
            source=source,
            active_only=active_only
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.post("/alerts/search", response_model=List[SystemAlertListResponse])
async def search_alerts(
    search_params: AlertSearch,
    skip: int = Query(0, ge=0, description="Records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum records to return"),
    active_only: bool = Query(True, description="Only active alerts"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Search system alerts."""
    try:
        return await service.search_alerts(
            search_params=search_params,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.put("/alerts/{alert_id}", response_model=SystemAlertResponse)
async def update_alert(
    alert_id: UUID,
    alert_data: SystemAlertUpdate,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Update a system alert."""
    try:
        return await service.update_alert(alert_id, alert_data)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/alerts/{alert_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_alert(
    alert_id: UUID,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Delete a system alert."""
    try:
        success = await service.delete_alert(alert_id)
        if not success:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Alert not found")
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.post("/alerts/{alert_id}/acknowledge", response_model=SystemAlertResponse)
async def acknowledge_alert(
    alert_id: UUID,
    acknowledge_request: AlertAcknowledgeRequest,
    acknowledged_by: UUID = Query(..., description="User ID acknowledging the alert"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Acknowledge an alert."""
    try:
        return await service.acknowledge_alert(alert_id, acknowledged_by, acknowledge_request)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/alerts/{alert_id}/resolve", response_model=SystemAlertResponse)
async def resolve_alert(
    alert_id: UUID,
    resolve_request: AlertResolveRequest,
    resolved_by: UUID = Query(..., description="User ID resolving the alert"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Resolve an alert."""
    try:
        return await service.resolve_alert(alert_id, resolved_by, resolve_request)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/alerts/{alert_id}/suppress", response_model=SystemAlertResponse)
async def suppress_alert(
    alert_id: UUID,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Suppress an alert."""
    try:
        return await service.suppress_alert(alert_id)
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


# Dashboard and monitoring endpoints
@router.get("/dashboard", response_model=AnalyticsDashboard)
async def get_analytics_dashboard(
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get analytics dashboard data."""
    try:
        return await service.get_analytics_dashboard()
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.get("/rentals/dashboard")
async def get_rentals_dashboard(
    start_date: Optional[str] = Query(None, description="Start date filter (YYYY-MM-DD)"),
    end_date: Optional[str] = Query(None, description="End date filter (YYYY-MM-DD)"),
    customer_id: Optional[str] = Query(None, description="Customer ID filter"),
    location_id: Optional[str] = Query(None, description="Location ID filter"),
    session: AsyncSession = Depends(get_session)
) -> dict:
    """Get rental-specific dashboard analytics."""
    try:
        from app.modules.transactions.base.models import TransactionHeader, TransactionType
        from sqlalchemy import select
        from datetime import datetime
        
        # Base query for rental transactions
        base_query = select(TransactionHeader).where(
            TransactionHeader.transaction_type == TransactionType.RENTAL,
            TransactionHeader.is_active == True
        )
        
        # Apply date filters if provided
        if start_date:
            start_dt = datetime.strptime(start_date, "%Y-%m-%d")
            base_query = base_query.where(TransactionHeader.transaction_date >= start_dt)
        if end_date:
            end_dt = datetime.strptime(end_date, "%Y-%m-%d")
            base_query = base_query.where(TransactionHeader.transaction_date <= end_dt)
        if customer_id:
            base_query = base_query.where(TransactionHeader.customer_id == customer_id)
        if location_id:
            base_query = base_query.where(TransactionHeader.location_id == location_id)
        
        # Execute query
        result = await session.execute(base_query)
        rentals = result.scalars().all()
        
        # Calculate metrics
        total_rentals = len(rentals)
        total_revenue = sum(float(rental.total_amount or 0) for rental in rentals)
        average_rental_value = total_revenue / total_rentals if total_rentals > 0 else 0
        
        return {
            "overview": {
                "total_rentals": total_rentals,
                "total_revenue": total_revenue,
                "average_rental_value": average_rental_value,
                "active_rentals": total_rentals,
                "overdue_rentals": 0,
                "completion_rate": 100.0 if total_rentals > 0 else 0.0
            },
            "trends": {
                "daily_rentals": [],
                "monthly_growth": 0.0,
                "revenue_growth": 0.0
            },
            "top_performers": {
                "customers": [],
                "items": [],
                "locations": []
            },
            "recent_activity": [
                {
                    "rental_id": str(rental.id),
                    "rental_number": rental.transaction_number,
                    "customer_name": "Customer",
                    "action": "created",
                    "timestamp": rental.created_at.isoformat(),
                    "amount": float(rental.total_amount or 0)
                }
                for rental in rentals[-5:]  # Last 5 rentals
            ]
        }
        
    except Exception as e:
        return {
            "overview": {
                "total_rentals": 0,
                "total_revenue": 0.0,
                "average_rental_value": 0.0,
                "active_rentals": 0,
                "overdue_rentals": 0,
                "completion_rate": 0.0
            },
            "trends": {
                "daily_rentals": [],
                "monthly_growth": 0.0,
                "revenue_growth": 0.0
            },
            "top_performers": {
                "customers": [],
                "items": [],
                "locations": []
            },
            "recent_activity": []
        }


@router.get("/system/health", response_model=SystemHealthSummary)
async def get_system_health(
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get system health summary."""
    try:
        return await service.get_system_health()
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


# Report type specific endpoints
@router.get("/reports/types/{report_type}", response_model=List[AnalyticsReportListResponse])
async def get_reports_by_type(
    report_type: ReportType,
    limit: int = Query(10, ge=1, le=100, description="Maximum records to return"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get reports by type."""
    try:
        return await service.get_reports(
            report_type=report_type,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/reports/status/{report_status}", response_model=List[AnalyticsReportListResponse])
async def get_reports_by_status(
    report_status: ReportStatus,
    limit: int = Query(10, ge=1, le=100, description="Maximum records to return"),
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get reports by status."""
    try:
        return await service.get_reports(
            report_status=report_status,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


# Metric category specific endpoints
@router.get("/metrics/categories/{category}", response_model=List[BusinessMetricListResponse])
async def get_metrics_by_category(
    category: str,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get metrics by category."""
    try:
        return await service.get_metrics(
            category=category
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/metrics/with-targets", response_model=List[BusinessMetricListResponse])
async def get_metrics_with_targets(
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get metrics that have targets set."""
    try:
        return await service.get_metrics(
            has_target=True
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


# Alert severity specific endpoints
@router.get("/alerts/severity/{severity}", response_model=List[SystemAlertListResponse])
async def get_alerts_by_severity(
    severity: AlertSeverity,
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get alerts by severity."""
    try:
        return await service.get_alerts(
            severity=severity
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/alerts/active", response_model=List[SystemAlertListResponse])
async def get_active_alerts(
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get active alerts."""
    try:
        return await service.get_alerts(
            status=AlertStatus.ACTIVE
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/alerts/critical", response_model=List[SystemAlertListResponse])
async def get_critical_alerts(
    service: AnalyticsService = Depends(get_analytics_service)
):
    """Get critical alerts."""
    try:
        return await service.get_alerts(
            severity=AlertSeverity.CRITICAL,
            status=AlertStatus.ACTIVE
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))






===== modules/analytics/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List, Dict, Any
from datetime import datetime, date
from decimal import Decimal
from pydantic import BaseModel, Field, ConfigDict, field_validator, computed_field
from uuid import UUID

from app.modules.analytics.models import (
    ReportType, ReportStatus, ReportFormat, MetricType, 
    AlertSeverity, AlertStatus
)


# Analytics Report Schemas
class AnalyticsReportCreate(BaseModel):
    """Schema for creating a new analytics report."""
    report_name: str = Field(..., description="Name of the report")
    report_type: ReportType = Field(..., description="Type of report")
    report_format: ReportFormat = Field(..., description="Format of the report")
    start_date: Optional[datetime] = Field(None, description="Start date for report data")
    end_date: Optional[datetime] = Field(None, description="End date for report data")
    filters: Optional[Dict[str, Any]] = Field(None, description="JSON filters applied to the report")
    parameters: Optional[Dict[str, Any]] = Field(None, description="Additional report parameters")
    
    @field_validator('report_name')
    @classmethod
    def validate_report_name(cls, v):
        if not v or not v.strip():
            raise ValueError("Report name cannot be empty")
        if len(v) > 200:
            raise ValueError("Report name cannot exceed 200 characters")
        return v.strip()
    
    @field_validator('end_date')
    @classmethod
    def validate_date_range(cls, v, info):
        if v is not None and info.data.get('start_date') is not None:
            if v < info.data.get('start_date'):
                raise ValueError("End date must be after start date")
        return v


class AnalyticsReportUpdate(BaseModel):
    """Schema for updating an analytics report."""
    report_name: Optional[str] = Field(None, description="Name of the report")
    report_type: Optional[ReportType] = Field(None, description="Type of report")
    report_format: Optional[ReportFormat] = Field(None, description="Format of the report")
    start_date: Optional[datetime] = Field(None, description="Start date for report data")
    end_date: Optional[datetime] = Field(None, description="End date for report data")
    filters: Optional[Dict[str, Any]] = Field(None, description="JSON filters applied to the report")
    parameters: Optional[Dict[str, Any]] = Field(None, description="Additional report parameters")
    
    @field_validator('report_name')
    @classmethod
    def validate_report_name(cls, v):
        if v is not None:
            if not v or not v.strip():
                raise ValueError("Report name cannot be empty")
            if len(v) > 200:
                raise ValueError("Report name cannot exceed 200 characters")
        return v.strip() if v else None


class AnalyticsReportResponse(BaseModel):
    """Schema for analytics report response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    report_name: str
    report_type: ReportType
    report_format: ReportFormat
    report_status: ReportStatus
    start_date: Optional[datetime]
    end_date: Optional[datetime]
    filters: Optional[Dict[str, Any]]
    parameters: Optional[Dict[str, Any]]
    file_path: Optional[str]
    file_size: Optional[str]
    generated_by: UUID
    generated_at: Optional[datetime]
    error_message: Optional[str]
    report_metadata: Optional[Dict[str, Any]]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.report_name} ({self.report_type.value})"
    
    @computed_field
    @property
    def is_completed(self) -> bool:
        return self.report_status == ReportStatus.COMPLETED
    
    @computed_field
    @property
    def is_failed(self) -> bool:
        return self.report_status == ReportStatus.FAILED
    
    @computed_field
    @property
    def file_size_mb(self) -> Optional[float]:
        if self.file_size:
            try:
                return float(self.file_size) / (1024 * 1024)
            except ValueError:
                return None
        return None
    
    @computed_field
    @property
    def duration_minutes(self) -> Optional[int]:
        if self.generated_at:
            return int((self.generated_at - self.created_at).total_seconds() / 60)
        return None


class AnalyticsReportListResponse(BaseModel):
    """Schema for analytics report list response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    report_name: str
    report_type: ReportType
    report_format: ReportFormat
    report_status: ReportStatus
    start_date: Optional[datetime]
    end_date: Optional[datetime]
    file_size: Optional[str]
    generated_by: UUID
    generated_at: Optional[datetime]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.report_name} ({self.report_type.value})"
    
    @computed_field
    @property
    def is_completed(self) -> bool:
        return self.report_status == ReportStatus.COMPLETED


# Business Metric Schemas
class BusinessMetricCreate(BaseModel):
    """Schema for creating a new business metric."""
    metric_name: str = Field(..., description="Name of the metric")
    metric_type: MetricType = Field(..., description="Type of metric")
    category: str = Field(..., description="Category of the metric")
    current_value: Decimal = Field(..., description="Current value of the metric")
    previous_value: Optional[Decimal] = Field(None, description="Previous value of the metric")
    target_value: Optional[Decimal] = Field(None, description="Target value for the metric")
    unit: Optional[str] = Field(None, description="Unit of measurement")
    calculation_method: Optional[str] = Field(None, description="How the metric is calculated")
    metric_metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")
    
    @field_validator('metric_name')
    @classmethod
    def validate_metric_name(cls, v):
        if not v or not v.strip():
            raise ValueError("Metric name cannot be empty")
        if len(v) > 100:
            raise ValueError("Metric name cannot exceed 100 characters")
        return v.strip()
    
    @field_validator('category')
    @classmethod
    def validate_category(cls, v):
        if not v or not v.strip():
            raise ValueError("Category cannot be empty")
        if len(v) > 50:
            raise ValueError("Category cannot exceed 50 characters")
        return v.strip()
    
    @field_validator('unit')
    @classmethod
    def validate_unit(cls, v):
        if v is not None and len(v) > 20:
            raise ValueError("Unit cannot exceed 20 characters")
        return v


class BusinessMetricUpdate(BaseModel):
    """Schema for updating a business metric."""
    metric_name: Optional[str] = Field(None, description="Name of the metric")
    metric_type: Optional[MetricType] = Field(None, description="Type of metric")
    category: Optional[str] = Field(None, description="Category of the metric")
    current_value: Optional[Decimal] = Field(None, description="Current value of the metric")
    previous_value: Optional[Decimal] = Field(None, description="Previous value of the metric")
    target_value: Optional[Decimal] = Field(None, description="Target value for the metric")
    unit: Optional[str] = Field(None, description="Unit of measurement")
    calculation_method: Optional[str] = Field(None, description="How the metric is calculated")
    metric_metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")
    
    @field_validator('metric_name')
    @classmethod
    def validate_metric_name(cls, v):
        if v is not None:
            if not v or not v.strip():
                raise ValueError("Metric name cannot be empty")
            if len(v) > 100:
                raise ValueError("Metric name cannot exceed 100 characters")
        return v.strip() if v else None


class BusinessMetricResponse(BaseModel):
    """Schema for business metric response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    metric_name: str
    metric_type: MetricType
    category: str
    current_value: Decimal
    previous_value: Optional[Decimal]
    target_value: Optional[Decimal]
    unit: Optional[str]
    calculation_method: Optional[str]
    tracked_date: datetime
    metric_metadata: Optional[Dict[str, Any]]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.metric_name} ({self.category})"
    
    @computed_field
    @property
    def formatted_value(self) -> str:
        if self.unit:
            return f"{self.current_value} {self.unit}"
        return str(self.current_value)
    
    @computed_field
    @property
    def change_percentage(self) -> Optional[Decimal]:
        if self.previous_value is None or self.previous_value == 0:
            return None
        
        change = ((self.current_value - self.previous_value) / self.previous_value) * 100
        return change.quantize(Decimal('0.01'))
    
    @computed_field
    @property
    def target_achievement(self) -> Optional[Decimal]:
        if self.target_value is None or self.target_value == 0:
            return None
        
        achievement = (self.current_value / self.target_value) * 100
        return achievement.quantize(Decimal('0.01'))
    
    @computed_field
    @property
    def is_target_met(self) -> bool:
        if self.target_value is None:
            return False
        return self.current_value >= self.target_value


class BusinessMetricListResponse(BaseModel):
    """Schema for business metric list response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    metric_name: str
    metric_type: MetricType
    category: str
    current_value: Decimal
    target_value: Optional[Decimal]
    unit: Optional[str]
    tracked_date: datetime
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.metric_name} ({self.category})"
    
    @computed_field
    @property
    def formatted_value(self) -> str:
        if self.unit:
            return f"{self.current_value} {self.unit}"
        return str(self.current_value)


# System Alert Schemas
class SystemAlertCreate(BaseModel):
    """Schema for creating a new system alert."""
    alert_name: str = Field(..., description="Name of the alert")
    alert_type: str = Field(..., description="Type of alert")
    severity: AlertSeverity = Field(..., description="Severity level of the alert")
    message: str = Field(..., description="Alert message")
    description: Optional[str] = Field(None, description="Detailed description of the alert")
    source: Optional[str] = Field(None, description="Source of the alert")
    trigger_condition: Optional[str] = Field(None, description="Condition that triggered the alert")
    alert_metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")
    
    @field_validator('alert_name')
    @classmethod
    def validate_alert_name(cls, v):
        if not v or not v.strip():
            raise ValueError("Alert name cannot be empty")
        if len(v) > 100:
            raise ValueError("Alert name cannot exceed 100 characters")
        return v.strip()
    
    @field_validator('alert_type')
    @classmethod
    def validate_alert_type(cls, v):
        if not v or not v.strip():
            raise ValueError("Alert type cannot be empty")
        if len(v) > 20:
            raise ValueError("Alert type cannot exceed 20 characters")
        return v.strip()
    
    @field_validator('message')
    @classmethod
    def validate_message(cls, v):
        if not v or not v.strip():
            raise ValueError("Alert message cannot be empty")
        return v.strip()
    
    @field_validator('source')
    @classmethod
    def validate_source(cls, v):
        if v is not None and len(v) > 100:
            raise ValueError("Source cannot exceed 100 characters")
        return v


class SystemAlertUpdate(BaseModel):
    """Schema for updating a system alert."""
    alert_name: Optional[str] = Field(None, description="Name of the alert")
    alert_type: Optional[str] = Field(None, description="Type of alert")
    severity: Optional[AlertSeverity] = Field(None, description="Severity level of the alert")
    message: Optional[str] = Field(None, description="Alert message")
    description: Optional[str] = Field(None, description="Detailed description of the alert")
    source: Optional[str] = Field(None, description="Source of the alert")
    trigger_condition: Optional[str] = Field(None, description="Condition that triggered the alert")
    alert_metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")


class SystemAlertResponse(BaseModel):
    """Schema for system alert response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    alert_name: str
    alert_type: str
    severity: AlertSeverity
    status: AlertStatus
    message: str
    description: Optional[str]
    source: Optional[str]
    trigger_condition: Optional[str]
    resolution_notes: Optional[str]
    acknowledged_by: Optional[UUID]
    acknowledged_at: Optional[datetime]
    resolved_by: Optional[UUID]
    resolved_at: Optional[datetime]
    alert_metadata: Optional[Dict[str, Any]]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.alert_name} ({self.severity.value})"
    
    @computed_field
    @property
    def is_resolved(self) -> bool:
        return self.status == AlertStatus.RESOLVED
    
    @computed_field
    @property
    def is_critical(self) -> bool:
        return self.severity == AlertSeverity.CRITICAL
    
    @computed_field
    @property
    def duration_minutes(self) -> int:
        if self.resolved_at:
            return int((self.resolved_at - self.created_at).total_seconds() / 60)
        return int((datetime.utcnow() - self.created_at).total_seconds() / 60)


class SystemAlertListResponse(BaseModel):
    """Schema for system alert list response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    alert_name: str
    alert_type: str
    severity: AlertSeverity
    status: AlertStatus
    message: str
    source: Optional[str]
    acknowledged_by: Optional[UUID]
    resolved_by: Optional[UUID]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    @computed_field
    @property
    def display_name(self) -> str:
        return f"{self.alert_name} ({self.severity.value})"
    
    @computed_field
    @property
    def is_critical(self) -> bool:
        return self.severity == AlertSeverity.CRITICAL


# Action Schemas
class AlertAcknowledgeRequest(BaseModel):
    """Schema for acknowledging an alert."""
    notes: Optional[str] = Field(None, description="Acknowledgment notes")


class AlertResolveRequest(BaseModel):
    """Schema for resolving an alert."""
    resolution_notes: str = Field(..., description="Resolution notes")
    
    @field_validator('resolution_notes')
    @classmethod
    def validate_resolution_notes(cls, v):
        if not v or not v.strip():
            raise ValueError("Resolution notes cannot be empty")
        return v.strip()


class MetricValueUpdate(BaseModel):
    """Schema for updating metric value."""
    new_value: Decimal = Field(..., description="New metric value")


class ReportGenerationRequest(BaseModel):
    """Schema for generating a report."""
    start_date: Optional[datetime] = Field(None, description="Start date for report data")
    end_date: Optional[datetime] = Field(None, description="End date for report data")
    filters: Optional[Dict[str, Any]] = Field(None, description="Additional filters")
    parameters: Optional[Dict[str, Any]] = Field(None, description="Additional parameters")


# Dashboard Schemas
class AnalyticsDashboard(BaseModel):
    """Schema for analytics dashboard."""
    total_reports: int
    pending_reports: int
    completed_reports: int
    failed_reports: int
    active_alerts: int
    critical_alerts: int
    total_metrics: int
    metrics_with_targets: int
    metrics_meeting_targets: int
    recent_reports: List[AnalyticsReportListResponse]
    critical_alerts_list: List[SystemAlertListResponse]
    key_metrics: List[BusinessMetricListResponse]


class SystemHealthSummary(BaseModel):
    """Schema for system health summary."""
    overall_health: str
    active_alerts: int
    critical_alerts: int
    warning_alerts: int
    system_uptime: str
    last_backup: Optional[datetime]
    database_size: str
    storage_usage: str
    cpu_usage: float
    memory_usage: float
    disk_usage: float


class AnalyticsSearch(BaseModel):
    """Schema for analytics search."""
    report_type: Optional[ReportType] = Field(None, description="Filter by report type")
    report_status: Optional[ReportStatus] = Field(None, description="Filter by report status")
    start_date: Optional[datetime] = Field(None, description="Filter by start date")
    end_date: Optional[datetime] = Field(None, description="Filter by end date")
    generated_by: Optional[UUID] = Field(None, description="Filter by generator")
    
    @field_validator('end_date')
    @classmethod
    def validate_date_range(cls, v, info):
        if v is not None and info.data.get('start_date') is not None:
            if v < info.data.get('start_date'):
                raise ValueError("End date must be after start date")
        return v


class MetricSearch(BaseModel):
    """Schema for metric search."""
    metric_type: Optional[MetricType] = Field(None, description="Filter by metric type")
    category: Optional[str] = Field(None, description="Filter by category")
    has_target: Optional[bool] = Field(None, description="Filter by target presence")
    target_met: Optional[bool] = Field(None, description="Filter by target achievement")
    tracked_from: Optional[datetime] = Field(None, description="Filter by tracked date from")
    tracked_to: Optional[datetime] = Field(None, description="Filter by tracked date to")


class AlertSearch(BaseModel):
    """Schema for alert search."""
    alert_type: Optional[str] = Field(None, description="Filter by alert type")
    severity: Optional[AlertSeverity] = Field(None, description="Filter by severity")
    status: Optional[AlertStatus] = Field(None, description="Filter by status")
    source: Optional[str] = Field(None, description="Filter by source")
    created_from: Optional[datetime] = Field(None, description="Filter by created date from")
    created_to: Optional[datetime] = Field(None, description="Filter by created date to")
    resolved_from: Optional[datetime] = Field(None, description="Filter by resolved date from")
    resolved_to: Optional[datetime] = Field(None, description="Filter by resolved date to")

===== modules/analytics/service.py â€“ 2025-07-21 19:04:48 IST =====
from typing import Optional, List, Dict, Any
from uuid import UUID
from decimal import Decimal
from datetime import datetime, date, timedelta
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.errors import NotFoundError, ValidationError, ConflictError
from app.modules.analytics.models import (
    AnalyticsReport, BusinessMetric, SystemAlert,
    ReportType, ReportStatus, ReportFormat, MetricType,
    AlertSeverity, AlertStatus
)
from app.modules.analytics.repository import (
    AnalyticsReportRepository, BusinessMetricRepository, SystemAlertRepository
)
from app.modules.analytics.schemas import (
    AnalyticsReportCreate, AnalyticsReportUpdate, AnalyticsReportResponse,
    AnalyticsReportListResponse, BusinessMetricCreate, BusinessMetricUpdate,
    BusinessMetricResponse, BusinessMetricListResponse, SystemAlertCreate,
    SystemAlertUpdate, SystemAlertResponse, SystemAlertListResponse,
    AnalyticsSearch, MetricSearch, AlertSearch, AnalyticsDashboard,
    SystemHealthSummary, AlertAcknowledgeRequest, AlertResolveRequest,
    MetricValueUpdate, ReportGenerationRequest
)
from app.modules.transactions.base.repository import TransactionHeaderRepository
from app.modules.customers.repository import CustomerRepository
from app.modules.inventory import InventoryUnit, InventoryUnitRepository


class AnalyticsService:
    """Service for analytics operations."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.report_repository = AnalyticsReportRepository(session)
        self.metric_repository = BusinessMetricRepository(session)
        self.alert_repository = SystemAlertRepository(session)
        # Import other repositories for analytics
        self.transaction_repository = TransactionHeaderRepository(session)
        self.customer_repository = CustomerRepository(session)
        self.item_repository = InventoryUnit(session)
        self.inventory_unit_repository = InventoryUnitRepository(session)
    
    # Analytics Report operations
    async def create_report(self, report_data: AnalyticsReportCreate, generated_by: UUID) -> AnalyticsReportResponse:
        """Create a new analytics report."""
        try:
            report = await self.report_repository.create(report_data, generated_by)
            return AnalyticsReportResponse.model_validate(report)
        except Exception as e:
            raise ValidationError(f"Failed to create analytics report: {str(e)}")
    
    async def get_report(self, report_id: UUID) -> AnalyticsReportResponse:
        """Get analytics report by ID."""
        report = await self.report_repository.get_by_id(report_id)
        if not report:
            raise NotFoundError(f"Analytics report with ID {report_id} not found")
        
        return AnalyticsReportResponse.model_validate(report)
    
    async def get_reports(
        self, 
        skip: int = 0, 
        limit: int = 100,
        report_type: Optional[ReportType] = None,
        report_status: Optional[ReportStatus] = None,
        generated_by: Optional[UUID] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        active_only: bool = True
    ) -> List[AnalyticsReportListResponse]:
        """Get all analytics reports with optional filtering."""
        reports = await self.report_repository.get_all(
            skip=skip,
            limit=limit,
            report_type=report_type,
            report_status=report_status,
            generated_by=generated_by,
            start_date=start_date,
            end_date=end_date,
            active_only=active_only
        )
        
        return [AnalyticsReportListResponse.model_validate(report) for report in reports]
    
    async def search_reports(
        self, 
        search_params: AnalyticsSearch,
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[AnalyticsReportListResponse]:
        """Search analytics reports."""
        reports = await self.report_repository.search(
            search_params=search_params,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
        
        return [AnalyticsReportListResponse.model_validate(report) for report in reports]
    
    async def update_report(self, report_id: UUID, report_data: AnalyticsReportUpdate) -> AnalyticsReportResponse:
        """Update an analytics report."""
        report = await self.report_repository.update(report_id, report_data)
        if not report:
            raise NotFoundError(f"Analytics report with ID {report_id} not found")
        
        return AnalyticsReportResponse.model_validate(report)
    
    async def delete_report(self, report_id: UUID) -> bool:
        """Delete an analytics report."""
        success = await self.report_repository.delete(report_id)
        if not success:
            raise NotFoundError(f"Analytics report with ID {report_id} not found")
        
        return success
    
    async def generate_report(self, report_id: UUID, generation_request: ReportGenerationRequest) -> AnalyticsReportResponse:
        """Generate a report."""
        report = await self.report_repository.get_by_id(report_id)
        if not report:
            raise NotFoundError(f"Analytics report with ID {report_id} not found")
        
        try:
            # Start generation
            report.start_generation()
            await self.session.commit()
            
            # Generate report based on type
            file_path, file_size = await self._generate_report_file(report, generation_request)
            
            # Complete generation
            report.complete_generation(file_path, file_size)
            await self.session.commit()
            
            return AnalyticsReportResponse.model_validate(report)
            
        except Exception as e:
            # Fail generation
            report.fail_generation(str(e))
            await self.session.commit()
            raise ValidationError(f"Failed to generate report: {str(e)}")
    
    async def _generate_report_file(self, report: AnalyticsReport, generation_request: ReportGenerationRequest) -> tuple[str, int]:
        """Generate report file based on type."""
        # This would contain the actual report generation logic
        # For now, we'll simulate file generation
        import json
        import os
        
        # Create reports directory if it doesn't exist
        reports_dir = "reports"
        os.makedirs(reports_dir, exist_ok=True)
        
        # Generate report data based on type
        report_data = await self._generate_report_data(report, generation_request)
        
        # Generate file based on format
        file_name = f"{report.report_name}_{report.id}.{report.report_format.lower()}"
        file_path = os.path.join(reports_dir, file_name)
        
        if report.report_format == ReportFormat.JSON.value:
            with open(file_path, 'w') as f:
                json.dump(report_data, f, indent=2, default=str)
        elif report.report_format == ReportFormat.CSV.value:
            import csv
            with open(file_path, 'w', newline='') as f:
                if report_data.get('rows'):
                    writer = csv.DictWriter(f, fieldnames=report_data['rows'][0].keys())
                    writer.writeheader()
                    writer.writerows(report_data['rows'])
        else:
            # For PDF and Excel, we'd use appropriate libraries
            with open(file_path, 'w') as f:
                f.write(json.dumps(report_data, indent=2, default=str))
        
        file_size = os.path.getsize(file_path)
        return file_path, file_size
    
    async def _generate_report_data(self, report: AnalyticsReport, generation_request: ReportGenerationRequest) -> Dict[str, Any]:
        """Generate report data based on type."""
        data = {
            'report_name': report.report_name,
            'report_type': report.report_type,
            'generated_at': datetime.utcnow().isoformat(),
            'date_range': {
                'start': generation_request.start_date.isoformat() if generation_request.start_date else None,
                'end': generation_request.end_date.isoformat() if generation_request.end_date else None
            },
            'filters': generation_request.filters or {},
            'data': []
        }
        
        if report.report_type == ReportType.SALES.value:
            data['data'] = await self._generate_sales_data(generation_request)
        elif report.report_type == ReportType.RENTALS.value:
            data['data'] = await self._generate_rentals_data(generation_request)
        elif report.report_type == ReportType.INVENTORY.value:
            data['data'] = await self._generate_inventory_data(generation_request)
        elif report.report_type == ReportType.CUSTOMER.value:
            data['data'] = await self._generate_customer_data(generation_request)
        elif report.report_type == ReportType.FINANCIAL.value:
            data['data'] = await self._generate_financial_data(generation_request)
        elif report.report_type == ReportType.PERFORMANCE.value:
            data['data'] = await self._generate_performance_data(generation_request)
        
        return data
    
    async def _generate_sales_data(self, generation_request: ReportGenerationRequest) -> List[Dict[str, Any]]:
        """Generate sales report data."""
        # Get sales transactions
        transactions = await self.transaction_repository.get_all(
            date_from=generation_request.start_date,
            date_to=generation_request.end_date,
            active_only=True
        )
        
        sales_data = []
        for transaction in transactions:
            if transaction.is_sale():
                sales_data.append({
                    'transaction_id': str(transaction.id),
                    'transaction_date': transaction.transaction_date.isoformat(),
                    'customer_id': transaction.customer_id,
                    'total_amount': float(transaction.total_amount),
                    'status': transaction.status
                })
        
        return sales_data
    
    async def _generate_rentals_data(self, generation_request: ReportGenerationRequest) -> List[Dict[str, Any]]:
        """Generate rentals report data."""
        # Get rental transactions with returns
        transactions = await self.transaction_repository.get_all(
            date_from=generation_request.start_date,
            date_to=generation_request.end_date,
            active_only=True
        )
        
        rental_data = []
        for transaction in transactions:
            if transaction.transaction_type == "RENTAL" and transaction.metadata_entries:
                # Look for return metadata
                for metadata in transaction.metadata_entries:
                    if metadata.key == "return_data":
                        return_data = metadata.value
                        rental_data.append({
                            'transaction_id': str(transaction.id),
                            'return_date': transaction.transaction_date.isoformat(),
                            'status': transaction.status,
                            'total_amount': float(transaction.total_amount),
                            'return_details': return_data
                        })
                        break
        
        return rental_data
    
    async def _generate_inventory_data(self, generation_request: ReportGenerationRequest) -> List[Dict[str, Any]]:
        """Generate inventory report data."""
        # Get inventory units
        inventory_units = await self.inventory_unit_repository.get_all(active_only=True)
        
        inventory_data = []
        for unit in inventory_units:
            inventory_data.append({
                'unit_id': str(unit.id),
                'unit_code': unit.unit_code,
                'item_id': unit.item_id,
                'status': unit.status,
                'condition': unit.condition,
                'location_id': unit.location_id,
                'purchase_price': float(unit.purchase_price)
            })
        
        return inventory_data
    
    async def _generate_customer_data(self, generation_request: ReportGenerationRequest) -> List[Dict[str, Any]]:
        """Generate customer report data."""
        # Get customers
        customers = await self.customer_repository.get_all(active_only=True)
        
        customer_data = []
        for customer in customers:
            customer_data.append({
                'customer_id': str(customer.id),
                'customer_name': customer.customer_name,
                'customer_type': customer.customer_type,
                'tier': customer.tier,
                'status': customer.status,
                'credit_limit': float(customer.credit_limit),
                'outstanding_balance': float(customer.outstanding_balance)
            })
        
        return customer_data
    
    async def _generate_financial_data(self, generation_request: ReportGenerationRequest) -> List[Dict[str, Any]]:
        """Generate financial report data."""
        # Get transactions for financial analysis
        transactions = await self.transaction_repository.get_all(
            date_from=generation_request.start_date,
            date_to=generation_request.end_date,
            active_only=True
        )
        
        financial_data = []
        for transaction in transactions:
            financial_data.append({
                'transaction_id': str(transaction.id),
                'transaction_date': transaction.transaction_date.isoformat(),
                'transaction_type': transaction.transaction_type,
                'total_amount': float(transaction.total_amount),
                'tax_amount': float(transaction.tax_amount),
                'discount_amount': float(transaction.discount_amount),
                'net_amount': float(transaction.net_amount)
            })
        
        return financial_data
    
    async def _generate_performance_data(self, generation_request: ReportGenerationRequest) -> List[Dict[str, Any]]:
        """Generate performance report data."""
        # Get metrics for performance analysis
        metrics = await self.metric_repository.get_all(active_only=True)
        
        performance_data = []
        for metric in metrics:
            performance_data.append({
                'metric_id': str(metric.id),
                'metric_name': metric.metric_name,
                'metric_type': metric.metric_type,
                'category': metric.category,
                'current_value': float(metric.current_value),
                'target_value': float(metric.target_value) if metric.target_value else None,
                'tracked_date': metric.tracked_date.isoformat()
            })
        
        return performance_data
    
    # Business Metric operations
    async def create_metric(self, metric_data: BusinessMetricCreate) -> BusinessMetricResponse:
        """Create a new business metric."""
        try:
            metric = await self.metric_repository.create(metric_data)
            return BusinessMetricResponse.model_validate(metric)
        except Exception as e:
            raise ValidationError(f"Failed to create business metric: {str(e)}")
    
    async def get_metric(self, metric_id: UUID) -> BusinessMetricResponse:
        """Get business metric by ID."""
        metric = await self.metric_repository.get_by_id(metric_id)
        if not metric:
            raise NotFoundError(f"Business metric with ID {metric_id} not found")
        
        return BusinessMetricResponse.model_validate(metric)
    
    async def get_metrics(
        self, 
        skip: int = 0, 
        limit: int = 100,
        metric_type: Optional[MetricType] = None,
        category: Optional[str] = None,
        has_target: Optional[bool] = None,
        active_only: bool = True
    ) -> List[BusinessMetricListResponse]:
        """Get all business metrics with optional filtering."""
        metrics = await self.metric_repository.get_all(
            skip=skip,
            limit=limit,
            metric_type=metric_type,
            category=category,
            has_target=has_target,
            active_only=active_only
        )
        
        return [BusinessMetricListResponse.model_validate(metric) for metric in metrics]
    
    async def search_metrics(
        self, 
        search_params: MetricSearch,
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[BusinessMetricListResponse]:
        """Search business metrics."""
        metrics = await self.metric_repository.search(
            search_params=search_params,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
        
        return [BusinessMetricListResponse.model_validate(metric) for metric in metrics]
    
    async def update_metric(self, metric_id: UUID, metric_data: BusinessMetricUpdate) -> BusinessMetricResponse:
        """Update a business metric."""
        metric = await self.metric_repository.update(metric_id, metric_data)
        if not metric:
            raise NotFoundError(f"Business metric with ID {metric_id} not found")
        
        return BusinessMetricResponse.model_validate(metric)
    
    async def delete_metric(self, metric_id: UUID) -> bool:
        """Delete a business metric."""
        success = await self.metric_repository.delete(metric_id)
        if not success:
            raise NotFoundError(f"Business metric with ID {metric_id} not found")
        
        return success
    
    async def update_metric_value(self, metric_id: UUID, value_update: MetricValueUpdate) -> BusinessMetricResponse:
        """Update metric value."""
        metric = await self.metric_repository.get_by_id(metric_id)
        if not metric:
            raise NotFoundError(f"Business metric with ID {metric_id} not found")
        
        metric.update_value(value_update.new_value)
        await self.session.commit()
        await self.session.refresh(metric)
        
        return BusinessMetricResponse.model_validate(metric)
    
    async def get_metric_history(self, metric_name: str, limit: int = 30) -> List[BusinessMetricResponse]:
        """Get metric history by name."""
        metrics = await self.metric_repository.get_metric_history(metric_name, limit)
        return [BusinessMetricResponse.model_validate(metric) for metric in metrics]
    
    # System Alert operations
    async def create_alert(self, alert_data: SystemAlertCreate) -> SystemAlertResponse:
        """Create a new system alert."""
        try:
            alert = await self.alert_repository.create(alert_data)
            return SystemAlertResponse.model_validate(alert)
        except Exception as e:
            raise ValidationError(f"Failed to create system alert: {str(e)}")
    
    async def get_alert(self, alert_id: UUID) -> SystemAlertResponse:
        """Get system alert by ID."""
        alert = await self.alert_repository.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"System alert with ID {alert_id} not found")
        
        return SystemAlertResponse.model_validate(alert)
    
    async def get_alerts(
        self, 
        skip: int = 0, 
        limit: int = 100,
        alert_type: Optional[str] = None,
        severity: Optional[AlertSeverity] = None,
        status: Optional[AlertStatus] = None,
        source: Optional[str] = None,
        active_only: bool = True
    ) -> List[SystemAlertListResponse]:
        """Get all system alerts with optional filtering."""
        alerts = await self.alert_repository.get_all(
            skip=skip,
            limit=limit,
            alert_type=alert_type,
            severity=severity,
            status=status,
            source=source,
            active_only=active_only
        )
        
        return [SystemAlertListResponse.model_validate(alert) for alert in alerts]
    
    async def search_alerts(
        self, 
        search_params: AlertSearch,
        skip: int = 0, 
        limit: int = 100,
        active_only: bool = True
    ) -> List[SystemAlertListResponse]:
        """Search system alerts."""
        alerts = await self.alert_repository.search(
            search_params=search_params,
            skip=skip,
            limit=limit,
            active_only=active_only
        )
        
        return [SystemAlertListResponse.model_validate(alert) for alert in alerts]
    
    async def update_alert(self, alert_id: UUID, alert_data: SystemAlertUpdate) -> SystemAlertResponse:
        """Update a system alert."""
        alert = await self.alert_repository.update(alert_id, alert_data)
        if not alert:
            raise NotFoundError(f"System alert with ID {alert_id} not found")
        
        return SystemAlertResponse.model_validate(alert)
    
    async def delete_alert(self, alert_id: UUID) -> bool:
        """Delete a system alert."""
        success = await self.alert_repository.delete(alert_id)
        if not success:
            raise NotFoundError(f"System alert with ID {alert_id} not found")
        
        return success
    
    async def acknowledge_alert(self, alert_id: UUID, acknowledged_by: UUID, request: AlertAcknowledgeRequest) -> SystemAlertResponse:
        """Acknowledge an alert."""
        alert = await self.alert_repository.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"System alert with ID {alert_id} not found")
        
        alert.acknowledge(str(acknowledged_by), request.notes)
        await self.session.commit()
        await self.session.refresh(alert)
        
        return SystemAlertResponse.model_validate(alert)
    
    async def resolve_alert(self, alert_id: UUID, resolved_by: UUID, request: AlertResolveRequest) -> SystemAlertResponse:
        """Resolve an alert."""
        alert = await self.alert_repository.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"System alert with ID {alert_id} not found")
        
        alert.resolve(str(resolved_by), request.resolution_notes)
        await self.session.commit()
        await self.session.refresh(alert)
        
        return SystemAlertResponse.model_validate(alert)
    
    async def suppress_alert(self, alert_id: UUID) -> SystemAlertResponse:
        """Suppress an alert."""
        alert = await self.alert_repository.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"System alert with ID {alert_id} not found")
        
        alert.suppress()
        await self.session.commit()
        await self.session.refresh(alert)
        
        return SystemAlertResponse.model_validate(alert)
    
    # Dashboard and reporting operations
    async def get_analytics_dashboard(self) -> AnalyticsDashboard:
        """Get analytics dashboard data."""
        # Get report summary
        report_summary = await self.report_repository.get_report_summary()
        
        # Get alert counts
        active_alerts = await self.alert_repository.count_by_status(AlertStatus.ACTIVE)
        critical_alerts = await self.alert_repository.count_by_severity(AlertSeverity.CRITICAL)
        
        # Get metrics counts
        all_metrics = await self.metric_repository.get_all(active_only=True)
        metrics_with_targets = await self.metric_repository.get_metrics_with_targets()
        metrics_meeting_targets = await self.metric_repository.get_metrics_meeting_targets()
        
        # Get recent reports
        recent_reports = await self.get_reports(limit=10)
        
        # Get critical alerts
        critical_alerts_list = await self.get_alerts(
            severity=AlertSeverity.CRITICAL,
            status=AlertStatus.ACTIVE,
            limit=10
        )
        
        # Get key metrics
        key_metrics = await self.get_metrics(limit=10)
        
        return AnalyticsDashboard(
            total_reports=report_summary['total_reports'],
            pending_reports=report_summary['pending_reports'],
            completed_reports=report_summary['completed_reports'],
            failed_reports=report_summary['failed_reports'],
            active_alerts=active_alerts,
            critical_alerts=critical_alerts,
            total_metrics=len(all_metrics),
            metrics_with_targets=len(metrics_with_targets),
            metrics_meeting_targets=len(metrics_meeting_targets),
            recent_reports=recent_reports,
            critical_alerts_list=critical_alerts_list,
            key_metrics=key_metrics
        )
    
    async def get_system_health(self) -> SystemHealthSummary:
        """Get system health summary."""
        # Get alert counts
        active_alerts = await self.alert_repository.count_by_status(AlertStatus.ACTIVE)
        critical_alerts = await self.alert_repository.count_by_severity(AlertSeverity.CRITICAL)
        warning_alerts = await self.alert_repository.count_by_severity(AlertSeverity.MEDIUM)
        
        # Determine overall health
        if critical_alerts > 0:
            overall_health = "CRITICAL"
        elif warning_alerts > 5:
            overall_health = "WARNING"
        elif active_alerts > 0:
            overall_health = "DEGRADED"
        else:
            overall_health = "HEALTHY"
        
        # Get system stats (these would be implemented with actual system monitoring)
        system_uptime = "99.9%"
        database_size = "245 MB"
        storage_usage = "15.2 GB"
        cpu_usage = 25.4
        memory_usage = 68.7
        disk_usage = 42.1
        
        return SystemHealthSummary(
            overall_health=overall_health,
            active_alerts=active_alerts,
            critical_alerts=critical_alerts,
            warning_alerts=warning_alerts,
            system_uptime=system_uptime,
            last_backup=datetime.utcnow() - timedelta(hours=6),
            database_size=database_size,
            storage_usage=storage_usage,
            cpu_usage=cpu_usage,
            memory_usage=memory_usage,
            disk_usage=disk_usage
        )
    
    # Metric calculation and automation
    async def calculate_key_metrics(self) -> List[BusinessMetricResponse]:
        """Calculate and update key business metrics."""
        metrics = []
        
        # Calculate total revenue
        total_revenue = await self._calculate_total_revenue()
        revenue_metric = await self._update_or_create_metric(
            "total_revenue",
            MetricType.CURRENCY,
            "financial",
            total_revenue,
            unit="USD"
        )
        metrics.append(BusinessMetricResponse.model_validate(revenue_metric))
        
        # Calculate total customers
        total_customers = await self._calculate_total_customers()
        customers_metric = await self._update_or_create_metric(
            "total_customers",
            MetricType.COUNTER,
            "business",
            total_customers,
            unit="customers"
        )
        metrics.append(BusinessMetricResponse.model_validate(customers_metric))
        
        # Calculate inventory utilization
        inventory_utilization = await self._calculate_inventory_utilization()
        utilization_metric = await self._update_or_create_metric(
            "inventory_utilization",
            MetricType.PERCENTAGE,
            "operations",
            inventory_utilization,
            unit="%"
        )
        metrics.append(BusinessMetricResponse.model_validate(utilization_metric))
        
        # Calculate return rate
        return_rate = await self._calculate_return_rate()
        return_metric = await self._update_or_create_metric(
            "return_rate",
            MetricType.PERCENTAGE,
            "operations",
            return_rate,
            unit="%"
        )
        metrics.append(BusinessMetricResponse.model_validate(return_metric))
        
        return metrics
    
    async def _calculate_total_revenue(self) -> Decimal:
        """Calculate total revenue from transactions."""
        transactions = await self.transaction_repository.get_all(active_only=True)
        total = sum(transaction.total_amount for transaction in transactions)
        return total
    
    async def _calculate_total_customers(self) -> Decimal:
        """Calculate total number of customers."""
        customers = await self.customer_repository.get_all(active_only=True)
        return Decimal(str(len(customers)))
    
    async def _calculate_inventory_utilization(self) -> Decimal:
        """Calculate inventory utilization percentage."""
        inventory_units = await self.inventory_unit_repository.get_all(active_only=True)
        if not inventory_units:
            return Decimal("0")
        
        rented_units = len([unit for unit in inventory_units if unit.is_rented()])
        total_units = len(inventory_units)
        
        utilization = (rented_units / total_units) * 100
        return Decimal(str(utilization)).quantize(Decimal('0.01'))
    
    async def _calculate_return_rate(self) -> Decimal:
        """Calculate return rate percentage."""
        transactions = await self.transaction_repository.get_all(active_only=True)
        
        if not transactions:
            return Decimal("0")
        
        rental_transactions = [t for t in transactions if t.is_rental()]
        if not rental_transactions:
            return Decimal("0")
        
        # Count rental transactions that have return metadata
        returned_rentals = 0
        for transaction in rental_transactions:
            if transaction.metadata_entries:
                for metadata in transaction.metadata_entries:
                    if metadata.key == "return_data":
                        returned_rentals += 1
                        break
        
        return_rate = (returned_rentals / len(rental_transactions)) * 100
        return Decimal(str(return_rate)).quantize(Decimal('0.01'))
    
    async def _update_or_create_metric(
        self, 
        metric_name: str, 
        metric_type: MetricType, 
        category: str, 
        value: Decimal,
        unit: Optional[str] = None
    ) -> BusinessMetric:
        """Update existing metric or create new one."""
        existing_metric = await self.metric_repository.get_by_name(metric_name)
        
        if existing_metric:
            existing_metric.update_value(value)
            await self.session.commit()
            await self.session.refresh(existing_metric)
            return existing_metric
        else:
            metric_data = BusinessMetricCreate(
                metric_name=metric_name,
                metric_type=metric_type,
                category=category,
                current_value=value,
                unit=unit
            )
            return await self.metric_repository.create(metric_data)

===== modules/company/__init__.py â€“ 2025-07-19 12:13:41 IST =====
"""Company module for managing company information."""

===== modules/company/models.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional
from sqlalchemy import Column, String, Text, Index

from app.db.base import BaseModel


class Company(BaseModel):
    """
    Company model for managing company information.
    
    Attributes:
        company_name: Name of the company
        address: Company address
        email: Company email address
        phone: Company phone number
        gst_no: GST registration number
        registration_number: Company registration number
    """
    
    __tablename__ = "companies"
    
    # Basic company information
    company_name = Column(String(255), nullable=False, unique=True, index=True, comment="Company name")
    address = Column(Text, nullable=True, comment="Company address")
    email = Column(String(255), nullable=True, comment="Company email")
    phone = Column(String(50), nullable=True, comment="Company phone number")
    gst_no = Column(String(50), nullable=True, unique=True, index=True, comment="GST registration number")
    registration_number = Column(String(100), nullable=True, unique=True, index=True, comment="Company registration number")
    
    # Additional indexes for performance
    __table_args__ = (
        Index('idx_company_name_active', 'company_name', 'is_active'),
    )
    
    def __init__(
        self,
        company_name: str,
        address: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        gst_no: Optional[str] = None,
        registration_number: Optional[str] = None,
        **kwargs
    ):
        """
        Initialize a Company.
        
        Args:
            company_name: Company name
            address: Company address
            email: Company email
            phone: Company phone number
            gst_no: GST registration number
            registration_number: Company registration number
            **kwargs: Additional BaseModel fields
        """
        super().__init__(
            company_name=company_name,
            address=address,
            email=email,
            phone=phone,
            gst_no=gst_no,
            registration_number=registration_number,
            **kwargs
        )
        self._validate()
    
    def _validate(self):
        """Validate company business rules."""
        # Company name validation
        if not self.company_name or not self.company_name.strip():
            raise ValueError("Company name cannot be empty")
        
        if len(self.company_name) > 255:
            raise ValueError("Company name cannot exceed 255 characters")
        
        # Email validation
        if self.email:
            if not self.email.strip():
                raise ValueError("Email cannot be empty if provided")
            
            if len(self.email) > 255:
                raise ValueError("Email cannot exceed 255 characters")
            
            # Basic email format validation
            if "@" not in self.email or "." not in self.email.split("@")[-1]:
                raise ValueError("Invalid email format")
        
        # Phone validation
        if self.phone:
            if not self.phone.strip():
                raise ValueError("Phone cannot be empty if provided")
            
            if len(self.phone) > 50:
                raise ValueError("Phone number cannot exceed 50 characters")
        
        # GST number validation
        if self.gst_no:
            if not self.gst_no.strip():
                raise ValueError("GST number cannot be empty if provided")
            
            if len(self.gst_no) > 50:
                raise ValueError("GST number cannot exceed 50 characters")
            
            # Uppercase GST number
            self.gst_no = self.gst_no.upper().strip()
        
        # Registration number validation
        if self.registration_number:
            if not self.registration_number.strip():
                raise ValueError("Registration number cannot be empty if provided")
            
            if len(self.registration_number) > 100:
                raise ValueError("Registration number cannot exceed 100 characters")
            
            # Uppercase registration number
            self.registration_number = self.registration_number.upper().strip()
    
    def update_info(
        self,
        company_name: Optional[str] = None,
        address: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        gst_no: Optional[str] = None,
        registration_number: Optional[str] = None,
        updated_by: Optional[str] = None
    ):
        """
        Update company information.
        
        Args:
            company_name: New company name
            address: New address
            email: New email
            phone: New phone number
            gst_no: New GST number
            registration_number: New registration number
            updated_by: User making the update
        """
        if company_name is not None:
            if not company_name or not company_name.strip():
                raise ValueError("Company name cannot be empty")
            if len(company_name) > 255:
                raise ValueError("Company name cannot exceed 255 characters")
            self.company_name = company_name.strip()
        
        if address is not None:
            self.address = address.strip() if address else None
        
        if email is not None:
            if email and not email.strip():
                raise ValueError("Email cannot be empty if provided")
            if email and len(email) > 255:
                raise ValueError("Email cannot exceed 255 characters")
            if email and ("@" not in email or "." not in email.split("@")[-1]):
                raise ValueError("Invalid email format")
            self.email = email.strip() if email else None
        
        if phone is not None:
            if phone and not phone.strip():
                raise ValueError("Phone cannot be empty if provided")
            if phone and len(phone) > 50:
                raise ValueError("Phone number cannot exceed 50 characters")
            self.phone = phone.strip() if phone else None
        
        if gst_no is not None:
            if gst_no and not gst_no.strip():
                raise ValueError("GST number cannot be empty if provided")
            if gst_no and len(gst_no) > 50:
                raise ValueError("GST number cannot exceed 50 characters")
            self.gst_no = gst_no.upper().strip() if gst_no else None
        
        if registration_number is not None:
            if registration_number and not registration_number.strip():
                raise ValueError("Registration number cannot be empty if provided")
            if registration_number and len(registration_number) > 100:
                raise ValueError("Registration number cannot exceed 100 characters")
            self.registration_number = registration_number.upper().strip() if registration_number else None
        
        self.updated_by = updated_by
    
    @property
    def display_name(self) -> str:
        """Get display name for the company."""
        return self.company_name
    
    def __str__(self) -> str:
        """String representation of company."""
        return self.display_name
    
    def __repr__(self) -> str:
        """Developer representation of company."""
        return f"<Company(id={self.id}, name='{self.company_name}', active={self.is_active})>"

===== modules/company/repository.py â€“ 2025-07-20 02:40:40 IST =====
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import select, func, or_, and_, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession

from .models import Company
from app.shared.repository import BaseRepository


class CompanyRepository(BaseRepository[Company]):
    """Repository for company data access operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with database session."""
        super().__init__(Company, session)
    
    # Methods inherited from BaseRepository:
    # - create(obj_data: Dict[str, Any]) -> Company
    # - get_by_id(id: UUID) -> Optional[Company]
    # - get_all(...) -> List[Company]
    # - update(id: UUID, obj_data: Dict[str, Any]) -> Optional[Company]
    # - delete(id: UUID) -> bool  (soft delete)
    # - count_all(...) -> int
    # - exists(id: UUID) -> bool
    # - search(...) -> List[Company]
    # - get_paginated(...) -> Dict[str, Any]
    
    # Company-specific methods
    
    async def get_by_name(self, company_name: str) -> Optional[Company]:
        """Get company by name."""
        return await self.get_by_field("company_name", company_name)
    
    async def get_by_gst_no(self, gst_no: str) -> Optional[Company]:
        """Get company by GST number."""
        return await self.get_by_field("gst_no", gst_no)
    
    async def get_by_registration_number(self, registration_number: str) -> Optional[Company]:
        """Get company by registration number."""
        return await self.get_by_field("registration_number", registration_number)
    
    async def get_active_company(self) -> Optional[Company]:
        """Get the active company (for single company mode)."""
        query = select(Company).where(Company.is_active == True).limit(1)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def update(self, company_id: UUID, update_data: dict) -> Optional[Company]:
        """Update existing company.
        
        Overrides base implementation to use model's update_info method.
        """
        company = await self.get_by_id(company_id)
        if not company:
            return None
        
        # Update fields using the model's update method
        company.update_info(**update_data)
        
        await self.session.commit()
        await self.session.refresh(company)
        
        return company
    
    async def activate(self, company_id: UUID) -> Optional[Company]:
        """Activate a company and deactivate all others (single company mode)."""
        # First deactivate all companies
        all_companies_query = select(Company)
        result = await self.session.execute(all_companies_query)
        all_companies = result.scalars().all()
        
        for comp in all_companies:
            comp.is_active = False
        
        # Then activate the specified company
        company = await self.get_by_id(company_id)
        if not company:
            return None
        
        company.is_active = True
        await self.session.commit()
        await self.session.refresh(company)
        
        return company
    
    async def exists_by_name(self, company_name: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a company with the given name exists."""
        query = select(func.count()).select_from(Company).where(
            Company.company_name == company_name
        )
        
        if exclude_id:
            query = query.where(Company.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0
    
    async def exists_by_gst_no(self, gst_no: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a company with the given GST number exists."""
        query = select(func.count()).select_from(Company).where(
            Company.gst_no == gst_no
        )
        
        if exclude_id:
            query = query.where(Company.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0
    
    async def exists_by_registration_number(self, registration_number: str, exclude_id: Optional[UUID] = None) -> bool:
        """Check if a company with the given registration number exists."""
        query = select(func.count()).select_from(Company).where(
            Company.registration_number == registration_number
        )
        
        if exclude_id:
            query = query.where(Company.id != exclude_id)
        
        result = await self.session.execute(query)
        count = result.scalar_one()
        
        return count > 0
    
    async def search(
        self,
        search_term: str,
        limit: int = 10,
        include_inactive: bool = False
    ) -> List[Company]:
        """Search companies by name, email, GST or registration number.
        
        Overrides base search to search specific Company fields.
        """
        search_fields = ["company_name", "email", "gst_no", "registration_number"]
        return await super().search(
            search_term=search_term,
            search_fields=search_fields,
            limit=limit,
            active_only=not include_inactive
        )

===== modules/company/routes.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional, List
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from fastapi.responses import JSONResponse

from .service import CompanyService
from .schemas import (
    CompanyCreate, CompanyUpdate, CompanyResponse, CompanySummary,
    CompanyList, CompanyFilter, CompanySort, CompanyActiveStatus
)
from app.shared.dependencies import get_company_service
from app.core.errors import (
    NotFoundError, ConflictError, ValidationError,
    BusinessRuleError
)


router = APIRouter(tags=["company"])


@router.post("/", response_model=CompanyResponse, status_code=status.HTTP_201_CREATED)
async def create_company(
    company_data: CompanyCreate,
    service: CompanyService = Depends(get_company_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Create a new company."""
    try:
        return await service.create_company(company_data, created_by=current_user_id)
    except ConflictError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get("/active", response_model=CompanyResponse)
async def get_active_company(
    service: CompanyService = Depends(get_company_service)
):
    """Get the active company."""
    try:
        return await service.get_active_company()
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/{company_id}", response_model=CompanyResponse)
async def get_company(
    company_id: UUID,
    service: CompanyService = Depends(get_company_service)
):
    """Get a company by ID."""
    try:
        return await service.get_company(company_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/", response_model=CompanyList)
async def list_companies(
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    company_name: Optional[str] = Query(None, description="Filter by company name (partial match)"),
    email: Optional[str] = Query(None, description="Filter by email (partial match)"),
    gst_no: Optional[str] = Query(None, description="Filter by GST number (partial match)"),
    registration_number: Optional[str] = Query(None, description="Filter by registration number (partial match)"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    search: Optional[str] = Query(None, description="Search in name, email, GST and registration number"),
    sort_field: str = Query("company_name", description="Field to sort by"),
    sort_direction: str = Query("asc", description="Sort direction (asc/desc)"),
    include_inactive: bool = Query(False, description="Include inactive companies"),
    service: CompanyService = Depends(get_company_service)
):
    """List companies with pagination, filtering, and sorting."""
    # Create filter object
    filters = CompanyFilter(
        company_name=company_name,
        email=email,
        gst_no=gst_no,
        registration_number=registration_number,
        is_active=is_active,
        search=search
    )
    
    # Create sort object
    sort_options = CompanySort(
        field=sort_field,
        direction=sort_direction
    )
    
    try:
        return await service.list_companies(
            page=page,
            page_size=page_size,
            filter_params=filters,
            sort_params=sort_options,
            include_inactive=include_inactive
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.put("/{company_id}", response_model=CompanyResponse)
async def update_company(
    company_id: UUID,
    company_data: CompanyUpdate,
    service: CompanyService = Depends(get_company_service),
    current_user_id: Optional[str] = None  # TODO: Get from auth context
):
    """Update an existing company."""
    try:
        return await service.update_company(
            company_id=company_id,
            company_data=company_data,
            updated_by=current_user_id
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ConflictError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.delete("/{company_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_company(
    company_id: UUID,
    service: CompanyService = Depends(get_company_service)
):
    """Soft delete a company."""
    try:
        await service.delete_company(company_id)
        return
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except BusinessRuleError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post("/{company_id}/activate", response_model=CompanyResponse)
async def activate_company(
    company_id: UUID,
    service: CompanyService = Depends(get_company_service)
):
    """Activate a company (and deactivate all others)."""
    try:
        return await service.activate_company(company_id)
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


@router.get("/search/", response_model=List[CompanySummary])
async def search_companies(
    q: str = Query(..., min_length=1, description="Search term"),
    limit: int = Query(10, ge=1, le=50, description="Maximum results"),
    include_inactive: bool = Query(False, description="Include inactive companies"),
    service: CompanyService = Depends(get_company_service)
):
    """Search companies by name, email, GST or registration number."""
    return await service.search_companies(
        search_term=q,
        limit=limit,
        include_inactive=include_inactive
    )

===== modules/company/schemas.py â€“ 2025-07-19 12:13:41 IST =====
from typing import Optional
from pydantic import BaseModel, ConfigDict, Field, field_validator
from datetime import datetime
from uuid import UUID


class CompanyBase(BaseModel):
    """Base company schema with common fields."""
    
    company_name: str = Field(..., min_length=1, max_length=255, description="Company name")
    address: Optional[str] = Field(None, description="Company address")
    email: Optional[str] = Field(None, max_length=255, description="Company email")
    phone: Optional[str] = Field(None, max_length=50, description="Company phone number")
    gst_no: Optional[str] = Field(None, max_length=50, description="GST registration number")
    registration_number: Optional[str] = Field(None, max_length=100, description="Company registration number")
    
    @field_validator('company_name')
    @classmethod
    def validate_company_name(cls, v):
        if not v or not v.strip():
            raise ValueError('Company name cannot be empty')
        return v.strip()
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Email cannot be empty if provided')
            
            # Basic email validation
            if "@" not in v or "." not in v.split("@")[-1]:
                raise ValueError('Invalid email format')
            
            return v.strip().lower()
        return v
    
    @field_validator('phone')
    @classmethod
    def validate_phone(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Phone cannot be empty if provided')
            return v.strip()
        return v
    
    @field_validator('gst_no')
    @classmethod
    def validate_gst_no(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('GST number cannot be empty if provided')
            return v.upper().strip()
        return v
    
    @field_validator('registration_number')
    @classmethod
    def validate_registration_number(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Registration number cannot be empty if provided')
            return v.upper().strip()
        return v
    
    @field_validator('address')
    @classmethod
    def validate_address(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class CompanyCreate(CompanyBase):
    """Schema for creating a new company."""
    pass


class CompanyUpdate(BaseModel):
    """Schema for updating an existing company."""
    
    company_name: Optional[str] = Field(None, min_length=1, max_length=255, description="Company name")
    address: Optional[str] = Field(None, description="Company address")
    email: Optional[str] = Field(None, max_length=255, description="Company email")
    phone: Optional[str] = Field(None, max_length=50, description="Company phone number")
    gst_no: Optional[str] = Field(None, max_length=50, description="GST registration number")
    registration_number: Optional[str] = Field(None, max_length=100, description="Company registration number")
    is_active: Optional[bool] = Field(None, description="Company active status")
    
    @field_validator('company_name')
    @classmethod
    def validate_company_name(cls, v):
        if v is not None:
            if not v or not v.strip():
                raise ValueError('Company name cannot be empty')
            return v.strip()
        return v
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Email cannot be empty if provided')
            
            # Basic email validation
            if "@" not in v or "." not in v.split("@")[-1]:
                raise ValueError('Invalid email format')
            
            return v.strip().lower()
        return v
    
    @field_validator('phone')
    @classmethod
    def validate_phone(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Phone cannot be empty if provided')
            return v.strip()
        return v
    
    @field_validator('gst_no')
    @classmethod
    def validate_gst_no(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('GST number cannot be empty if provided')
            return v.upper().strip()
        return v
    
    @field_validator('registration_number')
    @classmethod
    def validate_registration_number(cls, v):
        if v is not None:
            if not v.strip():
                raise ValueError('Registration number cannot be empty if provided')
            return v.upper().strip()
        return v
    
    @field_validator('address')
    @classmethod
    def validate_address(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class CompanyResponse(CompanyBase):
    """Schema for company response with all fields."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Company unique identifier")
    is_active: bool = Field(True, description="Company active status")
    created_at: datetime = Field(..., description="Company creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Company last update timestamp")
    created_by: Optional[str] = Field(None, description="User who created the company")
    updated_by: Optional[str] = Field(None, description="User who last updated the company")


class CompanySummary(BaseModel):
    """Schema for company summary with minimal fields."""
    
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID = Field(..., description="Company unique identifier")
    company_name: str = Field(..., description="Company name")
    email: Optional[str] = Field(None, description="Company email")
    phone: Optional[str] = Field(None, description="Company phone")
    is_active: bool = Field(True, description="Company active status")


class CompanyList(BaseModel):
    """Schema for paginated company list response."""
    
    items: list[CompanySummary] = Field(..., description="List of company summaries")
    total: int = Field(..., description="Total number of companies")
    page: int = Field(..., description="Current page number")
    page_size: int = Field(..., description="Number of items per page")
    total_pages: int = Field(..., description="Total number of pages")
    has_next: bool = Field(..., description="Whether there are more pages")
    has_previous: bool = Field(..., description="Whether there are previous pages")


class CompanyFilter(BaseModel):
    """Schema for company filtering and search."""
    
    company_name: Optional[str] = Field(None, description="Filter by company name (partial match)")
    email: Optional[str] = Field(None, description="Filter by email (partial match)")
    gst_no: Optional[str] = Field(None, description="Filter by GST number (partial match)")
    registration_number: Optional[str] = Field(None, description="Filter by registration number (partial match)")
    is_active: Optional[bool] = Field(None, description="Filter by active status")
    search: Optional[str] = Field(None, description="Search in name, email, GST and registration number")
    
    @field_validator('company_name', 'email', 'gst_no', 'registration_number', 'search')
    @classmethod
    def validate_string_filters(cls, v):
        if v is not None:
            return v.strip() if v.strip() else None
        return v


class CompanySort(BaseModel):
    """Schema for company sorting options."""
    
    field: str = Field('company_name', description="Field to sort by")
    direction: str = Field('asc', description="Sort direction (asc/desc)")
    
    @field_validator('field')
    @classmethod
    def validate_field(cls, v):
        allowed_fields = ['company_name', 'email', 'created_at', 'updated_at', 'is_active']
        if v not in allowed_fields:
            raise ValueError(f'Sort field must be one of: {", ".join(allowed_fields)}')
        return v
    
    @field_validator('direction')
    @classmethod
    def validate_direction(cls, v):
        if v.lower() not in ['asc', 'desc']:
            raise ValueError('Sort direction must be "asc" or "desc"')
        return v.lower()


class CompanyActiveStatus(BaseModel):
    """Schema for activating/deactivating a company."""
    
    is_active: bool = Field(..., description="Active status to set")

===== modules/company/service.py â€“ 2025-07-19 12:13:41 IST =====
from typing import List, Optional, Dict, Any
from uuid import UUID

from .repository import CompanyRepository
from .models import Company
from .schemas import (
    CompanyCreate, CompanyUpdate, CompanyResponse, CompanySummary,
    CompanyList, CompanyFilter, CompanySort, CompanyActiveStatus
)
from app.core.errors import (
    NotFoundError, ConflictError, ValidationError,
    BusinessRuleError
)


class CompanyService:
    """Service layer for company business logic."""
    
    def __init__(self, repository: CompanyRepository):
        """Initialize service with repository."""
        self.repository = repository
    
    async def create_company(
        self,
        company_data: CompanyCreate,
        created_by: Optional[str] = None
    ) -> CompanyResponse:
        """Create a new company.
        
        Args:
            company_data: Company creation data
            created_by: User creating the company
            
        Returns:
            Created company response
            
        Raises:
            ConflictError: If company name, GST or registration number already exists
            ValidationError: If company data is invalid
        """
        # Check if company name already exists
        if await self.repository.exists_by_name(company_data.company_name):
            raise ConflictError(f"Company with name '{company_data.company_name}' already exists")
        
        # Check if GST number already exists
        if company_data.gst_no and await self.repository.exists_by_gst_no(company_data.gst_no):
            raise ConflictError(f"Company with GST number '{company_data.gst_no}' already exists")
        
        # Check if registration number already exists
        if company_data.registration_number and await self.repository.exists_by_registration_number(company_data.registration_number):
            raise ConflictError(f"Company with registration number '{company_data.registration_number}' already exists")
        
        # Prepare company data
        create_data = company_data.model_dump()
        create_data.update({
            "created_by": created_by,
            "updated_by": created_by
        })
        
        # Create company
        company = await self.repository.create(create_data)
        
        # Convert to response
        return CompanyResponse.model_validate(company)
    
    async def get_company(self, company_id: UUID) -> CompanyResponse:
        """Get company by ID.
        
        Args:
            company_id: Company UUID
            
        Returns:
            Company response
            
        Raises:
            NotFoundError: If company not found
        """
        company = await self.repository.get_by_id(company_id)
        if not company:
            raise NotFoundError(f"Company with id {company_id} not found")
        
        return CompanyResponse.model_validate(company)
    
    async def get_active_company(self) -> CompanyResponse:
        """Get the active company.
        
        Returns:
            Active company response
            
        Raises:
            NotFoundError: If no active company found
        """
        company = await self.repository.get_active_company()
        if not company:
            raise NotFoundError("No active company found")
        
        return CompanyResponse.model_validate(company)
    
    async def update_company(
        self,
        company_id: UUID,
        company_data: CompanyUpdate,
        updated_by: Optional[str] = None
    ) -> CompanyResponse:
        """Update an existing company.
        
        Args:
            company_id: Company UUID
            company_data: Company update data
            updated_by: User updating the company
            
        Returns:
            Updated company response
            
        Raises:
            NotFoundError: If company not found
            ConflictError: If name, GST or registration number already exists
            ValidationError: If update data is invalid
        """
        # Get existing company
        existing_company = await self.repository.get_by_id(company_id)
        if not existing_company:
            raise NotFoundError(f"Company with id {company_id} not found")
        
        # Prepare update data
        update_data = {}
        
        # Check name uniqueness if provided
        if company_data.company_name is not None and company_data.company_name != existing_company.company_name:
            if await self.repository.exists_by_name(company_data.company_name, exclude_id=company_id):
                raise ConflictError(f"Company with name '{company_data.company_name}' already exists")
            update_data["company_name"] = company_data.company_name
        
        # Check GST number uniqueness if provided
        if company_data.gst_no is not None and company_data.gst_no != existing_company.gst_no:
            if company_data.gst_no and await self.repository.exists_by_gst_no(company_data.gst_no, exclude_id=company_id):
                raise ConflictError(f"Company with GST number '{company_data.gst_no}' already exists")
            update_data["gst_no"] = company_data.gst_no
        
        # Check registration number uniqueness if provided
        if company_data.registration_number is not None and company_data.registration_number != existing_company.registration_number:
            if company_data.registration_number and await self.repository.exists_by_registration_number(company_data.registration_number, exclude_id=company_id):
                raise ConflictError(f"Company with registration number '{company_data.registration_number}' already exists")
            update_data["registration_number"] = company_data.registration_number
        
        # Add other fields if provided
        if company_data.address is not None:
            update_data["address"] = company_data.address
        if company_data.email is not None:
            update_data["email"] = company_data.email
        if company_data.phone is not None:
            update_data["phone"] = company_data.phone
        if company_data.is_active is not None:
            update_data["is_active"] = company_data.is_active
        
        # Add updated_by
        update_data["updated_by"] = updated_by
        
        # Update company
        company = await self.repository.update(company_id, update_data)
        if not company:
            raise NotFoundError(f"Failed to update company with id {company_id}")
        
        return CompanyResponse.model_validate(company)
    
    async def delete_company(self, company_id: UUID) -> bool:
        """Soft delete a company.
        
        Args:
            company_id: Company UUID
            
        Returns:
            True if deleted successfully
            
        Raises:
            NotFoundError: If company not found
            BusinessRuleError: If company cannot be deleted
        """
        company = await self.repository.get_by_id(company_id)
        if not company:
            raise NotFoundError(f"Company with id {company_id} not found")
        
        # Check if this is the only active company
        total_active = await self.repository.count(include_inactive=False)
        if total_active == 1 and company.is_active:
            raise BusinessRuleError("Cannot delete the only active company")
        
        success = await self.repository.delete(company_id)
        if not success:
            raise BusinessRuleError(f"Failed to delete company with id {company_id}")
        
        return True
    
    async def activate_company(self, company_id: UUID) -> CompanyResponse:
        """Activate a company (and deactivate all others).
        
        Args:
            company_id: Company UUID to activate
            
        Returns:
            Activated company response
            
        Raises:
            NotFoundError: If company not found
        """
        company = await self.repository.activate(company_id)
        if not company:
            raise NotFoundError(f"Company with id {company_id} not found")
        
        return CompanyResponse.model_validate(company)
    
    async def list_companies(
        self,
        page: int = 1,
        page_size: int = 20,
        filter_params: Optional[CompanyFilter] = None,
        sort_params: Optional[CompanySort] = None,
        include_inactive: bool = False
    ) -> CompanyList:
        """List companies with pagination, filtering and sorting.
        
        Args:
            page: Page number (1-based)
            page_size: Items per page
            filter_params: Filtering parameters
            sort_params: Sorting parameters
            include_inactive: Include inactive companies
            
        Returns:
            Paginated company list
        """
        # Convert filter parameters to dict
        filters = filter_params.model_dump(exclude_none=True) if filter_params else {}
        
        # Get sorting parameters
        sort_by = sort_params.field if sort_params else "company_name"
        sort_order = sort_params.direction if sort_params else "asc"
        
        # Get paginated companies
        companies = await self.repository.get_paginated(
            page=page,
            page_size=page_size,
            filters=filters,
            sort_by=sort_by,
            sort_order=sort_order,
            include_inactive=include_inactive
        )
        
        # Get total count
        total = await self.repository.count(
            filters=filters,
            include_inactive=include_inactive
        )
        
        # Calculate pagination info
        total_pages = (total + page_size - 1) // page_size
        has_next = page < total_pages
        has_previous = page > 1
        
        # Convert to summaries
        items = [CompanySummary.model_validate(company) for company in companies]
        
        return CompanyList(
            items=items,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
            has_next=has_next,
            has_previous=has_previous
        )
    
    async def search_companies(
        self,
        search_term: str,
        limit: int = 10,
        include_inactive: bool = False
    ) -> List[CompanySummary]:
        """Search companies by name, email, GST or registration number.
        
        Args:
            search_term: Search term
            limit: Maximum results to return
            include_inactive: Include inactive companies
            
        Returns:
            List of company summaries
        """
        companies = await self.repository.search(
            search_term=search_term,
            limit=limit,
            include_inactive=include_inactive
        )
        
        return [CompanySummary.model_validate(company) for company in companies]

