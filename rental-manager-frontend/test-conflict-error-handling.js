/**\n * Test script for duplicate item error handling\n * This script tests the enhanced 409 conflict error dialog implementation\n */\n\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\n// Test configuration\nconst TEST_CONFIG = {\n  baseUrl: 'http://localhost:3000',\n  timeout: 30000,\n  headless: false, // Set to true for CI/CD\n  slowMo: 100 // Slow down actions for better visibility\n};\n\n// Test scenarios for conflict error handling\nconst TEST_SCENARIOS = [\n  {\n    name: 'Create duplicate item and handle conflict',\n    itemName: 'Cannon Cement Mixer',\n    expectedError: 'Item Already Exists',\n    expectedMessage: /already exists/i\n  },\n  {\n    name: 'Test alternative name suggestions',\n    itemName: 'Test Duplicate Item',\n    expectedError: 'Item Already Exists',\n    testAlternatives: true\n  },\n  {\n    name: 'Test retry functionality with network error',\n    itemName: 'Network Test Item',\n    simulateNetworkError: true\n  }\n];\n\nclass ConflictErrorTester {\n  constructor(config) {\n    this.config = config;\n    this.browser = null;\n    this.page = null;\n    this.results = {\n      passed: 0,\n      failed: 0,\n      details: []\n    };\n  }\n\n  async initialize() {\n    console.log('ðŸš€ Initializing Conflict Error Handler Test Suite...');\n    \n    this.browser = await puppeteer.launch({\n      headless: this.config.headless,\n      slowMo: this.config.slowMo,\n      defaultViewport: { width: 1200, height: 800 },\n      args: ['--disable-dev-shm-usage', '--no-sandbox']\n    });\n    \n    this.page = await this.browser.newPage();\n    \n    // Enable console logging\n    this.page.on('console', msg => {\n      if (msg.type() === 'error') {\n        console.log('âŒ Console Error:', msg.text());\n      } else if (msg.type() === 'warn') {\n        console.log('âš ï¸  Console Warning:', msg.text());\n      }\n    });\n\n    // Listen for network requests to catch API calls\n    this.page.on('response', response => {\n      if (response.url().includes('/api/items') && response.status() === 409) {\n        console.log('ðŸ” Detected 409 Conflict:', response.url());\n      }\n    });\n\n    await this.page.setDefaultTimeout(this.config.timeout);\n  }\n\n  async navigateToItemForm() {\n    console.log('ðŸ“ Navigating to item creation form...');\n    \n    try {\n      await this.page.goto(`${this.config.baseUrl}/products/items/new`, {\n        waitUntil: 'networkidle2'\n      });\n      \n      await this.page.waitForSelector('[data-testid=\"item-name-input\"]', {\n        timeout: 10000\n      });\n      \n      console.log('âœ… Successfully loaded item form');\n      return true;\n    } catch (error) {\n      console.error('âŒ Failed to load item form:', error.message);\n      return false;\n    }\n  }\n\n  async fillItemForm(itemName, additionalData = {}) {\n    console.log(`ðŸ“ Filling item form with name: \"${itemName}\"...`);\n    \n    try {\n      // Clear and fill item name\n      const nameInput = await this.page.waitForSelector('[data-testid=\"item-name-input\"]');\n      await nameInput.click({ clickCount: 3 }); // Select all\n      await nameInput.type(itemName);\n      \n      // Wait for any validation to complete\n      await this.page.waitForTimeout(1000);\n      \n      // Check for validation messages\n      const validatingText = await this.page.$('text=\"Checking for duplicates...\"');\n      if (validatingText) {\n        console.log('â³ Waiting for validation to complete...');\n        await this.page.waitForFunction(() => {\n          return !document.querySelector('text=\"Checking for duplicates...\"');\n        }, { timeout: 5000 });\n      }\n      \n      // Enable rentable option\n      const rentableCheckbox = await this.page.$('[data-testid=\"is-rentable-checkbox\"]');\n      if (rentableCheckbox) {\n        await rentableCheckbox.click();\n      }\n      \n      // Fill rental rate\n      const rentalRateInput = await this.page.$('#rental_rate_per_period');\n      if (rentalRateInput && !await rentalRateInput.isDisabled()) {\n        await rentalRateInput.type('100');\n      }\n      \n      // Select category if dropdown is available\n      try {\n        const categoryDropdown = await this.page.$('[data-testid=\"category-dropdown\"]');\n        if (categoryDropdown) {\n          await categoryDropdown.click();\n          await this.page.waitForTimeout(500);\n          const categoryOptions = await this.page.$$('option[value]:not([value=\"\"])');\n          if (categoryOptions.length > 0) {\n            await categoryOptions[0].click();\n          }\n        }\n      } catch (e) {\n        console.log('â„¹ï¸  Category dropdown not available or not needed');\n      }\n      \n      console.log('âœ… Form filled successfully');\n      return true;\n    } catch (error) {\n      console.error('âŒ Failed to fill form:', error.message);\n      return false;\n    }\n  }\n\n  async submitForm() {\n    console.log('ðŸ”„ Submitting form...');\n    \n    try {\n      const submitButton = await this.page.waitForSelector('button[type=\"submit\"]:not([disabled])', {\n        timeout: 5000\n      });\n      \n      await submitButton.click();\n      console.log('âœ… Form submitted');\n      return true;\n    } catch (error) {\n      console.error('âŒ Failed to submit form:', error.message);\n      \n      // Check if button is disabled and why\n      const disabledButton = await this.page.$('button[type=\"submit\"][disabled]');\n      if (disabledButton) {\n        const buttonText = await disabledButton.textContent();\n        console.log(`â„¹ï¸  Submit button is disabled: \"${buttonText}\"`);\n      }\n      \n      return false;\n    }\n  }\n\n  async waitForErrorDialog() {\n    console.log('â³ Waiting for error dialog...');\n    \n    try {\n      // Wait for dialog to appear\n      await this.page.waitForSelector('[role=\"dialog\"]', { timeout: 10000 });\n      \n      // Take screenshot for verification\n      await this.page.screenshot({\n        path: `test-screenshots/conflict-error-dialog-${Date.now()}.png`,\n        fullPage: true\n      });\n      \n      console.log('âœ… Error dialog detected');\n      return true;\n    } catch (error) {\n      console.error('âŒ Error dialog did not appear:', error.message);\n      return false;\n    }\n  }\n\n  async verifyErrorDialog(expectedError, expectedMessage) {\n    console.log('ðŸ” Verifying error dialog content...');\n    \n    try {\n      // Check for error title\n      const errorTitle = await this.page.$eval('[role=\"dialog\"] h2', el => el.textContent);\n      if (!errorTitle.includes(expectedError)) {\n        throw new Error(`Expected error title to contain \"${expectedError}\", got \"${errorTitle}\"`);\n      }\n      \n      // Check for error message\n      const errorMessage = await this.page.$eval('[role=\"dialog\"] p', el => el.textContent);\n      if (expectedMessage && !expectedMessage.test(errorMessage)) {\n        throw new Error(`Expected error message to match pattern, got \"${errorMessage}\"`);\n      }\n      \n      // Check for action buttons\n      const actionButtons = await this.page.$$('[role=\"dialog\"] button');\n      const buttonTexts = await Promise.all(\n        actionButtons.map(btn => btn.evaluate(el => el.textContent))\n      );\n      \n      console.log('ðŸŽ¯ Found action buttons:', buttonTexts);\n      \n      // Verify expected buttons are present\n      const expectedButtons = ['Try Different Name', 'View Existing Item', 'Cancel'];\n      const missingButtons = expectedButtons.filter(btn => \n        !buttonTexts.some(text => text.includes(btn))\n      );\n      \n      if (missingButtons.length > 0) {\n        console.warn('âš ï¸  Missing expected buttons:', missingButtons);\n      }\n      \n      console.log('âœ… Error dialog content verified');\n      return true;\n    } catch (error) {\n      console.error('âŒ Error dialog verification failed:', error.message);\n      return false;\n    }\n  }\n\n  async testAlternativeSelection() {\n    console.log('ðŸ”„ Testing alternative name selection...');\n    \n    try {\n      // Look for alternative suggestions\n      const alternatives = await this.page.$$('input[type=\"radio\"][name=\"alternative\"]');\n      \n      if (alternatives.length === 0) {\n        console.warn('âš ï¸  No alternative suggestions found');\n        return false;\n      }\n      \n      console.log(`ðŸ“‹ Found ${alternatives.length} alternative suggestions`);\n      \n      // Select the first alternative\n      await alternatives[0].click();\n      \n      // Click \"Try Different Name\" button\n      const tryDifferentButton = await this.page.$('button:has-text(\"Try Different Name\")');\n      if (tryDifferentButton) {\n        await tryDifferentButton.click();\n      } else {\n        // Fallback selector\n        await this.page.click('button');\n      }\n      \n      // Verify dialog closed\n      await this.page.waitForSelector('[role=\"dialog\"]', { \n        state: 'detached', \n        timeout: 5000 \n      });\n      \n      // Verify form was updated with new name\n      const updatedName = await this.page.$eval(\n        '[data-testid=\"item-name-input\"]', \n        el => el.value\n      );\n      \n      console.log(`âœ… Form updated with alternative name: \"${updatedName}\"`);\n      return true;\n    } catch (error) {\n      console.error('âŒ Alternative selection test failed:', error.message);\n      return false;\n    }\n  }\n\n  async testRetryFunctionality() {\n    console.log('ðŸ”„ Testing retry functionality...');\n    \n    try {\n      // Click retry button\n      const retryButton = await this.page.$('button:has-text(\"Try Again\")');\n      if (!retryButton) {\n        console.warn('âš ï¸  Retry button not found');\n        return false;\n      }\n      \n      await retryButton.click();\n      \n      // Wait for retry attempt (should show loading state)\n      const loadingButton = await this.page.waitForSelector(\n        'button:has-text(\"Saving...\"), button:has-text(\"Retrying...\")',\n        { timeout: 3000 }\n      );\n      \n      if (loadingButton) {\n        console.log('âœ… Retry attempt detected with loading state');\n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('âŒ Retry functionality test failed:', error.message);\n      return false;\n    }\n  }\n\n  async runScenario(scenario) {\n    console.log(`\\nðŸ§ª Running Scenario: ${scenario.name}`);\n    console.log('='.repeat(50));\n    \n    let scenarioResult = {\n      name: scenario.name,\n      passed: false,\n      errors: [],\n      screenshots: []\n    };\n    \n    try {\n      // Navigate to form\n      if (!await this.navigateToItemForm()) {\n        throw new Error('Failed to navigate to item form');\n      }\n      \n      // Fill form\n      if (!await this.fillItemForm(scenario.itemName)) {\n        throw new Error('Failed to fill item form');\n      }\n      \n      // Submit form\n      if (!await this.submitForm()) {\n        throw new Error('Failed to submit form');\n      }\n      \n      // Wait for error dialog (if expected)\n      if (scenario.expectedError) {\n        if (!await this.waitForErrorDialog()) {\n          throw new Error('Expected error dialog did not appear');\n        }\n        \n        // Verify error dialog content\n        if (!await this.verifyErrorDialog(scenario.expectedError, scenario.expectedMessage)) {\n          throw new Error('Error dialog content verification failed');\n        }\n        \n        // Test specific functionality based on scenario\n        if (scenario.testAlternatives) {\n          if (!await this.testAlternativeSelection()) {\n            throw new Error('Alternative selection test failed');\n          }\n        } else if (scenario.simulateNetworkError) {\n          if (!await this.testRetryFunctionality()) {\n            throw new Error('Retry functionality test failed');\n          }\n        }\n      }\n      \n      scenarioResult.passed = true;\n      console.log(`âœ… Scenario \"${scenario.name}\" PASSED`);\n      \n    } catch (error) {\n      scenarioResult.errors.push(error.message);\n      console.error(`âŒ Scenario \"${scenario.name}\" FAILED: ${error.message}`);\n      \n      // Take failure screenshot\n      const screenshotPath = `test-screenshots/failure-${scenario.name.replace(/\\s+/g, '-')}-${Date.now()}.png`;\n      await this.page.screenshot({ path: screenshotPath, fullPage: true });\n      scenarioResult.screenshots.push(screenshotPath);\n    }\n    \n    return scenarioResult;\n  }\n\n  async runAllScenarios() {\n    console.log('ðŸš€ Starting Conflict Error Handling Test Suite');\n    console.log('=' .repeat(60));\n    \n    for (const scenario of TEST_SCENARIOS) {\n      const result = await this.runScenario(scenario);\n      this.results.details.push(result);\n      \n      if (result.passed) {\n        this.results.passed++;\n      } else {\n        this.results.failed++;\n      }\n      \n      // Wait between scenarios\n      await this.page.waitForTimeout(1000);\n    }\n  }\n\n  async generateReport() {\n    console.log('\\nðŸ“Š TEST RESULTS SUMMARY');\n    console.log('=' .repeat(50));\n    console.log(`âœ… Passed: ${this.results.passed}`);\n    console.log(`âŒ Failed: ${this.results.failed}`);\n    console.log(`ðŸ“ˆ Success Rate: ${(this.results.passed / (this.results.passed + this.results.failed) * 100).toFixed(1)}%`);\n    \n    console.log('\\nðŸ“‹ DETAILED RESULTS:');\n    this.results.details.forEach((result, index) => {\n      console.log(`\\n${index + 1}. ${result.name}`);\n      console.log(`   Status: ${result.passed ? 'âœ… PASSED' : 'âŒ FAILED'}`);\n      \n      if (result.errors.length > 0) {\n        console.log('   Errors:');\n        result.errors.forEach(error => {\n          console.log(`   - ${error}`);\n        });\n      }\n      \n      if (result.screenshots.length > 0) {\n        console.log('   Screenshots:');\n        result.screenshots.forEach(screenshot => {\n          console.log(`   - ${screenshot}`);\n        });\n      }\n    });\n    \n    // Create detailed report file\n    const reportData = {\n      timestamp: new Date().toISOString(),\n      summary: {\n        total: this.results.passed + this.results.failed,\n        passed: this.results.passed,\n        failed: this.results.failed,\n        successRate: (this.results.passed / (this.results.passed + this.results.failed) * 100).toFixed(1) + '%'\n      },\n      scenarios: this.results.details\n    };\n    \n    const fs = require('fs');\n    const reportPath = `test-reports/conflict-error-test-${Date.now()}.json`;\n    \n    // Ensure directory exists\n    const reportDir = path.dirname(reportPath);\n    if (!fs.existsSync(reportDir)) {\n      fs.mkdirSync(reportDir, { recursive: true });\n    }\n    \n    fs.writeFileSync(reportPath, JSON.stringify(reportData, null, 2));\n    console.log(`\\nðŸ“„ Detailed report saved to: ${reportPath}`);\n  }\n\n  async cleanup() {\n    if (this.browser) {\n      await this.browser.close();\n    }\n  }\n}\n\n// Main execution\nasync function main() {\n  const tester = new ConflictErrorTester(TEST_CONFIG);\n  \n  try {\n    await tester.initialize();\n    await tester.runAllScenarios();\n    await tester.generateReport();\n  } catch (error) {\n    console.error('ðŸ’¥ Test suite failed with critical error:', error);\n    process.exit(1);\n  } finally {\n    await tester.cleanup();\n  }\n  \n  // Exit with appropriate code\n  const exitCode = tester.results.failed === 0 ? 0 : 1;\n  process.exit(exitCode);\n}\n\n// Run if called directly\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = { ConflictErrorTester, TEST_SCENARIOS };"